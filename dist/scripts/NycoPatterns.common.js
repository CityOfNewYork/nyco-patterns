'use strict';

/**
 * The Utility class
 * @class
 */

var Utility = function Utility() {
  return this;
};
/**
 * Boolean for debug mode
 * @return {boolean} wether or not the front-end is in debug mode.
 */


Utility.debug = function () {
  return Utility.getUrlParameter(Utility.PARAMS.DEBUG) === '1';
};
/**
 * Returns the value of a given key in a URL query string. If no URL query
 * string is provided, the current URL location is used.
 * @param  {string}  name        - Key name.
 * @param  {?string} queryString - Optional query string to check.
 * @return {?string} Query parameter value.
 */


Utility.getUrlParameter = function (name, queryString) {
  var query = queryString || window.location.search;
  var param = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
  var regex = new RegExp('[\\?&]' + param + '=([^&#]*)');
  var results = regex.exec(query);
  return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
};
/**
 * For translating strings, there is a global LOCALIZED_STRINGS array that
 * is defined on the HTML template level so that those strings are exposed to
 * WPML translation. The LOCALIZED_STRINGS array is composed of objects with a
 * `slug` key whose value is some constant, and a `label` value which is the
 * translated equivalent. This function takes a slug name and returns the
 * label.
 * @param  {string} slug
 * @return {string} localized value
 */


Utility.localize = function (slug) {
  var text = slug || '';
  var strings = window.LOCALIZED_STRINGS || [];
  var match = strings.filter(function (s) {
    return s.hasOwnProperty('slug') && s['slug'] === slug ? s : false;
  });
  return match[0] && match[0].hasOwnProperty('label') ? match[0].label : text;
};
/**
 * Application parameters
 * @type {Object}
 */


Utility.PARAMS = {
  DEBUG: 'debug'
};
/**
 * Selectors for the Utility module
 * @type {Object}
 */

Utility.SELECTORS = {
  parseMarkdown: '[data-js="markdown"]'
};

/**
 * The Icon module
 * @class
 */

var Icons = function Icons(path) {
  path = path ? path : Icons.path;
  fetch(path).then(function (response) {
    if (response.ok) {
      return response.text();
    } else // eslint-disable-next-line no-console
      if (Utility.debug()) {
        console.dir(response);
      }
  })["catch"](function (error) {
    // eslint-disable-next-line no-console
    if (Utility.debug()) {
      console.dir(error);
    }
  }).then(function (data) {
    var sprite = document.createElement('div');
    sprite.innerHTML = data;
    sprite.setAttribute('aria-hidden', true);
    sprite.setAttribute('style', 'display: none;');
    document.body.appendChild(sprite);
  });
  return this;
};
/** @type {String} The path of the icon file */


Icons.path = 'icons.svg';

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */

var Symbol$1 = root.Symbol;

/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString$1 = objectProto$1.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */

var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto$1 = Function.prototype,
    objectProto$2 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$1 = funcProto$1.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/** Used for built-in method references. */

var objectProto$3 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty$2.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */

function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var setToString = shortOut(baseSetToString);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */

function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */

function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */

function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */

var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */

var objectProto$4 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */

var argsTag$1 = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */

var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports$1 && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */

var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */

var objectProto$5 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$6;
  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */

var objectProto$7 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */

var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/** Built-in value references. */

var getPrototype = overArg(Object.getPrototypeOf, Object);

/** `Object#toString` result references. */

var objectTag$1 = '[object Object]';
/** Used for built-in method references. */

var funcProto$2 = Function.prototype,
    objectProto$8 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$2 = funcProto$2.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString$2.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}

/** `Object#toString` result references. */

var domExcTag = '[object DOMException]',
    errorTag$1 = '[object Error]';
/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */

function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }

  var tag = baseGetTag(value);
  return tag == errorTag$1 || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */

var attempt = baseRest(function (func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */

function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

/** Used for built-in method references. */

var objectProto$9 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */

function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined || eq(objValue, objectProto$9[key]) && !hasOwnProperty$7.call(object, key)) {
    return srcValue;
  }

  return objValue;
}

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};
/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */

var objectProto$a = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function (key) {
    return object == null ? undefined : object[key];
  };
}

/** Used to map characters to HTML entities. */

var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

var escapeHtmlChar = basePropertyOf(htmlEscapes);

/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */

function toString(value) {
  return value == null ? '' : baseToString(value);
}

/** Used to match HTML entities and HTML characters. */

var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */

function escape(string) {
  string = toString(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
}

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */

var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': {
      'escape': escape
    }
  }
};

/** Used to match empty string literals in compiled template source. */

var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */

var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
/** Used to ensure capturing order of template delimiters. */

var reNoMatch = /($^)/;
/** Used to match unescaped characters in compiled string literals. */

var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */

function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }

  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);
  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);
  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '"; // Compile the regexp to match each delimiter.

  var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.

  var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';
  string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets.

    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }

    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }

    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }

    index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.

    return match;
  });
  source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.

  var variable = options.variable;

  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  } // Cleanup code by stripping empty strings.


  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

  source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
  var result = attempt(function () {
    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
  }); // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.

  result.source = source;

  if (isError(result)) {
    throw result;
  }

  return result;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */

var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */

function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */

var baseEach = createBaseEach(baseForOwn);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */

function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */

function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* Built-in method references that are verified to be native. */

var Map = getNative(root, 'Map');

/* Built-in method references that are verified to be native. */

var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto$b = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */

var objectProto$c = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$a = objectProto$c.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$a.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/** Detect free variable `exports`. */

var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
/** Built-in value references. */

var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

/** Built-in value references. */

var Uint8Array = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */

function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */

function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */

function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack());
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */

var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */

function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);

  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */

function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Assume cyclic values are equal.


  var stacked = stack.get(array);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;
/** `Object#toString` result references. */

var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$2 = '[object Error]',
    mapTag$1 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';
var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$1:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag$2:
      return object.name == other.name && object.message == other.message;

    case regexpTag$1:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag$1:
      var convert = mapToArray;

    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG$1; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */

var objectProto$d = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable$1 = objectProto$d.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$2 = 1;
/** Used for built-in method references. */

var objectProto$e = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$b = objectProto$e.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty$b.call(other, key))) {
      return false;
    }
  } // Assume cyclic values are equal.


  var stacked = stack.get(object);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* Built-in method references that are verified to be native. */

var DataView = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */

var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */

var Set$1 = getNative(root, 'Set');

/* Built-in method references that are verified to be native. */

var WeakMap = getNative(root, 'WeakMap');

/** `Object#toString` result references. */

var mapTag$2 = '[object Map]',
    objectTag$2 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$2 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';
var dataViewTag$2 = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map && getTag(new Map()) != mapTag$2 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$2 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;

        case mapCtorString:
          return mapTag$2;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag$2;

        case weakMapCtorString:
          return weakMapTag$1;
      }
    }

    return result;
  };
}

var getTag$1 = getTag;

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$3 = 1;
/** `Object#toString` result references. */

var argsTag$2 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    objectTag$3 = '[object Object]';
/** Used for built-in method references. */

var objectProto$f = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$c = objectProto$f.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag$1 : getTag$1(object),
      othTag = othIsArr ? arrayTag$1 : getTag$1(other);
  objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
  othTag = othTag == argsTag$2 ? objectTag$3 : othTag;
  var objIsObj = objTag == objectTag$3,
      othIsObj = othTag == objectTag$3,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$c.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$c.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */

function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */

function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */

function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/** Used to match property names within property paths. */

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */

var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */

function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

/** Used as references for various `Number` constants. */

var INFINITY$1 = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */

function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */

function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */

function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */

function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */

function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */

function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (typeof value == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);

  while (length--) {
    array[length] = array[length].value;
  }

  return array;
}

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */

function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);
    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }

    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }

  return 0;
}

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */

function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);

    if (result) {
      if (index >= ordersLength) {
        return result;
      }

      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


  return object.index - other.index;
}

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */

function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
  var result = baseMap(collection, function (value, key, collection) {
    var criteria = arrayMap(iteratees, function (iteratee) {
      return iteratee(value);
    });
    return {
      'criteria': criteria,
      'index': ++index,
      'value': value
    };
  });
  return baseSortBy(result, function (object, other) {
    return compareMultiple(object, other, orders);
  });
}

/**
 * This method is like `_.sortBy` except that it allows specifying the sort
 * orders of the iteratees to sort by. If `orders` is unspecified, all values
 * are sorted in ascending order. Otherwise, specify an order of "desc" for
 * descending or "asc" for ascending sort order of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @param {string[]} [orders] The sort orders of `iteratees`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 34 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 36 }
 * ];
 *
 * // Sort by `user` in ascending order and by `age` in descending order.
 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 */

function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }

  if (!isArray(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }

  orders = guard ? undefined : orders;

  if (!isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }

  return baseOrderBy(collection, iteratees, orders);
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

/** Used as references for various `Number` constants. */

var INFINITY$2 = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY$2) ? noop : function (values) {
  return new Set$1(values);
};

/**
 *
 */

var Feed = function Feed(config) {
  this["default"] = Feed["default"];
  this._settings = merge({}, Feed["default"], config);
  this.init();
};
/**
 * Initializes the module
 */


Feed.prototype.init = function init() {
  var this$1 = this;
  var data = [];
  var feed = this._settings.feed;
  var config = {
    rssToJson: Feed.rssToJson,
    rssUrl: Array.isArray(feed) ? feed : [feed]
  }; // Go through each feed

  forEach(config.rssUrl, function (url, index) {
    // Make the request
    this$1._request(config, url).then(function (response) {
      // Process the data
      data.push(this$1._process(JSON.parse(response), this$1._settings)); // When all feeds have been requested, merge the data and compile

      if (data.length === config.rssUrl.length) {
        this$1._merge(data, this$1._settings);

        var compiled = this$1._render(this$1._merge(data, this$1._settings), this$1._settings);

        var el = document.querySelector(this$1._settings.selector);

        if (el) {
          el.innerHTML = compiled;
        }
      }
    });
  });

  return this;
};
/**
 * Create an XHR request for the feed data
 * @param{object} config The request data
 * @param{string} url  The request url
 * @return {Promise}     Resolves when the response is ready, rejects when
 *                       the operation times out or there is an error.
 */


Feed.prototype._request = function _request(config, url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function (event) {
      var _xhr = event.target;

      if (_xhr.readyState === 4) {
        if (_xhr.status >= 200 && _xhr.status < 400) {
          resolve(_xhr.response);
        } else {
          reject(new Error(_xhr.status));
        }
      }
    };

    xhr.ontimeout = function () {
      reject(new Error('The Feed request timed out'));
    };

    xhr.open('GET', config.rssToJson + "?rss_url=" + url, true);
    xhr.send();
    xhr = null;
  });
};
/**
 * Pass data to the appropriate processing function based on type
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {object}        The processed data
 */


Feed.prototype._process = function _process(data, settings) {
  return Feed.process[settings.type](data, settings);
};
/**
 * Pass data to the appropriate merge function based on type
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {object}        The merged feed data
 */


Feed.prototype._merge = function _merge(data, settings) {
  return Feed.merge[settings.type](data);
};
/**
 * Combine template components, pass data, and return compiled temlate
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {string}        The complied html string
 */


Feed.prototype._render = function _render(data, settings) {
  data.settings = settings;

  if (settings.log) {
    console.dir(data);
  }

  var template$1 = values(settings.templates).join('');

  var compiled = template(template$1, {
    'imports': {
      '_each': forEach
    }
  });

  return compiled(data);
};
/**
 * An open RSS to JSON api, see https://rss2json.com
 * @type {String}
 */


Feed.rssToJson = 'https://api.rss2json.com/v1/api.json';
/**
 * The template for the widget.
 * @type {String}
 */

Feed.templates = {
  medium: {
    opener: ['<section class="o-feed <%- settings.classes.wrapper %>" style="', '<% if (settings.fontSize) { %>font-size: <%- settings.fontSize %>;<% } %>', '<% if (settings.postBorderColor) { %>border-color: <%- settings.postBorderColor %>;<% } %>', '">'],
    header: ['<header class="o-feed__header <%- settings.classes.header %>">', '<div class="o-feed__avatar <%- settings.classes.avatar %>">', '<img src="', '<% if (settings.profileImg !== "") { %>', '<%- settings.profileImg %>', '<% } else { %>', '<%- feed.profileImg %>', '<% } %>" ', 'width="<%- settings.ratioProfile[0] %>" ', 'height="<%- settings.ratioProfile[1] %>">', '</div>', '<a class="o-feed__url <%- settings.classes.avatar %>" ', 'href="<% if (settings.titleUrl !== "") { %>', '<%- settings.titleUrl %>', '<% } else { %>', '<%- feed.url %>', '<% } %>" ', 'target="_blank" rel="noopener noreferrer nofollow">', '<% if (settings.title !== "") { %>', '<%- settings.title %>', '<% } else { %>', '<%- feed.title %>', '<% } %>', '</a>', '</header>'],
    posts: ['<div class="o-feed__items" style="', 'border-color: <%- settings.postBorderColor %>;', '">', '<% _each(items, function(post) { %>', '<div class="c-feed-item <%- settings.classes.feedItem %>">', '<h4 class="c-feed-item__title <%- settings.classes.title %>">', '<a class="c-feed-item__link <%- settings.classes.link %>"', 'href="<%- post.guid %>"', 'target="_blank"', 'rel="noopener noreferrer nofollow">', '<%- post.title %>', '</a>', '</h4>', '<span class="c-feed-item__date <%- settings.classes.date %>" ', 'title="<%- settings.postDateTitle %>">', '<%- post.date %>', '</span>', '<div class="c-feed-item__thumbnail <%- settings.classes.thumbnail %>"', 'style="', 'background-image: url(<%- post.thumbnail %>);', 'height: <%- settings.postImgHeight %>;"', 'aria-hidden="true">', '<img style="display: none;" src="<%- post.thumbnail %>" alt="<%- post.title %>">', '</div>', '<p class="c-feed-item__excerpt <%- settings.classes.excerpt %>">', '<%- post.excerpt %><%- settings.postExcerptTrail %>', '</p>', '<div class="c-feed-item__footer <%- settings.classes.itemFooter %>">', '<a class="c-feed-item__cta <%- settings.classes.cta %>" ', 'href="<%- post.guid %>" ', 'target="_blank" ', 'rel="noopener noreferrer nofollow">', '<%- settings.postCtaText %>', '</a>', '</div>', '</div>', '<% }); %>', '</div>'],
    closer: ['</section>']
  }
};
/**
 * Functions for processing the data based on the feed type.
 * @type {Object}
 */

Feed.process = {
  medium: function medium(data, settings) {
    var length = settings.postExcerptLength;

    forEach(data.items, function (post, index) {
      var excerpt = '';
      var date = ''; // Remove figures first

      excerpt = post.description.replace(/<figure.*>.*?<\/figure>/g, ''); // Remove all tags

      excerpt = excerpt.replace(/<(.|\n)*?>/g, ''); // Trim the excerpt

      excerpt = excerpt.substr(0, length);
      excerpt = excerpt.substr(0, Math.min(excerpt.length, excerpt.lastIndexOf(' ')));
      post.excerpt = excerpt; // Format the date

      date = new Date(Date.parse(post.pubDate.replace(' ', 'T'))).toLocaleDateString(settings.postDateLocal, settings.postDateFormat);
      post.date = date;
      return post;
    });

    return data;
  }
  /**
   * Functions for merging the data feeds together, based on the feed type.
   * @type {Object}
   */

};
Feed.merge = {
  medium: function medium(data) {
    var merged = {};
    var items = []; // Combine the post items

    data.forEach(function (feed) {
      items = items.concat(feed.items);
    }); // Merge the data, this will override values, it probably won't be
    // particularly useful for feeds that are the same, but potentially
    // different feed types could use this and combine unique data

    data.forEach(function (feed) {
      merged = merge(merged, feed);
    }); // Get unique posts
    // items = _uniqBy(items, (item) => item.guid);

    merged.items = orderBy(items, 'pubDate', 'desc');
    return merged;
  }
  /**
   * See https://rss2json.com/docs for details on default parameters
   * @type {Object}
   */

};
Feed["default"] = {
  feed: '',
  selector: '#js-feed',
  type: 'medium',
  title: '',
  titleUrl: '',
  profileImg: '',
  fontSize: '',
  ratioProfile: ['50', '50'],
  postBorderColor: 'lightsteelblue',
  postImgHeight: '200px',
  postExcerptLength: 120,
  postExcerptTrail: '…',
  postCtaText: 'Read the full post',
  postDateLocal: 'en-US',
  postDateFormat: {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  },
  postDateTitle: 'Published Date',
  classes: {
    wrapper: '',
    header: '',
    url: '',
    feedItem: '',
    title: '',
    link: '',
    thumbnail: '',
    excerpt: '',
    itemFooter: '',
    cta: '',
    date: ''
  },
  templates: {
    opener: Feed.templates.medium.opener.join(''),
    header: Feed.templates.medium.header.join(''),
    posts: Feed.templates.medium.posts.join(''),
    closer: Feed.templates.medium.closer.join('')
  },
  log: false,
  unique: false
};

/**
 * The Simple Toggle class. This will toggle the class 'active' and 'hidden'
 * on target elements, determined by a click event on a selected link or
 * element. This will also toggle the aria-hidden attribute for targeted
 * elements to support screen readers. Target settings and other functionality
 * can be controlled through data attributes.
 *
 * This uses the .matches() method which will require a polyfill for IE
 * https://polyfill.io/v2/docs/features/#Element_prototype_matches
 *
 * Basic Usage;
 *
 * javascript:
 *   new Toggle().init();
 *
 * Toggling Anchor links:
 *   <a data-js='toggle' href='#main-menu'>Menu</a>
 *   <div id='main-menu' aria-hidden='true'> ... </div>
 *
 * Toggling aria-control elements:
 *
 *   <button data-js='toggle' aria-controls='#main-menu' aria-pressed='false'>
 *      Menu
 *   </button>
 *   <div id='main-menu' aria-hidden='true'> ... </div>
 *
 * Create "Undo" Event (to close a dialogue);
 *   <a href='#main-menu' data-js='toggle' data-toggle-undo='#close'>Menu</a>
 *   <div id='main-menu' aria-hidden='true'>
 *     <a id="close">Close</a>
 *   </div>
 * @class
 */

var Toggle = function Toggle(s) {
  var this$1 = this;
  var body = document.querySelector('body');
  s = !s ? {} : s;
  this._settings = {
    selector: s.selector ? s.selector : Toggle.selector,
    namespace: s.namespace ? s.namespace : Toggle.namespace,
    inactiveClass: s.inactiveClass ? s.inactiveClass : Toggle.inactiveClass,
    activeClass: s.activeClass ? s.activeClass : Toggle.activeClass
  };
  body.addEventListener('click', function (event) {
    if (!event.target.matches(this$1._settings.selector)) {
      return;
    }

    event.preventDefault();

    this$1._toggle(event);
  });
  return this;
};
/**
 * Logs constants to the debugger
 * @param{object} eventThe main click event
 * @return {object}      The class
 */


Toggle.prototype._toggle = function _toggle(event) {
  var this$1 = this;
  var el = event.target;
  var target = false;
  /** Anchor Links */

  target = el.getAttribute('href') ? document.querySelector(el.getAttribute('href')) : target;
  /** Toggle Controls */
  // console.dir(el.getAttribute('aria-controls'));

  target = el.getAttribute('aria-controls') ? document.querySelector("#" + el.getAttribute('aria-controls')) : target;
  /** Main Functionality */

  if (!target) {
    return this;
  }

  this.elementToggle(el, target);
  /** Undo */

  if (el.dataset[this._settings.namespace + "Undo"]) {
    var undo = document.querySelector(el.dataset[this._settings.namespace + "Undo"]);
    undo.addEventListener('click', function (event) {
      event.preventDefault();
      this$1.elementToggle(el, target);
      undo.removeEventListener('click');
    });
  }

  return this;
};
/**
 * The main toggling method
 * @param{object} el   The current element to toggle active
 * @param{object} target The target element to toggle active/hidden
 * @return {object}      The class
 */


Toggle.prototype.elementToggle = function elementToggle(el, target) {
  if (this._settings.activeClass !== '') {
    el.classList.toggle(this._settings.activeClass);
    target.classList.toggle(this._settings.activeClass);
  }

  if (this._settings.inactiveClass !== '') {
    target.classList.toggle(this._settings.inactiveClass);
  } // Check the element for defined aria roles and toggle them if they exist


  for (var i = 0; i < Toggle.elAriaRoles.length; i++) {
    if (el.getAttribute(Toggle.elAriaRoles[i])) {
      el.setAttribute(Toggle.elAriaRoles[i], !(el.getAttribute(Toggle.elAriaRoles[i]) === 'true'));
    }
  } // Check the target for defined aria roles and toggle them if they exist


  for (var i$1 = 0; i$1 < Toggle.targetAriaRoles.length; i$1++) {
    if (target.getAttribute(Toggle.targetAriaRoles[i$1])) {
      target.setAttribute(Toggle.targetAriaRoles[i$1], !(target.getAttribute(Toggle.targetAriaRoles[i$1]) === 'true'));
    }
  }

  if (el.getAttribute('href') && target.classList.contains(this._settings.activeClass)) {
    window.location.hash = '';
    window.location.hash = el.getAttribute('href');
  }

  return this;
};
/** @type {String} The main selector to add the toggling function to */


Toggle.selector = '[data-js*="toggle"]';
/** @type {String} The namespace for our data attribute settings */

Toggle.namespace = 'toggle';
/** @type {String} The hide class */

Toggle.inactiveClass = 'hidden';
/** @type {String} The active class */

Toggle.activeClass = 'active';
/** @type {Array} Aria roles to toggle true/false on the toggling element */

Toggle.elAriaRoles = ['aria-pressed', 'aria-expanded'];
/** @type {Array} Aria roles to toggle true/false on the target element */

Toggle.targetAriaRoles = ['aria-hidden'];

/**
 * Tracking bus for Google analytics and Webtrends.
 */

var Track = function Track(s) {
  var this$1 = this;
  var body = document.querySelector('body');
  s = !s ? {} : s;
  this._settings = {
    selector: s.selector ? s.selector : Track.selector
  };
  body.addEventListener('click', function (event) {
    if (!event.target.matches(this$1._settings.selector)) {
      return;
    }

    var key = event.target.dataset.trackKey;
    var data = JSON.parse(event.target.dataset.trackData);
    this$1.click(key, data);
  });
  return this;
};
/**
 * Tracking function wrapper
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 * @return {object}        The final data object
 */


Track.prototype.click = function click(key, data) {
  // Set the path name based on the location
  var d = data.map(function (el) {
    if (el.hasOwnProperty(Track.key)) {
      el[Track.key] = window.location.pathname + "/" + el[Track.key];
    }

    return el;
  });
  var wt = this.webtrends(key, d);
  var ga = this.gtag(key, d);
  /* eslint-disable no-console */

  if (Utility.debug()) {
    console.dir({
      'Track': [wt, ga]
    });
  }
  /* eslint-enable no-console */


  return d;
};
/**
 * Data bus for tracking views in Webtrends and Google Analytics
 * @param{string}   appThe name of the Single Page Application to track
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.view = function view(app, key, data) {
  var wt = this.webtrends(key, data);
  var ga = this.gtagView(app, key);
  /* eslint-disable no-console */

  if (Utility.debug()) {
    console.dir({
      'Track': [wt, ga]
    });
  }
  /* eslint-enable no-console */

};
/**
 * Push Events to Webtrends
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.webtrends = function webtrends(key, data) {
  var event = [{
    'WT.ti': key
  }];

  if (data[0] && data[0].hasOwnProperty(Track.key)) {
    event.push({
      'DCS.dcsuri': data[0][Track.key]
    });
  } else {
    Object.assign(event, data);
  } // Format data for Webtrends


  var wtd = {
    argsa: event.flatMap(function (e) {
      return Object.keys(e).flatMap(function (k) {
        return [k, e[k]];
      });
    })
  };
  /* eslint-disable no-undef */

  if (typeof Webtrends !== 'undefined') {
    Webtrends.multiTrack(wtd);
  }
  /* eslint-disable no-undef */


  return ['Webtrends', wtd];
};
/**
 * Push Click Events to Google Analytics
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.gtag = function gtag$1(key, data) {
  var uri = data.find(function (element) {
    return element.hasOwnProperty(Track.key);
  });
  var event = {
    'event_category': key
  };
  /* eslint-disable no-undef */

  if (typeof gtag !== 'undefined') {
    gtag(Track.key, uri[Track.key], event);
  }
  /* eslint-enable no-undef */


  return ['gtag', Track.key, uri[Track.key], event];
};
/**
 * Push Screen View Events to Google Analytics
 * @param{string}   appThe name of the application
 * @param{string}   keyThe key or event of the data
 */

Track.prototype.gtagView = function gtagView(app, key) {
  var view = {
    app_name: app,
    screen_name: key
  };
  /* eslint-disable no-undef */

  if (typeof gtag !== 'undefined') {
    gtag('event', 'screen_view', view);
  }
  /* eslint-enable no-undef */


  return ['gtag', Track.key, 'screen_view', view];
};
/** @type {String} The main selector to add the tracking function to */


Track.selector = '[data-js*="track"]';
/** @type {String} The main event tracking key to map to Webtrends DCS.uri */

Track.key = 'event';

/*!
 * Vue.js v2.6.6
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject$1(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject$1(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString$1(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject$1(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty$d = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty$d.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop$1(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity$1 = function (_) {
  return _;
};
/**
 * Generate a string containing static keys from compiler modules.
 */


function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject$1(a);
  var isObjectB = isObject$1(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop$1,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity$1,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */

var unicodeLetters = 'a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD';
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeLetters + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = '__proto__' in {}; // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set =
  /*@__PURE__*/
  function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop$1;
var tip = noop$1;
var generateComponentTrace = noop$1; // work around flow check

var formatComponentName = noop$1;
{
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat$1 = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat$1(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */

var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if (!config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto$1 = Array.prototype;
var arrayMethods = Object.create(arrayProto$1);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto$1[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject$1(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject$1(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if (customSetter) {
        customSetter();
      } // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if (isUndef(target) || isPrimitive(target)) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if (isUndef(target) || isPrimitive(target)) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

{
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */

function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject$1(toVal) && isPlainObject$1(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
    assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeLetters + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject$1(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject$1(val) ? val : {
        type: val
      };
    }
  } else {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject$1(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject$1(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];

      if (typeof def$$1 === 'function') {
        dirs[key] = {
          bind: def$$1,
          update: def$$1
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject$1(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if (warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if (isObject$1(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject$1(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */


function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

function isExplicable(value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  if (vm) {
    var cur = vm;

    while (cur = cur.$parent) {
      var hooks = cur.$options.errorCaptured;

      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;

            if (capture) {
              return;
            }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }

  globalHandleError(err, vm, info);
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res)) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      });
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */

  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var isUsingMicroTask = false;
var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop$1);
    }
  };

  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };

  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */


var mark;
var measure;
{
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag); // perf.clearMeasures(name)
    };
  }
}
/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;
{
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function (target, key) {
    warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */

var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject$1(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;

  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
      warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      }
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (slots.$stable && prevSlots && prevSlots !== emptyObject && Object.keys(normalSlots).length === 0) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key in slots) {
      if (slots[key] && key[0] !== '$') {
        res[key] = normalizeScopedSlot(normalSlots, key, slots[key]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$1 in normalSlots) {
    if (!(key$1 in res)) {
      res[key$1] = proxyNormalSlot(normalSlots, key$1);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', slots ? !!slots.$stable : true);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    return res && res.length === 0 ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject$1(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if (!isObject$1(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity$1;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject$1(value)) {
      warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);

        if (!(key in hash) && !(camelizedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + camelizedKey] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject$1(value)) {
      warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
hasDynamicKeys, res) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, hasDynamicKeys, res);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (key !== '' && key !== null) {
      // null is a speical value for explicitly removing a binding
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString$1;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */

/*  */

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject$1(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject$1(data.style)) {
    traverse(data.style);
  }

  if (isObject$1(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  }
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack becaues all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if (vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if (Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject$1(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  var owner = currentRenderingInstance;

  if (isDef(factory.owners)) {
    // already pending
    factory.owners.push(owner);
  } else {
    var owners = factory.owners = [owner];
    var sync = true;

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
      warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject$1(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject("timeout (" + res.timeout + "ms)");
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if (config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop$1, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.

  var hasDynamicScopedSlot = !!(parentVnode.data.scopedSlots && !parentVnode.data.scopedSlots.$stable || vm.$scopedSlots !== emptyObject && !vm.$scopedSlots.$stable); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  {
    circular = {};
  }
  waiting = flushing = false;
} // Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.


var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.

if (inBrowser && getNow() > document.createEvent('Event').timeStamp) {
  // if the low-res timestamp which is bigger than the event timestamp
  // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
  // and we need to use the hi-res version for event listeners as well.
  getNow = function () {
    return performance.now();
  };
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if (has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if (!config.async) {
        flushSchedulerQueue();
        return;
      }

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$2 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$2; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = expOrFn.toString(); // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop$1;
      warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject$1(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop$1,
  set: noop$1
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.

    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject$1(data)) {
    data = {};
    warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];
    {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
      warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if (getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop$1, noop$1, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop$1;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop$1;
    sharedPropertyDefinition.set = userDef.set || noop$1;
  }

  if (sharedPropertyDefinition.set === noop$1) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    {
      if (typeof methods[key] !== 'function') {
        warn("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop$1 : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject$1(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  {
    dataDef.set = function () {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject$1(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
      }
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if (config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    {
      initProxy(vm);
    } // expose real self

    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if (config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}

function Vue(options) {
  if (!(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if (name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject$1(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var cachedNode = cache[key];

    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];

  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.6';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject$1(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function (tag) {
  return tag === 'pre';
};

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
      warn('Cannot find element: ' + el);
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps =
/*#__PURE__*/
Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if (data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;
    {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        {
          checkDuplicateKeys(ch);
        }

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};
/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);

    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;
          break;
        // "

        case 0x27:
          inSingle = true;
          break;
        // '

        case 0x60:
          inTemplateString = true;
          break;
        // `

        case 0x28:
          paren++;
          break;
        // (

        case 0x29:
          paren--;
          break;
        // )

        case 0x5B:
          square++;
          break;
        // [

        case 0x5D:
          square--;
          break;
        // ]

        case 0x7B:
          curly++;
          break;
        // {

        case 0x7D:
          curly--;
          break;
        // }
      }

      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0; // find first non-whitespace prev char

        for (; j >= 0; j--) {
          p = exp.charAt(j);

          if (p !== ' ') {
            break;
          }
        }

        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');

  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
  }
}
/*  */

/* eslint-disable no-unused-vars */


function baseWarn(msg, range) {
  console.error("[Vue compiler]: " + msg);
}
/* eslint-enable no-unused-vars */


function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
}

function addAttr(el, name, value, range, dynamic) {
  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
  attrs.push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
} // add a raw attr (use this in preTransforms)


function addRawAttr(el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({
    name: name,
    value: value
  }, range));
}

function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker(symbol, name, dynamic) {
  return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
}

function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
  modifiers = modifiers || emptyObject; // warn prevent and passive modifier

  /* istanbul ignore if */

  if (warn && modifiers.prevent && modifiers.passive) {
    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.', range);
  } // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.


  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  } // check capture modifier


  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }

  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */


  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;

  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({
    value: value.trim(),
    dynamic: dynamic
  }, range);

  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */

  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr(el, name) {
  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);

  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);

    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
} // note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.


function getAndRemoveAttr(el, name, removeFromMap) {
  var val;

  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;

    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }

  if (removeFromMap) {
    delete el.attrsMap[name];
  }

  return val;
}

function getAndRemoveAttrByRegex(el, name) {
  var list = el.attrsList;

  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];

    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr;
    }
  }
}

function rangeSetItem(item, range) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }

    if (range.end != null) {
      item.end = range.end;
    }
  }

  return item;
}
/*  */

/**
 * Cross-platform code generation for component v-model
 */


function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;
  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;

  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var assignment = genAssignmentCode(value, valueExpression);
  el.model = {
    value: "(" + value + ")",
    expression: JSON.stringify(value),
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}
/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */


function genAssignmentCode(value, assignment) {
  var res = parseModel(value);

  if (res.key === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
  }
}
/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */


var len, str, chr, index$1, expressionPos, expressionEndPos;

function parseModel(val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');

    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      };
    } else {
      return {
        exp: val,
        key: null
      };
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */

    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;

  while (!eof()) {
    chr = next();

    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }

    if (chr === 0x5B) {
      inBracket++;
    }

    if (chr === 0x5D) {
      inBracket--;
    }

    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;

  while (!eof()) {
    chr = next();

    if (chr === stringQuote) {
      break;
    }
  }
}
/*  */


var warn$1; // in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.

var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;
  {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
  } // ensure runtime directive metadata


  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type

  {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];

    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
    }
  }
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
  var valueExpression = '$event.target.value';

  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);

  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);

  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.


function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.


var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;

    handler = original._wrapper = function (e) {
      if ( // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget || // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp || // #9462 bail for iOS 9 bug: event.timeStamp is 0 after history.pushState
      e.timeStamp === 0 || // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }

  target$1.addEventListener(name, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    } // skip the update if old and new VDOM state is the same.
    // the only exception is `value` where the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This also covers #4521 by skipping the unnecesarry `checked` update.


    if (key !== 'value' && cur === oldProps[key]) {
      continue;
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;

      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }

      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else {
      elm[key] = cur;
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};
/*  */

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def$$1 === 'object') {
    var res = {};

    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }

    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject$1(duration) ? duration.enter : duration);

  if (explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject$1(duration) ? duration.leave : duration);

  if (isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue$1);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue$1);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
    warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue$1(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue$1(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue$1(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if (children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if (mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update = this._update;

    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );

      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};
/*  */
// install platform specific utils

Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop$1; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }

    if (config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
/*  */


var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;

  if (!tagRE.test(text)) {
    return;
  }

  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;

  while (match = tagRE.exec(text)) {
    index = match.index; // push text token

    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    } // tag token


    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    rawTokens.push({
      '@binding': exp
    });
    lastIndex = index + match[0].length;
  }

  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }

  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  };
}
/*  */


function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');

  if (staticClass) {
    var res = parseText(staticClass, options.delimiters);

    if (res) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
    }
  }

  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }

  var classBinding = getBindingAttr(el, 'class', false
  /* getStatic */
  );

  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData(el) {
  var data = '';

  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }

  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }

  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};
/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');

  if (staticStyle) {
    /* istanbul ignore if */
    {
      var res = parseText(staticStyle, options.delimiters);

      if (res) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false
  /* getStatic */
  );

  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1(el) {
  var data = '';

  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }

  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }

  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};
/*  */

var decoder;
var he = {
  decode: function decode(html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent;
  }
};
/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open
// (and which close themselves)

var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
/**
 * Not type-checking this file because it's mostly vendor code.
 */
// Regular Expressions for parsing tags and attributes

var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeLetters + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page

var comment = /^<!\--/;
var conditionalComment = /^<!\[/; // Special Elements (can contain anything)

var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};
var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992

var isIgnoreNewlineTag = makeMap('pre,textarea', true);

var shouldIgnoreFirstNewline = function (tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;

  while (html) {
    last = html; // Make sure we're not in a plaintext content element like script/style

    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');

      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }

            advance(commentEnd + 3);
            continue;
          }
        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment


        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        } // Doctype:


        var doctypeMatch = html.match(doctype);

        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        } // End tag:


        var endTagMatch = html.match(endTag);

        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        } // Start tag:


        var startTagMatch = parseStartTag();

        if (startTagMatch) {
          handleStartTag(startTagMatch);

          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }

          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;

      if (textEnd >= 0) {
        rest = html.slice(textEnd);

        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);

          if (next < 0) {
            break;
          }

          textEnd += next;
          rest = html.slice(textEnd);
        }

        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;

        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
          .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }

        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }

        if (options.chars) {
          options.chars(text);
        }

        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);

      if (!stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"", {
          start: index + html.length
        });
      }

      break;
    }
  } // Clean up any remaining tags


  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);

    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;

      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }

      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }

      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
    var l = match.attrs.length;
    var attrs = new Array(l);

    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };

      if (options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({
        tag: tagName,
        lowerCasedTag: tagName.toLowerCase(),
        attrs: attrs,
        start: match.start,
        end: match.end
      });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;

    if (start == null) {
      start = index;
    }

    if (end == null) {
      end = index;
    } // Find the closest opened tag of the same type


    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();

      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (i > pos || !tagName && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.", {
            start: stack[i].start
          });
        }

        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      } // Remove the open elements from the stack


      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }

      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}
/*  */


var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;
var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.]+/g;
var slotRE = /^v-slot(:|$)|^#/;
var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /\s+/g;
var invalidAttributeRE = /[\s"'<>\/=]/;
var decodeHTMLCached = cached(he.decode);
var emptySlotScopeToken = "_empty_"; // configurable state

var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  };
}
/**
 * Convert HTML string to AST.
 */


function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;

  maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;
  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement(element) {
    trimEndingWhitespace(element);

    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    } // tree management


    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else {
        warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.", {
          start: element.start
        });
      }
    }

    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"';
          (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }

        currentParent.children.push(element);
        element.parent = currentParent;
      }
    } // final children cleanup
    // filter out scoped slots


    element.children = element.children.filter(function (c) {
      return !c.slotScope;
    }); // remove trailing whitespace node again

    trimEndingWhitespace(element); // check pre state

    if (element.pre) {
      inVPre = false;
    }

    if (platformIsPreTag(element.tag)) {
      inPre = false;
    } // apply post-transforms


    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace(el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;

      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints(el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', {
        start: el.start
      });
    }

    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start(tag, attrs, unary, start$1) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug

      /* istanbul ignore if */

      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);

      if (ns) {
        element.ns = ns;
      }

      {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated;
          }, {});
        }

        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2("Invalid dynamic argument expression: attribute names cannot contain " + "spaces, quotes, <, >, / or =.", {
              start: attr.start + attr.name.indexOf("["),
              end: attr.start + attr.name.length
            });
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.', {
          start: element.start
        });
      } // apply pre-transforms


      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);

        if (element.pre) {
          inVPre = true;
        }
      }

      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }

      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },
    end: function end(tag, start, end$1) {
      var element = stack[stack.length - 1]; // pop stack

      stack.length -= 1;
      currentParent = stack[stack.length - 1];

      if (options.outputSourceRange) {
        element.end = end$1;
      }

      closeElement(element);
    },
    chars: function chars(text, start, end) {
      if (!currentParent) {
        {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.', {
              start: start
            });
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.", {
              start: start
            });
          }
        }
        return;
      } // IE textarea placeholder bug

      /* istanbul ignore if */


      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }

      var children = currentParent.children;

      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }

      if (text) {
        if (whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }

        var res;
        var child;

        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }

        if (child) {
          if (options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }

          children.push(child);
        }
      }
    },
    comment: function comment(text, start, end) {
      // adding anyting as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };

        if (options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }

        currentParent.children.push(child);
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var list = el.attrsList;
  var len = list.length;

  if (len) {
    var attrs = el.attrs = new Array(len);

    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };

      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element); // determine whether this is a plain element after
  // removing structural attributes

  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;
  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);

  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }

  processAttrs(element);
  return element;
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');

  if (exp) {
    {
      if (el.tag === 'template') {
        warn$2("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
      }

      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;

        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2("Do not use v-for index as key on <transition-group> children, " + "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true
          /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');

  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;

  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var res = parseFor(exp);

    if (res) {
      extend(el, res);
    } else {
      warn$2("Invalid v-for expression: " + exp, el.rawAttrsMap['v-for']);
    }
  }
}

function parseFor(exp) {
  var inMatch = exp.match(forAliasRE);

  if (!inMatch) {
    return;
  }

  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);

  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();

    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }

  return res;
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');

  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }

    var elseif = getAndRemoveAttr(el, 'v-else-if');

    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);

  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
  }
}

function findPrevElement(children) {
  var i = children.length;

  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.", children[i]);
      }

      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }

  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');

  if (once$$1 != null) {
    el.once = true;
  }
} // handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">


function processSlotContent(el) {
  var slotScope;

  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */

    if (slotScope) {
      warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", el.rawAttrsMap['scope'], true);
    }

    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
    /* istanbul ignore if */
    if (el.attrsMap['v-for']) {
      warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
    }

    el.slotScope = slotScope;
  } // slot="xxx"


  var slotTarget = getBindingAttr(el, 'slot');

  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.

    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  } // 2.6 v-slot syntax


  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding) {
        {
          if (el.slotTarget || el.slotScope) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.parent && !maybeComponent(el.parent)) {
            warn$2("<template v-slot> can only appear at the root level inside " + "the receiving the component", el);
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding$1) {
        {
          if (!maybeComponent(el)) {
            warn$2("v-slot can only be used on components or <template>.", slotBinding$1);
          }

          if (el.slotScope || el.slotTarget) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.scopedSlots) {
            warn$2("To avoid scope ambiguity, the default slot should also use " + "<template> syntax when there are other named slots.", slotBinding$1);
          }
        } // add the component's children to its default slot

        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true;
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now

        el.children = []; // mark el non-plain so data gets generated

        el.plain = false;
      }
    }
  }
}

function getSlotName(binding) {
  var name = binding.name.replace(slotRE, '');

  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else {
      warn$2("v-slot shorthand syntax requires a slot name.", binding);
    }
  }

  return dynamicArgRE.test(name) // dynamic [name]
  ? {
    name: name.slice(1, -1),
    dynamic: true // static name

  } : {
    name: "\"" + name + "\"",
    dynamic: false
  };
} // handle <slot/> outlets


function processSlotOutlet(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');

    if (el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
    }
  }
}

function processComponent(el) {
  var binding;

  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }

  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;

  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;

    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true; // modifiers

      modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier

      if (modifiers) {
        name = name.replace(modifierRE, '');
      }

      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        if (value.trim().length === 0) {
          warn$2("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"");
        }

        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);

            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }

          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }

          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");

            if (!isDynamic) {
              addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$2, list[i]);

              if (hyphenate(name) !== camelize(name)) {
                addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$2, list[i]);
              }
            } else {
              // handler w/ dynamic event name
              addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn$2, list[i], true // dynamic
              );
            }
          }
        }

        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else {
        // normal directives
        name = name.replace(dirRE, ''); // parse arg

        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;

        if (arg) {
          name = name.slice(0, -(arg.length + 1));

          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }

        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);

        if (name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      {
        var res = parseText(value, delimiters);

        if (res) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation

      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;

  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }

    parent = parent.parent;
  }

  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);

  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};

  for (var i = 0, l = attrs.length; i < l; i++) {
    if (map[attrs[i].name] && !isIE && !isEdge) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }

    map[attrs[i].name] = attrs[i].value;
  }

  return map;
} // for script (e.g. type="x/template") or style, do not decode content


function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;
/* istanbul ignore next */

function guardIESVGBug(attrs) {
  var res = [];

  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];

    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }

  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;

  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
    }

    _el = _el.parent;
  }
}
/*  */


function preTransformNode(el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;

    if (!map['v-model']) {
      return;
    }

    var typeBinding;

    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }

    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + map['v-bind'] + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox

      var branch0 = cloneASTElement(el); // process for on the main node

      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed

      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      }); // 2. add radio else-if condition

      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      }); // 3. other

      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0;
    }
  }
}

function cloneASTElement(el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}

var model$1 = {
  preTransformNode: preTransformNode
};
var modules$1 = [klass$1, style$1, model$1];
/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")", dir);
  }
}
/*  */


function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")", dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};
/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};
/*  */

var isStaticKey;
var isPlatformReservedTag;
var genStaticKeysCached = cached(genStaticKeys$1);
/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */

function optimize(root, options) {
  if (!root) {
    return;
  }

  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.

  markStatic$1(root); // second pass: mark static roots.

  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);

  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }

    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);

      if (!child.static) {
        node.static = false;
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);

        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    } // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.


    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }

    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }

  if (node.type === 3) {
    // text
    return true;
  }

  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;

    if (node.tag !== 'template') {
      return false;
    }

    if (node.for) {
      return true;
    }
  }

  return false;
}
/*  */


var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // KeyboardEvent.keyCode aliases

var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
}; // KeyboardEvent.key aliases

var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
}; // #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once

var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";

  for (var name in events) {
    var handlerCode = genHandler(events[name]);

    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }

  staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";

  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
  } else {
    return prefix + staticHandlers;
  }
}

function genHandler(handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value;
    }

    return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];

    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key]; // left/right

        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = handler.modifiers;
        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
          return !modifiers[keyModifier];
        }).map(function (keyModifier) {
          return "$event." + keyModifier + "Key";
        }).join('||'));
      } else {
        keys.push(key);
      }
    }

    if (keys.length) {
      code += genKeyFilter(keys);
    } // Make sure modifiers like prevent and stop get executed after key filtering


    if (genModifierCode) {
      code += genModifierCode;
    }

    var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return (// make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;"
  );
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);

  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }

  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
}
/*  */


function on(el, dir) {
  if (dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }

  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}
/*  */


function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}
/*  */


var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop$1
};
/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;

  this.maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;

    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;

      if (!el.plain || el.pre && state.maybeComponent(el)) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    } // module transforms


    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }

    return code;
  }
} // hoist static sub-trees out


function genStatic(el, state) {
  el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.

  var originalPreState = state.pre;

  if (el.pre) {
    state.pre = el.pre;
  }

  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  state.pre = originalPreState;
  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
} // v-once


function genOnce(el, state) {
  el.onceProcessed = true;

  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;

    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }

      parent = parent.parent;
    }

    if (!key) {
      state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
      return genElement(el, state);
    }

    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion

  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();

  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  } // v-if with v-once should generate code like (a)?_m(0):_m(1)


  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true
    /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion

  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{'; // directives first.
  // directives may mutate the el's other properties before they are generated.

  var dirs = genDirectives(el, state);

  if (dirs) {
    data += dirs + ',';
  } // key


  if (el.key) {
    data += "key:" + el.key + ",";
  } // ref


  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }

  if (el.refInFor) {
    data += "refInFor:true,";
  } // pre


  if (el.pre) {
    data += "pre:true,";
  } // record original tag name for components using "is" attribute


  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  } // module data generation functions


  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  } // attributes


  if (el.attrs) {
    data += "attrs:" + genProps(el.attrs) + ",";
  } // DOM props


  if (el.props) {
    data += "domProps:" + genProps(el.props) + ",";
  } // event handlers


  if (el.events) {
    data += genHandlers(el.events, false) + ",";
  }

  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  } // slot target
  // only for non-scoped slots


  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + el.slotTarget + ",";
  } // scoped slots


  if (el.scopedSlots) {
    data += genScopedSlots(el, el.scopedSlots, state) + ",";
  } // component v-model


  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  } // inline-template


  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);

    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }

  data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.

  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
  } // v-bind data wrap


  if (el.wrapData) {
    data = el.wrapData(data);
  } // v-on data wrap


  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }

  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;

  if (!dirs) {
    return;
  }

  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;

  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];

    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }

    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }

  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];

  if (el.children.length !== 1 || ast.type !== 1) {
    state.warn('Inline-template components must have exactly one child element.', {
      start: el.start
    });
  }

  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(el, slots, state) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    ;
  }); // OR when it is inside another scoped slot (the reactivity is disconnected)
  // #9438

  if (!needsForceUpdate) {
    var parent = el.parent;

    while (parent) {
      if (parent.slotScope && parent.slotScope !== emptySlotScopeToken) {
        needsForceUpdate = true;
        break;
      }

      parent = parent.parent;
    }
  }

  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(slots[key], state);
  }).join(',') + "]" + (needsForceUpdate ? ",true" : "") + ")";
}

function containsSlotChild(el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true;
    }

    return el.children.some(containsSlotChild);
  }

  return false;
}

function genScopedSlot(el, state) {
  var isLegacySyntax = el.attrsMap['slot-scope'];

  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null");
  }

  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot);
  }

  var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
  var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}"; // reverse proxy v-slot without scope on this.$slots

  var reverseProxy = slotScope ? "" : ",proxy:true";
  return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;

  if (children.length) {
    var el$1 = children[0]; // optimize single v-for

    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
      return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
    }

    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
  }
} // determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed


function getNormalizationType(children, maybeComponent) {
  var res = 0;

  for (var i = 0; i < children.length; i++) {
    var el = children[i];

    if (el.type !== 1) {
      continue;
    }

    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }

    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }

  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  } else if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
    return {
      // slot props are camelized
      name: camelize(attr.name),
      value: attr.value,
      dynamic: attr.dynamic
    };
  })) : null;
  var bind$$1 = el.attrsMap['v-bind'];

  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }

  if (attrs) {
    res += "," + attrs;
  }

  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }

  return res + ')';
} // componentName is el.component, take it as argument to shun flow's pessimistic refinement


function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var staticProps = "";
  var dynamicProps = "";

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);

    if (prop.dynamic) {
      dynamicProps += prop.name + "," + value + ",";
    } else {
      staticProps += "\"" + prop.name + "\":" + value + ",";
    }
  }

  staticProps = "{" + staticProps.slice(0, -1) + "}";

  if (dynamicProps) {
    return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
  } else {
    return staticProps;
  }
} // #3895, #4268


function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}
/*  */
// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed


var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b'); // these unary operators should not be used as property/method names

var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)'); // strip strings in expressions

var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; // detect problematic expressions in a template

function detectErrors(ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode(node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];

        if (value) {
          var range = node.rawAttrsMap[name];

          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", warn, range);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", warn, range);
          }
        }
      }
    }

    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent(exp, text, warn, range) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);

  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
  }

  checkExpression(exp, text, warn, range);
}

function checkFor(node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier(ident, type, text, warn, range) {
  if (typeof ident === 'string') {
    try {
      new Function("var " + ident + "=_");
    } catch (e) {
      warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
    }
  }
}

function checkExpression(exp, text, warn, range) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

    if (keywordMatch) {
      warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
    } else {
      warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
    }
  }
}
/*  */


var range = 2;

function generateCodeFrame(source, start, end) {
  if (start === void 0) start = 0;
  if (end === void 0) end = source.length;
  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];

  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) {
          continue;
        }

        res.push("" + (j + 1) + repeat(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
        var lineLength = lines[j].length;

        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat(" ", pad) + repeat("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat("^", length$1));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}

function repeat(str, n) {
  var result = '';

  while (true) {
    // eslint-disable-line
    if (n & 1) {
      result += str;
    }

    n >>>= 1;

    if (n <= 0) {
      break;
    }

    str += str;
  }

  return result;
}
/*  */


function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({
      err: err,
      code: code
    });
    return noop$1;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);
  return function compileToFunctions(template, options, vm) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;
    /* istanbul ignore if */

    {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    } // check cache

    var key = options.delimiters ? String(options.delimiters) + template : template;

    if (cache[key]) {
      return cache[key];
    } // compile


    var compiled = compile(template, options); // check compilation errors/tips

    {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
          });
        } else {
          warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
      }

      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) {
            return tip(e.msg, vm);
          });
        } else {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }
    } // turn code into functions

    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    }); // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use

    /* istanbul ignore if */

    {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;
          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }
    return cache[key] = res;
  };
}
/*  */


function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if (options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = {
              msg: msg
            };

            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }

              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }

            (tip ? tips : errors).push(data);
          };
        } // merge custom modules


        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        } // merge custom directives


        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
        } // copy other options


        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;
      var compiled = baseCompile(template.trim(), finalOptions);
      {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}
/*  */
// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.


var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);

  if (options.optimize !== false) {
    optimize(ast, options);
  }

  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});
/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;
/*  */
// check whether current browser encodes a char inside attribute values

var div;

function getShouldDecode(href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0;
} // #3663: IE encodes newlines inside attribute values while other browsers don't


var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]

var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;
/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});
var mount = Vue.prototype.$mount;

Vue.prototype.$mount = function (el, hydrating) {
  el = el && query(el);
  /* istanbul ignore if */

  if (el === document.body || el === document.documentElement) {
    warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options; // resolve template/el and convert to render function

  if (!options.render) {
    var template = options.template;

    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */

          if (!template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }

    if (template) {
      /* istanbul ignore if */
      if (config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;
      /* istanbul ignore if */

      if (config.performance && mark) {
        mark('compile end');
        measure("vue " + this._name + " compile", 'compile', 'compile end');
      }
    }
  }

  return mount.call(this, el, hydrating);
};
/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */


function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue.compile = compileToFunctions;

//
//
//
//
//
//
//
//
//
//
//
//
var script = {
  props: ['options', 'value'],
  data: function data() {
    return {
      selected: null
    };
  },
  mounted: function mounted() {
    this.selected = this.value;
  },
  watch: {
    value: function value(newValue) {
      this.selected = newValue;
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function () {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

var normalizeComponent_1 = normalizeComponent;

var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

function createInjector(context) {
  return function (id, style) {
    return addStyle(id, style);
  };
}

var HEAD = document.head || document.getElementsByTagName('head')[0];
var styles = {};

function addStyle(id, css) {
  var group = isOldIE ? css.media || 'default' : id;
  var style = styles[group] || (styles[group] = {
    ids: new Set(),
    styles: []
  });

  if (!style.ids.has(id)) {
    style.ids.add(id);
    var code = css.source;

    if (css.map) {
      // https://developer.chrome.com/devtools/docs/javascript-debugging
      // this makes source maps inside style tags work properly in Chrome
      code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

      code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
    }

    if (!style.element) {
      style.element = document.createElement('style');
      style.element.type = 'text/css';

      if (css.media) {
        style.element.setAttribute('media', css.media);
      }

      HEAD.appendChild(style.element);
    }

    if ('styleSheet' in style.element) {
      style.styles.push(code);
      style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
    } else {
      var index = style.ids.size - 1;
      var textNode = document.createTextNode(code);
      var nodes = style.element.childNodes;

      if (nodes[index]) {
        style.element.removeChild(nodes[index]);
      }

      if (nodes.length) {
        style.element.insertBefore(textNode, nodes[index]);
      } else {
        style.element.appendChild(textNode);
      }
    }
  }
}

var browser = createInjector;

/* script */
var __vue_script__ = script;

/* template */
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", [
    _c(
      "select",
      {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.selected,
            expression: "selected"
          }
        ],
        staticClass: "select",
        on: {
          input: function(event) {
            _vm.$emit("input", event.target.value);
          },
          change: function($event) {
            var $$selectedVal = Array.prototype.filter
              .call($event.target.options, function(o) {
                return o.selected
              })
              .map(function(o) {
                var val = "_value" in o ? o._value : o.value;
                return val
              });
            _vm.selected = $event.target.multiple
              ? $$selectedVal
              : $$selectedVal[0];
          }
        }
      },
      _vm._l(_vm.options, function(option) {
        return _c(
          "option",
          { key: option.value, domProps: { value: option.value } },
          [_vm._v("\n      " + _vm._s(option.text) + "\n    ")]
        )
      }),
      0
    )
  ])
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  var __vue_inject_styles__ = function (inject) {
    if (!inject) { return }
    inject("data-v-0fefdf17_0", { source: "\n\n\n\n\n\n\n\n\n\n", map: {"version":3,"sources":[],"names":[],"mappings":"","file":"select.vue"}, media: undefined });

  };
  /* scoped */
  var __vue_scope_id__ = undefined;
  /* module identifier */
  var __vue_module_identifier__ = undefined;
  /* functional template */
  var __vue_is_functional_template__ = false;
  /* style inject SSR */
  

  
  var SelectComponent = normalizeComponent_1(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    browser,
    undefined
  );

var SelectData = [{
  text: 'All Boroughs',
  value: 'all'
}, {
  text: 'Brooklyn',
  value: 'brooklyn'
}, {
  text: 'Queens',
  value: 'queens'
}, {
  text: 'Manhattan',
  value: 'manhattan'
}, {
  text: 'Staten Island',
  value: 'staten island'
}, {
  text: 'The Bronx',
  value: 'bronx'
}];

var Select = function Select(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


Select.prototype.init = function init() {
  Vue.component('nyco-select', SelectComponent);
  new Vue({
    el: '[data-js="app"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        options: Select.data,
        selected: 'all'
      };
    },
    methods: {}
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


Select.prototype._constants = function _constants(param) {
  console.dir(param);
};

Select.data = SelectData;

function dataHandler(newData, oldData) {
  if (oldData) {
    var chart = this.$data._chart;
    var newDatasetLabels = newData.datasets.map(function (dataset) {
      return dataset.label;
    });
    var oldDatasetLabels = oldData.datasets.map(function (dataset) {
      return dataset.label;
    });
    var oldLabels = JSON.stringify(oldDatasetLabels);
    var newLabels = JSON.stringify(newDatasetLabels);

    if (newLabels === oldLabels && oldData.datasets.length === newData.datasets.length) {
      newData.datasets.forEach(function (dataset, i) {
        var oldDatasetKeys = Object.keys(oldData.datasets[i]);
        var newDatasetKeys = Object.keys(dataset);
        var deletionKeys = oldDatasetKeys.filter(function (key) {
          return key !== '_meta' && newDatasetKeys.indexOf(key) === -1;
        });
        deletionKeys.forEach(function (deletionKey) {
          delete chart.data.datasets[i][deletionKey];
        });

        for (var attribute in dataset) {
          if (dataset.hasOwnProperty(attribute)) {
            chart.data.datasets[i][attribute] = dataset[attribute];
          }
        }
      });

      if (newData.hasOwnProperty('labels')) {
        chart.data.labels = newData.labels;
        this.$emit('labels:update');
      }

      if (newData.hasOwnProperty('xLabels')) {
        chart.data.xLabels = newData.xLabels;
        this.$emit('xlabels:update');
      }

      if (newData.hasOwnProperty('yLabels')) {
        chart.data.yLabels = newData.yLabels;
        this.$emit('ylabels:update');
      }

      chart.update();
      this.$emit('chart:update');
    } else {
      if (chart) {
        chart.destroy();
        this.$emit('chart:destroy');
      }

      this.renderChart(this.chartData, this.options);
      this.$emit('chart:render');
    }
  } else {
    if (this.$data._chart) {
      this.$data._chart.destroy();

      this.$emit('chart:destroy');
    }

    this.renderChart(this.chartData, this.options);
    this.$emit('chart:render');
  }
}

var reactiveData = {
  data: function data() {
    return {
      chartData: null
    };
  },
  watch: {
    'chartData': dataHandler
  }
};
var reactiveProp = {
  props: {
    chartData: {
      required: true
    }
  },
  watch: {
    'chartData': dataHandler
  }
};
var mixins = {
  reactiveData: reactiveData,
  reactiveProp: reactiveProp
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var moment = createCommonjsModule(function (module, exports) {

  (function (global, factory) {
    module.exports = factory();
  })(commonjsGlobal, function () {

    var hookCallback;

    function hooks() {
      return hookCallback.apply(null, arguments);
    } // This is done to register the method called with moment()
    // without creating circular dependencies.


    function setHookCallback(callback) {
      hookCallback = callback;
    }

    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
      // IE8 will treat undefined and null as object if it wasn't for
      // input != null
      return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;

        for (k in obj) {
          if (obj.hasOwnProperty(k)) {
            return false;
          }
        }

        return true;
      }
    }

    function isUndefined(input) {
      return input === void 0;
    }

    function isNumber(input) {
      return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
      var res = [],
          i;

      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }

      return res;
    }

    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }

      if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
      }

      if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
      }

      return a;
    }

    function createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
      // We need to deep clone this object.
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }

    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }

      return m._pf;
    }

    var some;

    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }

        return false;
      };
    }

    function isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
          return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }

      return m._isValid;
    }

    function createInvalid(flags) {
      var m = createUTC(NaN);

      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }

      return m;
    } // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.


    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
      var i, prop, val;

      if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
      }

      if (!isUndefined(from._i)) {
        to._i = from._i;
      }

      if (!isUndefined(from._f)) {
        to._f = from._f;
      }

      if (!isUndefined(from._l)) {
        to._l = from._l;
      }

      if (!isUndefined(from._strict)) {
        to._strict = from._strict;
      }

      if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
      }

      if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
      }

      if (!isUndefined(from._offset)) {
        to._offset = from._offset;
      }

      if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
      }

      if (!isUndefined(from._locale)) {
        to._locale = from._locale;
      }

      if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
          prop = momentProperties[i];
          val = from[prop];

          if (!isUndefined(val)) {
            to[prop] = val;
          }
        }
      }

      return to;
    }

    var updateInProgress = false; // Moment prototype object

    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);

      if (!this.isValid()) {
        this._d = new Date(NaN);
      } // Prevent infinite loop in case updateOffset creates new moment
      // objects.


      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }

    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }

    function absFloor(number) {
      if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }

    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;

      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }

      return value;
    } // compare two arrays, return the number of differences


    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;

      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }

      return diffs + lengthDiff;
    }

    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
        console.warn('Deprecation warning: ' + msg);
      }
    }

    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function () {
        var arguments$1 = arguments;

        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }

        if (firstTime) {
          var args = [];
          var arg;

          for (var i = 0; i < arguments.length; i++) {
            arg = '';

            if (typeof arguments$1[i] === 'object') {
              arg += '\n[' + i + '] ';

              for (var key in arguments[0]) {
                arg += key + ': ' + arguments$1[0][key] + ', ';
              }

              arg = arg.slice(0, -2); // Remove trailing comma and space
            } else {
              arg = arguments$1[i];
            }

            args.push(arg);
          }

          warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
          firstTime = false;
        }

        return fn.apply(this, arguments);
      }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }

      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
      return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set(config) {
      var prop, i;

      for (i in config) {
        prop = config[i];

        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }

      this._config = config; // Lenient ordinal parsing accepts just a number in addition to
      // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
      // TODO: Remove "ordinalParse" fallback in next major release.

      this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
    }

    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig),
          prop;

      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }

      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          // make sure changes to properties don't modify parent config
          res[prop] = extend({}, res[prop]);
        }
      }

      return res;
    }

    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }

    var keys;

    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function (obj) {
        var i,
            res = [];

        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }

        return res;
      };
    }

    var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };

    function calendar(key, mom, now) {
      var output = this._calendar[key] || this._calendar['sameElse'];
      return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];

      if (format || !formatUpper) {
        return format;
      }

      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
      });
      return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
      return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
      return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;

      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);

          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }

      return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
      var units = [];

      for (var u in unitsObj) {
        units.push({
          unit: u,
          priority: priorities[u]
        });
      }

      units.sort(function (a, b) {
        return a.priority - b.priority;
      });
      return units;
    }

    function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {}; // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }

    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;

      if (typeof callback === 'string') {
        func = function () {
          return this[callback]();
        };
      }

      if (token) {
        formatTokenFunctions[token] = func;
      }

      if (padded) {
        formatTokenFunctions[padded[0]] = function () {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }

      if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
          return this.localeData().ordinal(func.apply(this, arguments), token);
        };
      }
    }

    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
      }

      return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;

      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }

      return function (mom) {
        var output = '',
            i;

        for (i = 0; i < length; i++) {
          output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }

        return output;
      };
    } // format date using native date object


    function formatMoment(m, format) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }

      format = expandFormat(format, m.localeData());
      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
      return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
      var i = 5;

      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
      }

      localFormattingTokens.lastIndex = 0;

      while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }

      return format;
    }

    var match1 = /\d/; //       0 - 9

    var match2 = /\d\d/; //      00 - 99

    var match3 = /\d{3}/; //     000 - 999

    var match4 = /\d{4}/; //    0000 - 9999

    var match6 = /[+-]?\d{6}/; // -999999 - 999999

    var match1to2 = /\d\d?/; //       0 - 99

    var match3to4 = /\d\d\d\d?/; //     999 - 9999

    var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

    var match1to3 = /\d{1,3}/; //       0 - 999

    var match1to4 = /\d{1,4}/; //       0 - 9999

    var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

    var matchUnsigned = /\d+/; //       0 - inf

    var matchSigned = /[+-]?\d+/; //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months

    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    var regexes = {};

    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }

    function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
      }

      return regexes[token](config._strict, config._locale);
    } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


    function unescapeFormat(s) {
      return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }));
    }

    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
      var i,
          func = callback;

      if (typeof token === 'string') {
        token = [token];
      }

      if (isNumber(callback)) {
        func = function (input, array) {
          array[callback] = toInt(input);
        };
      }

      for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
      }
    }

    function addWeekParseToken(token, callback) {
      addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
      });
    }

    function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
      }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8; // FORMATTING

    addFormatToken('Y', 0, 0, function () {
      var y = this.year();
      return y <= 9999 ? '' + y : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function () {
      return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

    addUnitAlias('year', 'y'); // PRIORITIES

    addUnitPriority('year', 1); // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
      array[YEAR] = parseInt(input, 10);
    }); // HELPERS

    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    } // HOOKS


    hooks.parseTwoDigitYear = function (input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    }; // MOMENTS


    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
      return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
      return function (value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }

    function get(mom, unit) {
      return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        } else {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
      }
    } // MOMENTS


    function stringGet(units) {
      units = normalizeUnits(units);

      if (isFunction(this[units])) {
        return this[units]();
      }

      return this;
    }

    function stringSet(units, value) {
      if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);

        for (var i = 0; i < prioritized.length; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);

        if (isFunction(this[units])) {
          return this[units](value);
        }
      }

      return this;
    }

    function mod(n, x) {
      return (n % x + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function (o) {
        // I know
        var i;

        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }

        return -1;
      };
    }

    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }

      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    } // FORMATTING


    addFormatToken('M', ['MM', 2], 'Mo', function () {
      return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
      return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
      return this.localeData().months(this, format);
    }); // ALIASES

    addUnitAlias('month', 'M'); // PRIORITY

    addUnitPriority('month', 8); // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
      return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
      return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function (input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    }); // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

    function localeMonths(m, format) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months['standalone'];
      }

      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

    function localeMonthsShort(m, format) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
      }

      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
      var i,
          ii,
          mom,
          llc = monthName.toLocaleLowerCase();

      if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];

        for (i = 0; i < 12; ++i) {
          mom = createUTC([2000, i]);
          this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeMonthsParse(monthName, format, strict) {
      var i, mom, regex;

      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
      }

      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      } // TODO: add sorting
      // Sorting makes sure if one month (or abbr) is a prefix of another
      // see sorting in computeMonthsParse


      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);

        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }

        if (!strict && !this._monthsParse[i]) {
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    } // MOMENTS


    function setMonth(mom, value) {
      var dayOfMonth;

      if (!mom.isValid()) {
        // No op
        return mom;
      }

      if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

          if (!isNumber(value)) {
            return mom;
          }
        }
      }

      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

      return mom;
    }

    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, 'Month');
      }
    }

    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;

    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }

        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }

    var defaultMonthsRegex = matchWord;

    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
          this._monthsRegex = defaultMonthsRegex;
        }

        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }

    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom;

      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
      } // Sorting makes sure if one month (or abbr) is a prefix of another it
      // will match the longer piece.


      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
      }

      for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate(y, m, d, h, M, s, ms) {
      // can't just apply() to create a date:
      // https://stackoverflow.com/q/181348
      var date; // the date constructor remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        date = new Date(y + 400, m, d, h, M, s, ms);

        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h, M, s, ms);
      }

      return date;
    }

    function createUTCDate(y) {
      var date; // the Date.UTC function remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        var args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));

        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }

      return date;
    } // start-of-first-week - start-of-year


    function firstWeekOffset(year, dow, doy) {
      var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      fwd = 7 + dow - doy,
          // first-week day local weekday -- which local weekday is fwd
      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear,
          resDayOfYear;

      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }

      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }

    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek,
          resYear;

      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }

      return {
        week: resWeek,
        year: resYear
      };
    }

    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    } // FORMATTING


    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W'); // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5); // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    }); // HELPERS
    // LOCALES

    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    };

    function localeFirstDayOfWeek() {
      return this._week.dow;
    }

    function localeFirstDayOfYear() {
      return this._week.doy;
    } // MOMENTS


    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    } // FORMATTING


    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
      return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
      return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
      return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E'); // PRIORITY

    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11); // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
      return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
      return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
      return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
      week[token] = toInt(input);
    }); // HELPERS

    function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
        return input;
      }

      if (!isNaN(input)) {
        return parseInt(input, 10);
      }

      input = locale.weekdaysParse(input);

      if (typeof input === 'number') {
        return input;
      }

      return null;
    }

    function parseIsoWeekday(input, locale) {
      if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
      }

      return isNaN(input) ? null : input;
    } // LOCALES


    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

    function localeWeekdays(m, format) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
      var i,
          ii,
          mom,
          llc = weekdayName.toLocaleLowerCase();

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
          mom = createUTC([2000, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
      var i, mom, regex;

      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
      }

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);

        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
          this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
          this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
        }

        if (!this._weekdaysParse[i]) {
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    } // MOMENTS


    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    }

    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      } // behaves the same as moment#day except
      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
      // as a setter, sunday should belong to the previous week.


      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }

    var defaultWeekdaysRegex = matchWord;

    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }

        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }

    var defaultWeekdaysShortRegex = matchWord;

    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }

        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }

    var defaultWeekdaysMinRegex = matchWord;

    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }

        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }

    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var minPieces = [],
          shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom,
          minp,
          shortp,
          longp;

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
      // will match the longer piece.


      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    } // FORMATTING


    function hFormat() {
      return this.hours() % 12 || 12;
    }

    function kFormat() {
      return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }

    meridiem('a', true);
    meridiem('A', false); // ALIASES

    addUnitAlias('hour', 'h'); // PRIORITY

    addUnitPriority('hour', 13); // PARSING

    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    }); // LOCALES

    function localeIsPM(input) {
      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
      // Using charAt should be more compatible.
      return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

    function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    } // MOMENTS
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.


    var getSetHour = makeGetSet('Hours', true);
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    }; // internal storage for locale config files

    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
    } // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


    function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;

      while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;

        while (j > 0) {
          locale = loadLocale(split.slice(0, j).join('-'));

          if (locale) {
            return locale;
          }

          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
            //the next array item is better than a shallower substring of this one
            break;
          }

          j--;
        }

        i++;
      }

      return globalLocale;
    }

    function loadLocale(name) {
      var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

      if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
        try {
          oldLocale = globalLocale._abbr;
          var aliasedRequire = commonjsRequire;
          aliasedRequire('./locale/' + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {}
      }

      return locales[name];
    } // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.


    function getSetGlobalLocale(key, values) {
      var data;

      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }

        if (data) {
          // moment.duration._locale = moment._locale = data;
          globalLocale = data;
        } else {
          if (typeof console !== 'undefined' && console.warn) {
            //warn user if arguments are passed but the locale could not be set
            console.warn('Locale ' + key + ' not found. Did you forget to load it?');
          }
        }
      }

      return globalLocale._abbr;
    }

    function defineLocale(name, config) {
      if (config !== null) {
        var locale,
            parentConfig = baseConfig;
        config.abbr = name;

        if (locales[name] != null) {
          deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale = loadLocale(config.parentLocale);

            if (locale != null) {
              parentConfig = locale._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }

              localeFamilies[config.parentLocale].push({
                name: name,
                config: config
              });
              return null;
            }
          }
        }

        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function (x) {
            defineLocale(x.name, x.config);
          });
        } // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.


        getSetGlobalLocale(name);
        return locales[name];
      } else {
        // useful for testing
        delete locales[name];
        return null;
      }
    }

    function updateLocale(name, config) {
      if (config != null) {
        var locale,
            tmpLocale,
            parentConfig = baseConfig; // MERGE

        tmpLocale = loadLocale(name);

        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }

        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale; // backwards compat for now: also set the locale

        getSetGlobalLocale(name);
      } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }

      return locales[name];
    } // returns locale data


    function getLocale(key) {
      var locale;

      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }

      if (!key) {
        return globalLocale;
      }

      if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);

        if (locale) {
          return locale;
        }

        key = [key];
      }

      return chooseLocale(key);
    }

    function listLocales() {
      return keys(locales);
    }

    function checkOverflow(m) {
      var overflow;
      var a = m._a;

      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }

        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }

        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
      }

      return m;
    } // Pick the first defined of two or three arguments.


    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }

      if (b != null) {
        return b;
      }

      return c;
    }

    function currentDateArray(config) {
      // hooks is actually the exported moment object
      var nowValue = new Date(hooks.now());

      if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
      }

      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    } // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]


    function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          expectedWeekday,
          yearToUse;

      if (config._d) {
        return;
      }

      currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      } //if the day of the year is set, figure out what it is


      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      } // Default to current date.
      // * if no year, month, day of month are given, default to today
      // * if day of month is given, default month and year
      // * if month is given, default only year
      // * if year is given, don't default anything


      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      } // Zero out whatever was not defaulted, including time


      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      } // Check for 24:00:00.000


      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }

      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
      // with parseZone.

      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }

      if (config._nextDay) {
        config._a[HOUR] = 24;
      } // check for mismatching day of week


      if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }

    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
      w = config._w;

      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).

        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);

        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        var curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
          // weekday -- low day numbers are considered next week
          weekday = w.d;

          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          // local weekday -- counting starts from beginning of week
          weekday = w.e + dow;

          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          // default to beginning of week
          weekday = dow;
        }
      }

      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    } // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

    function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime,
          dateFormat,
          timeFormat,
          tzFormat;

      if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }

        if (dateFormat == null) {
          config._isValid = false;
          return;
        }

        if (match[3]) {
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              // match[2] should be 'T' or space
              timeFormat = (match[2] || ' ') + isoTimes[i][0];
              break;
            }
          }

          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }

        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }

        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = 'Z';
          } else {
            config._isValid = false;
            return;
          }
        }

        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }

      return result;
    }

    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);

      if (year <= 49) {
        return 2000 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }

      return year;
    }

    function preprocessRFC2822(s) {
      // Remove comments and folding whitespace and replace multiple-spaces with a single space
      return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }

      return true;
    }

    var obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
      } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100,
            h = (hm - m) / 100;
        return h * 60 + m;
      }
    } // date and time from ref 2822 format


    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i));

      if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);

        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    } // date from iso format or fallback


    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);

      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }

      configFromISO(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }

      configFromRFC2822(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      } // Final attempt, use Input Fallback


      hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }); // constant that refers to the ISO standard

    hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


    hooks.RFC_2822 = function () {}; // date from string and format string


    function configFromStringAndFormat(config) {
      // TODO: Move this to another part of the creation flow to prevent circular deps
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }

      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }

      config._a = [];
      getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;
      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));

        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));

          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }

          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        } // don't parse if it's not a known token


        if (formatTokenFunctions[token]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token);
          }

          addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token);
        }
      } // add remaining unparsed input length to the string


      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      } // clear _12h flag if hour is <= 12


      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }

      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      configFromArray(config);
      checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;

      if (meridiem == null) {
        // nothing to do
        return hour;
      }

      if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);

        if (isPm && hour < 12) {
          hour += 12;
        }

        if (!isPm && hour === 12) {
          hour = 0;
        }

        return hour;
      } else {
        // this is not supposed to happen
        return hour;
      }
    } // date from string and array of format strings


    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore;

      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }

      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);

        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }

        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
          continue;
        } // if there is any input that was not parsed add a penalty for that format


        currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }

      extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
      if (config._d) {
        return;
      }

      var i = normalizeObjectUnits(config._i);
      config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
      });
      configFromArray(config);
    }

    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));

      if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
      }

      return res;
    }

    function prepareConfig(config) {
      var input = config._i,
          format = config._f;
      config._locale = config._locale || getLocale(config._l);

      if (input === null || format === undefined && input === '') {
        return createInvalid({
          nullInput: true
        });
      }

      if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
      }

      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format)) {
        configFromStringAndArray(config);
      } else if (format) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }

      if (!isValid(config)) {
        config._d = null;
      }

      return config;
    }

    function configFromInput(config) {
      var input = config._i;

      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === 'string') {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};

      if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
      }

      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = undefined;
      } // object construction must be done this way.
      // https://github.com/moment/moment/issues/1423


      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;
      return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    }); // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.

    function pickBy(fn, moments) {
      var res, i;

      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }

      if (!moments.length) {
        return createLocal();
      }

      res = moments[0];

      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }

      return res;
    } // TODO: Use [].sort instead?


    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isBefore', args);
    }

    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isAfter', args);
    }

    var now = function () {
      return Date.now ? Date.now() : +new Date();
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
      for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }

      var unitHasDecimal = false;

      for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false; // only allow non-integers for smallest unit
          }

          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }

      return true;
    }

    function isValid$1() {
      return this._isValid;
    }

    function createInvalid$1() {
      return createDuration(NaN);
    }

    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

      this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
      minutes * 6e4 + // 1000 * 60
      hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
      // Because of dateAddRemove treats 24 hours as different from a
      // day when working around DST, we need to store them separately

      this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
      // which months you are are talking about, so we have to store
      // it separately.

      this._months = +months + quarters * 3 + years * 12;
      this._data = {};
      this._locale = getLocale();

      this._bubble();
    }

    function isDuration(obj) {
      return obj instanceof Duration;
    }

    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    } // FORMATTING


    function offset(token, separator) {
      addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';

        if (offset < 0) {
          offset = -offset;
          sign = '-';
        }

        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
      });
    }

    offset('Z', ':');
    offset('ZZ', ''); // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    }); // HELPERS
    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']

    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
      var matches = (string || '').match(matcher);

      if (matches === null) {
        return null;
      }

      var chunk = matches[matches.length - 1] || [];
      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);
      return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    } // Return a moment from input, that is local/utc/zone equivalent to model.


    function cloneWithOffset(input, model) {
      var res, diff;

      if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

        res._d.setTime(res._d.valueOf() + diff);

        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }

    function getDateOffset(m) {
      // On Firefox.24 Date#getTimezoneOffset returns a floating point.
      // https://github.com/moment/moment/pull/1871
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    } // HOOKS
    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.


    hooks.updateOffset = function () {}; // MOMENTS
    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.


    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset = this._offset || 0,
          localAdjust;

      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      if (input != null) {
        if (typeof input === 'string') {
          input = offsetFromString(matchShortOffset, input);

          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }

        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }

        this._offset = input;
        this._isUTC = true;

        if (localAdjust != null) {
          this.add(localAdjust, 'm');
        }

        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(this, createDuration(input - offset, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }

        return this;
      } else {
        return this._isUTC ? offset : getDateOffset(this);
      }
    }

    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== 'string') {
          input = -input;
        }

        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }

    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
          this.subtract(getDateOffset(this), 'm');
        }
      }

      return this;
    }

    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);

        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }

      return this;
    }

    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }

      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }

    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }

      var c = {};
      copyConfig(c, this);
      c = prepareConfig(c);

      if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }

      return this._isDSTShifted;
    }

    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    } // ASP.NET json date format regex


    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day

    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
      var duration = input,
          // matching against regexp is expensive, do it on demand
      match = null,
          sign,
          ret,
          diffRes;

      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input)) {
        duration = {};

        if (key) {
          duration[key] = input;
        } else {
          duration.milliseconds = input;
        }
      } else if (!!(match = aspNetRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign,
          h: toInt(match[HOUR]) * sign,
          m: toInt(match[MINUTE]) * sign,
          s: toInt(match[SECOND]) * sign,
          ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

        };
      } else if (!!(match = isoRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign),
          M: parseIso(match[3], sign),
          w: parseIso(match[4], sign),
          d: parseIso(match[5], sign),
          h: parseIso(match[6], sign),
          m: parseIso(match[7], sign),
          s: parseIso(match[8], sign)
        };
      } else if (duration == null) {
        // checks for null or undefined
        duration = {};
      } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }

      ret = new Duration(duration);

      if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
      }

      return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
      // We'd normally use ~~inp for this, but unfortunately it also
      // converts floats to ints.
      // inp may be undefined, so careful calling replace on it.
      var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

      return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

      if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
      }

      res.milliseconds = +other - +base.clone().add(res.months, 'M');
      return res;
    }

    function momentsDifference(base, other) {
      var res;

      if (!(base.isValid() && other.isValid())) {
        return {
          milliseconds: 0,
          months: 0
        };
      }

      other = cloneWithOffset(other, base);

      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }

      return res;
    } // TODO: remove 'name' arg after deprecation is removed


    function createAdder(direction, name) {
      return function (val, period) {
        var dur, tmp; //invert the arguments, but complain about it

        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
          tmp = val;
          val = period;
          period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);

      if (!mom.isValid()) {
        // No op
        return;
      }

      updateOffset = updateOffset == null ? true : updateOffset;

      if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
      }

      if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
      }

      if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
      }

      if (updateOffset) {
        hooks.updateOffset(mom, days || months);
      }
    }

    var add = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
      var diff = myMoment.diff(now, 'days', true);
      return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1(time, formats) {
      // We want to compare the start of today, vs this.
      // Getting start-of-today depends on whether we're local/utc/offset or not.
      var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse';
      var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
      return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone() {
      return new Moment(this);
    }

    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }

    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }

    function isBetween(from, to, units, inclusivity) {
      var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to);

      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }

      inclusivity = inclusivity || '()';
      return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input),
          inputMs;

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }

    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
      var that, zoneDelta, output;

      if (!this.isValid()) {
        return NaN;
      }

      that = cloneWithOffset(input, this);

      if (!that.isValid()) {
        return NaN;
      }

      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);

      switch (units) {
        case 'year':
          output = monthDiff(this, that) / 12;
          break;

        case 'month':
          output = monthDiff(this, that);
          break;

        case 'quarter':
          output = monthDiff(this, that) / 3;
          break;

        case 'second':
          output = (this - that) / 1e3;
          break;
        // 1000

        case 'minute':
          output = (this - that) / 6e4;
          break;
        // 1000 * 60

        case 'hour':
          output = (this - that) / 36e5;
          break;
        // 1000 * 60 * 60

        case 'day':
          output = (this - that - zoneDelta) / 864e5;
          break;
        // 1000 * 60 * 60 * 24, negate dst

        case 'week':
          output = (this - that - zoneDelta) / 6048e5;
          break;
        // 1000 * 60 * 60 * 24 * 7, negate dst

        default:
          output = this - that;
      }

      return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
      // difference in months
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;

      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor2 - anchor);
      } //check for negative zero, return zero if negative zero


      return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }

      var utc = keepOffset !== true;
      var m = utc ? this.clone().utc() : this;

      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
      }

      return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */


    function inspect() {
      if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
      }

      var func = 'moment';
      var zone = '';

      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
      }

      var prefix = '[' + func + '("]';
      var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
      var datetime = '-MM-DD[T]HH:mm:ss.SSS';
      var suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }

      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          to: this,
          from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          from: this,
          to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    } // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.


    function locale(key) {
      var newLocaleData;

      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);

        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }

        return this;
      }
    }

    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });

    function localeData() {
      return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }

    function utcStartOfDate(y, m, d) {
      // Date.UTC remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }

    function startOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year(), 0, 1);
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
          break;

        case 'month':
          time = startOfDate(this.year(), this.month(), 1);
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date());
          break;

        case 'hour':
          time = this._d.valueOf();
          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
          break;

        case 'minute':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;

        case 'second':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function endOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;

        case 'month':
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;

        case 'hour':
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
          break;

        case 'minute':
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;

        case 'second':
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
      return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
      return new Date(this.valueOf());
    }

    function toArray() {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }

    function toJSON() {
      // new Date(NaN).toJSON() === null
      return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
      return isValid(this);
    }

    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
      return getParsingFlags(this).overflow;
    }

    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    } // FORMATTING


    addFormatToken(0, ['gg', 2], 0, function () {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function () {
      return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1); // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
      week[token] = hooks.parseTwoDigitYear(input);
    }); // MOMENTS

    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }

    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;

      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;

      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);

        if (week > weeksTarget) {
          week = weeksTarget;
        }

        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    } // FORMATTING


    addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

    addUnitAlias('quarter', 'Q'); // PRIORITY

    addUnitPriority('quarter', 7); // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    }); // MOMENTS

    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    } // FORMATTING


    addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

    addUnitAlias('date', 'D'); // PRIORITY

    addUnitPriority('date', 9); // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
      // TODO: Remove "ordinalParse" fallback in next major release.
      return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    }); // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

    addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

    addUnitPriority('dayOfYear', 4); // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
      config._dayOfYear = toInt(input);
    }); // HELPERS
    // MOMENTS

    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    } // FORMATTING


    addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

    addUnitAlias('minute', 'm'); // PRIORITY

    addUnitPriority('minute', 14); // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE); // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

    addUnitAlias('second', 's'); // PRIORITY

    addUnitPriority('second', 15); // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND); // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

    addFormatToken('S', 0, 0, function () {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function () {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
      return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
      return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
      return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
      return this.millisecond() * 1000000;
    }); // ALIASES

    addUnitAlias('millisecond', 'ms'); // PRIORITY

    addUnitPriority('millisecond', 16); // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token;

    for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
    } // MOMENTS


    var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

    function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix(input) {
      return createLocal(input * 1000);
    }

    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
      return string;
    }

    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
      var locale = getLocale();
      var utc = createUTC().set(setter, index);
      return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';

      if (index != null) {
        return get$1(format, index, field, 'month');
      }

      var i;
      var out = [];

      for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
      }

      return out;
    } // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)


    function listWeekdaysImpl(localeSorted, format, index, field) {
      if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      }

      var locale = getLocale(),
          shift = localeSorted ? locale._week.dow : 0;

      if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
      }

      var i;
      var out = [];

      for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
      }

      return out;
    }

    function listMonths(format, index) {
      return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
      return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function (number) {
        var b = number % 10,
            output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        return number + output;
      }
    }); // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    var mathAbs = Math.abs;

    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }

    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    } // supports only 2.0-style add(1, 's') or add(duration)


    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    } // supports only 2.0-style subtract(1, 's') or subtract(duration)


    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }

    function bubble() {
      var milliseconds = this._milliseconds;
      var days = this._days;
      var months = this._months;
      var data = this._data;
      var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
      // check: https://github.com/moment/moment/issues/2166

      if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
      } // The following code bubbles up values, see the tests for
      // examples of what that means.


      data.milliseconds = milliseconds % 1000;
      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;
      hours = absFloor(minutes / 60);
      data.hours = hours % 24;
      days += absFloor(hours / 24); // convert days to months

      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
      return this;
    }

    function daysToMonths(days) {
      // 400 years have 146097 days (taking into account leap year rules)
      // 400 years have 12 months === 4800
      return days * 4800 / 146097;
    }

    function monthsToDays(months) {
      // the reverse of daysToMonths
      return months * 146097 / 4800;
    }

    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }

      var days;
      var months;
      var milliseconds = this._milliseconds;
      units = normalizeUnits(units);

      if (units === 'month' || units === 'quarter' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);

        switch (units) {
          case 'month':
            return months;

          case 'quarter':
            return months / 3;

          case 'year':
            return months / 12;
        }
      } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));

        switch (units) {
          case 'week':
            return days / 7 + milliseconds / 6048e5;

          case 'day':
            return days + milliseconds / 864e5;

          case 'hour':
            return days * 24 + milliseconds / 36e5;

          case 'minute':
            return days * 1440 + milliseconds / 6e4;

          case 'second':
            return days * 86400 + milliseconds / 1000;
          // Math.floor prevents floating point math errors here

          case 'millisecond':
            return Math.floor(days * 864e5) + milliseconds;

          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    } // TODO: Use this.as('ms')?


    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }

      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }

    function makeAs(alias) {
      return function () {
        return this.as(alias);
      };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asQuarters = makeAs('Q');
    var asYears = makeAs('y');

    function clone$1() {
      return createDuration(this);
    }

    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
      return function () {
        return this.isValid() ? this._data[name] : NaN;
      };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
      return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month
      M: 11 // months to year

    }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
      var duration = createDuration(posNegDuration).abs();
      var seconds = round(duration.as('s'));
      var minutes = round(duration.as('m'));
      var hours = round(duration.as('h'));
      var days = round(duration.as('d'));
      var months = round(duration.as('M'));
      var years = round(duration.as('y'));
      var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
    } // This function allows you to set the rounding function for relative time strings


    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === undefined) {
        return round;
      }

      if (typeof roundingFunction === 'function') {
        round = roundingFunction;
        return true;
      }

      return false;
    } // This function allows you to set a threshold for relative time strings


    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }

      if (limit === undefined) {
        return thresholds[threshold];
      }

      thresholds[threshold] = limit;

      if (threshold === 's') {
        thresholds.ss = limit - 1;
      }

      return true;
    }

    function humanize(withSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var locale = this.localeData();
      var output = relativeTime$1(this, !withSuffix, locale);

      if (withSuffix) {
        output = locale.pastFuture(+this, output);
      }

      return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
      // for ISO strings we do not use the normal bubbling rules:
      //  * milliseconds bubble up until they become hours
      //  * days do not bubble at all
      //  * months bubble up until they become years
      // This is because there is no context-free conversion between hours and days
      // (think of clock changes)
      // and also not between days and months (28-31 days per month)
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var seconds = abs$1(this._milliseconds) / 1000;
      var days = abs$1(this._days);
      var months = abs$1(this._months);
      var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

      minutes = absFloor(seconds / 60);
      hours = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60; // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

      var Y = years;
      var M = months;
      var D = days;
      var h = hours;
      var m = minutes;
      var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
      var total = this.asSeconds();

      if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
      }

      var totalSign = total < 0 ? '-' : '';
      var ymSign = sign(this._months) !== sign(total) ? '-' : '';
      var daysSign = sign(this._days) !== sign(total) ? '-' : '';
      var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
      return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang; // Side effect imports
    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf'); // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
      config._d = new Date(toInt(input));
    }); // Side effect imports

    hooks.version = '2.24.0';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

    hooks.HTML5_FMT = {
      DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
      // <input type="datetime-local" step="0.001" />
      DATE: 'YYYY-MM-DD',
      // <input type="date" />
      TIME: 'HH:mm',
      // <input type="time" />
      TIME_SECONDS: 'HH:mm:ss',
      // <input type="time" step="1" />
      TIME_MS: 'HH:mm:ss.SSS',
      // <input type="time" step="0.001" />
      WEEK: 'GGGG-[W]WW',
      // <input type="week" />
      MONTH: 'YYYY-MM' // <input type="month" />

    };
    return hooks;
  });
});

var Chart$1 = createCommonjsModule(function (module, exports) {
  /*!
   * Chart.js v2.8.0
   * https://www.chartjs.org
   * (c) 2019 Chart.js Contributors
   * Released under the MIT License
   */
  (function (global, factory) {
    module.exports = factory(function () {
      try {
        return moment;
      } catch (e) {}
    }());
  })(commonjsGlobal, function (moment) {

    moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;
    /* MIT license */

    var conversions = {
      rgb2hsl: rgb2hsl,
      rgb2hsv: rgb2hsv,
      rgb2hwb: rgb2hwb,
      rgb2cmyk: rgb2cmyk,
      rgb2keyword: rgb2keyword,
      rgb2xyz: rgb2xyz,
      rgb2lab: rgb2lab,
      rgb2lch: rgb2lch,
      hsl2rgb: hsl2rgb,
      hsl2hsv: hsl2hsv,
      hsl2hwb: hsl2hwb,
      hsl2cmyk: hsl2cmyk,
      hsl2keyword: hsl2keyword,
      hsv2rgb: hsv2rgb,
      hsv2hsl: hsv2hsl,
      hsv2hwb: hsv2hwb,
      hsv2cmyk: hsv2cmyk,
      hsv2keyword: hsv2keyword,
      hwb2rgb: hwb2rgb,
      hwb2hsl: hwb2hsl,
      hwb2hsv: hwb2hsv,
      hwb2cmyk: hwb2cmyk,
      hwb2keyword: hwb2keyword,
      cmyk2rgb: cmyk2rgb,
      cmyk2hsl: cmyk2hsl,
      cmyk2hsv: cmyk2hsv,
      cmyk2hwb: cmyk2hwb,
      cmyk2keyword: cmyk2keyword,
      keyword2rgb: keyword2rgb,
      keyword2hsl: keyword2hsl,
      keyword2hsv: keyword2hsv,
      keyword2hwb: keyword2hwb,
      keyword2cmyk: keyword2cmyk,
      keyword2lab: keyword2lab,
      keyword2xyz: keyword2xyz,
      xyz2rgb: xyz2rgb,
      xyz2lab: xyz2lab,
      xyz2lch: xyz2lch,
      lab2xyz: lab2xyz,
      lab2rgb: lab2rgb,
      lab2lch: lab2lch,
      lch2lab: lch2lab,
      lch2xyz: lch2xyz,
      lch2rgb: lch2rgb
    };

    function rgb2hsl(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          l;

      if (max == min) {
        h = 0;
      } else if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else if (b == max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      l = (min + max) / 2;

      if (max == min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100];
    }

    function rgb2hsv(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          v;

      if (max == 0) {
        s = 0;
      } else {
        s = delta / max * 1000 / 10;
      }

      if (max == min) {
        h = 0;
      } else if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else if (b == max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      v = max / 255 * 1000 / 10;
      return [h, s, v];
    }

    function rgb2hwb(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          h = rgb2hsl(rgb)[0],
          w = 1 / 255 * Math.min(r, Math.min(g, b)),
          b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    }

    function rgb2cmyk(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          c,
          m,
          y,
          k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    }

    function rgb2keyword(rgb) {
      return reverseKeywords[JSON.stringify(rgb)];
    }

    function rgb2xyz(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255; // assume sRGB

      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    }

    function rgb2lab(rgb) {
      var xyz = rgb2xyz(rgb),
          x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function rgb2lch(args) {
      return lab2lch(rgb2lab(args));
    }

    function hsl2rgb(hsl) {
      var h = hsl[0] / 360,
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          t1,
          t2,
          t3,
          rgb,
          val;

      if (s == 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        t3 < 0 && t3++;
        t3 > 1 && t3--;

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    }

    function hsl2hsv(hsl) {
      var h = hsl[0],
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          sv,
          v;

      if (l === 0) {
        // no need to do calc on black
        // also avoids divide by 0 error
        return [0, 0, 0];
      }

      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      v = (l + s) / 2;
      sv = 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    }

    function hsl2hwb(args) {
      return rgb2hwb(hsl2rgb(args));
    }

    function hsl2cmyk(args) {
      return rgb2cmyk(hsl2rgb(args));
    }

    function hsl2keyword(args) {
      return rgb2keyword(hsl2rgb(args));
    }

    function hsv2rgb(hsv) {
      var h = hsv[0] / 60,
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          hi = Math.floor(h) % 6;
      var f = h - Math.floor(h),
          p = 255 * v * (1 - s),
          q = 255 * v * (1 - s * f),
          t = 255 * v * (1 - s * (1 - f)),
          v = 255 * v;

      switch (hi) {
        case 0:
          return [v, t, p];

        case 1:
          return [q, v, p];

        case 2:
          return [p, v, t];

        case 3:
          return [p, q, v];

        case 4:
          return [t, p, v];

        case 5:
          return [v, p, q];
      }
    }

    function hsv2hsl(hsv) {
      var h = hsv[0],
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          sl,
          l;
      l = (2 - s) * v;
      sl = s * v;
      sl /= l <= 1 ? l : 2 - l;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    }

    function hsv2hwb(args) {
      return rgb2hwb(hsv2rgb(args));
    }

    function hsv2cmyk(args) {
      return rgb2cmyk(hsv2rgb(args));
    }

    function hsv2keyword(args) {
      return rgb2keyword(hsv2rgb(args));
    } // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


    function hwb2rgb(hwb) {
      var h = hwb[0] / 360,
          wh = hwb[1] / 100,
          bl = hwb[2] / 100,
          ratio = wh + bl,
          i,
          v,
          f,
          n; // wh + bl cant be > 1

      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }

      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;

      if ((i & 0x01) != 0) {
        f = 1 - f;
      }

      n = wh + f * (v - wh); // linear interpolation

      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;

        case 1:
          r = n;
          g = v;
          b = wh;
          break;

        case 2:
          r = wh;
          g = v;
          b = n;
          break;

        case 3:
          r = wh;
          g = n;
          b = v;
          break;

        case 4:
          r = n;
          g = wh;
          b = v;
          break;

        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }

      return [r * 255, g * 255, b * 255];
    }

    function hwb2hsl(args) {
      return rgb2hsl(hwb2rgb(args));
    }

    function hwb2hsv(args) {
      return rgb2hsv(hwb2rgb(args));
    }

    function hwb2cmyk(args) {
      return rgb2cmyk(hwb2rgb(args));
    }

    function hwb2keyword(args) {
      return rgb2keyword(hwb2rgb(args));
    }

    function cmyk2rgb(cmyk) {
      var c = cmyk[0] / 100,
          m = cmyk[1] / 100,
          y = cmyk[2] / 100,
          k = cmyk[3] / 100,
          r,
          g,
          b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    }

    function cmyk2hsl(args) {
      return rgb2hsl(cmyk2rgb(args));
    }

    function cmyk2hsv(args) {
      return rgb2hsv(cmyk2rgb(args));
    }

    function cmyk2hwb(args) {
      return rgb2hwb(cmyk2rgb(args));
    }

    function cmyk2keyword(args) {
      return rgb2keyword(cmyk2rgb(args));
    }

    function xyz2rgb(xyz) {
      var x = xyz[0] / 100,
          y = xyz[1] / 100,
          z = xyz[2] / 100,
          r,
          g,
          b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    }

    function xyz2lab(xyz) {
      var x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function xyz2lch(args) {
      return lab2lch(xyz2lab(args));
    }

    function lab2xyz(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          x,
          y,
          z,
          y2;

      if (l <= 8) {
        y = l * 100 / 903.3;
        y2 = 7.787 * (y / 100) + 16 / 116;
      } else {
        y = 100 * Math.pow((l + 16) / 116, 3);
        y2 = Math.pow(y / 100, 1 / 3);
      }

      x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
      z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
      return [x, y, z];
    }

    function lab2lch(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          hr,
          h,
          c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;

      if (h < 0) {
        h += 360;
      }

      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    }

    function lab2rgb(args) {
      return xyz2rgb(lab2xyz(args));
    }

    function lch2lab(lch) {
      var l = lch[0],
          c = lch[1],
          h = lch[2],
          a,
          b,
          hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    }

    function lch2xyz(args) {
      return lab2xyz(lch2lab(args));
    }

    function lch2rgb(args) {
      return lab2rgb(lch2lab(args));
    }

    function keyword2rgb(keyword) {
      return cssKeywords[keyword];
    }

    function keyword2hsl(args) {
      return rgb2hsl(keyword2rgb(args));
    }

    function keyword2hsv(args) {
      return rgb2hsv(keyword2rgb(args));
    }

    function keyword2hwb(args) {
      return rgb2hwb(keyword2rgb(args));
    }

    function keyword2cmyk(args) {
      return rgb2cmyk(keyword2rgb(args));
    }

    function keyword2lab(args) {
      return rgb2lab(keyword2rgb(args));
    }

    function keyword2xyz(args) {
      return rgb2xyz(keyword2rgb(args));
    }

    var cssKeywords = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    var reverseKeywords = {};

    for (var key in cssKeywords) {
      reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
    }

    var convert = function () {
      return new Converter();
    };

    for (var func in conversions) {
      // export Raw versions
      convert[func + "Raw"] = function (func) {
        // accept array or plain args
        return function (arg) {
          if (typeof arg == "number") {
            arg = Array.prototype.slice.call(arguments);
          }

          return conversions[func](arg);
        };
      }(func);

      var pair = /(\w+)2(\w+)/.exec(func),
          from = pair[1],
          to = pair[2]; // export rgb2hsl and ["rgb"]["hsl"]

      convert[from] = convert[from] || {};

      convert[from][to] = convert[func] = function (func) {
        return function (arg) {
          if (typeof arg == "number") {
            arg = Array.prototype.slice.call(arguments);
          }

          var val = conversions[func](arg);

          if (typeof val == "string" || val === undefined) {
            return val;
          } // keyword


          for (var i = 0; i < val.length; i++) {
            val[i] = Math.round(val[i]);
          }

          return val;
        };
      }(func);
    }
    /* Converter does lazy conversion and caching */


    var Converter = function () {
      this.convs = {};
    };
    /* Either get the values for a space or
      set the values for a space, depending on args */


    Converter.prototype.routeSpace = function (space, args) {
      var values = args[0];

      if (values === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof values == "number") {
        values = Array.prototype.slice.call(args);
      }

      return this.setValues(space, values);
    };
    /* Set the values for a space, invalidating cache */


    Converter.prototype.setValues = function (space, values) {
      this.space = space;
      this.convs = {};
      this.convs[space] = values;
      return this;
    };
    /* Get the values for a space. If there's already
      a conversion for the space, fetch it, otherwise
      compute it */


    Converter.prototype.getValues = function (space) {
      var vals = this.convs[space];

      if (!vals) {
        var fspace = this.space,
            from = this.convs[fspace];
        vals = convert[fspace][space](from);
        this.convs[space] = vals;
      }

      return vals;
    };

    ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
      Converter.prototype[space] = function (vals) {
        return this.routeSpace(space, arguments);
      };
    });
    var colorConvert = convert;
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    /* MIT license */

    var colorString = {
      getRgba: getRgba,
      getHsla: getHsla,
      getRgb: getRgb,
      getHsl: getHsl,
      getHwb: getHwb,
      getAlpha: getAlpha,
      hexString: hexString,
      rgbString: rgbString,
      rgbaString: rgbaString,
      percentString: percentString,
      percentaString: percentaString,
      hslString: hslString,
      hslaString: hslaString,
      hwbString: hwbString,
      keyword: keyword
    };

    function getRgba(string) {
      if (!string) {
        return;
      }

      var abbr = /^#([a-fA-F0-9]{3,4})$/i,
          hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
          rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          keyword = /(\w+)/;
      var rgb = [0, 0, 0],
          a = 1,
          match = string.match(abbr),
          hexAlpha = "";

      if (match) {
        match = match[1];
        hexAlpha = match[3];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }

        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
        }

        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(rgba)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i + 1]);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(per)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(keyword)) {
        if (match[1] == "transparent") {
          return [0, 0, 0, 0];
        }

        rgb = colorName[match[1]];

        if (!rgb) {
          return;
        }
      }

      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = scale(rgb[i], 0, 255);
      }

      if (!a && a != 0) {
        a = 1;
      } else {
        a = scale(a, 0, 1);
      }

      rgb[3] = a;
      return rgb;
    }

    function getHsla(string) {
      if (!string) {
        return;
      }

      var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hsl);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            s = scale(parseFloat(match[2]), 0, 100),
            l = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
    }

    function getHwb(string) {
      if (!string) {
        return;
      }

      var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hwb);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            w = scale(parseFloat(match[2]), 0, 100),
            b = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
    }

    function getRgb(string) {
      var rgba = getRgba(string);
      return rgba && rgba.slice(0, 3);
    }

    function getHsl(string) {
      var hsla = getHsla(string);
      return hsla && hsla.slice(0, 3);
    }

    function getAlpha(string) {
      var vals = getRgba(string);

      if (vals) {
        return vals[3];
      } else if (vals = getHsla(string)) {
        return vals[3];
      } else if (vals = getHwb(string)) {
        return vals[3];
      }
    } // generators


    function hexString(rgba, a) {
      var a = a !== undefined && rgba.length === 3 ? a : rgba[3];
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
    }

    function rgbString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return rgbaString(rgba, alpha);
      }

      return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
    }

    function rgbaString(rgba, alpha) {
      if (alpha === undefined) {
        alpha = rgba[3] !== undefined ? rgba[3] : 1;
      }

      return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
    }

    function percentString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return percentaString(rgba, alpha);
      }

      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgb(" + r + "%, " + g + "%, " + b + "%)";
    }

    function percentaString(rgba, alpha) {
      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
    }

    function hslString(hsla, alpha) {
      if (alpha < 1 || hsla[3] && hsla[3] < 1) {
        return hslaString(hsla, alpha);
      }

      return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
    }

    function hslaString(hsla, alpha) {
      if (alpha === undefined) {
        alpha = hsla[3] !== undefined ? hsla[3] : 1;
      }

      return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
    } // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
    // (hwb have alpha optional & 1 is default value)


    function hwbString(hwb, alpha) {
      if (alpha === undefined) {
        alpha = hwb[3] !== undefined ? hwb[3] : 1;
      }

      return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
    }

    function keyword(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    } // helpers


    function scale(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }

    function hexDouble(num) {
      var str = num.toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    } //create a list of reverse color names


    var reverseNames = {};

    for (var name in colorName) {
      reverseNames[colorName[name]] = name;
    }
    /* MIT license */


    var Color = function (obj) {
      if (obj instanceof Color) {
        return obj;
      }

      if (!(this instanceof Color)) {
        return new Color(obj);
      }

      this.valid = false;
      this.values = {
        rgb: [0, 0, 0],
        hsl: [0, 0, 0],
        hsv: [0, 0, 0],
        hwb: [0, 0, 0],
        cmyk: [0, 0, 0, 0],
        alpha: 1
      }; // parse Color() argument

      var vals;

      if (typeof obj === 'string') {
        vals = colorString.getRgba(obj);

        if (vals) {
          this.setValues('rgb', vals);
        } else if (vals = colorString.getHsla(obj)) {
          this.setValues('hsl', vals);
        } else if (vals = colorString.getHwb(obj)) {
          this.setValues('hwb', vals);
        }
      } else if (typeof obj === 'object') {
        vals = obj;

        if (vals.r !== undefined || vals.red !== undefined) {
          this.setValues('rgb', vals);
        } else if (vals.l !== undefined || vals.lightness !== undefined) {
          this.setValues('hsl', vals);
        } else if (vals.v !== undefined || vals.value !== undefined) {
          this.setValues('hsv', vals);
        } else if (vals.w !== undefined || vals.whiteness !== undefined) {
          this.setValues('hwb', vals);
        } else if (vals.c !== undefined || vals.cyan !== undefined) {
          this.setValues('cmyk', vals);
        }
      }
    };

    Color.prototype = {
      isValid: function () {
        return this.valid;
      },
      rgb: function () {
        return this.setSpace('rgb', arguments);
      },
      hsl: function () {
        return this.setSpace('hsl', arguments);
      },
      hsv: function () {
        return this.setSpace('hsv', arguments);
      },
      hwb: function () {
        return this.setSpace('hwb', arguments);
      },
      cmyk: function () {
        return this.setSpace('cmyk', arguments);
      },
      rgbArray: function () {
        return this.values.rgb;
      },
      hslArray: function () {
        return this.values.hsl;
      },
      hsvArray: function () {
        return this.values.hsv;
      },
      hwbArray: function () {
        var values = this.values;

        if (values.alpha !== 1) {
          return values.hwb.concat([values.alpha]);
        }

        return values.hwb;
      },
      cmykArray: function () {
        return this.values.cmyk;
      },
      rgbaArray: function () {
        var values = this.values;
        return values.rgb.concat([values.alpha]);
      },
      hslaArray: function () {
        var values = this.values;
        return values.hsl.concat([values.alpha]);
      },
      alpha: function (val) {
        if (val === undefined) {
          return this.values.alpha;
        }

        this.setValues('alpha', val);
        return this;
      },
      red: function (val) {
        return this.setChannel('rgb', 0, val);
      },
      green: function (val) {
        return this.setChannel('rgb', 1, val);
      },
      blue: function (val) {
        return this.setChannel('rgb', 2, val);
      },
      hue: function (val) {
        if (val) {
          val %= 360;
          val = val < 0 ? 360 + val : val;
        }

        return this.setChannel('hsl', 0, val);
      },
      saturation: function (val) {
        return this.setChannel('hsl', 1, val);
      },
      lightness: function (val) {
        return this.setChannel('hsl', 2, val);
      },
      saturationv: function (val) {
        return this.setChannel('hsv', 1, val);
      },
      whiteness: function (val) {
        return this.setChannel('hwb', 1, val);
      },
      blackness: function (val) {
        return this.setChannel('hwb', 2, val);
      },
      value: function (val) {
        return this.setChannel('hsv', 2, val);
      },
      cyan: function (val) {
        return this.setChannel('cmyk', 0, val);
      },
      magenta: function (val) {
        return this.setChannel('cmyk', 1, val);
      },
      yellow: function (val) {
        return this.setChannel('cmyk', 2, val);
      },
      black: function (val) {
        return this.setChannel('cmyk', 3, val);
      },
      hexString: function () {
        return colorString.hexString(this.values.rgb);
      },
      rgbString: function () {
        return colorString.rgbString(this.values.rgb, this.values.alpha);
      },
      rgbaString: function () {
        return colorString.rgbaString(this.values.rgb, this.values.alpha);
      },
      percentString: function () {
        return colorString.percentString(this.values.rgb, this.values.alpha);
      },
      hslString: function () {
        return colorString.hslString(this.values.hsl, this.values.alpha);
      },
      hslaString: function () {
        return colorString.hslaString(this.values.hsl, this.values.alpha);
      },
      hwbString: function () {
        return colorString.hwbString(this.values.hwb, this.values.alpha);
      },
      keyword: function () {
        return colorString.keyword(this.values.rgb, this.values.alpha);
      },
      rgbNumber: function () {
        var rgb = this.values.rgb;
        return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
      },
      luminosity: function () {
        // http://www.w3.org/TR/WCAG20/#relativeluminancedef
        var rgb = this.values.rgb;
        var lum = [];

        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }

        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function (color2) {
        // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();

        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }

        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function (color2) {
        var contrastRatio = this.contrast(color2);

        if (contrastRatio >= 7.1) {
          return 'AAA';
        }

        return contrastRatio >= 4.5 ? 'AA' : '';
      },
      dark: function () {
        // YIQ equation from http://24ways.org/2010/calculating-color-contrast
        var rgb = this.values.rgb;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
        return yiq < 128;
      },
      light: function () {
        return !this.dark();
      },
      negate: function () {
        var rgb = [];

        for (var i = 0; i < 3; i++) {
          rgb[i] = 255 - this.values.rgb[i];
        }

        this.setValues('rgb', rgb);
        return this;
      },
      lighten: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] += hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      darken: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] -= hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      saturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] += hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      desaturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] -= hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      whiten: function (ratio) {
        var hwb = this.values.hwb;
        hwb[1] += hwb[1] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      blacken: function (ratio) {
        var hwb = this.values.hwb;
        hwb[2] += hwb[2] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      greyscale: function () {
        var rgb = this.values.rgb; // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale

        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        this.setValues('rgb', [val, val, val]);
        return this;
      },
      clearer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha - alpha * ratio);
        return this;
      },
      opaquer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha + alpha * ratio);
        return this;
      },
      rotate: function (degrees) {
        var hsl = this.values.hsl;
        var hue = (hsl[0] + degrees) % 360;
        hsl[0] = hue < 0 ? 360 + hue : hue;
        this.setValues('hsl', hsl);
        return this;
      },

      /**
       * Ported from sass implementation in C
       * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
       */
      mix: function (mixinColor, weight) {
        var color1 = this;
        var color2 = mixinColor;
        var p = weight === undefined ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;
        return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
      },
      toJSON: function () {
        return this.rgb();
      },
      clone: function () {
        // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
        // making the final build way to big to embed in Chart.js. So let's do it manually,
        // assuming that values to clone are 1 dimension arrays containing only numbers,
        // except 'alpha' which is a number.
        var result = new Color();
        var source = this.values;
        var target = result.values;
        var value, type;

        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            value = source[prop];
            type = {}.toString.call(value);

            if (type === '[object Array]') {
              target[prop] = value.slice(0);
            } else if (type === '[object Number]') {
              target[prop] = value;
            } else {
              console.error('unexpected color value:', value);
            }
          }
        }

        return result;
      }
    };
    Color.prototype.spaces = {
      rgb: ['red', 'green', 'blue'],
      hsl: ['hue', 'saturation', 'lightness'],
      hsv: ['hue', 'saturation', 'value'],
      hwb: ['hue', 'whiteness', 'blackness'],
      cmyk: ['cyan', 'magenta', 'yellow', 'black']
    };
    Color.prototype.maxes = {
      rgb: [255, 255, 255],
      hsl: [360, 100, 100],
      hsv: [360, 100, 100],
      hwb: [360, 100, 100],
      cmyk: [100, 100, 100, 100]
    };

    Color.prototype.getValues = function (space) {
      var values = this.values;
      var vals = {};

      for (var i = 0; i < space.length; i++) {
        vals[space.charAt(i)] = values[space][i];
      }

      if (values.alpha !== 1) {
        vals.a = values.alpha;
      } // {r: 255, g: 255, b: 255, a: 0.4}


      return vals;
    };

    Color.prototype.setValues = function (space, vals) {
      var values = this.values;
      var spaces = this.spaces;
      var maxes = this.maxes;
      var alpha = 1;
      var i;
      this.valid = true;

      if (space === 'alpha') {
        alpha = vals;
      } else if (vals.length) {
        // [10, 10, 10]
        values[space] = vals.slice(0, space.length);
        alpha = vals[space.length];
      } else if (vals[space.charAt(0)] !== undefined) {
        // {r: 10, g: 10, b: 10}
        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[space.charAt(i)];
        }

        alpha = vals.a;
      } else if (vals[spaces[space][0]] !== undefined) {
        // {red: 10, green: 10, blue: 10}
        var chans = spaces[space];

        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[chans[i]];
        }

        alpha = vals.alpha;
      }

      values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

      if (space === 'alpha') {
        return false;
      }

      var capped; // cap values of the space prior converting all values

      for (i = 0; i < space.length; i++) {
        capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
        values[space][i] = Math.round(capped);
      } // convert to all the other color spaces


      for (var sname in spaces) {
        if (sname !== space) {
          values[sname] = colorConvert[space][sname](values[space]);
        }
      }

      return true;
    };

    Color.prototype.setSpace = function (space, args) {
      var vals = args[0];

      if (vals === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof vals === 'number') {
        vals = Array.prototype.slice.call(args);
      }

      this.setValues(space, vals);
      return this;
    };

    Color.prototype.setChannel = function (space, index, val) {
      var svalues = this.values[space];

      if (val === undefined) {
        // color.red()
        return svalues[index];
      } else if (val === svalues[index]) {
        // color.red(color.red())
        return this;
      } // color.red(100)


      svalues[index] = val;
      this.setValues(space, svalues);
      return this;
    };

    if (typeof window !== 'undefined') {
      window.Color = Color;
    }

    var chartjsColor = Color;
    /**
     * @namespace Chart.helpers
     */

    var helpers = {
      /**
       * An empty function that can be used, for example, for optional callback.
       */
      noop: function () {},

      /**
       * Returns a unique id, sequentially generated from a global variable.
       * @returns {number}
       * @function
       */
      uid: function () {
        var id = 0;
        return function () {
          return id++;
        };
      }(),

      /**
       * Returns true if `value` is neither null nor undefined, else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @since 2.7.0
       */
      isNullOrUndef: function (value) {
        return value === null || typeof value === 'undefined';
      },

      /**
       * Returns true if `value` is an array (including typed arrays), else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @function
       */
      isArray: function (value) {
        if (Array.isArray && Array.isArray(value)) {
          return true;
        }

        var type = Object.prototype.toString.call(value);

        if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
          return true;
        }

        return false;
      },

      /**
       * Returns true if `value` is an object (excluding null), else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @since 2.7.0
       */
      isObject: function (value) {
        return value !== null && Object.prototype.toString.call(value) === '[object Object]';
      },

      /**
       * Returns true if `value` is a finite number, else returns false
       * @param {*} value  - The value to test.
       * @returns {boolean}
       */
      isFinite: function (value) {
        return (typeof value === 'number' || value instanceof Number) && isFinite(value);
      },

      /**
       * Returns `value` if defined, else returns `defaultValue`.
       * @param {*} value - The value to return if defined.
       * @param {*} defaultValue - The value to return if `value` is undefined.
       * @returns {*}
       */
      valueOrDefault: function (value, defaultValue) {
        return typeof value === 'undefined' ? defaultValue : value;
      },

      /**
       * Returns value at the given `index` in array if defined, else returns `defaultValue`.
       * @param {Array} value - The array to lookup for value at `index`.
       * @param {number} index - The index in `value` to lookup for value.
       * @param {*} defaultValue - The value to return if `value[index]` is undefined.
       * @returns {*}
       */
      valueAtIndexOrDefault: function (value, index, defaultValue) {
        return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
      },

      /**
       * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
       * value returned by `fn`. If `fn` is not a function, this method returns undefined.
       * @param {function} fn - The function to call.
       * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
       * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @returns {*}
       */
      callback: function (fn, args, thisArg) {
        if (fn && typeof fn.call === 'function') {
          return fn.apply(thisArg, args);
        }
      },

      /**
       * Note(SB) for performance sake, this method should only be used when loopable type
       * is unknown or in none intensive code (not called often and small loopable). Else
       * it's preferable to use a regular for() loop and save extra function calls.
       * @param {object|Array} loopable - The object or array to be iterated.
       * @param {function} fn - The function to call for each item.
       * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @param {boolean} [reverse] - If true, iterates backward on the loopable.
       */
      each: function (loopable, fn, thisArg, reverse) {
        var i, len, keys;

        if (helpers.isArray(loopable)) {
          len = loopable.length;

          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              fn.call(thisArg, loopable[i], i);
            }
          } else {
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[i], i);
            }
          }
        } else if (helpers.isObject(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;

          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
        }
      },

      /**
       * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
       * @see https://stackoverflow.com/a/14853974
       * @param {Array} a0 - The array to compare
       * @param {Array} a1 - The array to compare
       * @returns {boolean}
       */
      arrayEquals: function (a0, a1) {
        var i, ilen, v0, v1;

        if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
        }

        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];

          if (v0 instanceof Array && v1 instanceof Array) {
            if (!helpers.arrayEquals(v0, v1)) {
              return false;
            }
          } else if (v0 !== v1) {
            // NOTE: two different object instances will never be equal: {x:20} != {x:20}
            return false;
          }
        }

        return true;
      },

      /**
       * Returns a deep copy of `source` without keeping references on objects and arrays.
       * @param {*} source - The value to clone.
       * @returns {*}
       */
      clone: function (source) {
        if (helpers.isArray(source)) {
          return source.map(helpers.clone);
        }

        if (helpers.isObject(source)) {
          var target = {};
          var keys = Object.keys(source);
          var klen = keys.length;
          var k = 0;

          for (; k < klen; ++k) {
            target[keys[k]] = helpers.clone(source[keys[k]]);
          }

          return target;
        }

        return source;
      },

      /**
       * The default merger when Chart.helpers.merge is called without merger option.
       * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
       * @private
       */
      _merger: function (key, target, source, options) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.merge(tval, sval, options);
        } else {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Merges source[key] in target[key] only if target[key] is undefined.
       * @private
       */
      _mergerIf: function (key, target, source) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.mergeIf(tval, sval);
        } else if (!target.hasOwnProperty(key)) {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Recursively deep copies `source` properties into `target` with the given `options`.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {object} target - The target object in which all sources are merged into.
       * @param {object|object[]} source - Object(s) to merge into `target`.
       * @param {object} [options] - Merging options:
       * @param {function} [options.merger] - The merge method (key, target, source, options)
       * @returns {object} The `target` object.
       */
      merge: function (target, source, options) {
        var sources = helpers.isArray(source) ? source : [source];
        var ilen = sources.length;
        var merge, i, keys, klen, k;

        if (!helpers.isObject(target)) {
          return target;
        }

        options = options || {};
        merge = options.merger || helpers._merger;

        for (i = 0; i < ilen; ++i) {
          source = sources[i];

          if (!helpers.isObject(source)) {
            continue;
          }

          keys = Object.keys(source);

          for (k = 0, klen = keys.length; k < klen; ++k) {
            merge(keys[k], target, source, options);
          }
        }

        return target;
      },

      /**
       * Recursively deep copies `source` properties into `target` *only* if not defined in target.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {object} target - The target object in which all sources are merged into.
       * @param {object|object[]} source - Object(s) to merge into `target`.
       * @returns {object} The `target` object.
       */
      mergeIf: function (target, source) {
        return helpers.merge(target, source, {
          merger: helpers._mergerIf
        });
      },

      /**
       * Applies the contents of two or more objects together into the first object.
       * @param {object} target - The target object in which all objects are merged into.
       * @param {object} arg1 - Object containing additional properties to merge in target.
       * @param {object} argN - Additional objects containing properties to merge in target.
       * @returns {object} The `target` object.
       */
      extend: function (target) {
        var arguments$1 = arguments;

        var setFn = function (value, key) {
          target[key] = value;
        };

        for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
          helpers.each(arguments$1[i], setFn);
        }

        return target;
      },

      /**
       * Basic javascript inheritance based on the model created in Backbone.js
       */
      inherits: function (extensions) {
        var me = this;
        var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
          return me.apply(this, arguments);
        };

        var Surrogate = function () {
          this.constructor = ChartElement;
        };

        Surrogate.prototype = me.prototype;
        ChartElement.prototype = new Surrogate();
        ChartElement.extend = helpers.inherits;

        if (extensions) {
          helpers.extend(ChartElement.prototype, extensions);
        }

        ChartElement.__super__ = me.prototype;
        return ChartElement;
      }
    };
    var helpers_core = helpers; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.callback instead.
     * @function Chart.helpers.callCallback
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    helpers.callCallback = helpers.callback;
    /**
     * Provided for backward compatibility, use Array.prototype.indexOf instead.
     * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
     * @function Chart.helpers.indexOf
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.indexOf = function (array, item, fromIndex) {
      return Array.prototype.indexOf.call(array, item, fromIndex);
    };
    /**
     * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
     * @function Chart.helpers.getValueOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */


    helpers.getValueOrDefault = helpers.valueOrDefault;
    /**
     * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
     * @function Chart.helpers.getValueAtIndexOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
    /**
     * Easing functions adapted from Robert Penner's easing equations.
     * @namespace Chart.helpers.easingEffects
     * @see http://www.robertpenner.com/easing/
     */

    var effects = {
      linear: function (t) {
        return t;
      },
      easeInQuad: function (t) {
        return t * t;
      },
      easeOutQuad: function (t) {
        return -t * (t - 2);
      },
      easeInOutQuad: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t;
        }

        return -0.5 * (--t * (t - 2) - 1);
      },
      easeInCubic: function (t) {
        return t * t * t;
      },
      easeOutCubic: function (t) {
        return (t = t - 1) * t * t + 1;
      },
      easeInOutCubic: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t + 2);
      },
      easeInQuart: function (t) {
        return t * t * t * t;
      },
      easeOutQuart: function (t) {
        return -((t = t - 1) * t * t * t - 1);
      },
      easeInOutQuart: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t;
        }

        return -0.5 * ((t -= 2) * t * t * t - 2);
      },
      easeInQuint: function (t) {
        return t * t * t * t * t;
      },
      easeOutQuint: function (t) {
        return (t = t - 1) * t * t * t * t + 1;
      },
      easeInOutQuint: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t * t * t + 2);
      },
      easeInSine: function (t) {
        return -Math.cos(t * (Math.PI / 2)) + 1;
      },
      easeOutSine: function (t) {
        return Math.sin(t * (Math.PI / 2));
      },
      easeInOutSine: function (t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
      },
      easeInExpo: function (t) {
        return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
      },
      easeOutExpo: function (t) {
        return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
      },
      easeInOutExpo: function (t) {
        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(2, 10 * (t - 1));
        }

        return 0.5 * (-Math.pow(2, -10 * --t) + 2);
      },
      easeInCirc: function (t) {
        if (t >= 1) {
          return t;
        }

        return -(Math.sqrt(1 - t * t) - 1);
      },
      easeOutCirc: function (t) {
        return Math.sqrt(1 - (t = t - 1) * t);
      },
      easeInOutCirc: function (t) {
        if ((t /= 0.5) < 1) {
          return -0.5 * (Math.sqrt(1 - t * t) - 1);
        }

        return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      },
      easeInElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
      },
      easeOutElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
      },
      easeInOutElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if ((t /= 0.5) === 2) {
          return 1;
        }

        if (!p) {
          p = 0.45;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        if (t < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
        }

        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
      },
      easeInBack: function (t) {
        var s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      easeOutBack: function (t) {
        var s = 1.70158;
        return (t = t - 1) * t * ((s + 1) * t + s) + 1;
      },
      easeInOutBack: function (t) {
        var s = 1.70158;

        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }

        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
      },
      easeInBounce: function (t) {
        return 1 - effects.easeOutBounce(1 - t);
      },
      easeOutBounce: function (t) {
        if (t < 1 / 2.75) {
          return 7.5625 * t * t;
        }

        if (t < 2 / 2.75) {
          return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        }

        if (t < 2.5 / 2.75) {
          return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        }

        return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      },
      easeInOutBounce: function (t) {
        if (t < 0.5) {
          return effects.easeInBounce(t * 2) * 0.5;
        }

        return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
      }
    };
    var helpers_easing = {
      effects: effects
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
     * @function Chart.helpers.easingEffects
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.easingEffects = effects;
    var PI = Math.PI;
    var RAD_PER_DEG = PI / 180;
    var DOUBLE_PI = PI * 2;
    var HALF_PI = PI / 2;
    var QUARTER_PI = PI / 4;
    var TWO_THIRDS_PI = PI * 2 / 3;
    /**
     * @namespace Chart.helpers.canvas
     */

    var exports$1 = {
      /**
       * Clears the entire canvas associated to the given `chart`.
       * @param {Chart} chart - The chart for which to clear the canvas.
       */
      clear: function (chart) {
        chart.ctx.clearRect(0, 0, chart.width, chart.height);
      },

      /**
       * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
       * given size (width, height) and the same `radius` for all corners.
       * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
       * @param {number} x - The x axis of the coordinate for the rectangle starting point.
       * @param {number} y - The y axis of the coordinate for the rectangle starting point.
       * @param {number} width - The rectangle's width.
       * @param {number} height - The rectangle's height.
       * @param {number} radius - The rounded amount (in pixels) for the four corners.
       * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
       */
      roundedRect: function (ctx, x, y, width, height, radius) {
        if (radius) {
          var r = Math.min(radius, height / 2, width / 2);
          var left = x + r;
          var top = y + r;
          var right = x + width - r;
          var bottom = y + height - r;
          ctx.moveTo(x, top);

          if (left < right && top < bottom) {
            ctx.arc(left, top, r, -PI, -HALF_PI);
            ctx.arc(right, top, r, -HALF_PI, 0);
            ctx.arc(right, bottom, r, 0, HALF_PI);
            ctx.arc(left, bottom, r, HALF_PI, PI);
          } else if (left < right) {
            ctx.moveTo(left, y);
            ctx.arc(right, top, r, -HALF_PI, HALF_PI);
            ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
          } else if (top < bottom) {
            ctx.arc(left, top, r, -PI, 0);
            ctx.arc(left, bottom, r, 0, PI);
          } else {
            ctx.arc(left, top, r, -PI, PI);
          }

          ctx.closePath();
          ctx.moveTo(x, y);
        } else {
          ctx.rect(x, y, width, height);
        }
      },
      drawPoint: function (ctx, style, radius, x, y, rotation) {
        var type, xOffset, yOffset, size, cornerRadius;
        var rad = (rotation || 0) * RAD_PER_DEG;

        if (style && typeof style === 'object') {
          type = style.toString();

          if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
            ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
            return;
          }
        }

        if (isNaN(radius) || radius <= 0) {
          return;
        }

        ctx.beginPath();

        switch (style) {
          // Default includes circle
          default:
            ctx.arc(x, y, radius, 0, DOUBLE_PI);
            ctx.closePath();
            break;

          case 'triangle':
            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;

          case 'rectRounded':
            // NOTE: the rounded rect implementation changed to use `arc` instead of
            // `quadraticCurveTo` since it generates better results when rect is
            // almost a circle. 0.516 (instead of 0.5) produces results with visually
            // closer proportion to the previous impl and it is inscribed in the
            // circle with `radius`. For more details, see the following PRs:
            // https://github.com/chartjs/Chart.js/issues/5597
            // https://github.com/chartjs/Chart.js/issues/5858
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;

          case 'rect':
            if (!rotation) {
              size = Math.SQRT1_2 * radius;
              ctx.rect(x - size, y - size, 2 * size, 2 * size);
              break;
            }

            rad += QUARTER_PI;

          /* falls through */

          case 'rectRot':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + yOffset, y - xOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            ctx.closePath();
            break;

          case 'crossRot':
            rad += QUARTER_PI;

          /* falls through */

          case 'cross':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case 'star':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            rad += QUARTER_PI;
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case 'line':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;

          case 'dash':
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
            break;
        }

        ctx.fill();
        ctx.stroke();
      },

      /**
       * Returns true if the point is inside the rectangle
       * @param {object} point - The point to test
       * @param {object} area - The rectangle
       * @returns {boolean}
       * @private
       */
      _isPointInArea: function (point, area) {
        var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.

        return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
      },
      clipArea: function (ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
      },
      unclipArea: function (ctx) {
        ctx.restore();
      },
      lineTo: function (ctx, previous, target, flip) {
        var stepped = target.steppedLine;

        if (stepped) {
          if (stepped === 'middle') {
            var midpoint = (previous.x + target.x) / 2.0;
            ctx.lineTo(midpoint, flip ? target.y : previous.y);
            ctx.lineTo(midpoint, flip ? previous.y : target.y);
          } else if (stepped === 'after' && !flip || stepped !== 'after' && flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }

          ctx.lineTo(target.x, target.y);
          return;
        }

        if (!target.tension) {
          ctx.lineTo(target.x, target.y);
          return;
        }

        ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
      }
    };
    var helpers_canvas = exports$1; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
     * @namespace Chart.helpers.clear
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.clear = exports$1.clear;
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
     * @namespace Chart.helpers.drawRoundedRectangle
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.drawRoundedRectangle = function (ctx) {
      ctx.beginPath();
      exports$1.roundedRect.apply(exports$1, arguments);
    };

    var defaults = {
      /**
       * @private
       */
      _set: function (scope, values) {
        return helpers_core.merge(this[scope] || (this[scope] = {}), values);
      }
    };

    defaults._set('global', {
      defaultColor: 'rgba(0,0,0,0.1)',
      defaultFontColor: '#666',
      defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      defaultFontSize: 12,
      defaultFontStyle: 'normal',
      defaultLineHeight: 1.2,
      showLines: true
    });

    var core_defaults = defaults;
    var valueOrDefault = helpers_core.valueOrDefault;
    /**
     * Converts the given font object into a CSS font string.
     * @param {object} font - A font object.
     * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
     * @private
     */

    function toFontString(font) {
      if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
        return null;
      }

      return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
    }
    /**
     * @alias Chart.helpers.options
     * @namespace
     */


    var helpers_options = {
      /**
       * Converts the given line height `value` in pixels for a specific font `size`.
       * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
       * @param {number} size - The font size (in pixels) used to resolve relative `value`.
       * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
       * @since 2.7.0
       */
      toLineHeight: function (value, size) {
        var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);

        if (!matches || matches[1] === 'normal') {
          return size * 1.2;
        }

        value = +matches[2];

        switch (matches[3]) {
          case 'px':
            return value;

          case '%':
            value /= 100;
            break;

          default:
            break;
        }

        return size * value;
      },

      /**
       * Converts the given value into a padding object with pre-computed width/height.
       * @param {number|object} value - If a number, set the value to all TRBL component,
       *  else, if and object, use defined properties and sets undefined ones to 0.
       * @returns {object} The padding values (top, right, bottom, left, width, height)
       * @since 2.7.0
       */
      toPadding: function (value) {
        var t, r, b, l;

        if (helpers_core.isObject(value)) {
          t = +value.top || 0;
          r = +value.right || 0;
          b = +value.bottom || 0;
          l = +value.left || 0;
        } else {
          t = r = b = l = +value || 0;
        }

        return {
          top: t,
          right: r,
          bottom: b,
          left: l,
          height: t + b,
          width: l + r
        };
      },

      /**
       * Parses font options and returns the font object.
       * @param {object} options - A object that contains font options to be parsed.
       * @return {object} The font object.
       * @todo Support font.* options and renamed to toFont().
       * @private
       */
      _parseFont: function (options) {
        var globalDefaults = core_defaults.global;
        var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
        var font = {
          family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
          lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
          size: size,
          style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
          weight: null,
          string: ''
        };
        font.string = toFontString(font);
        return font;
      },

      /**
       * Evaluates the given `inputs` sequentially and returns the first defined value.
       * @param {Array} inputs - An array of values, falling back to the last value.
       * @param {object} [context] - If defined and the current value is a function, the value
       * is called with `context` as first argument and the result becomes the new input.
       * @param {number} [index] - If defined and the current value is an array, the value
       * at `index` become the new input.
       * @since 2.7.0
       */
      resolve: function (inputs, context, index) {
        var i, ilen, value;

        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
          value = inputs[i];

          if (value === undefined) {
            continue;
          }

          if (context !== undefined && typeof value === 'function') {
            value = value(context);
          }

          if (index !== undefined && helpers_core.isArray(value)) {
            value = value[index];
          }

          if (value !== undefined) {
            return value;
          }
        }
      }
    };
    var helpers$1 = helpers_core;
    var easing = helpers_easing;
    var canvas = helpers_canvas;
    var options = helpers_options;
    helpers$1.easing = easing;
    helpers$1.canvas = canvas;
    helpers$1.options = options;

    function interpolate(start, view, model, ease) {
      var keys = Object.keys(model);
      var i, ilen, key, actual, origin, target, type, c0, c1;

      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        target = model[key]; // if a value is added to the model after pivot() has been called, the view
        // doesn't contain it, so let's initialize the view to the target value.

        if (!view.hasOwnProperty(key)) {
          view[key] = target;
        }

        actual = view[key];

        if (actual === target || key[0] === '_') {
          continue;
        }

        if (!start.hasOwnProperty(key)) {
          start[key] = actual;
        }

        origin = start[key];
        type = typeof target;

        if (type === typeof origin) {
          if (type === 'string') {
            c0 = chartjsColor(origin);

            if (c0.valid) {
              c1 = chartjsColor(target);

              if (c1.valid) {
                view[key] = c1.mix(c0, ease).rgbString();
                continue;
              }
            }
          } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
            view[key] = origin + (target - origin) * ease;
            continue;
          }
        }

        view[key] = target;
      }
    }

    var Element = function (configuration) {
      helpers$1.extend(this, configuration);
      this.initialize.apply(this, arguments);
    };

    helpers$1.extend(Element.prototype, {
      initialize: function () {
        this.hidden = false;
      },
      pivot: function () {
        var me = this;

        if (!me._view) {
          me._view = helpers$1.clone(me._model);
        }

        me._start = {};
        return me;
      },
      transition: function (ease) {
        var me = this;
        var model = me._model;
        var start = me._start;
        var view = me._view; // No animation -> No Transition

        if (!model || ease === 1) {
          me._view = model;
          me._start = null;
          return me;
        }

        if (!view) {
          view = me._view = {};
        }

        if (!start) {
          start = me._start = {};
        }

        interpolate(start, view, model, ease);
        return me;
      },
      tooltipPosition: function () {
        return {
          x: this._model.x,
          y: this._model.y
        };
      },
      hasValue: function () {
        return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
      }
    });
    Element.extend = helpers$1.inherits;
    var core_element = Element;
    var exports$2 = core_element.extend({
      chart: null,
      // the animation associated chart instance
      currentStep: 0,
      // the current animation step
      numSteps: 60,
      // default number of steps
      easing: '',
      // the easing to use for this animation
      render: null,
      // render function used by the animation service
      onAnimationProgress: null,
      // user specified callback to fire on each step of the animation
      onAnimationComplete: null // user specified callback to fire when the animation finishes

    });
    var core_animation = exports$2; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.Animation instead
     * @prop Chart.Animation#animationObject
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */

    Object.defineProperty(exports$2.prototype, 'animationObject', {
      get: function () {
        return this;
      }
    });
    /**
     * Provided for backward compatibility, use Chart.Animation#chart instead
     * @prop Chart.Animation#chartInstance
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */

    Object.defineProperty(exports$2.prototype, 'chartInstance', {
      get: function () {
        return this.chart;
      },
      set: function (value) {
        this.chart = value;
      }
    });

    core_defaults._set('global', {
      animation: {
        duration: 1000,
        easing: 'easeOutQuart',
        onProgress: helpers$1.noop,
        onComplete: helpers$1.noop
      }
    });

    var core_animations = {
      animations: [],
      request: null,

      /**
       * @param {Chart} chart - The chart to animate.
       * @param {Chart.Animation} animation - The animation that we will animate.
       * @param {number} duration - The animation duration in ms.
       * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
       */
      addAnimation: function (chart, animation, duration, lazy) {
        var animations = this.animations;
        var i, ilen;
        animation.chart = chart;
        animation.startTime = Date.now();
        animation.duration = duration;

        if (!lazy) {
          chart.animating = true;
        }

        for (i = 0, ilen = animations.length; i < ilen; ++i) {
          if (animations[i].chart === chart) {
            animations[i] = animation;
            return;
          }
        }

        animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word

        if (animations.length === 1) {
          this.requestAnimationFrame();
        }
      },
      cancelAnimation: function (chart) {
        var index = helpers$1.findIndex(this.animations, function (animation) {
          return animation.chart === chart;
        });

        if (index !== -1) {
          this.animations.splice(index, 1);
          chart.animating = false;
        }
      },
      requestAnimationFrame: function () {
        var me = this;

        if (me.request === null) {
          // Skip animation frame requests until the active one is executed.
          // This can happen when processing mouse events, e.g. 'mousemove'
          // and 'mouseout' events will trigger multiple renders.
          me.request = helpers$1.requestAnimFrame.call(window, function () {
            me.request = null;
            me.startDigest();
          });
        }
      },

      /**
       * @private
       */
      startDigest: function () {
        var me = this;
        me.advance(); // Do we have more stuff to animate?

        if (me.animations.length > 0) {
          me.requestAnimationFrame();
        }
      },

      /**
       * @private
       */
      advance: function () {
        var animations = this.animations;
        var animation, chart, numSteps, nextStep;
        var i = 0; // 1 animation per chart, so we are looping charts here

        while (i < animations.length) {
          animation = animations[i];
          chart = animation.chart;
          numSteps = animation.numSteps; // Make sure that currentStep starts at 1
          // https://github.com/chartjs/Chart.js/issues/6104

          nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
          animation.currentStep = Math.min(nextStep, numSteps);
          helpers$1.callback(animation.render, [chart, animation], chart);
          helpers$1.callback(animation.onAnimationProgress, [animation], chart);

          if (animation.currentStep >= numSteps) {
            helpers$1.callback(animation.onAnimationComplete, [animation], chart);
            chart.animating = false;
            animations.splice(i, 1);
          } else {
            ++i;
          }
        }
      }
    };
    var resolve = helpers$1.options.resolve;
    var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
    /**
     * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
     * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
     * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
     */

    function listenArrayEvents(array, listener) {
      if (array._chartjs) {
        array._chartjs.listeners.push(listener);

        return;
      }

      Object.defineProperty(array, '_chartjs', {
        configurable: true,
        enumerable: false,
        value: {
          listeners: [listener]
        }
      });
      arrayEvents.forEach(function (key) {
        var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
        var base = array[key];
        Object.defineProperty(array, key, {
          configurable: true,
          enumerable: false,
          value: function () {
            var args = Array.prototype.slice.call(arguments);
            var res = base.apply(this, args);
            helpers$1.each(array._chartjs.listeners, function (object) {
              if (typeof object[method] === 'function') {
                object[method].apply(object, args);
              }
            });
            return res;
          }
        });
      });
    }
    /**
     * Removes the given array event listener and cleanup extra attached properties (such as
     * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
     */


    function unlistenArrayEvents(array, listener) {
      var stub = array._chartjs;

      if (!stub) {
        return;
      }

      var listeners = stub.listeners;
      var index = listeners.indexOf(listener);

      if (index !== -1) {
        listeners.splice(index, 1);
      }

      if (listeners.length > 0) {
        return;
      }

      arrayEvents.forEach(function (key) {
        delete array[key];
      });
      delete array._chartjs;
    } // Base class for all dataset controllers (line, bar, etc)


    var DatasetController = function (chart, datasetIndex) {
      this.initialize(chart, datasetIndex);
    };

    helpers$1.extend(DatasetController.prototype, {
      /**
       * Element type used to generate a meta dataset (e.g. Chart.element.Line).
       * @type {Chart.core.element}
       */
      datasetElementType: null,

      /**
       * Element type used to generate a meta data (e.g. Chart.element.Point).
       * @type {Chart.core.element}
       */
      dataElementType: null,
      initialize: function (chart, datasetIndex) {
        var me = this;
        me.chart = chart;
        me.index = datasetIndex;
        me.linkScales();
        me.addElements();
      },
      updateIndex: function (datasetIndex) {
        this.index = datasetIndex;
      },
      linkScales: function () {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();

        if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
          meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
        }

        if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
          meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
        }
      },
      getDataset: function () {
        return this.chart.data.datasets[this.index];
      },
      getMeta: function () {
        return this.chart.getDatasetMeta(this.index);
      },
      getScaleForId: function (scaleID) {
        return this.chart.scales[scaleID];
      },

      /**
       * @private
       */
      _getValueScaleId: function () {
        return this.getMeta().yAxisID;
      },

      /**
       * @private
       */
      _getIndexScaleId: function () {
        return this.getMeta().xAxisID;
      },

      /**
       * @private
       */
      _getValueScale: function () {
        return this.getScaleForId(this._getValueScaleId());
      },

      /**
       * @private
       */
      _getIndexScale: function () {
        return this.getScaleForId(this._getIndexScaleId());
      },
      reset: function () {
        this.update(true);
      },

      /**
       * @private
       */
      destroy: function () {
        if (this._data) {
          unlistenArrayEvents(this._data, this);
        }
      },
      createMetaDataset: function () {
        var me = this;
        var type = me.datasetElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index
        });
      },
      createMetaData: function (index) {
        var me = this;
        var type = me.dataElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index,
          _index: index
        });
      },
      addElements: function () {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data || [];
        var metaData = meta.data;
        var i, ilen;

        for (i = 0, ilen = data.length; i < ilen; ++i) {
          metaData[i] = metaData[i] || me.createMetaData(i);
        }

        meta.dataset = meta.dataset || me.createMetaDataset();
      },
      addElementAndReset: function (index) {
        var element = this.createMetaData(index);
        this.getMeta().data.splice(index, 0, element);
        this.updateElement(element, index, true);
      },
      buildOrUpdateElements: function () {
        var me = this;
        var dataset = me.getDataset();
        var data = dataset.data || (dataset.data = []); // In order to correctly handle data addition/deletion animation (an thus simulate
        // real-time charts), we need to monitor these data modifications and synchronize
        // the internal meta data accordingly.

        if (me._data !== data) {
          if (me._data) {
            // This case happens when the user replaced the data array instance.
            unlistenArrayEvents(me._data, me);
          }

          if (data && Object.isExtensible(data)) {
            listenArrayEvents(data, me);
          }

          me._data = data;
        } // Re-sync meta data in case the user replaced the data array or if we missed
        // any updates and so make sure that we handle number of datapoints changing.


        me.resyncElements();
      },
      update: helpers$1.noop,
      transition: function (easingValue) {
        var meta = this.getMeta();
        var elements = meta.data || [];
        var ilen = elements.length;
        var i = 0;

        for (; i < ilen; ++i) {
          elements[i].transition(easingValue);
        }

        if (meta.dataset) {
          meta.dataset.transition(easingValue);
        }
      },
      draw: function () {
        var meta = this.getMeta();
        var elements = meta.data || [];
        var ilen = elements.length;
        var i = 0;

        if (meta.dataset) {
          meta.dataset.draw();
        }

        for (; i < ilen; ++i) {
          elements[i].draw();
        }
      },
      removeHoverStyle: function (element) {
        helpers$1.merge(element._model, element.$previousStyle || {});
        delete element.$previousStyle;
      },
      setHoverStyle: function (element) {
        var dataset = this.chart.data.datasets[element._datasetIndex];
        var index = element._index;
        var custom = element.custom || {};
        var model = element._model;
        var getHoverColor = helpers$1.getHoverColor;
        element.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);
        model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);
        model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);
      },

      /**
       * @private
       */
      resyncElements: function () {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data;
        var numMeta = meta.data.length;
        var numData = data.length;

        if (numData < numMeta) {
          meta.data.splice(numData, numMeta - numData);
        } else if (numData > numMeta) {
          me.insertElements(numMeta, numData - numMeta);
        }
      },

      /**
       * @private
       */
      insertElements: function (start, count) {
        for (var i = 0; i < count; ++i) {
          this.addElementAndReset(start + i);
        }
      },

      /**
       * @private
       */
      onDataPush: function () {
        var count = arguments.length;
        this.insertElements(this.getDataset().data.length - count, count);
      },

      /**
       * @private
       */
      onDataPop: function () {
        this.getMeta().data.pop();
      },

      /**
       * @private
       */
      onDataShift: function () {
        this.getMeta().data.shift();
      },

      /**
       * @private
       */
      onDataSplice: function (start, count) {
        this.getMeta().data.splice(start, count);
        this.insertElements(start, arguments.length - 2);
      },

      /**
       * @private
       */
      onDataUnshift: function () {
        this.insertElements(0, arguments.length);
      }
    });
    DatasetController.extend = helpers$1.inherits;
    var core_datasetController = DatasetController;

    core_defaults._set('global', {
      elements: {
        arc: {
          backgroundColor: core_defaults.global.defaultColor,
          borderColor: '#fff',
          borderWidth: 2,
          borderAlign: 'center'
        }
      }
    });

    var element_arc = core_element.extend({
      inLabelRange: function (mouseX) {
        var vm = this._view;

        if (vm) {
          return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
        }

        return false;
      },
      inRange: function (chartX, chartY) {
        var vm = this._view;

        if (vm) {
          var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {
            x: chartX,
            y: chartY
          });
          var angle = pointRelativePosition.angle;
          var distance = pointRelativePosition.distance; // Sanitise angle range

          var startAngle = vm.startAngle;
          var endAngle = vm.endAngle;

          while (endAngle < startAngle) {
            endAngle += 2.0 * Math.PI;
          }

          while (angle > endAngle) {
            angle -= 2.0 * Math.PI;
          }

          while (angle < startAngle) {
            angle += 2.0 * Math.PI;
          } // Check if within the range of the open/close angle


          var betweenAngles = angle >= startAngle && angle <= endAngle;
          var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
          return betweenAngles && withinRadius;
        }

        return false;
      },
      getCenterPoint: function () {
        var vm = this._view;
        var halfAngle = (vm.startAngle + vm.endAngle) / 2;
        var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
        return {
          x: vm.x + Math.cos(halfAngle) * halfRadius,
          y: vm.y + Math.sin(halfAngle) * halfRadius
        };
      },
      getArea: function () {
        var vm = this._view;
        return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
      },
      tooltipPosition: function () {
        var vm = this._view;
        var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
        var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
        return {
          x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
          y: vm.y + Math.sin(centreAngle) * rangeFromCentre
        };
      },
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var sA = vm.startAngle;
        var eA = vm.endAngle;
        var pixelMargin = vm.borderAlign === 'inner' ? 0.33 : 0;
        var angleMargin;
        ctx.save();
        ctx.beginPath();
        ctx.arc(vm.x, vm.y, Math.max(vm.outerRadius - pixelMargin, 0), sA, eA);
        ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
        ctx.closePath();
        ctx.fillStyle = vm.backgroundColor;
        ctx.fill();

        if (vm.borderWidth) {
          if (vm.borderAlign === 'inner') {
            // Draw an inner border by cliping the arc and drawing a double-width border
            // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
            ctx.beginPath();
            angleMargin = pixelMargin / vm.outerRadius;
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA - angleMargin, eA + angleMargin);

            if (vm.innerRadius > pixelMargin) {
              angleMargin = pixelMargin / vm.innerRadius;
              ctx.arc(vm.x, vm.y, vm.innerRadius - pixelMargin, eA + angleMargin, sA - angleMargin, true);
            } else {
              ctx.arc(vm.x, vm.y, pixelMargin, eA + Math.PI / 2, sA - Math.PI / 2);
            }

            ctx.closePath();
            ctx.clip();
            ctx.beginPath();
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
            ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
            ctx.closePath();
            ctx.lineWidth = vm.borderWidth * 2;
            ctx.lineJoin = 'round';
          } else {
            ctx.lineWidth = vm.borderWidth;
            ctx.lineJoin = 'bevel';
          }

          ctx.strokeStyle = vm.borderColor;
          ctx.stroke();
        }

        ctx.restore();
      }
    });
    var valueOrDefault$1 = helpers$1.valueOrDefault;
    var defaultColor = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        line: {
          tension: 0.4,
          backgroundColor: defaultColor,
          borderWidth: 3,
          borderColor: defaultColor,
          borderCapStyle: 'butt',
          borderDash: [],
          borderDashOffset: 0.0,
          borderJoinStyle: 'miter',
          capBezierPoints: true,
          fill: true // do we fill in the area between the line and its base axis

        }
      }
    });

    var element_line = core_element.extend({
      draw: function () {
        var me = this;
        var vm = me._view;
        var ctx = me._chart.ctx;
        var spanGaps = vm.spanGaps;

        var points = me._children.slice(); // clone array


        var globalDefaults = core_defaults.global;
        var globalOptionLineElements = globalDefaults.elements.line;
        var lastDrawnIndex = -1;
        var index, current, previous, currentVM; // If we are looping, adding the first point again

        if (me._loop && points.length) {
          points.push(points[0]);
        }

        ctx.save(); // Stroke Line Options

        ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash

        if (ctx.setLineDash) {
          ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
        }

        ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
        ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
        ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
        ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line

        ctx.beginPath();
        lastDrawnIndex = -1;

        for (index = 0; index < points.length; ++index) {
          current = points[index];
          previous = helpers$1.previousItem(points, index);
          currentVM = current._view; // First point moves to it's starting position no matter what

          if (index === 0) {
            if (!currentVM.skip) {
              ctx.moveTo(currentVM.x, currentVM.y);
              lastDrawnIndex = index;
            }
          } else {
            previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

            if (!currentVM.skip) {
              if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
                // There was a gap and this is the first point after the gap
                ctx.moveTo(currentVM.x, currentVM.y);
              } else {
                // Line to next point
                helpers$1.canvas.lineTo(ctx, previous._view, current._view);
              }

              lastDrawnIndex = index;
            }
          }
        }

        ctx.stroke();
        ctx.restore();
      }
    });
    var valueOrDefault$2 = helpers$1.valueOrDefault;
    var defaultColor$1 = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        point: {
          radius: 3,
          pointStyle: 'circle',
          backgroundColor: defaultColor$1,
          borderColor: defaultColor$1,
          borderWidth: 1,
          // Hover
          hitRadius: 1,
          hoverRadius: 4,
          hoverBorderWidth: 1
        }
      }
    });

    function xRange(mouseX) {
      var vm = this._view;
      return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
    }

    function yRange(mouseY) {
      var vm = this._view;
      return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
    }

    var element_point = core_element.extend({
      inRange: function (mouseX, mouseY) {
        var vm = this._view;
        return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
      },
      inLabelRange: xRange,
      inXRange: xRange,
      inYRange: yRange,
      getCenterPoint: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      },
      getArea: function () {
        return Math.PI * Math.pow(this._view.radius, 2);
      },
      tooltipPosition: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y,
          padding: vm.radius + vm.borderWidth
        };
      },
      draw: function (chartArea) {
        var vm = this._view;
        var ctx = this._chart.ctx;
        var pointStyle = vm.pointStyle;
        var rotation = vm.rotation;
        var radius = vm.radius;
        var x = vm.x;
        var y = vm.y;
        var globalDefaults = core_defaults.global;
        var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow

        if (vm.skip) {
          return;
        } // Clipping for Points.


        if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {
          ctx.strokeStyle = vm.borderColor || defaultColor;
          ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
          ctx.fillStyle = vm.backgroundColor || defaultColor;
          helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
        }
      }
    });
    var defaultColor$2 = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        rectangle: {
          backgroundColor: defaultColor$2,
          borderColor: defaultColor$2,
          borderSkipped: 'bottom',
          borderWidth: 0
        }
      }
    });

    function isVertical(vm) {
      return vm && vm.width !== undefined;
    }
    /**
     * Helper function to get the bounds of the bar regardless of the orientation
     * @param bar {Chart.Element.Rectangle} the bar
     * @return {Bounds} bounds of the bar
     * @private
     */


    function getBarBounds(vm) {
      var x1, x2, y1, y2, half;

      if (isVertical(vm)) {
        half = vm.width / 2;
        x1 = vm.x - half;
        x2 = vm.x + half;
        y1 = Math.min(vm.y, vm.base);
        y2 = Math.max(vm.y, vm.base);
      } else {
        half = vm.height / 2;
        x1 = Math.min(vm.x, vm.base);
        x2 = Math.max(vm.x, vm.base);
        y1 = vm.y - half;
        y2 = vm.y + half;
      }

      return {
        left: x1,
        top: y1,
        right: x2,
        bottom: y2
      };
    }

    function swap(orig, v1, v2) {
      return orig === v1 ? v2 : orig === v2 ? v1 : orig;
    }

    function parseBorderSkipped(vm) {
      var edge = vm.borderSkipped;
      var res = {};

      if (!edge) {
        return res;
      }

      if (vm.horizontal) {
        if (vm.base > vm.x) {
          edge = swap(edge, 'left', 'right');
        }
      } else if (vm.base < vm.y) {
        edge = swap(edge, 'bottom', 'top');
      }

      res[edge] = true;
      return res;
    }

    function parseBorderWidth(vm, maxW, maxH) {
      var value = vm.borderWidth;
      var skip = parseBorderSkipped(vm);
      var t, r, b, l;

      if (helpers$1.isObject(value)) {
        t = +value.top || 0;
        r = +value.right || 0;
        b = +value.bottom || 0;
        l = +value.left || 0;
      } else {
        t = r = b = l = +value || 0;
      }

      return {
        t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,
        r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,
        b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
        l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l
      };
    }

    function boundingRects(vm) {
      var bounds = getBarBounds(vm);
      var width = bounds.right - bounds.left;
      var height = bounds.bottom - bounds.top;
      var border = parseBorderWidth(vm, width / 2, height / 2);
      return {
        outer: {
          x: bounds.left,
          y: bounds.top,
          w: width,
          h: height
        },
        inner: {
          x: bounds.left + border.l,
          y: bounds.top + border.t,
          w: width - border.l - border.r,
          h: height - border.t - border.b
        }
      };
    }

    function inRange(vm, x, y) {
      var skipX = x === null;
      var skipY = y === null;
      var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
      return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
    }

    var element_rectangle = core_element.extend({
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var rects = boundingRects(vm);
        var outer = rects.outer;
        var inner = rects.inner;
        ctx.fillStyle = vm.backgroundColor;
        ctx.fillRect(outer.x, outer.y, outer.w, outer.h);

        if (outer.w === inner.w && outer.h === inner.h) {
          return;
        }

        ctx.save();
        ctx.beginPath();
        ctx.rect(outer.x, outer.y, outer.w, outer.h);
        ctx.clip();
        ctx.fillStyle = vm.borderColor;
        ctx.rect(inner.x, inner.y, inner.w, inner.h);
        ctx.fill('evenodd');
        ctx.restore();
      },
      height: function () {
        var vm = this._view;
        return vm.base - vm.y;
      },
      inRange: function (mouseX, mouseY) {
        return inRange(this._view, mouseX, mouseY);
      },
      inLabelRange: function (mouseX, mouseY) {
        var vm = this._view;
        return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
      },
      inXRange: function (mouseX) {
        return inRange(this._view, mouseX, null);
      },
      inYRange: function (mouseY) {
        return inRange(this._view, null, mouseY);
      },
      getCenterPoint: function () {
        var vm = this._view;
        var x, y;

        if (isVertical(vm)) {
          x = vm.x;
          y = (vm.y + vm.base) / 2;
        } else {
          x = (vm.x + vm.base) / 2;
          y = vm.y;
        }

        return {
          x: x,
          y: y
        };
      },
      getArea: function () {
        var vm = this._view;
        return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
      },
      tooltipPosition: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      }
    });
    var elements = {};
    var Arc = element_arc;
    var Line = element_line;
    var Point = element_point;
    var Rectangle = element_rectangle;
    elements.Arc = Arc;
    elements.Line = Line;
    elements.Point = Point;
    elements.Rectangle = Rectangle;
    var resolve$1 = helpers$1.options.resolve;

    core_defaults._set('bar', {
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }],
        yAxes: [{
          type: 'linear'
        }]
      }
    });
    /**
     * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
     * @private
     */


    function computeMinSampleSize(scale, pixels) {
      var min = scale.isHorizontal() ? scale.width : scale.height;
      var ticks = scale.getTicks();
      var prev, curr, i, ilen;

      for (i = 1, ilen = pixels.length; i < ilen; ++i) {
        min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
      }

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        curr = scale.getPixelForTick(i);
        min = i > 0 ? Math.min(min, curr - prev) : min;
        prev = curr;
      }

      return min;
    }
    /**
     * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
     * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
     * mode currently always generates bars equally sized (until we introduce scriptable options?).
     * @private
     */


    function computeFitCategoryTraits(index, ruler, options) {
      var thickness = options.barThickness;
      var count = ruler.stackCount;
      var curr = ruler.pixels[index];
      var size, ratio;

      if (helpers$1.isNullOrUndef(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
      } else {
        // When bar thickness is enforced, category and bar percentages are ignored.
        // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
        // and deprecate barPercentage since this value is ignored when thickness is absolute.
        size = thickness * count;
        ratio = 1;
      }

      return {
        chunk: size / count,
        ratio: ratio,
        start: curr - size / 2
      };
    }
    /**
     * Computes an "optimal" category that globally arranges bars side by side (no gap when
     * percentage options are 1), based on the previous and following categories. This mode
     * generates bars with different widths when data are not evenly spaced.
     * @private
     */


    function computeFlexCategoryTraits(index, ruler, options) {
      var pixels = ruler.pixels;
      var curr = pixels[index];
      var prev = index > 0 ? pixels[index - 1] : null;
      var next = index < pixels.length - 1 ? pixels[index + 1] : null;
      var percent = options.categoryPercentage;
      var start, size;

      if (prev === null) {
        // first data: its size is double based on the next point or,
        // if it's also the last data, we use the scale size.
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
      }

      if (next === null) {
        // last data: its size is also double based on the previous point.
        next = curr + curr - prev;
      }

      start = curr - (curr - Math.min(prev, next)) / 2 * percent;
      size = Math.abs(next - prev) / 2 * percent;
      return {
        chunk: size / ruler.stackCount,
        ratio: options.barPercentage,
        start: start
      };
    }

    var controller_bar = core_datasetController.extend({
      dataElementType: elements.Rectangle,
      initialize: function () {
        var me = this;
        var meta;
        core_datasetController.prototype.initialize.apply(me, arguments);
        meta = me.getMeta();
        meta.stack = me.getDataset().stack;
        meta.bar = true;
      },
      update: function (reset) {
        var me = this;
        var rects = me.getMeta().data;
        var i, ilen;
        me._ruler = me.getRuler();

        for (i = 0, ilen = rects.length; i < ilen; ++i) {
          me.updateElement(rects[i], i, reset);
        }
      },
      updateElement: function (rectangle, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();

        var options = me._resolveElementOptions(rectangle, index);

        rectangle._xScale = me.getScaleForId(meta.xAxisID);
        rectangle._yScale = me.getScaleForId(meta.yAxisID);
        rectangle._datasetIndex = me.index;
        rectangle._index = index;
        rectangle._model = {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderSkipped: options.borderSkipped,
          borderWidth: options.borderWidth,
          datasetLabel: dataset.label,
          label: me.chart.data.labels[index]
        };

        me._updateElementGeometry(rectangle, index, reset);

        rectangle.pivot();
      },

      /**
       * @private
       */
      _updateElementGeometry: function (rectangle, index, reset) {
        var me = this;
        var model = rectangle._model;

        var vscale = me._getValueScale();

        var base = vscale.getBasePixel();
        var horizontal = vscale.isHorizontal();
        var ruler = me._ruler || me.getRuler();
        var vpixels = me.calculateBarValuePixels(me.index, index);
        var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
        model.horizontal = horizontal;
        model.base = reset ? base : vpixels.base;
        model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
        model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
        model.height = horizontal ? ipixels.size : undefined;
        model.width = horizontal ? undefined : ipixels.size;
      },

      /**
       * Returns the stacks based on groups and bar visibility.
       * @param {number} [last] - The dataset index
       * @returns {string[]} The list of stack IDs
       * @private
       */
      _getStacks: function (last) {
        var me = this;
        var chart = me.chart;

        var scale = me._getIndexScale();

        var stacked = scale.options.stacked;
        var ilen = last === undefined ? chart.data.datasets.length : last + 1;
        var stacks = [];
        var i, meta;

        for (i = 0; i < ilen; ++i) {
          meta = chart.getDatasetMeta(i);

          if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
            stacks.push(meta.stack);
          }
        }

        return stacks;
      },

      /**
       * Returns the effective number of stacks based on groups and bar visibility.
       * @private
       */
      getStackCount: function () {
        return this._getStacks().length;
      },

      /**
       * Returns the stack index for the given dataset based on groups and bar visibility.
       * @param {number} [datasetIndex] - The dataset index
       * @param {string} [name] - The stack name to find
       * @returns {number} The stack index
       * @private
       */
      getStackIndex: function (datasetIndex, name) {
        var stacks = this._getStacks(datasetIndex);

        var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present

        return index === -1 ? stacks.length - 1 : index;
      },

      /**
       * @private
       */
      getRuler: function () {
        var me = this;

        var scale = me._getIndexScale();

        var stackCount = me.getStackCount();
        var datasetIndex = me.index;
        var isHorizontal = scale.isHorizontal();
        var start = isHorizontal ? scale.left : scale.top;
        var end = start + (isHorizontal ? scale.width : scale.height);
        var pixels = [];
        var i, ilen, min;

        for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
          pixels.push(scale.getPixelForValue(null, i, datasetIndex));
        }

        min = helpers$1.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;
        return {
          min: min,
          pixels: pixels,
          start: start,
          end: end,
          stackCount: stackCount,
          scale: scale
        };
      },

      /**
       * Note: pixel values are not clamped to the scale area.
       * @private
       */
      calculateBarValuePixels: function (datasetIndex, index) {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();

        var scale = me._getValueScale();

        var isHorizontal = scale.isHorizontal();
        var datasets = chart.data.datasets;
        var value = +scale.getRightValue(datasets[datasetIndex].data[index]);
        var minBarLength = scale.options.minBarLength;
        var stacked = scale.options.stacked;
        var stack = meta.stack;
        var start = 0;
        var i, imeta, ivalue, base, head, size;

        if (stacked || stacked === undefined && stack !== undefined) {
          for (i = 0; i < datasetIndex; ++i) {
            imeta = chart.getDatasetMeta(i);

            if (imeta.bar && imeta.stack === stack && imeta.controller._getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {
              ivalue = +scale.getRightValue(datasets[i].data[index]);

              if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
                start += ivalue;
              }
            }
          }
        }

        base = scale.getPixelForValue(start);
        head = scale.getPixelForValue(start + value);
        size = head - base;

        if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
          size = minBarLength;

          if (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {
            head = base - minBarLength;
          } else {
            head = base + minBarLength;
          }
        }

        return {
          size: size,
          base: base,
          head: head,
          center: head + size / 2
        };
      },

      /**
       * @private
       */
      calculateBarIndexPixels: function (datasetIndex, index, ruler) {
        var me = this;
        var options = ruler.scale.options;
        var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);
        var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
        var center = range.start + range.chunk * stackIndex + range.chunk / 2;
        var size = Math.min(helpers$1.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);
        return {
          base: center - size / 2,
          head: center + size / 2,
          center: center,
          size: size
        };
      },
      draw: function () {
        var me = this;
        var chart = me.chart;

        var scale = me._getValueScale();

        var rects = me.getMeta().data;
        var dataset = me.getDataset();
        var ilen = rects.length;
        var i = 0;
        helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);

        for (; i < ilen; ++i) {
          if (!isNaN(scale.getRightValue(dataset.data[i]))) {
            rects[i].draw();
          }
        }

        helpers$1.canvas.unclipArea(chart.ctx);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (rectangle, index) {
        var me = this;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var dataset = datasets[me.index];
        var custom = rectangle.custom || {};
        var options = chart.options.elements.rectangle;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$1([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      }
    });
    var valueOrDefault$3 = helpers$1.valueOrDefault;
    var resolve$2 = helpers$1.options.resolve;

    core_defaults._set('bubble', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          // bubble should probably use a linear scale by default
          position: 'bottom',
          id: 'x-axis-0' // need an ID so datasets can reference the scale

        }],
        yAxes: [{
          type: 'linear',
          position: 'left',
          id: 'y-axis-0'
        }]
      },
      tooltips: {
        callbacks: {
          title: function () {
            // Title doesn't make sense for scatter since we format the data as a point
            return '';
          },
          label: function (item, data) {
            var datasetLabel = data.datasets[item.datasetIndex].label || '';
            var dataPoint = data.datasets[item.datasetIndex].data[item.index];
            return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
          }
        }
      }
    });

    var controller_bubble = core_datasetController.extend({
      /**
       * @protected
       */
      dataElementType: elements.Point,

      /**
       * @protected
       */
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var points = meta.data; // Update Points

        helpers$1.each(points, function (point, index) {
          me.updateElement(point, index, reset);
        });
      },

      /**
       * @protected
       */
      updateElement: function (point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var xScale = me.getScaleForId(meta.xAxisID);
        var yScale = me.getScaleForId(meta.yAxisID);

        var options = me._resolveElementOptions(point, index);

        var data = me.getDataset().data[index];
        var dsIndex = me.index;
        var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
        var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options;
        point._datasetIndex = dsIndex;
        point._index = index;
        point._model = {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          hitRadius: options.hitRadius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          radius: reset ? 0 : options.radius,
          skip: custom.skip || isNaN(x) || isNaN(y),
          x: x,
          y: y
        };
        point.pivot();
      },

      /**
       * @protected
       */
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$3(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$3(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$3(options.hoverBorderWidth, options.borderWidth);
        model.radius = options.radius + options.hoverRadius;
      },

      /**
       * @private
       */
      _resolveElementOptions: function (point, index) {
        var me = this;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var dataset = datasets[me.index];
        var custom = point.custom || {};
        var options = chart.options.elements.point;
        var data = dataset.data[index];
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle', 'rotation'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$2([custom[key], dataset[key], options[key]], context, index);
        } // Custom radius resolution


        values.radius = resolve$2([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);
        return values;
      }
    });
    var resolve$3 = helpers$1.options.resolve;
    var valueOrDefault$4 = helpers$1.valueOrDefault;

    core_defaults._set('doughnut', {
      animation: {
        // Boolean - Whether we animate the rotation of the Doughnut
        animateRotate: true,
        // Boolean - Whether we animate scaling the Doughnut from the centre
        animateScale: false
      },
      hover: {
        mode: 'single'
      },
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function (chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc && arc.custom || {};
                var arcOpts = chart.options.elements.arc;
                var fill = resolve$3([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                var stroke = resolve$3([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                var bw = resolve$3([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function (e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i); // toggle visibility of index if exists

            if (meta.data[index]) {
              meta.data[index].hidden = !meta.data[index].hidden;
            }
          }

          chart.update();
        }
      },
      // The percentage of the chart that we cut out of the middle.
      cutoutPercentage: 50,
      // The rotation of the chart, where the first data arc begins.
      rotation: Math.PI * -0.5,
      // The total circumference of the chart.
      circumference: Math.PI * 2.0,
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function () {
            return '';
          },
          label: function (tooltipItem, data) {
            var dataLabel = data.labels[tooltipItem.index];
            var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

            if (helpers$1.isArray(dataLabel)) {
              // show value on first line of multiline label
              // need to clone because we are changing the value
              dataLabel = dataLabel.slice();
              dataLabel[0] += value;
            } else {
              dataLabel += value;
            }

            return dataLabel;
          }
        }
      }
    });

    var controller_doughnut = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
      getRingIndex: function (datasetIndex) {
        var ringIndex = 0;

        for (var j = 0; j < datasetIndex; ++j) {
          if (this.chart.isDatasetVisible(j)) {
            ++ringIndex;
          }
        }

        return ringIndex;
      },
      update: function (reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var availableWidth = chartArea.right - chartArea.left;
        var availableHeight = chartArea.bottom - chartArea.top;
        var minSize = Math.min(availableWidth, availableHeight);
        var offset = {
          x: 0,
          y: 0
        };
        var meta = me.getMeta();
        var arcs = meta.data;
        var cutoutPercentage = opts.cutoutPercentage;
        var circumference = opts.circumference;

        var chartWeight = me._getRingWeight(me.index);

        var i, ilen; // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc

        if (circumference < Math.PI * 2.0) {
          var startAngle = opts.rotation % (Math.PI * 2.0);
          startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
          var endAngle = startAngle + circumference;
          var start = {
            x: Math.cos(startAngle),
            y: Math.sin(startAngle)
          };
          var end = {
            x: Math.cos(endAngle),
            y: Math.sin(endAngle)
          };
          var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
          var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
          var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
          var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
          var cutout = cutoutPercentage / 100.0;
          var min = {
            x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
            y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
          };
          var max = {
            x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
            y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
          };
          var size = {
            width: (max.x - min.x) * 0.5,
            height: (max.y - min.y) * 0.5
          };
          minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
          offset = {
            x: (max.x + min.x) * -0.5,
            y: (max.y + min.y) * -0.5
          };
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveElementOptions(arcs[i], i);
        }

        chart.borderWidth = me.getMaxBorderWidth();
        chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
        chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
        chart.offsetX = offset.x * chart.outerRadius;
        chart.offsetY = offset.y * chart.outerRadius;
        meta.total = me.calculateTotal();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
        me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          me.updateElement(arcs[i], i, reset);
        }
      },
      updateElement: function (arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var animationOpts = opts.animation;
        var centerX = (chartArea.left + chartArea.right) / 2;
        var centerY = (chartArea.top + chartArea.bottom) / 2;
        var startAngle = opts.rotation; // non reset case handled later

        var endAngle = opts.rotation; // non reset case handled later

        var dataset = me.getDataset();
        var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
        var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
        var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
        var options = arc._options || {};
        helpers$1.extend(arc, {
          // Utility
          _datasetIndex: me.index,
          _index: index,
          // Desired view properties
          _model: {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            borderAlign: options.borderAlign,
            x: centerX + chart.offsetX,
            y: centerY + chart.offsetY,
            startAngle: startAngle,
            endAngle: endAngle,
            circumference: circumference,
            outerRadius: outerRadius,
            innerRadius: innerRadius,
            label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
          }
        });
        var model = arc._model; // Set correct angles if not resetting

        if (!reset || !animationOpts.animateRotate) {
          if (index === 0) {
            model.startAngle = opts.rotation;
          } else {
            model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
          }

          model.endAngle = model.startAngle + model.circumference;
        }

        arc.pivot();
      },
      calculateTotal: function () {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var total = 0;
        var value;
        helpers$1.each(meta.data, function (element, index) {
          value = dataset.data[index];

          if (!isNaN(value) && !element.hidden) {
            total += Math.abs(value);
          }
        });
        /* if (total === 0) {
        	total = NaN;
        }*/

        return total;
      },
      calculateCircumference: function (value) {
        var total = this.getMeta().total;

        if (total > 0 && !isNaN(value)) {
          return Math.PI * 2.0 * (Math.abs(value) / total);
        }

        return 0;
      },
      // gets the max border or hover width to properly scale pie charts
      getMaxBorderWidth: function (arcs) {
        var me = this;
        var max = 0;
        var chart = me.chart;
        var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;

        if (!arcs) {
          // Find the outmost visible dataset
          for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
            if (chart.isDatasetVisible(i)) {
              meta = chart.getDatasetMeta(i);
              arcs = meta.data;

              if (i !== me.index) {
                controller = meta.controller;
              }

              break;
            }
          }
        }

        if (!arcs) {
          return 0;
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arc = arcs[i];
          options = controller ? controller._resolveElementOptions(arc, i) : arc._options;

          if (options.borderAlign !== 'inner') {
            borderWidth = options.borderWidth;
            hoverWidth = options.hoverBorderWidth;
            max = borderWidth > max ? borderWidth : max;
            max = hoverWidth > max ? hoverWidth : max;
          }
        }

        return max;
      },

      /**
       * @protected
       */
      setHoverStyle: function (arc) {
        var model = arc._model;
        var options = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (arc, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = arc.custom || {};
        var options = chart.options.elements.arc;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$3([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly
       * @private
       */
      _getRingWeightOffset: function (datasetIndex) {
        var ringWeightOffset = 0;

        for (var i = 0; i < datasetIndex; ++i) {
          if (this.chart.isDatasetVisible(i)) {
            ringWeightOffset += this._getRingWeight(i);
          }
        }

        return ringWeightOffset;
      },

      /**
       * @private
       */
      _getRingWeight: function (dataSetIndex) {
        return Math.max(valueOrDefault$4(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
      },

      /**
       * Returns the sum of all visibile data set weights.  This value can be 0.
       * @private
       */
      _getVisibleDatasetWeightTotal: function () {
        return this._getRingWeightOffset(this.chart.data.datasets.length);
      }
    });

    core_defaults._set('horizontalBar', {
      hover: {
        mode: 'index',
        axis: 'y'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          position: 'bottom'
        }],
        yAxes: [{
          type: 'category',
          position: 'left',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }]
      },
      elements: {
        rectangle: {
          borderSkipped: 'left'
        }
      },
      tooltips: {
        mode: 'index',
        axis: 'y'
      }
    });

    var controller_horizontalBar = controller_bar.extend({
      /**
       * @private
       */
      _getValueScaleId: function () {
        return this.getMeta().xAxisID;
      },

      /**
       * @private
       */
      _getIndexScaleId: function () {
        return this.getMeta().yAxisID;
      }
    });
    var valueOrDefault$5 = helpers$1.valueOrDefault;
    var resolve$4 = helpers$1.options.resolve;
    var isPointInArea = helpers$1.canvas._isPointInArea;

    core_defaults._set('line', {
      showLines: true,
      spanGaps: false,
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          id: 'x-axis-0'
        }],
        yAxes: [{
          type: 'linear',
          id: 'y-axis-0'
        }]
      }
    });

    function lineEnabled(dataset, options) {
      return valueOrDefault$5(dataset.showLine, options.showLines);
    }

    var controller_line = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale = me.getScaleForId(meta.yAxisID);
        var dataset = me.getDataset();
        var showLine = lineEnabled(dataset, me.chart.options);
        var i, ilen; // Update Line

        if (showLine) {
          // Compatibility: If the properties are defined with only the old name, use those values
          if (dataset.tension !== undefined && dataset.lineTension === undefined) {
            dataset.lineTension = dataset.tension;
          } // Utility


          line._scale = scale;
          line._datasetIndex = me.index; // Data

          line._children = points; // Model

          line._model = me._resolveLineOptions(line);
          line.pivot();
        } // Update Points


        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        }

        if (showLine && line._model.tension !== 0) {
          me.updateBezierControlPoints();
        } // Now pivot the point for animation


        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function (point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var datasetIndex = me.index;
        var value = dataset.data[index];
        var yScale = me.getScaleForId(meta.yAxisID);
        var xScale = me.getScaleForId(meta.xAxisID);
        var lineModel = meta.dataset._model;
        var x, y;

        var options = me._resolvePointOptions(point, index);

        x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
        y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility

        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options;
        point._datasetIndex = datasetIndex;
        point._index = index; // Desired view properties

        point._model = {
          x: x,
          y: y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          // Appearance
          radius: options.radius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          tension: valueOrDefault$5(custom.tension, lineModel ? lineModel.tension : 0),
          steppedLine: lineModel ? lineModel.steppedLine : false,
          // Tooltip
          hitRadius: options.hitRadius
        };
      },

      /**
       * @private
       */
      _resolvePointOptions: function (element, index) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.point;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var ELEMENT_OPTIONS = {
          backgroundColor: 'pointBackgroundColor',
          borderColor: 'pointBorderColor',
          borderWidth: 'pointBorderWidth',
          hitRadius: 'pointHitRadius',
          hoverBackgroundColor: 'pointHoverBackgroundColor',
          hoverBorderColor: 'pointHoverBorderColor',
          hoverBorderWidth: 'pointHoverBorderWidth',
          hoverRadius: 'pointHoverRadius',
          pointStyle: 'pointStyle',
          radius: 'pointRadius',
          rotation: 'pointRotation'
        };
        var keys = Object.keys(ELEMENT_OPTIONS);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$4([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _resolveLineOptions: function (element) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options;
        var elementOptions = options.elements.line;
        var values = {};
        var i, ilen, key;
        var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill', 'cubicInterpolationMode'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$4([custom[key], dataset[key], elementOptions[key]]);
        } // The default behavior of lines is to break at null values, according
        // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
        // This option gives lines the ability to span gaps


        values.spanGaps = valueOrDefault$5(dataset.spanGaps, options.spanGaps);
        values.tension = valueOrDefault$5(dataset.lineTension, elementOptions.tension);
        values.steppedLine = resolve$4([custom.steppedLine, dataset.steppedLine, elementOptions.stepped]);
        return values;
      },
      calculatePointY: function (value, index, datasetIndex) {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var yScale = me.getScaleForId(meta.yAxisID);
        var sumPos = 0;
        var sumNeg = 0;
        var i, ds, dsMeta;

        if (yScale.options.stacked) {
          for (i = 0; i < datasetIndex; i++) {
            ds = chart.data.datasets[i];
            dsMeta = chart.getDatasetMeta(i);

            if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
              var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));

              if (stackedRightValue < 0) {
                sumNeg += stackedRightValue || 0;
              } else {
                sumPos += stackedRightValue || 0;
              }
            }
          }

          var rightValue = Number(yScale.getRightValue(value));

          if (rightValue < 0) {
            return yScale.getPixelForValue(sumNeg + rightValue);
          }

          return yScale.getPixelForValue(sumPos + rightValue);
        }

        return yScale.getPixelForValue(value);
      },
      updateBezierControlPoints: function () {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var lineModel = meta.dataset._model;
        var area = chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used

        if (lineModel.spanGaps) {
          points = points.filter(function (pt) {
            return !pt._model.skip;
          });
        }

        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }

        if (lineModel.cubicInterpolationMode === 'monotone') {
          helpers$1.splineCurveMonotone(points);
        } else {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;
            controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
            model.controlPointPreviousX = controlPoints.previous.x;
            model.controlPointPreviousY = controlPoints.previous.y;
            model.controlPointNextX = controlPoints.next.x;
            model.controlPointNextY = controlPoints.next.y;
          }
        }

        if (chart.options.elements.line.capBezierPoints) {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;

            if (isPointInArea(model, area)) {
              if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
              }

              if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
              }
            }
          }
        }
      },
      draw: function () {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var points = meta.data || [];
        var area = chart.chartArea;
        var ilen = points.length;
        var halfBorderWidth;
        var i = 0;

        if (lineEnabled(me.getDataset(), chart.options)) {
          halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;
          helpers$1.canvas.clipArea(chart.ctx, {
            left: area.left,
            right: area.right,
            top: area.top - halfBorderWidth,
            bottom: area.bottom + halfBorderWidth
          });
          meta.dataset.draw();
          helpers$1.canvas.unclipArea(chart.ctx);
        } // Draw the points


        for (; i < ilen; ++i) {
          points[i].draw(area);
        }
      },

      /**
       * @protected
       */
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
        model.radius = valueOrDefault$5(options.hoverRadius, options.radius);
      }
    });
    var resolve$5 = helpers$1.options.resolve;

    core_defaults._set('polarArea', {
      scale: {
        type: 'radialLinear',
        angleLines: {
          display: false
        },
        gridLines: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        ticks: {
          beginAtZero: true
        }
      },
      // Boolean - Whether to animate the rotation of the chart
      animation: {
        animateRotate: true,
        animateScale: true
      },
      startAngle: -0.5 * Math.PI,
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function (chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc.custom || {};
                var arcOpts = chart.options.elements.arc;
                var fill = resolve$5([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                var stroke = resolve$5([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                var bw = resolve$5([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function (e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i);
            meta.data[index].hidden = !meta.data[index].hidden;
          }

          chart.update();
        }
      },
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function () {
            return '';
          },
          label: function (item, data) {
            return data.labels[item.index] + ': ' + item.yLabel;
          }
        }
      }
    });

    var controller_polarArea = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      update: function (reset) {
        var me = this;
        var dataset = me.getDataset();
        var meta = me.getMeta();
        var start = me.chart.options.startAngle || 0;
        var starts = me._starts = [];
        var angles = me._angles = [];
        var arcs = meta.data;
        var i, ilen, angle;

        me._updateRadius();

        meta.count = me.countVisibleElements();

        for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
          starts[i] = start;
          angle = me._computeAngle(i);
          angles[i] = angle;
          start += angle;
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveElementOptions(arcs[i], i);
          me.updateElement(arcs[i], i, reset);
        }
      },

      /**
       * @private
       */
      _updateRadius: function () {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        chart.outerRadius = Math.max(minSize / 2, 0);
        chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
        me.innerRadius = me.outerRadius - chart.radiusLength;
      },
      updateElement: function (arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var opts = chart.options;
        var animationOpts = opts.animation;
        var scale = chart.scale;
        var labels = chart.data.labels;
        var centerX = scale.xCenter;
        var centerY = scale.yCenter; // var negHalfPI = -0.5 * Math.PI;

        var datasetStartAngle = opts.startAngle;
        var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
        var startAngle = me._starts[index];
        var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
        var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
        var options = arc._options || {};
        helpers$1.extend(arc, {
          // Utility
          _datasetIndex: me.index,
          _index: index,
          _scale: scale,
          // Desired view properties
          _model: {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            borderAlign: options.borderAlign,
            x: centerX,
            y: centerY,
            innerRadius: 0,
            outerRadius: reset ? resetRadius : distance,
            startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
            endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
            label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
          }
        });
        arc.pivot();
      },
      countVisibleElements: function () {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var count = 0;
        helpers$1.each(meta.data, function (element, index) {
          if (!isNaN(dataset.data[index]) && !element.hidden) {
            count++;
          }
        });
        return count;
      },

      /**
       * @protected
       */
      setHoverStyle: function (arc) {
        var model = arc._model;
        var options = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        var valueOrDefault = helpers$1.valueOrDefault;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (arc, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = arc.custom || {};
        var options = chart.options.elements.arc;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$5([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _computeAngle: function (index) {
        var me = this;
        var count = this.getMeta().count;
        var dataset = me.getDataset();
        var meta = me.getMeta();

        if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
          return 0;
        } // Scriptable options


        var context = {
          chart: me.chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        return resolve$5([me.chart.options.elements.arc.angle, 2 * Math.PI / count], context, index);
      }
    });

    core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));

    core_defaults._set('pie', {
      cutoutPercentage: 0
    }); // Pie charts are Doughnut chart with different defaults


    var controller_pie = controller_doughnut;
    var valueOrDefault$6 = helpers$1.valueOrDefault;
    var resolve$6 = helpers$1.options.resolve;

    core_defaults._set('radar', {
      scale: {
        type: 'radialLinear'
      },
      elements: {
        line: {
          tension: 0 // no bezier in radar

        }
      }
    });

    var controller_radar = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      linkScales: helpers$1.noop,
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale = me.chart.scale;
        var dataset = me.getDataset();
        var i, ilen; // Compatibility: If the properties are defined with only the old name, use those values

        if (dataset.tension !== undefined && dataset.lineTension === undefined) {
          dataset.lineTension = dataset.tension;
        } // Utility


        line._scale = scale;
        line._datasetIndex = me.index; // Data

        line._children = points;
        line._loop = true; // Model

        line._model = me._resolveLineOptions(line);
        line.pivot(); // Update Points

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        } // Update bezier control points


        me.updateBezierControlPoints(); // Now pivot the point for animation

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function (point, index, reset) {
        var me = this;
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var scale = me.chart.scale;
        var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

        var options = me._resolvePointOptions(point, index);

        var lineModel = me.getMeta().dataset._model;

        var x = reset ? scale.xCenter : pointPosition.x;
        var y = reset ? scale.yCenter : pointPosition.y; // Utility

        point._scale = scale;
        point._options = options;
        point._datasetIndex = me.index;
        point._index = index; // Desired view properties

        point._model = {
          x: x,
          // value not used in dataset scale, but we want a consistent API between scales
          y: y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          // Appearance
          radius: options.radius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
          // Tooltip
          hitRadius: options.hitRadius
        };
      },

      /**
       * @private
       */
      _resolvePointOptions: function (element, index) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.point;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var ELEMENT_OPTIONS = {
          backgroundColor: 'pointBackgroundColor',
          borderColor: 'pointBorderColor',
          borderWidth: 'pointBorderWidth',
          hitRadius: 'pointHitRadius',
          hoverBackgroundColor: 'pointHoverBackgroundColor',
          hoverBorderColor: 'pointHoverBorderColor',
          hoverBorderWidth: 'pointHoverBorderWidth',
          hoverRadius: 'pointHoverRadius',
          pointStyle: 'pointStyle',
          radius: 'pointRadius',
          rotation: 'pointRotation'
        };
        var keys = Object.keys(ELEMENT_OPTIONS);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$6([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _resolveLineOptions: function (element) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.line;
        var values = {};
        var i, ilen, key;
        var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$6([custom[key], dataset[key], options[key]]);
        }

        values.tension = valueOrDefault$6(dataset.lineTension, options.tension);
        return values;
      },
      updateBezierControlPoints: function () {
        var me = this;
        var meta = me.getMeta();
        var area = me.chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints;

        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          model = points[i]._model;
          controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension); // Prevent the bezier going outside of the bounds of the graph

          model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
          model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
          model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
          model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
        }
      },
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
        model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
      }
    });

    core_defaults._set('scatter', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          id: 'x-axis-1',
          // need an ID so datasets can reference the scale
          type: 'linear',
          // scatter should not use a category axis
          position: 'bottom'
        }],
        yAxes: [{
          id: 'y-axis-1',
          type: 'linear',
          position: 'left'
        }]
      },
      showLines: false,
      tooltips: {
        callbacks: {
          title: function () {
            return ''; // doesn't make sense for scatter since data are formatted as a point
          },
          label: function (item) {
            return '(' + item.xLabel + ', ' + item.yLabel + ')';
          }
        }
      }
    }); // Scatter charts use line controllers


    var controller_scatter = controller_line; // NOTE export a map in which the key represents the controller type, not
    // the class, and so must be CamelCase in order to be correctly retrieved
    // by the controller in core.controller.js (`controllers[meta.type]`).

    var controllers = {
      bar: controller_bar,
      bubble: controller_bubble,
      doughnut: controller_doughnut,
      horizontalBar: controller_horizontalBar,
      line: controller_line,
      polarArea: controller_polarArea,
      pie: controller_pie,
      radar: controller_radar,
      scatter: controller_scatter
    };
    /**
     * Helper function to get relative position for an event
     * @param {Event|IEvent} event - The event to get the position for
     * @param {Chart} chart - The chart
     * @returns {object} the event position
     */

    function getRelativePosition(e, chart) {
      if (e.native) {
        return {
          x: e.x,
          y: e.y
        };
      }

      return helpers$1.getRelativePosition(e, chart);
    }
    /**
     * Helper function to traverse all of the visible elements in the chart
     * @param {Chart} chart - the chart
     * @param {function} handler - the callback to execute for each visible item
     */


    function parseVisibleItems(chart, handler) {
      var datasets = chart.data.datasets;
      var meta, i, j, ilen, jlen;

      for (i = 0, ilen = datasets.length; i < ilen; ++i) {
        if (!chart.isDatasetVisible(i)) {
          continue;
        }

        meta = chart.getDatasetMeta(i);

        for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
          var element = meta.data[j];

          if (!element._view.skip) {
            handler(element);
          }
        }
      }
    }
    /**
     * Helper function to get the items that intersect the event position
     * @param {ChartElement[]} items - elements to filter
     * @param {object} position - the point to be nearest to
     * @return {ChartElement[]} the nearest items
     */


    function getIntersectItems(chart, position) {
      var elements = [];
      parseVisibleItems(chart, function (element) {
        if (element.inRange(position.x, position.y)) {
          elements.push(element);
        }
      });
      return elements;
    }
    /**
     * Helper function to get the items nearest to the event position considering all visible items in teh chart
     * @param {Chart} chart - the chart to look at elements from
     * @param {object} position - the point to be nearest to
     * @param {boolean} intersect - if true, only consider items that intersect the position
     * @param {function} distanceMetric - function to provide the distance between points
     * @return {ChartElement[]} the nearest items
     */


    function getNearestItems(chart, position, intersect, distanceMetric) {
      var minDistance = Number.POSITIVE_INFINITY;
      var nearestItems = [];
      parseVisibleItems(chart, function (element) {
        if (intersect && !element.inRange(position.x, position.y)) {
          return;
        }

        var center = element.getCenterPoint();
        var distance = distanceMetric(position, center);

        if (distance < minDistance) {
          nearestItems = [element];
          minDistance = distance;
        } else if (distance === minDistance) {
          // Can have multiple items at the same distance in which case we sort by size
          nearestItems.push(element);
        }
      });
      return nearestItems;
    }
    /**
     * Get a distance metric function for two points based on the
     * axis mode setting
     * @param {string} axis - the axis mode. x|y|xy
     */


    function getDistanceMetricForAxis(axis) {
      var useX = axis.indexOf('x') !== -1;
      var useY = axis.indexOf('y') !== -1;
      return function (pt1, pt2) {
        var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
    }

    function indexMode(chart, e, options) {
      var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour

      options.axis = options.axis || 'x';
      var distanceMetric = getDistanceMetricForAxis(options.axis);
      var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
      var elements = [];

      if (!items.length) {
        return [];
      }

      chart.data.datasets.forEach(function (dataset, datasetIndex) {
        if (chart.isDatasetVisible(datasetIndex)) {
          var meta = chart.getDatasetMeta(datasetIndex);
          var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)

          if (element && !element._view.skip) {
            elements.push(element);
          }
        }
      });
      return elements;
    }
    /**
     * @interface IInteractionOptions
     */

    /**
     * If true, only consider items that intersect the point
     * @name IInterfaceOptions#boolean
     * @type Boolean
     */

    /**
     * Contains interaction related functions
     * @namespace Chart.Interaction
     */


    var core_interaction = {
      // Helper function for different modes
      modes: {
        single: function (chart, e) {
          var position = getRelativePosition(e, chart);
          var elements = [];
          parseVisibleItems(chart, function (element) {
            if (element.inRange(position.x, position.y)) {
              elements.push(element);
              return elements;
            }
          });
          return elements.slice(0, 1);
        },

        /**
         * @function Chart.Interaction.modes.label
         * @deprecated since version 2.4.0
         * @todo remove at version 3
         * @private
         */
        label: indexMode,

        /**
         * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
         * @function Chart.Interaction.modes.index
         * @since v2.4.0
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        index: indexMode,

        /**
         * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect is false, we find the nearest item and return the items in that dataset
         * @function Chart.Interaction.modes.dataset
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        dataset: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

          if (items.length > 0) {
            items = chart.getDatasetMeta(items[0]._datasetIndex).data;
          }

          return items;
        },

        /**
         * @function Chart.Interaction.modes.x-axis
         * @deprecated since version 2.4.0. Use index mode and intersect == true
         * @todo remove at version 3
         * @private
         */
        'x-axis': function (chart, e) {
          return indexMode(chart, e, {
            intersect: false
          });
        },

        /**
         * Point mode returns all elements that hit test based on the event position
         * of the event
         * @function Chart.Interaction.modes.intersect
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        point: function (chart, e) {
          var position = getRelativePosition(e, chart);
          return getIntersectItems(chart, position);
        },

        /**
         * nearest mode returns the element closest to the point
         * @function Chart.Interaction.modes.intersect
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        nearest: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          return getNearestItems(chart, position, options.intersect, distanceMetric);
        },

        /**
         * x mode returns the elements that hit-test at the current x coordinate
         * @function Chart.Interaction.modes.x
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        x: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inXRange(position.x)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        },

        /**
         * y mode returns the elements that hit-test at the current y coordinate
         * @function Chart.Interaction.modes.y
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        y: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inYRange(position.y)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        }
      }
    };

    function filterByPosition(array, position) {
      return helpers$1.where(array, function (v) {
        return v.position === position;
      });
    }

    function sortByWeight(array, reverse) {
      array.forEach(function (v, i) {
        v._tmpIndex_ = i;
        return v;
      });
      array.sort(function (a, b) {
        var v0 = reverse ? b : a;
        var v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
      });
      array.forEach(function (v) {
        delete v._tmpIndex_;
      });
    }

    function findMaxPadding(boxes) {
      var top = 0;
      var left = 0;
      var bottom = 0;
      var right = 0;
      helpers$1.each(boxes, function (box) {
        if (box.getPadding) {
          var boxPadding = box.getPadding();
          top = Math.max(top, boxPadding.top);
          left = Math.max(left, boxPadding.left);
          bottom = Math.max(bottom, boxPadding.bottom);
          right = Math.max(right, boxPadding.right);
        }
      });
      return {
        top: top,
        left: left,
        bottom: bottom,
        right: right
      };
    }

    function addSizeByPosition(boxes, size) {
      helpers$1.each(boxes, function (box) {
        size[box.position] += box.isHorizontal() ? box.height : box.width;
      });
    }

    core_defaults._set('global', {
      layout: {
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      }
    });
    /**
     * @interface ILayoutItem
     * @prop {string} position - The position of the item in the chart layout. Possible values are
     * 'left', 'top', 'right', 'bottom', and 'chartArea'
     * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area
     * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
     * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
     * @prop {function} update - Takes two parameters: width and height. Returns size of item
     * @prop {function} getPadding -  Returns an object with padding on the edges
     * @prop {number} width - Width of item. Must be valid after update()
     * @prop {number} height - Height of item. Must be valid after update()
     * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update
     * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update
     * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update
     * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
     */
    // The layout service is very self explanatory.  It's responsible for the layout within a chart.
    // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
    // It is this service's responsibility of carrying out that layout.


    var core_layouts = {
      defaults: {},

      /**
       * Register a box to a chart.
       * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
       * @param {Chart} chart - the chart to use
       * @param {ILayoutItem} item - the item to add to be layed out
       */
      addBox: function (chart, item) {
        if (!chart.boxes) {
          chart.boxes = [];
        } // initialize item with default values


        item.fullWidth = item.fullWidth || false;
        item.position = item.position || 'top';
        item.weight = item.weight || 0;
        chart.boxes.push(item);
      },

      /**
       * Remove a layoutItem from a chart
       * @param {Chart} chart - the chart to remove the box from
       * @param {ILayoutItem} layoutItem - the item to remove from the layout
       */
      removeBox: function (chart, layoutItem) {
        var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;

        if (index !== -1) {
          chart.boxes.splice(index, 1);
        }
      },

      /**
       * Sets (or updates) options on the given `item`.
       * @param {Chart} chart - the chart in which the item lives (or will be added to)
       * @param {ILayoutItem} item - the item to configure with the given options
       * @param {object} options - the new item options.
       */
      configure: function (chart, item, options) {
        var props = ['fullWidth', 'position', 'weight'];
        var ilen = props.length;
        var i = 0;
        var prop;

        for (; i < ilen; ++i) {
          prop = props[i];

          if (options.hasOwnProperty(prop)) {
            item[prop] = options[prop];
          }
        }
      },

      /**
       * Fits boxes of the given chart into the given size by having each box measure itself
       * then running a fitting algorithm
       * @param {Chart} chart - the chart
       * @param {number} width - the width to fit into
       * @param {number} height - the height to fit into
       */
      update: function (chart, width, height) {
        if (!chart) {
          return;
        }

        var layoutOptions = chart.options.layout || {};
        var padding = helpers$1.options.toPadding(layoutOptions.padding);
        var leftPadding = padding.left;
        var rightPadding = padding.right;
        var topPadding = padding.top;
        var bottomPadding = padding.bottom;
        var leftBoxes = filterByPosition(chart.boxes, 'left');
        var rightBoxes = filterByPosition(chart.boxes, 'right');
        var topBoxes = filterByPosition(chart.boxes, 'top');
        var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
        var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea'); // Sort boxes by weight. A higher weight is further away from the chart area

        sortByWeight(leftBoxes, true);
        sortByWeight(rightBoxes, false);
        sortByWeight(topBoxes, true);
        sortByWeight(bottomBoxes, false);
        var verticalBoxes = leftBoxes.concat(rightBoxes);
        var horizontalBoxes = topBoxes.concat(bottomBoxes);
        var outerBoxes = verticalBoxes.concat(horizontalBoxes); // Essentially we now have any number of boxes on each of the 4 sides.
        // Our canvas looks like the following.
        // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
        // B1 is the bottom axis
        // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
        // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
        // an error will be thrown.
        //
        // |----------------------------------------------------|
        // |                  T1 (Full Width)                   |
        // |----------------------------------------------------|
        // |    |    |                 T2                  |    |
        // |    |----|-------------------------------------|----|
        // |    |    | C1 |                           | C2 |    |
        // |    |    |----|                           |----|    |
        // |    |    |                                     |    |
        // | L1 | L2 |           ChartArea (C0)            | R1 |
        // |    |    |                                     |    |
        // |    |    |----|                           |----|    |
        // |    |    | C3 |                           | C4 |    |
        // |    |----|-------------------------------------|----|
        // |    |    |                 B1                  |    |
        // |----------------------------------------------------|
        // |                  B2 (Full Width)                   |
        // |----------------------------------------------------|
        //
        // What we do to find the best sizing, we do the following
        // 1. Determine the minimum size of the chart area.
        // 2. Split the remaining width equally between each vertical axis
        // 3. Split the remaining height equally between each horizontal axis
        // 4. Give each layout the maximum size it can be. The layout will return it's minimum size
        // 5. Adjust the sizes of each axis based on it's minimum reported size.
        // 6. Refit each axis
        // 7. Position each axis in the final location
        // 8. Tell the chart the final location of the chart area
        // 9. Tell any axes that overlay the chart area the positions of the chart area
        // Step 1

        var chartWidth = width - leftPadding - rightPadding;
        var chartHeight = height - topPadding - bottomPadding;
        var chartAreaWidth = chartWidth / 2; // min 50%
        // Step 2

        var verticalBoxWidth = (width - chartAreaWidth) / verticalBoxes.length; // Step 3
        // TODO re-limit horizontal axis height (this limit has affected only padding calculation since PR 1837)
        // var horizontalBoxHeight = (height - chartAreaHeight) / horizontalBoxes.length;
        // Step 4

        var maxChartAreaWidth = chartWidth;
        var maxChartAreaHeight = chartHeight;
        var outerBoxSizes = {
          top: topPadding,
          left: leftPadding,
          bottom: bottomPadding,
          right: rightPadding
        };
        var minBoxSizes = [];
        var maxPadding;

        function getMinimumBoxSize(box) {
          var minSize;
          var isHorizontal = box.isHorizontal();

          if (isHorizontal) {
            minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2);
            maxChartAreaHeight -= minSize.height;
          } else {
            minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
            maxChartAreaWidth -= minSize.width;
          }

          minBoxSizes.push({
            horizontal: isHorizontal,
            width: minSize.width,
            box: box
          });
        }

        helpers$1.each(outerBoxes, getMinimumBoxSize); // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)

        maxPadding = findMaxPadding(outerBoxes); // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
        // be if the axes are drawn at their minimum sizes.
        // Steps 5 & 6
        // Function to fit a box

        function fitBox(box) {
          var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minBox) {
            return minBox.box === box;
          });

          if (minBoxSize) {
            if (minBoxSize.horizontal) {
              var scaleMargin = {
                left: Math.max(outerBoxSizes.left, maxPadding.left),
                right: Math.max(outerBoxSizes.right, maxPadding.right),
                top: 0,
                bottom: 0
              }; // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
              // on the margin. Sometimes they need to increase in size slightly

              box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
            } else {
              box.update(minBoxSize.width, maxChartAreaHeight);
            }
          }
        } // Update, and calculate the left and right margins for the horizontal boxes


        helpers$1.each(verticalBoxes, fitBox);
        addSizeByPosition(verticalBoxes, outerBoxSizes); // Set the Left and Right margins for the horizontal boxes

        helpers$1.each(horizontalBoxes, fitBox);
        addSizeByPosition(horizontalBoxes, outerBoxSizes);

        function finalFitVerticalBox(box) {
          var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minSize) {
            return minSize.box === box;
          });
          var scaleMargin = {
            left: 0,
            right: 0,
            top: outerBoxSizes.top,
            bottom: outerBoxSizes.bottom
          };

          if (minBoxSize) {
            box.update(minBoxSize.width, maxChartAreaHeight, scaleMargin);
          }
        } // Let the left layout know the final margin


        helpers$1.each(verticalBoxes, finalFitVerticalBox); // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)

        outerBoxSizes = {
          top: topPadding,
          left: leftPadding,
          bottom: bottomPadding,
          right: rightPadding
        };
        addSizeByPosition(outerBoxes, outerBoxSizes); // We may be adding some padding to account for rotated x axis labels

        var leftPaddingAddition = Math.max(maxPadding.left - outerBoxSizes.left, 0);
        outerBoxSizes.left += leftPaddingAddition;
        outerBoxSizes.right += Math.max(maxPadding.right - outerBoxSizes.right, 0);
        var topPaddingAddition = Math.max(maxPadding.top - outerBoxSizes.top, 0);
        outerBoxSizes.top += topPaddingAddition;
        outerBoxSizes.bottom += Math.max(maxPadding.bottom - outerBoxSizes.bottom, 0); // Figure out if our chart area changed. This would occur if the dataset layout label rotation
        // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
        // without calling `fit` again

        var newMaxChartAreaHeight = height - outerBoxSizes.top - outerBoxSizes.bottom;
        var newMaxChartAreaWidth = width - outerBoxSizes.left - outerBoxSizes.right;

        if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
          helpers$1.each(verticalBoxes, function (box) {
            box.height = newMaxChartAreaHeight;
          });
          helpers$1.each(horizontalBoxes, function (box) {
            if (!box.fullWidth) {
              box.width = newMaxChartAreaWidth;
            }
          });
          maxChartAreaHeight = newMaxChartAreaHeight;
          maxChartAreaWidth = newMaxChartAreaWidth;
        } // Step 7 - Position the boxes


        var left = leftPadding + leftPaddingAddition;
        var top = topPadding + topPaddingAddition;

        function placeBox(box) {
          if (box.isHorizontal()) {
            box.left = box.fullWidth ? leftPadding : outerBoxSizes.left;
            box.right = box.fullWidth ? width - rightPadding : outerBoxSizes.left + maxChartAreaWidth;
            box.top = top;
            box.bottom = top + box.height; // Move to next point

            top = box.bottom;
          } else {
            box.left = left;
            box.right = left + box.width;
            box.top = outerBoxSizes.top;
            box.bottom = outerBoxSizes.top + maxChartAreaHeight; // Move to next point

            left = box.right;
          }
        }

        helpers$1.each(leftBoxes.concat(topBoxes), placeBox); // Account for chart width and height

        left += maxChartAreaWidth;
        top += maxChartAreaHeight;
        helpers$1.each(rightBoxes, placeBox);
        helpers$1.each(bottomBoxes, placeBox); // Step 8

        chart.chartArea = {
          left: outerBoxSizes.left,
          top: outerBoxSizes.top,
          right: outerBoxSizes.left + maxChartAreaWidth,
          bottom: outerBoxSizes.top + maxChartAreaHeight
        }; // Step 9

        helpers$1.each(chartAreaBoxes, function (box) {
          box.left = chart.chartArea.left;
          box.top = chart.chartArea.top;
          box.right = chart.chartArea.right;
          box.bottom = chart.chartArea.bottom;
          box.update(maxChartAreaWidth, maxChartAreaHeight);
        });
      }
    };
    /**
     * Platform fallback implementation (minimal).
     * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
     */

    var platform_basic = {
      acquireContext: function (item) {
        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        }

        return item && item.getContext('2d') || null;
      }
    };
    var platform_dom = "/*\n * DOM element rendering detection\n * https://davidwalsh.name/detect-node-insertion\n */\n@keyframes chartjs-render-animation {\n\tfrom { opacity: 0.99; }\n\tto { opacity: 1; }\n}\n\n.chartjs-render-monitor {\n\tanimation: chartjs-render-animation 0.001s;\n}\n\n/*\n * DOM element resizing detection\n * https://github.com/marcj/css-element-queries\n */\n.chartjs-size-monitor,\n.chartjs-size-monitor-expand,\n.chartjs-size-monitor-shrink {\n\tposition: absolute;\n\tdirection: ltr;\n\tleft: 0;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\toverflow: hidden;\n\tpointer-events: none;\n\tvisibility: hidden;\n\tz-index: -1;\n}\n\n.chartjs-size-monitor-expand > div {\n\tposition: absolute;\n\twidth: 1000000px;\n\theight: 1000000px;\n\tleft: 0;\n\ttop: 0;\n}\n\n.chartjs-size-monitor-shrink > div {\n\tposition: absolute;\n\twidth: 200%;\n\theight: 200%;\n\tleft: 0;\n\ttop: 0;\n}\n";
    var platform_dom$1 =
    /*#__PURE__*/
    Object.freeze({
      default: platform_dom
    });

    function getCjsExportFromNamespace(n) {
      return n && n.default || n;
    }

    var stylesheet = getCjsExportFromNamespace(platform_dom$1);
    var EXPANDO_KEY = '$chartjs';
    var CSS_PREFIX = 'chartjs-';
    var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';
    var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
    var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
    var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
    /**
     * DOM event types -> Chart.js event types.
     * Note: only events with different types are mapped.
     * @see https://developer.mozilla.org/en-US/docs/Web/Events
     */

    var EVENT_TYPES = {
      touchstart: 'mousedown',
      touchmove: 'mousemove',
      touchend: 'mouseup',
      pointerenter: 'mouseenter',
      pointerdown: 'mousedown',
      pointermove: 'mousemove',
      pointerup: 'mouseup',
      pointerleave: 'mouseout',
      pointerout: 'mouseout'
    };
    /**
     * The "used" size is the final value of a dimension property after all calculations have
     * been performed. This method uses the computed style of `element` but returns undefined
     * if the computed style is not expressed in pixels. That can happen in some cases where
     * `element` has a size relative to its parent and this last one is not yet displayed,
     * for example because of `display: none` on a parent node.
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     * @returns {number} Size in pixels or undefined if unknown.
     */

    function readUsedSize(element, property) {
      var value = helpers$1.getStyle(element, property);
      var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches ? Number(matches[1]) : undefined;
    }
    /**
     * Initializes the canvas style and render size without modifying the canvas display size,
     * since responsiveness is handled by the controller.resize() method. The config is used
     * to determine the aspect ratio to apply in case no explicit height has been specified.
     */


    function initCanvas(canvas, config) {
      var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
      // returns null or '' if no explicit value has been set to the canvas attribute.

      var renderHeight = canvas.getAttribute('height');
      var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy

      canvas[EXPANDO_KEY] = {
        initial: {
          height: renderHeight,
          width: renderWidth,
          style: {
            display: style.display,
            height: style.height,
            width: style.width
          }
        }
      }; // Force canvas to display as block to avoid extra space caused by inline
      // elements, which would interfere with the responsive resize process.
      // https://github.com/chartjs/Chart.js/issues/2538

      style.display = style.display || 'block';

      if (renderWidth === null || renderWidth === '') {
        var displayWidth = readUsedSize(canvas, 'width');

        if (displayWidth !== undefined) {
          canvas.width = displayWidth;
        }
      }

      if (renderHeight === null || renderHeight === '') {
        if (canvas.style.height === '') {
          // If no explicit render height and style height, let's apply the aspect ratio,
          // which one can be specified by the user but also by charts as default option
          // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
          canvas.height = canvas.width / (config.options.aspectRatio || 2);
        } else {
          var displayHeight = readUsedSize(canvas, 'height');

          if (displayWidth !== undefined) {
            canvas.height = displayHeight;
          }
        }
      }

      return canvas;
    }
    /**
     * Detects support for options object argument in addEventListener.
     * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
     * @private
     */


    var supportsEventListenerOptions = function () {
      var supports = false;

      try {
        var options = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line getter-return
          get: function () {
            supports = true;
          }
        });
        window.addEventListener('e', null, options);
      } catch (e) {// continue regardless of error
      }

      return supports;
    }(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
    // https://github.com/chartjs/Chart.js/issues/4287


    var eventListenerOptions = supportsEventListenerOptions ? {
      passive: true
    } : false;

    function addListener(node, type, listener) {
      node.addEventListener(type, listener, eventListenerOptions);
    }

    function removeListener(node, type, listener) {
      node.removeEventListener(type, listener, eventListenerOptions);
    }

    function createEvent(type, chart, x, y, nativeEvent) {
      return {
        type: type,
        chart: chart,
        native: nativeEvent || null,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
      };
    }

    function fromNativeEvent(event, chart) {
      var type = EVENT_TYPES[event.type] || event.type;
      var pos = helpers$1.getRelativePosition(event, chart);
      return createEvent(type, chart, pos.x, pos.y, event);
    }

    function throttled(fn, thisArg) {
      var ticking = false;
      var args = [];
      return function () {
        args = Array.prototype.slice.call(arguments);
        thisArg = thisArg || this;

        if (!ticking) {
          ticking = true;
          helpers$1.requestAnimFrame.call(window, function () {
            ticking = false;
            fn.apply(thisArg, args);
          });
        }
      };
    }

    function createDiv(cls) {
      var el = document.createElement('div');
      el.className = cls || '';
      return el;
    } // Implementation based on https://github.com/marcj/css-element-queries


    function createResizer(handler) {
      var maxSize = 1000000; // NOTE(SB) Don't use innerHTML because it could be considered unsafe.
      // https://github.com/chartjs/Chart.js/issues/5902

      var resizer = createDiv(CSS_SIZE_MONITOR);
      var expand = createDiv(CSS_SIZE_MONITOR + '-expand');
      var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');
      expand.appendChild(createDiv());
      shrink.appendChild(createDiv());
      resizer.appendChild(expand);
      resizer.appendChild(shrink);

      resizer._reset = function () {
        expand.scrollLeft = maxSize;
        expand.scrollTop = maxSize;
        shrink.scrollLeft = maxSize;
        shrink.scrollTop = maxSize;
      };

      var onScroll = function () {
        resizer._reset();

        handler();
      };

      addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
      addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
      return resizer;
    } // https://davidwalsh.name/detect-node-insertion


    function watchForRender(node, handler) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

      var proxy = expando.renderProxy = function (e) {
        if (e.animationName === CSS_RENDER_ANIMATION) {
          handler();
        }
      };

      helpers$1.each(ANIMATION_START_EVENTS, function (type) {
        addListener(node, type, proxy);
      }); // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
      // is removed then added back immediately (same animation frame?). Accessing the
      // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
      // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
      // https://github.com/chartjs/Chart.js/issues/4737

      expando.reflow = !!node.offsetParent;
      node.classList.add(CSS_RENDER_MONITOR);
    }

    function unwatchForRender(node) {
      var expando = node[EXPANDO_KEY] || {};
      var proxy = expando.renderProxy;

      if (proxy) {
        helpers$1.each(ANIMATION_START_EVENTS, function (type) {
          removeListener(node, type, proxy);
        });
        delete expando.renderProxy;
      }

      node.classList.remove(CSS_RENDER_MONITOR);
    }

    function addResizeListener(node, listener, chart) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {}); // Let's keep track of this added resizer and thus avoid DOM query when removing it.

      var resizer = expando.resizer = createResizer(throttled(function () {
        if (expando.resizer) {
          var container = chart.options.maintainAspectRatio && node.parentNode;
          var w = container ? container.clientWidth : 0;
          listener(createEvent('resize', chart));

          if (container && container.clientWidth < w && chart.canvas) {
            // If the container size shrank during chart resize, let's assume
            // scrollbar appeared. So we resize again with the scrollbar visible -
            // effectively making chart smaller and the scrollbar hidden again.
            // Because we are inside `throttled`, and currently `ticking`, scroll
            // events are ignored during this whole 2 resize process.
            // If we assumed wrong and something else happened, we are resizing
            // twice in a frame (potential performance issue)
            listener(createEvent('resize', chart));
          }
        }
      })); // The resizer needs to be attached to the node parent, so we first need to be
      // sure that `node` is attached to the DOM before injecting the resizer element.

      watchForRender(node, function () {
        if (expando.resizer) {
          var container = node.parentNode;

          if (container && container !== resizer.parentNode) {
            container.insertBefore(resizer, container.firstChild);
          } // The container size might have changed, let's reset the resizer state.


          resizer._reset();
        }
      });
    }

    function removeResizeListener(node) {
      var expando = node[EXPANDO_KEY] || {};
      var resizer = expando.resizer;
      delete expando.resizer;
      unwatchForRender(node);

      if (resizer && resizer.parentNode) {
        resizer.parentNode.removeChild(resizer);
      }
    }

    function injectCSS(platform, css) {
      // https://stackoverflow.com/q/3922139
      var style = platform._style || document.createElement('style');

      if (!platform._style) {
        platform._style = style;
        css = '/* Chart.js */\n' + css;
        style.setAttribute('type', 'text/css');
        document.getElementsByTagName('head')[0].appendChild(style);
      }

      style.appendChild(document.createTextNode(css));
    }

    var platform_dom$2 = {
      /**
       * When `true`, prevents the automatic injection of the stylesheet required to
       * correctly detect when the chart is added to the DOM and then resized. This
       * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)
       * to be manually imported to make this library compatible with any CSP.
       * See https://github.com/chartjs/Chart.js/issues/5208
       */
      disableCSSInjection: false,

      /**
       * This property holds whether this platform is enabled for the current environment.
       * Currently used by platform.js to select the proper implementation.
       * @private
       */
      _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

      /**
       * @private
       */
      _ensureLoaded: function () {
        if (this._loaded) {
          return;
        }

        this._loaded = true; // https://github.com/chartjs/Chart.js/issues/5208

        if (!this.disableCSSInjection) {
          injectCSS(this, stylesheet);
        }
      },
      acquireContext: function (item, config) {
        if (typeof item === 'string') {
          item = document.getElementById(item);
        } else if (item.length) {
          // Support for array based queries (such as jQuery)
          item = item[0];
        }

        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        } // To prevent canvas fingerprinting, some add-ons undefine the getContext
        // method, for example: https://github.com/kkapsner/CanvasBlocker
        // https://github.com/chartjs/Chart.js/issues/2807


        var context = item && item.getContext && item.getContext('2d'); // Load platform resources on first chart creation, to make possible to change
        // platform options after importing the library (e.g. `disableCSSInjection`).

        this._ensureLoaded(); // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
        // inside an iframe or when running in a protected environment. We could guess the
        // types from their toString() value but let's keep things flexible and assume it's
        // a sufficient condition if the item has a context2D which has item as `canvas`.
        // https://github.com/chartjs/Chart.js/issues/3887
        // https://github.com/chartjs/Chart.js/issues/4102
        // https://github.com/chartjs/Chart.js/issues/4152


        if (context && context.canvas === item) {
          initCanvas(item, config);
          return context;
        }

        return null;
      },
      releaseContext: function (context) {
        var canvas = context.canvas;

        if (!canvas[EXPANDO_KEY]) {
          return;
        }

        var initial = canvas[EXPANDO_KEY].initial;
        ['height', 'width'].forEach(function (prop) {
          var value = initial[prop];

          if (helpers$1.isNullOrUndef(value)) {
            canvas.removeAttribute(prop);
          } else {
            canvas.setAttribute(prop, value);
          }
        });
        helpers$1.each(initial.style || {}, function (value, key) {
          canvas.style[key] = value;
        }); // The canvas render size might have been changed (and thus the state stack discarded),
        // we can't use save() and restore() to restore the initial state. So make sure that at
        // least the canvas context is reset to the default state by setting the canvas width.
        // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
        // eslint-disable-next-line no-self-assign

        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
      },
      addEventListener: function (chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          addResizeListener(canvas, listener, chart);
          return;
        }

        var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
        var proxies = expando.proxies || (expando.proxies = {});

        var proxy = proxies[chart.id + '_' + type] = function (event) {
          listener(fromNativeEvent(event, chart));
        };

        addListener(canvas, type, proxy);
      },
      removeEventListener: function (chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          removeResizeListener(canvas);
          return;
        }

        var expando = listener[EXPANDO_KEY] || {};
        var proxies = expando.proxies || {};
        var proxy = proxies[chart.id + '_' + type];

        if (!proxy) {
          return;
        }

        removeListener(canvas, type, proxy);
      }
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use EventTarget.addEventListener instead.
     * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     * @function Chart.helpers.addEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.addEvent = addListener;
    /**
     * Provided for backward compatibility, use EventTarget.removeEventListener instead.
     * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
     * @function Chart.helpers.removeEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.removeEvent = removeListener; // @TODO Make possible to select another platform at build time.

    var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
    /**
     * @namespace Chart.platform
     * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
     * @since 2.4.0
     */

    var platform = helpers$1.extend({
      /**
       * @since 2.7.0
       */
      initialize: function () {},

      /**
       * Called at chart construction time, returns a context2d instance implementing
       * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
       * @param {*} item - The native item from which to acquire context (platform specific)
       * @param {object} options - The chart options
       * @returns {CanvasRenderingContext2D} context2d instance
       */
      acquireContext: function () {},

      /**
       * Called at chart destruction time, releases any resources associated to the context
       * previously returned by the acquireContext() method.
       * @param {CanvasRenderingContext2D} context - The context2d instance
       * @returns {boolean} true if the method succeeded, else false
       */
      releaseContext: function () {},

      /**
       * Registers the specified listener on the given chart.
       * @param {Chart} chart - Chart from which to listen for event
       * @param {string} type - The ({@link IEvent}) type to listen for
       * @param {function} listener - Receives a notification (an object that implements
       * the {@link IEvent} interface) when an event of the specified type occurs.
       */
      addEventListener: function () {},

      /**
       * Removes the specified listener previously registered with addEventListener.
       * @param {Chart} chart - Chart from which to remove the listener
       * @param {string} type - The ({@link IEvent}) type to remove
       * @param {function} listener - The listener function to remove from the event target.
       */
      removeEventListener: function () {}
    }, implementation);

    core_defaults._set('global', {
      plugins: {}
    });
    /**
     * The plugin service singleton
     * @namespace Chart.plugins
     * @since 2.1.0
     */


    var core_plugins = {
      /**
       * Globally registered plugins.
       * @private
       */
      _plugins: [],

      /**
       * This identifier is used to invalidate the descriptors cache attached to each chart
       * when a global plugin is registered or unregistered. In this case, the cache ID is
       * incremented and descriptors are regenerated during following API calls.
       * @private
       */
      _cacheId: 0,

      /**
       * Registers the given plugin(s) if not already registered.
       * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
       */
      register: function (plugins) {
        var p = this._plugins;
        [].concat(plugins).forEach(function (plugin) {
          if (p.indexOf(plugin) === -1) {
            p.push(plugin);
          }
        });
        this._cacheId++;
      },

      /**
       * Unregisters the given plugin(s) only if registered.
       * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
       */
      unregister: function (plugins) {
        var p = this._plugins;
        [].concat(plugins).forEach(function (plugin) {
          var idx = p.indexOf(plugin);

          if (idx !== -1) {
            p.splice(idx, 1);
          }
        });
        this._cacheId++;
      },

      /**
       * Remove all registered plugins.
       * @since 2.1.5
       */
      clear: function () {
        this._plugins = [];
        this._cacheId++;
      },

      /**
       * Returns the number of registered plugins?
       * @returns {number}
       * @since 2.1.5
       */
      count: function () {
        return this._plugins.length;
      },

      /**
       * Returns all registered plugin instances.
       * @returns {IPlugin[]} array of plugin objects.
       * @since 2.1.5
       */
      getAll: function () {
        return this._plugins;
      },

      /**
       * Calls enabled plugins for `chart` on the specified hook and with the given args.
       * This method immediately returns as soon as a plugin explicitly returns false. The
       * returned value can be used, for instance, to interrupt the current action.
       * @param {Chart} chart - The chart instance for which plugins should be called.
       * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
       * @param {Array} [args] - Extra arguments to apply to the hook call.
       * @returns {boolean} false if any of the plugins return false, else returns true.
       */
      notify: function (chart, hook, args) {
        var descriptors = this.descriptors(chart);
        var ilen = descriptors.length;
        var i, descriptor, plugin, params, method;

        for (i = 0; i < ilen; ++i) {
          descriptor = descriptors[i];
          plugin = descriptor.plugin;
          method = plugin[hook];

          if (typeof method === 'function') {
            params = [chart].concat(args || []);
            params.push(descriptor.options);

            if (method.apply(plugin, params) === false) {
              return false;
            }
          }
        }

        return true;
      },

      /**
       * Returns descriptors of enabled plugins for the given chart.
       * @returns {object[]} [{ plugin, options }]
       * @private
       */
      descriptors: function (chart) {
        var cache = chart.$plugins || (chart.$plugins = {});

        if (cache.id === this._cacheId) {
          return cache.descriptors;
        }

        var plugins = [];
        var descriptors = [];
        var config = chart && chart.config || {};
        var options = config.options && config.options.plugins || {};

        this._plugins.concat(config.plugins || []).forEach(function (plugin) {
          var idx = plugins.indexOf(plugin);

          if (idx !== -1) {
            return;
          }

          var id = plugin.id;
          var opts = options[id];

          if (opts === false) {
            return;
          }

          if (opts === true) {
            opts = helpers$1.clone(core_defaults.global.plugins[id]);
          }

          plugins.push(plugin);
          descriptors.push({
            plugin: plugin,
            options: opts || {}
          });
        });

        cache.descriptors = descriptors;
        cache.id = this._cacheId;
        return descriptors;
      },

      /**
       * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
       * but in some cases, this reference can be changed by the user when updating options.
       * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
       * @private
       */
      _invalidate: function (chart) {
        delete chart.$plugins;
      }
    };
    var core_scaleService = {
      // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
      // use the new chart options to grab the correct scale
      constructors: {},
      // Use a registration function so that we can move to an ES6 map when we no longer need to support
      // old browsers
      // Scale config defaults
      defaults: {},
      registerScaleType: function (type, scaleConstructor, scaleDefaults) {
        this.constructors[type] = scaleConstructor;
        this.defaults[type] = helpers$1.clone(scaleDefaults);
      },
      getScaleConstructor: function (type) {
        return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
      },
      getScaleDefaults: function (type) {
        // Return the scale defaults merged with the global settings so that we always use the latest ones
        return this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};
      },
      updateScaleDefaults: function (type, additions) {
        var me = this;

        if (me.defaults.hasOwnProperty(type)) {
          me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
        }
      },
      addScalesToLayout: function (chart) {
        // Adds each scale to the chart.boxes array to be sized accordingly
        helpers$1.each(chart.scales, function (scale) {
          // Set ILayoutItem parameters for backwards compatibility
          scale.fullWidth = scale.options.fullWidth;
          scale.position = scale.options.position;
          scale.weight = scale.options.weight;
          core_layouts.addBox(chart, scale);
        });
      }
    };
    var valueOrDefault$7 = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      tooltips: {
        enabled: true,
        custom: null,
        mode: 'nearest',
        position: 'average',
        intersect: true,
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleFontStyle: 'bold',
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleFontColor: '#fff',
        titleAlign: 'left',
        bodySpacing: 2,
        bodyFontColor: '#fff',
        bodyAlign: 'left',
        footerFontStyle: 'bold',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFontColor: '#fff',
        footerAlign: 'left',
        yPadding: 6,
        xPadding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        multiKeyBackground: '#fff',
        displayColors: true,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        callbacks: {
          // Args are: (tooltipItems, data)
          beforeTitle: helpers$1.noop,
          title: function (tooltipItems, data) {
            var title = '';
            var labels = data.labels;
            var labelCount = labels ? labels.length : 0;

            if (tooltipItems.length > 0) {
              var item = tooltipItems[0];

              if (item.label) {
                title = item.label;
              } else if (item.xLabel) {
                title = item.xLabel;
              } else if (labelCount > 0 && item.index < labelCount) {
                title = labels[item.index];
              }
            }

            return title;
          },
          afterTitle: helpers$1.noop,
          // Args are: (tooltipItems, data)
          beforeBody: helpers$1.noop,
          // Args are: (tooltipItem, data)
          beforeLabel: helpers$1.noop,
          label: function (tooltipItem, data) {
            var label = data.datasets[tooltipItem.datasetIndex].label || '';

            if (label) {
              label += ': ';
            }

            if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
              label += tooltipItem.value;
            } else {
              label += tooltipItem.yLabel;
            }

            return label;
          },
          labelColor: function (tooltipItem, chart) {
            var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
            var activeElement = meta.data[tooltipItem.index];
            var view = activeElement._view;
            return {
              borderColor: view.borderColor,
              backgroundColor: view.backgroundColor
            };
          },
          labelTextColor: function () {
            return this._options.bodyFontColor;
          },
          afterLabel: helpers$1.noop,
          // Args are: (tooltipItems, data)
          afterBody: helpers$1.noop,
          // Args are: (tooltipItems, data)
          beforeFooter: helpers$1.noop,
          footer: helpers$1.noop,
          afterFooter: helpers$1.noop
        }
      }
    });

    var positioners = {
      /**
       * Average mode places the tooltip at the average position of the elements shown
       * @function Chart.Tooltip.positioners.average
       * @param elements {ChartElement[]} the elements being displayed in the tooltip
       * @returns {object} tooltip position
       */
      average: function (elements) {
        if (!elements.length) {
          return false;
        }

        var i, len;
        var x = 0;
        var y = 0;
        var count = 0;

        for (i = 0, len = elements.length; i < len; ++i) {
          var el = elements[i];

          if (el && el.hasValue()) {
            var pos = el.tooltipPosition();
            x += pos.x;
            y += pos.y;
            ++count;
          }
        }

        return {
          x: x / count,
          y: y / count
        };
      },

      /**
       * Gets the tooltip position nearest of the item nearest to the event position
       * @function Chart.Tooltip.positioners.nearest
       * @param elements {Chart.Element[]} the tooltip elements
       * @param eventPosition {object} the position of the event in canvas coordinates
       * @returns {object} the tooltip position
       */
      nearest: function (elements, eventPosition) {
        var x = eventPosition.x;
        var y = eventPosition.y;
        var minDistance = Number.POSITIVE_INFINITY;
        var i, len, nearestElement;

        for (i = 0, len = elements.length; i < len; ++i) {
          var el = elements[i];

          if (el && el.hasValue()) {
            var center = el.getCenterPoint();
            var d = helpers$1.distanceBetweenPoints(eventPosition, center);

            if (d < minDistance) {
              minDistance = d;
              nearestElement = el;
            }
          }
        }

        if (nearestElement) {
          var tp = nearestElement.tooltipPosition();
          x = tp.x;
          y = tp.y;
        }

        return {
          x: x,
          y: y
        };
      }
    }; // Helper to push or concat based on if the 2nd parameter is an array or not

    function pushOrConcat(base, toPush) {
      if (toPush) {
        if (helpers$1.isArray(toPush)) {
          // base = base.concat(toPush);
          Array.prototype.push.apply(base, toPush);
        } else {
          base.push(toPush);
        }
      }

      return base;
    }
    /**
     * Returns array of strings split by newline
     * @param {string} value - The value to split by newline.
     * @returns {string[]} value if newline present - Returned from String split() method
     * @function
     */


    function splitNewlines(str) {
      if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
        return str.split('\n');
      }

      return str;
    }
    /**
     * Private helper to create a tooltip item model
     * @param element - the chart element (point, arc, bar) to create the tooltip item for
     * @return new tooltip item
     */


    function createTooltipItem(element) {
      var xScale = element._xScale;
      var yScale = element._yScale || element._scale; // handle radar || polarArea charts

      var index = element._index;
      var datasetIndex = element._datasetIndex;

      var controller = element._chart.getDatasetMeta(datasetIndex).controller;

      var indexScale = controller._getIndexScale();

      var valueScale = controller._getValueScale();

      return {
        xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
        yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
        label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',
        value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',
        index: index,
        datasetIndex: datasetIndex,
        x: element._model.x,
        y: element._model.y
      };
    }
    /**
     * Helper to get the reset model for the tooltip
     * @param tooltipOpts {object} the tooltip options
     */


    function getBaseModel(tooltipOpts) {
      var globalDefaults = core_defaults.global;
      return {
        // Positioning
        xPadding: tooltipOpts.xPadding,
        yPadding: tooltipOpts.yPadding,
        xAlign: tooltipOpts.xAlign,
        yAlign: tooltipOpts.yAlign,
        // Body
        bodyFontColor: tooltipOpts.bodyFontColor,
        _bodyFontFamily: valueOrDefault$7(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
        _bodyFontStyle: valueOrDefault$7(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
        _bodyAlign: tooltipOpts.bodyAlign,
        bodyFontSize: valueOrDefault$7(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
        bodySpacing: tooltipOpts.bodySpacing,
        // Title
        titleFontColor: tooltipOpts.titleFontColor,
        _titleFontFamily: valueOrDefault$7(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
        _titleFontStyle: valueOrDefault$7(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
        titleFontSize: valueOrDefault$7(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
        _titleAlign: tooltipOpts.titleAlign,
        titleSpacing: tooltipOpts.titleSpacing,
        titleMarginBottom: tooltipOpts.titleMarginBottom,
        // Footer
        footerFontColor: tooltipOpts.footerFontColor,
        _footerFontFamily: valueOrDefault$7(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
        _footerFontStyle: valueOrDefault$7(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
        footerFontSize: valueOrDefault$7(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
        _footerAlign: tooltipOpts.footerAlign,
        footerSpacing: tooltipOpts.footerSpacing,
        footerMarginTop: tooltipOpts.footerMarginTop,
        // Appearance
        caretSize: tooltipOpts.caretSize,
        cornerRadius: tooltipOpts.cornerRadius,
        backgroundColor: tooltipOpts.backgroundColor,
        opacity: 0,
        legendColorBackground: tooltipOpts.multiKeyBackground,
        displayColors: tooltipOpts.displayColors,
        borderColor: tooltipOpts.borderColor,
        borderWidth: tooltipOpts.borderWidth
      };
    }
    /**
     * Get the size of the tooltip
     */


    function getTooltipSize(tooltip, model) {
      var ctx = tooltip._chart.ctx;
      var height = model.yPadding * 2; // Tooltip Padding

      var width = 0; // Count of all lines in the body

      var body = model.body;
      var combinedBodyLength = body.reduce(function (count, bodyItem) {
        return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
      }, 0);
      combinedBodyLength += model.beforeBody.length + model.afterBody.length;
      var titleLineCount = model.title.length;
      var footerLineCount = model.footer.length;
      var titleFontSize = model.titleFontSize;
      var bodyFontSize = model.bodyFontSize;
      var footerFontSize = model.footerFontSize;
      height += titleLineCount * titleFontSize; // Title Lines

      height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing

      height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin

      height += combinedBodyLength * bodyFontSize; // Body Lines

      height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing

      height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin

      height += footerLineCount * footerFontSize; // Footer Lines

      height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
      // Title width

      var widthPadding = 0;

      var maxLineWidth = function (line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
      };

      ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
      helpers$1.each(model.title, maxLineWidth); // Body width

      ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
      helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth); // Body lines may include some extra width due to the color box

      widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
      helpers$1.each(body, function (bodyItem) {
        helpers$1.each(bodyItem.before, maxLineWidth);
        helpers$1.each(bodyItem.lines, maxLineWidth);
        helpers$1.each(bodyItem.after, maxLineWidth);
      }); // Reset back to 0

      widthPadding = 0; // Footer width

      ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
      helpers$1.each(model.footer, maxLineWidth); // Add padding

      width += 2 * model.xPadding;
      return {
        width: width,
        height: height
      };
    }
    /**
     * Helper to get the alignment of a tooltip given the size
     */


    function determineAlignment(tooltip, size) {
      var model = tooltip._model;
      var chart = tooltip._chart;
      var chartArea = tooltip._chart.chartArea;
      var xAlign = 'center';
      var yAlign = 'center';

      if (model.y < size.height) {
        yAlign = 'top';
      } else if (model.y > chart.height - size.height) {
        yAlign = 'bottom';
      }

      var lf, rf; // functions to determine left, right alignment

      var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart

      var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges

      var midX = (chartArea.left + chartArea.right) / 2;
      var midY = (chartArea.top + chartArea.bottom) / 2;

      if (yAlign === 'center') {
        lf = function (x) {
          return x <= midX;
        };

        rf = function (x) {
          return x > midX;
        };
      } else {
        lf = function (x) {
          return x <= size.width / 2;
        };

        rf = function (x) {
          return x >= chart.width - size.width / 2;
        };
      }

      olf = function (x) {
        return x + size.width + model.caretSize + model.caretPadding > chart.width;
      };

      orf = function (x) {
        return x - size.width - model.caretSize - model.caretPadding < 0;
      };

      yf = function (y) {
        return y <= midY ? 'top' : 'bottom';
      };

      if (lf(model.x)) {
        xAlign = 'left'; // Is tooltip too wide and goes over the right side of the chart.?

        if (olf(model.x)) {
          xAlign = 'center';
          yAlign = yf(model.y);
        }
      } else if (rf(model.x)) {
        xAlign = 'right'; // Is tooltip too wide and goes outside left edge of canvas?

        if (orf(model.x)) {
          xAlign = 'center';
          yAlign = yf(model.y);
        }
      }

      var opts = tooltip._options;
      return {
        xAlign: opts.xAlign ? opts.xAlign : xAlign,
        yAlign: opts.yAlign ? opts.yAlign : yAlign
      };
    }
    /**
     * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
     */


    function getBackgroundPoint(vm, size, alignment, chart) {
      // Background Position
      var x = vm.x;
      var y = vm.y;
      var caretSize = vm.caretSize;
      var caretPadding = vm.caretPadding;
      var cornerRadius = vm.cornerRadius;
      var xAlign = alignment.xAlign;
      var yAlign = alignment.yAlign;
      var paddingAndSize = caretSize + caretPadding;
      var radiusAndPadding = cornerRadius + caretPadding;

      if (xAlign === 'right') {
        x -= size.width;
      } else if (xAlign === 'center') {
        x -= size.width / 2;

        if (x + size.width > chart.width) {
          x = chart.width - size.width;
        }

        if (x < 0) {
          x = 0;
        }
      }

      if (yAlign === 'top') {
        y += paddingAndSize;
      } else if (yAlign === 'bottom') {
        y -= size.height + paddingAndSize;
      } else {
        y -= size.height / 2;
      }

      if (yAlign === 'center') {
        if (xAlign === 'left') {
          x += paddingAndSize;
        } else if (xAlign === 'right') {
          x -= paddingAndSize;
        }
      } else if (xAlign === 'left') {
        x -= radiusAndPadding;
      } else if (xAlign === 'right') {
        x += radiusAndPadding;
      }

      return {
        x: x,
        y: y
      };
    }

    function getAlignedX(vm, align) {
      return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
    }
    /**
     * Helper to build before and after body lines
     */


    function getBeforeAfterBodyLines(callback) {
      return pushOrConcat([], splitNewlines(callback));
    }

    var exports$3 = core_element.extend({
      initialize: function () {
        this._model = getBaseModel(this._options);
        this._lastActive = [];
      },
      // Get the title
      // Args are: (tooltipItem, data)
      getTitle: function () {
        var me = this;
        var opts = me._options;
        var callbacks = opts.callbacks;
        var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
        var title = callbacks.title.apply(me, arguments);
        var afterTitle = callbacks.afterTitle.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
      },
      // Args are: (tooltipItem, data)
      getBeforeBody: function () {
        return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
      },
      // Args are: (tooltipItem, data)
      getBody: function (tooltipItems, data) {
        var me = this;
        var callbacks = me._options.callbacks;
        var bodyItems = [];
        helpers$1.each(tooltipItems, function (tooltipItem) {
          var bodyItem = {
            before: [],
            lines: [],
            after: []
          };
          pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
          pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
          pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
          bodyItems.push(bodyItem);
        });
        return bodyItems;
      },
      // Args are: (tooltipItem, data)
      getAfterBody: function () {
        return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
      },
      // Get the footer and beforeFooter and afterFooter lines
      // Args are: (tooltipItem, data)
      getFooter: function () {
        var me = this;
        var callbacks = me._options.callbacks;
        var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
        var footer = callbacks.footer.apply(me, arguments);
        var afterFooter = callbacks.afterFooter.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
      },
      update: function (changed) {
        var me = this;
        var opts = me._options; // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
        // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
        // which breaks any animations.

        var existingModel = me._model;
        var model = me._model = getBaseModel(opts);
        var active = me._active;
        var data = me._data; // In the case where active.length === 0 we need to keep these at existing values for good animations

        var alignment = {
          xAlign: existingModel.xAlign,
          yAlign: existingModel.yAlign
        };
        var backgroundPoint = {
          x: existingModel.x,
          y: existingModel.y
        };
        var tooltipSize = {
          width: existingModel.width,
          height: existingModel.height
        };
        var tooltipPosition = {
          x: existingModel.caretX,
          y: existingModel.caretY
        };
        var i, len;

        if (active.length) {
          model.opacity = 1;
          var labelColors = [];
          var labelTextColors = [];
          tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
          var tooltipItems = [];

          for (i = 0, len = active.length; i < len; ++i) {
            tooltipItems.push(createTooltipItem(active[i]));
          } // If the user provided a filter function, use it to modify the tooltip items


          if (opts.filter) {
            tooltipItems = tooltipItems.filter(function (a) {
              return opts.filter(a, data);
            });
          } // If the user provided a sorting function, use it to modify the tooltip items


          if (opts.itemSort) {
            tooltipItems = tooltipItems.sort(function (a, b) {
              return opts.itemSort(a, b, data);
            });
          } // Determine colors for boxes


          helpers$1.each(tooltipItems, function (tooltipItem) {
            labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
            labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
          }); // Build the Text Lines

          model.title = me.getTitle(tooltipItems, data);
          model.beforeBody = me.getBeforeBody(tooltipItems, data);
          model.body = me.getBody(tooltipItems, data);
          model.afterBody = me.getAfterBody(tooltipItems, data);
          model.footer = me.getFooter(tooltipItems, data); // Initial positioning and colors

          model.x = tooltipPosition.x;
          model.y = tooltipPosition.y;
          model.caretPadding = opts.caretPadding;
          model.labelColors = labelColors;
          model.labelTextColors = labelTextColors; // data points

          model.dataPoints = tooltipItems; // We need to determine alignment of the tooltip

          tooltipSize = getTooltipSize(this, model);
          alignment = determineAlignment(this, tooltipSize); // Final Size and Position

          backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
        } else {
          model.opacity = 0;
        }

        model.xAlign = alignment.xAlign;
        model.yAlign = alignment.yAlign;
        model.x = backgroundPoint.x;
        model.y = backgroundPoint.y;
        model.width = tooltipSize.width;
        model.height = tooltipSize.height; // Point where the caret on the tooltip points to

        model.caretX = tooltipPosition.x;
        model.caretY = tooltipPosition.y;
        me._model = model;

        if (changed && opts.custom) {
          opts.custom.call(me, model);
        }

        return me;
      },
      drawCaret: function (tooltipPoint, size) {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
      },
      getCaretPosition: function (tooltipPoint, size, vm) {
        var x1, x2, x3, y1, y2, y3;
        var caretSize = vm.caretSize;
        var cornerRadius = vm.cornerRadius;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var ptX = tooltipPoint.x;
        var ptY = tooltipPoint.y;
        var width = size.width;
        var height = size.height;

        if (yAlign === 'center') {
          y2 = ptY + height / 2;

          if (xAlign === 'left') {
            x1 = ptX;
            x2 = x1 - caretSize;
            x3 = x1;
            y1 = y2 + caretSize;
            y3 = y2 - caretSize;
          } else {
            x1 = ptX + width;
            x2 = x1 + caretSize;
            x3 = x1;
            y1 = y2 - caretSize;
            y3 = y2 + caretSize;
          }
        } else {
          if (xAlign === 'left') {
            x2 = ptX + cornerRadius + caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else if (xAlign === 'right') {
            x2 = ptX + width - cornerRadius - caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else {
            x2 = vm.caretX;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          }

          if (yAlign === 'top') {
            y1 = ptY;
            y2 = y1 - caretSize;
            y3 = y1;
          } else {
            y1 = ptY + height;
            y2 = y1 + caretSize;
            y3 = y1; // invert drawing order

            var tmp = x3;
            x3 = x1;
            x1 = tmp;
          }
        }

        return {
          x1: x1,
          x2: x2,
          x3: x3,
          y1: y1,
          y2: y2,
          y3: y3
        };
      },
      drawTitle: function (pt, vm, ctx) {
        var title = vm.title;

        if (title.length) {
          pt.x = getAlignedX(vm, vm._titleAlign);
          ctx.textAlign = vm._titleAlign;
          ctx.textBaseline = 'top';
          var titleFontSize = vm.titleFontSize;
          var titleSpacing = vm.titleSpacing;
          ctx.fillStyle = vm.titleFontColor;
          ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
          var i, len;

          for (i = 0, len = title.length; i < len; ++i) {
            ctx.fillText(title[i], pt.x, pt.y);
            pt.y += titleFontSize + titleSpacing; // Line Height and spacing

            if (i + 1 === title.length) {
              pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
            }
          }
        }
      },
      drawBody: function (pt, vm, ctx) {
        var bodyFontSize = vm.bodyFontSize;
        var bodySpacing = vm.bodySpacing;
        var bodyAlign = vm._bodyAlign;
        var body = vm.body;
        var drawColorBoxes = vm.displayColors;
        var labelColors = vm.labelColors;
        var xLinePadding = 0;
        var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;
        var textColor;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = 'top';
        ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
        pt.x = getAlignedX(vm, bodyAlign); // Before Body

        var fillLineOfText = function (line) {
          ctx.fillText(line, pt.x + xLinePadding, pt.y);
          pt.y += bodyFontSize + bodySpacing;
        }; // Before body lines


        ctx.fillStyle = vm.bodyFontColor;
        helpers$1.each(vm.beforeBody, fillLineOfText);
        xLinePadding = drawColorBoxes && bodyAlign !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0; // Draw body lines now

        helpers$1.each(body, function (bodyItem, i) {
          textColor = vm.labelTextColors[i];
          ctx.fillStyle = textColor;
          helpers$1.each(bodyItem.before, fillLineOfText);
          helpers$1.each(bodyItem.lines, function (line) {
            // Draw Legend-like boxes if needed
            if (drawColorBoxes) {
              // Fill a white rect so that colours merge nicely if the opacity is < 1
              ctx.fillStyle = vm.legendColorBackground;
              ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Border

              ctx.lineWidth = 1;
              ctx.strokeStyle = labelColors[i].borderColor;
              ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Inner square

              ctx.fillStyle = labelColors[i].backgroundColor;
              ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
              ctx.fillStyle = textColor;
            }

            fillLineOfText(line);
          });
          helpers$1.each(bodyItem.after, fillLineOfText);
        }); // Reset back to 0 for after body

        xLinePadding = 0; // After body lines

        helpers$1.each(vm.afterBody, fillLineOfText);
        pt.y -= bodySpacing; // Remove last body spacing
      },
      drawFooter: function (pt, vm, ctx) {
        var footer = vm.footer;

        if (footer.length) {
          pt.x = getAlignedX(vm, vm._footerAlign);
          pt.y += vm.footerMarginTop;
          ctx.textAlign = vm._footerAlign;
          ctx.textBaseline = 'top';
          ctx.fillStyle = vm.footerFontColor;
          ctx.font = helpers$1.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
          helpers$1.each(footer, function (line) {
            ctx.fillText(line, pt.x, pt.y);
            pt.y += vm.footerFontSize + vm.footerSpacing;
          });
        }
      },
      drawBackground: function (pt, vm, ctx, tooltipSize) {
        ctx.fillStyle = vm.backgroundColor;
        ctx.strokeStyle = vm.borderColor;
        ctx.lineWidth = vm.borderWidth;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var x = pt.x;
        var y = pt.y;
        var width = tooltipSize.width;
        var height = tooltipSize.height;
        var radius = vm.cornerRadius;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);

        if (yAlign === 'top') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);

        if (yAlign === 'center' && xAlign === 'right') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);

        if (yAlign === 'bottom') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);

        if (yAlign === 'center' && xAlign === 'left') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();

        if (vm.borderWidth > 0) {
          ctx.stroke();
        }
      },
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;

        if (vm.opacity === 0) {
          return;
        }

        var tooltipSize = {
          width: vm.width,
          height: vm.height
        };
        var pt = {
          x: vm.x,
          y: vm.y
        }; // IE11/Edge does not like very small opacities, so snap to 0

        var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity; // Truthy/falsey value for empty tooltip

        var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

        if (this._options.enabled && hasTooltipContent) {
          ctx.save();
          ctx.globalAlpha = opacity; // Draw Background

          this.drawBackground(pt, vm, ctx, tooltipSize); // Draw Title, Body, and Footer

          pt.y += vm.yPadding; // Titles

          this.drawTitle(pt, vm, ctx); // Body

          this.drawBody(pt, vm, ctx); // Footer

          this.drawFooter(pt, vm, ctx);
          ctx.restore();
        }
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event - The event to handle
       * @returns {boolean} true if the tooltip changed
       */
      handleEvent: function (e) {
        var me = this;
        var options = me._options;
        var changed = false;
        me._lastActive = me._lastActive || []; // Find Active Elements for tooltips

        if (e.type === 'mouseout') {
          me._active = [];
        } else {
          me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
        } // Remember Last Actives


        changed = !helpers$1.arrayEquals(me._active, me._lastActive); // Only handle target event on tooltip change

        if (changed) {
          me._lastActive = me._active;

          if (options.enabled || options.custom) {
            me._eventPosition = {
              x: e.x,
              y: e.y
            };
            me.update(true);
            me.pivot();
          }
        }

        return changed;
      }
    });
    /**
     * @namespace Chart.Tooltip.positioners
     */

    var positioners_1 = positioners;
    var core_tooltip = exports$3;
    core_tooltip.positioners = positioners_1;
    var valueOrDefault$8 = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      elements: {},
      events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
      hover: {
        onHover: null,
        mode: 'nearest',
        intersect: true,
        animationDuration: 400
      },
      onClick: null,
      maintainAspectRatio: true,
      responsive: true,
      responsiveAnimationDuration: 0
    });
    /**
     * Recursively merge the given config objects representing the `scales` option
     * by incorporating scale defaults in `xAxes` and `yAxes` array items, then
     * returns a deep copy of the result, thus doesn't alter inputs.
     */


    function mergeScaleConfig()
    /* config objects ... */
    {
      return helpers$1.merge({}, [].slice.call(arguments), {
        merger: function (key, target, source, options) {
          if (key === 'xAxes' || key === 'yAxes') {
            var slen = source[key].length;
            var i, type, scale;

            if (!target[key]) {
              target[key] = [];
            }

            for (i = 0; i < slen; ++i) {
              scale = source[key][i];
              type = valueOrDefault$8(scale.type, key === 'xAxes' ? 'category' : 'linear');

              if (i >= target[key].length) {
                target[key].push({});
              }

              if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
                // new/untyped scale or type changed: let's apply the new defaults
                // then merge source scale to correctly overwrite the defaults.
                helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);
              } else {
                // scales type are the same
                helpers$1.merge(target[key][i], scale);
              }
            }
          } else {
            helpers$1._merger(key, target, source, options);
          }
        }
      });
    }
    /**
     * Recursively merge the given config objects as the root options by handling
     * default scale options for the `scales` and `scale` properties, then returns
     * a deep copy of the result, thus doesn't alter inputs.
     */


    function mergeConfig()
    /* config objects ... */
    {
      return helpers$1.merge({}, [].slice.call(arguments), {
        merger: function (key, target, source, options) {
          var tval = target[key] || {};
          var sval = source[key];

          if (key === 'scales') {
            // scale config merging is complex. Add our own function here for that
            target[key] = mergeScaleConfig(tval, sval);
          } else if (key === 'scale') {
            // used in polar area & radar charts since there is only one scale
            target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
          } else {
            helpers$1._merger(key, target, source, options);
          }
        }
      });
    }

    function initConfig(config) {
      config = config || {}; // Do NOT use mergeConfig for the data object because this method merges arrays
      // and so would change references to labels and datasets, preventing data updates.

      var data = config.data = config.data || {};
      data.datasets = data.datasets || [];
      data.labels = data.labels || [];
      config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
      return config;
    }

    function updateConfig(chart) {
      var newOptions = chart.options;
      helpers$1.each(chart.scales, function (scale) {
        core_layouts.removeBox(chart, scale);
      });
      newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
      chart.options = chart.config.options = newOptions;
      chart.ensureScalesHaveIDs();
      chart.buildOrUpdateScales(); // Tooltip

      chart.tooltip._options = newOptions.tooltips;
      chart.tooltip.initialize();
    }

    function positionIsHorizontal(position) {
      return position === 'top' || position === 'bottom';
    }

    var Chart = function (item, config) {
      this.construct(item, config);
      return this;
    };

    helpers$1.extend(Chart.prototype,
    /** @lends Chart */
    {
      /**
       * @private
       */
      construct: function (item, config) {
        var me = this;
        config = initConfig(config);
        var context = platform.acquireContext(item, config);
        var canvas = context && context.canvas;
        var height = canvas && canvas.height;
        var width = canvas && canvas.width;
        me.id = helpers$1.uid();
        me.ctx = context;
        me.canvas = canvas;
        me.config = config;
        me.width = width;
        me.height = height;
        me.aspectRatio = height ? width / height : null;
        me.options = config.options;
        me._bufferedRender = false;
        /**
         * Provided for backward compatibility, Chart and Chart.Controller have been merged,
         * the "instance" still need to be defined since it might be called from plugins.
         * @prop Chart#chart
         * @deprecated since version 2.6.0
         * @todo remove at version 3
         * @private
         */

        me.chart = me;
        me.controller = me; // chart.chart.controller #inception
        // Add the chart instance to the global namespace

        Chart.instances[me.id] = me; // Define alias to the config data: `chart.data === chart.config.data`

        Object.defineProperty(me, 'data', {
          get: function () {
            return me.config.data;
          },
          set: function (value) {
            me.config.data = value;
          }
        });

        if (!context || !canvas) {
          // The given item is not a compatible context2d element, let's return before finalizing
          // the chart initialization but after setting basic chart / controller properties that
          // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
          // https://github.com/chartjs/Chart.js/issues/2807
          console.error("Failed to create chart: can't acquire context from the given item");
          return;
        }

        me.initialize();
        me.update();
      },

      /**
       * @private
       */
      initialize: function () {
        var me = this; // Before init plugin notification

        core_plugins.notify(me, 'beforeInit');
        helpers$1.retinaScale(me, me.options.devicePixelRatio);
        me.bindEvents();

        if (me.options.responsive) {
          // Initial resize before chart draws (must be silent to preserve initial animations).
          me.resize(true);
        } // Make sure scales have IDs and are built before we build any controllers.


        me.ensureScalesHaveIDs();
        me.buildOrUpdateScales();
        me.initToolTip(); // After init plugin notification

        core_plugins.notify(me, 'afterInit');
        return me;
      },
      clear: function () {
        helpers$1.canvas.clear(this);
        return this;
      },
      stop: function () {
        // Stops any current animation loop occurring
        core_animations.cancelAnimation(this);
        return this;
      },
      resize: function (silent) {
        var me = this;
        var options = me.options;
        var canvas = me.canvas;
        var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that
        // the canvas display style uses the same integer values to avoid blurring effect.
        // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed

        var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
        var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));

        if (me.width === newWidth && me.height === newHeight) {
          return;
        }

        canvas.width = me.width = newWidth;
        canvas.height = me.height = newHeight;
        canvas.style.width = newWidth + 'px';
        canvas.style.height = newHeight + 'px';
        helpers$1.retinaScale(me, options.devicePixelRatio);

        if (!silent) {
          // Notify any plugins about the resize
          var newSize = {
            width: newWidth,
            height: newHeight
          };
          core_plugins.notify(me, 'resize', [newSize]); // Notify of resize

          if (options.onResize) {
            options.onResize(me, newSize);
          }

          me.stop();
          me.update({
            duration: options.responsiveAnimationDuration
          });
        }
      },
      ensureScalesHaveIDs: function () {
        var options = this.options;
        var scalesOptions = options.scales || {};
        var scaleOptions = options.scale;
        helpers$1.each(scalesOptions.xAxes, function (xAxisOptions, index) {
          xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
        });
        helpers$1.each(scalesOptions.yAxes, function (yAxisOptions, index) {
          yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
        });

        if (scaleOptions) {
          scaleOptions.id = scaleOptions.id || 'scale';
        }
      },

      /**
       * Builds a map of scale ID to scale object for future lookup.
       */
      buildOrUpdateScales: function () {
        var me = this;
        var options = me.options;
        var scales = me.scales || {};
        var items = [];
        var updated = Object.keys(scales).reduce(function (obj, id) {
          obj[id] = false;
          return obj;
        }, {});

        if (options.scales) {
          items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
            return {
              options: xAxisOptions,
              dtype: 'category',
              dposition: 'bottom'
            };
          }), (options.scales.yAxes || []).map(function (yAxisOptions) {
            return {
              options: yAxisOptions,
              dtype: 'linear',
              dposition: 'left'
            };
          }));
        }

        if (options.scale) {
          items.push({
            options: options.scale,
            dtype: 'radialLinear',
            isDefault: true,
            dposition: 'chartArea'
          });
        }

        helpers$1.each(items, function (item) {
          var scaleOptions = item.options;
          var id = scaleOptions.id;
          var scaleType = valueOrDefault$8(scaleOptions.type, item.dtype);

          if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
            scaleOptions.position = item.dposition;
          }

          updated[id] = true;
          var scale = null;

          if (id in scales && scales[id].type === scaleType) {
            scale = scales[id];
            scale.options = scaleOptions;
            scale.ctx = me.ctx;
            scale.chart = me;
          } else {
            var scaleClass = core_scaleService.getScaleConstructor(scaleType);

            if (!scaleClass) {
              return;
            }

            scale = new scaleClass({
              id: id,
              type: scaleType,
              options: scaleOptions,
              ctx: me.ctx,
              chart: me
            });
            scales[scale.id] = scale;
          }

          scale.mergeTicksOptions(); // TODO(SB): I think we should be able to remove this custom case (options.scale)
          // and consider it as a regular scale part of the "scales"" map only! This would
          // make the logic easier and remove some useless? custom code.

          if (item.isDefault) {
            me.scale = scale;
          }
        }); // clear up discarded scales

        helpers$1.each(updated, function (hasUpdated, id) {
          if (!hasUpdated) {
            delete scales[id];
          }
        });
        me.scales = scales;
        core_scaleService.addScalesToLayout(this);
      },
      buildOrUpdateControllers: function () {
        var me = this;
        var newControllers = [];
        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          var meta = me.getDatasetMeta(datasetIndex);
          var type = dataset.type || me.config.type;

          if (meta.type && meta.type !== type) {
            me.destroyDatasetMeta(datasetIndex);
            meta = me.getDatasetMeta(datasetIndex);
          }

          meta.type = type;

          if (meta.controller) {
            meta.controller.updateIndex(datasetIndex);
            meta.controller.linkScales();
          } else {
            var ControllerClass = controllers[meta.type];

            if (ControllerClass === undefined) {
              throw new Error('"' + meta.type + '" is not a chart type.');
            }

            meta.controller = new ControllerClass(me, datasetIndex);
            newControllers.push(meta.controller);
          }
        }, me);
        return newControllers;
      },

      /**
       * Reset the elements of all datasets
       * @private
       */
      resetElements: function () {
        var me = this;
        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.reset();
        }, me);
      },

      /**
      * Resets the chart back to it's state before the initial animation
      */
      reset: function () {
        this.resetElements();
        this.tooltip.initialize();
      },
      update: function (config) {
        var me = this;

        if (!config || typeof config !== 'object') {
          // backwards compatibility
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }

        updateConfig(me); // plugins options references might have change, let's invalidate the cache
        // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167

        core_plugins._invalidate(me);

        if (core_plugins.notify(me, 'beforeUpdate') === false) {
          return;
        } // In case the entire data object changed


        me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset

        var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts

        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
        }, me);
        me.updateLayout(); // Can only reset the new controllers after the scales have been updated

        if (me.options.animation && me.options.animation.duration) {
          helpers$1.each(newControllers, function (controller) {
            controller.reset();
          });
        }

        me.updateDatasets(); // Need to reset tooltip in case it is displayed with elements that are removed
        // after update.

        me.tooltip.initialize(); // Last active contains items that were previously in the tooltip.
        // When we reset the tooltip, we need to clear it

        me.lastActive = []; // Do this before render so that any plugins that need final scale updates can use it

        core_plugins.notify(me, 'afterUpdate');

        if (me._bufferedRender) {
          me._bufferedRequest = {
            duration: config.duration,
            easing: config.easing,
            lazy: config.lazy
          };
        } else {
          me.render(config);
        }
      },

      /**
       * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
       * hook, in which case, plugins will not be called on `afterLayout`.
       * @private
       */
      updateLayout: function () {
        var me = this;

        if (core_plugins.notify(me, 'beforeLayout') === false) {
          return;
        }

        core_layouts.update(this, this.width, this.height);
        /**
         * Provided for backward compatibility, use `afterLayout` instead.
         * @method IPlugin#afterScaleUpdate
         * @deprecated since version 2.5.0
         * @todo remove at version 3
         * @private
         */

        core_plugins.notify(me, 'afterScaleUpdate');
        core_plugins.notify(me, 'afterLayout');
      },

      /**
       * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
       * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
       * @private
       */
      updateDatasets: function () {
        var me = this;

        if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {
          return;
        }

        for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.updateDataset(i);
        }

        core_plugins.notify(me, 'afterDatasetsUpdate');
      },

      /**
       * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
       * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
       * @private
       */
      updateDataset: function (index) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta: meta,
          index: index
        };

        if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
          return;
        }

        meta.controller.update();
        core_plugins.notify(me, 'afterDatasetUpdate', [args]);
      },
      render: function (config) {
        var me = this;

        if (!config || typeof config !== 'object') {
          // backwards compatibility
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }

        var animationOptions = me.options.animation;
        var duration = valueOrDefault$8(config.duration, animationOptions && animationOptions.duration);
        var lazy = config.lazy;

        if (core_plugins.notify(me, 'beforeRender') === false) {
          return;
        }

        var onComplete = function (animation) {
          core_plugins.notify(me, 'afterRender');
          helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);
        };

        if (animationOptions && duration) {
          var animation = new core_animation({
            numSteps: duration / 16.66,
            // 60 fps
            easing: config.easing || animationOptions.easing,
            render: function (chart, animationObject) {
              var easingFunction = helpers$1.easing.effects[animationObject.easing];
              var currentStep = animationObject.currentStep;
              var stepDecimal = currentStep / animationObject.numSteps;
              chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
            },
            onAnimationProgress: animationOptions.onProgress,
            onAnimationComplete: onComplete
          });
          core_animations.addAnimation(me, animation, duration, lazy);
        } else {
          me.draw(); // See https://github.com/chartjs/Chart.js/issues/3781

          onComplete(new core_animation({
            numSteps: 0,
            chart: me
          }));
        }

        return me;
      },
      draw: function (easingValue) {
        var me = this;
        me.clear();

        if (helpers$1.isNullOrUndef(easingValue)) {
          easingValue = 1;
        }

        me.transition(easingValue);

        if (me.width <= 0 || me.height <= 0) {
          return;
        }

        if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
          return;
        } // Draw all the scales


        helpers$1.each(me.boxes, function (box) {
          box.draw(me.chartArea);
        }, me);
        me.drawDatasets(easingValue);

        me._drawTooltip(easingValue);

        core_plugins.notify(me, 'afterDraw', [easingValue]);
      },

      /**
       * @private
       */
      transition: function (easingValue) {
        var me = this;

        for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
          if (me.isDatasetVisible(i)) {
            me.getDatasetMeta(i).controller.transition(easingValue);
          }
        }

        me.tooltip.transition(easingValue);
      },

      /**
       * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
       * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
       * @private
       */
      drawDatasets: function (easingValue) {
        var me = this;

        if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
          return;
        } // Draw datasets reversed to support proper line stacking


        for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
          if (me.isDatasetVisible(i)) {
            me.drawDataset(i, easingValue);
          }
        }

        core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
      },

      /**
       * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
       * hook, in which case, plugins will not be called on `afterDatasetDraw`.
       * @private
       */
      drawDataset: function (index, easingValue) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta: meta,
          index: index,
          easingValue: easingValue
        };

        if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
          return;
        }

        meta.controller.draw(easingValue);
        core_plugins.notify(me, 'afterDatasetDraw', [args]);
      },

      /**
       * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
       * hook, in which case, plugins will not be called on `afterTooltipDraw`.
       * @private
       */
      _drawTooltip: function (easingValue) {
        var me = this;
        var tooltip = me.tooltip;
        var args = {
          tooltip: tooltip,
          easingValue: easingValue
        };

        if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
          return;
        }

        tooltip.draw();
        core_plugins.notify(me, 'afterTooltipDraw', [args]);
      },

      /**
       * Get the single element that was clicked on
       * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
       */
      getElementAtEvent: function (e) {
        return core_interaction.modes.single(this, e);
      },
      getElementsAtEvent: function (e) {
        return core_interaction.modes.label(this, e, {
          intersect: true
        });
      },
      getElementsAtXAxis: function (e) {
        return core_interaction.modes['x-axis'](this, e, {
          intersect: true
        });
      },
      getElementsAtEventForMode: function (e, mode, options) {
        var method = core_interaction.modes[mode];

        if (typeof method === 'function') {
          return method(this, e, options);
        }

        return [];
      },
      getDatasetAtEvent: function (e) {
        return core_interaction.modes.dataset(this, e, {
          intersect: true
        });
      },
      getDatasetMeta: function (datasetIndex) {
        var me = this;
        var dataset = me.data.datasets[datasetIndex];

        if (!dataset._meta) {
          dataset._meta = {};
        }

        var meta = dataset._meta[me.id];

        if (!meta) {
          meta = dataset._meta[me.id] = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            // See isDatasetVisible() comment
            xAxisID: null,
            yAxisID: null
          };
        }

        return meta;
      },
      getVisibleDatasetCount: function () {
        var count = 0;

        for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          if (this.isDatasetVisible(i)) {
            count++;
          }
        }

        return count;
      },
      isDatasetVisible: function (datasetIndex) {
        var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
        // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.

        return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
      },
      generateLegend: function () {
        return this.options.legendCallback(this);
      },

      /**
       * @private
       */
      destroyDatasetMeta: function (datasetIndex) {
        var id = this.id;
        var dataset = this.data.datasets[datasetIndex];
        var meta = dataset._meta && dataset._meta[id];

        if (meta) {
          meta.controller.destroy();
          delete dataset._meta[id];
        }
      },
      destroy: function () {
        var me = this;
        var canvas = me.canvas;
        var i, ilen;
        me.stop(); // dataset controllers need to cleanup associated data

        for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.destroyDatasetMeta(i);
        }

        if (canvas) {
          me.unbindEvents();
          helpers$1.canvas.clear(me);
          platform.releaseContext(me.ctx);
          me.canvas = null;
          me.ctx = null;
        }

        core_plugins.notify(me, 'destroy');
        delete Chart.instances[me.id];
      },
      toBase64Image: function () {
        return this.canvas.toDataURL.apply(this.canvas, arguments);
      },
      initToolTip: function () {
        var me = this;
        me.tooltip = new core_tooltip({
          _chart: me,
          _chartInstance: me,
          // deprecated, backward compatibility
          _data: me.data,
          _options: me.options.tooltips
        }, me);
      },

      /**
       * @private
       */
      bindEvents: function () {
        var me = this;
        var listeners = me._listeners = {};

        var listener = function () {
          me.eventHandler.apply(me, arguments);
        };

        helpers$1.each(me.options.events, function (type) {
          platform.addEventListener(me, type, listener);
          listeners[type] = listener;
        }); // Elements used to detect size change should not be injected for non responsive charts.
        // See https://github.com/chartjs/Chart.js/issues/2210

        if (me.options.responsive) {
          listener = function () {
            me.resize();
          };

          platform.addEventListener(me, 'resize', listener);
          listeners.resize = listener;
        }
      },

      /**
       * @private
       */
      unbindEvents: function () {
        var me = this;
        var listeners = me._listeners;

        if (!listeners) {
          return;
        }

        delete me._listeners;
        helpers$1.each(listeners, function (listener, type) {
          platform.removeEventListener(me, type, listener);
        });
      },
      updateHoverStyle: function (elements, mode, enabled) {
        var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
        var element, i, ilen;

        for (i = 0, ilen = elements.length; i < ilen; ++i) {
          element = elements[i];

          if (element) {
            this.getDatasetMeta(element._datasetIndex).controller[method](element);
          }
        }
      },

      /**
       * @private
       */
      eventHandler: function (e) {
        var me = this;
        var tooltip = me.tooltip;

        if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {
          return;
        } // Buffer any update calls so that renders do not occur


        me._bufferedRender = true;
        me._bufferedRequest = null;
        var changed = me.handleEvent(e); // for smooth tooltip animations issue #4989
        // the tooltip should be the source of change
        // Animation check workaround:
        // tooltip._start will be null when tooltip isn't animating

        if (tooltip) {
          changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
        }

        core_plugins.notify(me, 'afterEvent', [e]);
        var bufferedRequest = me._bufferedRequest;

        if (bufferedRequest) {
          // If we have an update that was triggered, we need to do a normal render
          me.render(bufferedRequest);
        } else if (changed && !me.animating) {
          // If entering, leaving, or changing elements, animate the change via pivot
          me.stop(); // We only need to render at this point. Updating will cause scales to be
          // recomputed generating flicker & using more memory than necessary.

          me.render({
            duration: me.options.hover.animationDuration,
            lazy: true
          });
        }

        me._bufferedRender = false;
        me._bufferedRequest = null;
        return me;
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event the event to handle
       * @return {boolean} true if the chart needs to re-render
       */
      handleEvent: function (e) {
        var me = this;
        var options = me.options || {};
        var hoverOptions = options.hover;
        var changed = false;
        me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips

        if (e.type === 'mouseout') {
          me.active = [];
        } else {
          me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
        } // Invoke onHover hook
        // Need to call with native event here to not break backwards compatibility


        helpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

        if (e.type === 'mouseup' || e.type === 'click') {
          if (options.onClick) {
            // Use e.native here for backwards compatibility
            options.onClick.call(me, e.native, me.active);
          }
        } // Remove styling for last active (even if it may still be active)


        if (me.lastActive.length) {
          me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
        } // Built in hover styling


        if (me.active.length && hoverOptions.mode) {
          me.updateHoverStyle(me.active, hoverOptions.mode, true);
        }

        changed = !helpers$1.arrayEquals(me.active, me.lastActive); // Remember Last Actives

        me.lastActive = me.active;
        return changed;
      }
    });
    /**
     * NOTE(SB) We actually don't use this container anymore but we need to keep it
     * for backward compatibility. Though, it can still be useful for plugins that
     * would need to work on multiple charts?!
     */

    Chart.instances = {};
    var core_controller = Chart; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart instead.
     * @class Chart.Controller
     * @deprecated since version 2.6
     * @todo remove at version 3
     * @private
     */

    Chart.Controller = Chart;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart
     * @deprecated since version 2.8
     * @todo remove at version 3
     * @private
     */

    Chart.types = {};
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.helpers.configMerge
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.configMerge = mergeConfig;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.helpers.scaleMerge
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.scaleMerge = mergeScaleConfig;

    var core_helpers = function () {
      // -- Basic js utility methods
      helpers$1.where = function (collection, filterCallback) {
        if (helpers$1.isArray(collection) && Array.prototype.filter) {
          return collection.filter(filterCallback);
        }

        var filtered = [];
        helpers$1.each(collection, function (item) {
          if (filterCallback(item)) {
            filtered.push(item);
          }
        });
        return filtered;
      };

      helpers$1.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
        return array.findIndex(callback, scope);
      } : function (array, callback, scope) {
        scope = scope === undefined ? array : scope;

        for (var i = 0, ilen = array.length; i < ilen; ++i) {
          if (callback.call(scope, array[i], i, array)) {
            return i;
          }
        }

        return -1;
      };

      helpers$1.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to start of the array
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = -1;
        }

        for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      };

      helpers$1.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to end of the array
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = arrayToSearch.length;
        }

        for (var i = startIndex - 1; i >= 0; i--) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      }; // -- Math methods


      helpers$1.isNumber = function (n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      };

      helpers$1.almostEquals = function (x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      };

      helpers$1.almostWhole = function (x, epsilon) {
        var rounded = Math.round(x);
        return rounded - epsilon < x && rounded + epsilon > x;
      };

      helpers$1.max = function (array) {
        return array.reduce(function (max, value) {
          if (!isNaN(value)) {
            return Math.max(max, value);
          }

          return max;
        }, Number.NEGATIVE_INFINITY);
      };

      helpers$1.min = function (array) {
        return array.reduce(function (min, value) {
          if (!isNaN(value)) {
            return Math.min(min, value);
          }

          return min;
        }, Number.POSITIVE_INFINITY);
      };

      helpers$1.sign = Math.sign ? function (x) {
        return Math.sign(x);
      } : function (x) {
        x = +x; // convert to a number

        if (x === 0 || isNaN(x)) {
          return x;
        }

        return x > 0 ? 1 : -1;
      };
      helpers$1.log10 = Math.log10 ? function (x) {
        return Math.log10(x);
      } : function (x) {
        var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
        // Check for whole powers of 10,
        // which due to floating point rounding error should be corrected.

        var powerOf10 = Math.round(exponent);
        var isPowerOf10 = x === Math.pow(10, powerOf10);
        return isPowerOf10 ? powerOf10 : exponent;
      };

      helpers$1.toRadians = function (degrees) {
        return degrees * (Math.PI / 180);
      };

      helpers$1.toDegrees = function (radians) {
        return radians * (180 / Math.PI);
      };
      /**
       * Returns the number of decimal places
       * i.e. the number of digits after the decimal point, of the value of this Number.
       * @param {number} x - A number.
       * @returns {number} The number of decimal places.
       * @private
       */


      helpers$1._decimalPlaces = function (x) {
        if (!helpers$1.isFinite(x)) {
          return;
        }

        var e = 1;
        var p = 0;

        while (Math.round(x * e) / e !== x) {
          e *= 10;
          p++;
        }

        return p;
      }; // Gets the angle from vertical upright to the point about a centre.


      helpers$1.getAngleFromPoint = function (centrePoint, anglePoint) {
        var distanceFromXCenter = anglePoint.x - centrePoint.x;
        var distanceFromYCenter = anglePoint.y - centrePoint.y;
        var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

        if (angle < -0.5 * Math.PI) {
          angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
        }

        return {
          angle: angle,
          distance: radialDistanceFromCenter
        };
      };

      helpers$1.distanceBetweenPoints = function (pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      };
      /**
       * Provided for backward compatibility, not available anymore
       * @function Chart.helpers.aliasPixel
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       */


      helpers$1.aliasPixel = function (pixelWidth) {
        return pixelWidth % 2 === 0 ? 0 : 0.5;
      };
      /**
       * Returns the aligned pixel value to avoid anti-aliasing blur
       * @param {Chart} chart - The chart instance.
       * @param {number} pixel - A pixel value.
       * @param {number} width - The width of the element.
       * @returns {number} The aligned pixel value.
       * @private
       */


      helpers$1._alignPixel = function (chart, pixel, width) {
        var devicePixelRatio = chart.currentDevicePixelRatio;
        var halfWidth = width / 2;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
      };

      helpers$1.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
        // Props to Rob Spencer at scaled innovation for his post on splining between points
        // http://scaledinnovation.com/analytics/splines/aboutSplines.html
        // This function must also respect "skipped" points
        var previous = firstPoint.skip ? middlePoint : firstPoint;
        var current = middlePoint;
        var next = afterPoint.skip ? middlePoint : afterPoint;
        var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
        var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
        var s01 = d01 / (d01 + d12);
        var s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf

        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        var fa = t * s01; // scaling factor for triangle Ta

        var fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        };
      };

      helpers$1.EPSILON = Number.EPSILON || 1e-14;

      helpers$1.splineCurveMonotone = function (points) {
        // This function calculates Bézier control points in a similar way than |splineCurve|,
        // but preserves monotonicity of the provided data and ensures no local extremums are added
        // between the dataset discrete points due to the interpolation.
        // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
        var pointsWithTangents = (points || []).map(function (point) {
          return {
            model: point._model,
            deltaK: 0,
            mK: 0
          };
        }); // Calculate slopes (deltaK) and initialize tangents (mK)

        var pointsLen = pointsWithTangents.length;
        var i, pointBefore, pointCurrent, pointAfter;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointAfter && !pointAfter.model.skip) {
            var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0

            pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
          }

          if (!pointBefore || pointBefore.model.skip) {
            pointCurrent.mK = pointCurrent.deltaK;
          } else if (!pointAfter || pointAfter.model.skip) {
            pointCurrent.mK = pointBefore.deltaK;
          } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
            pointCurrent.mK = 0;
          } else {
            pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
          }
        } // Adjust tangents to ensure monotonic properties


        var alphaK, betaK, tauK, squaredMagnitude;

        for (i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointsWithTangents[i];
          pointAfter = pointsWithTangents[i + 1];

          if (pointCurrent.model.skip || pointAfter.model.skip) {
            continue;
          }

          if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
            pointCurrent.mK = pointAfter.mK = 0;
            continue;
          }

          alphaK = pointCurrent.mK / pointCurrent.deltaK;
          betaK = pointAfter.mK / pointCurrent.deltaK;
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);

          if (squaredMagnitude <= 9) {
            continue;
          }

          tauK = 3 / Math.sqrt(squaredMagnitude);
          pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
          pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
        } // Compute control points


        var deltaX;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointBefore && !pointBefore.model.skip) {
            deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
            pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
            pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
          }

          if (pointAfter && !pointAfter.model.skip) {
            deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
            pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
            pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
          }
        }
      };

      helpers$1.nextItem = function (collection, index, loop) {
        if (loop) {
          return index >= collection.length - 1 ? collection[0] : collection[index + 1];
        }

        return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
      };

      helpers$1.previousItem = function (collection, index, loop) {
        if (loop) {
          return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
        }

        return index <= 0 ? collection[0] : collection[index - 1];
      }; // Implementation of the nice number algorithm used in determining where axis labels will go


      helpers$1.niceNum = function (range, round) {
        var exponent = Math.floor(helpers$1.log10(range));
        var fraction = range / Math.pow(10, exponent);
        var niceFraction;

        if (round) {
          if (fraction < 1.5) {
            niceFraction = 1;
          } else if (fraction < 3) {
            niceFraction = 2;
          } else if (fraction < 7) {
            niceFraction = 5;
          } else {
            niceFraction = 10;
          }
        } else if (fraction <= 1.0) {
          niceFraction = 1;
        } else if (fraction <= 2) {
          niceFraction = 2;
        } else if (fraction <= 5) {
          niceFraction = 5;
        } else {
          niceFraction = 10;
        }

        return niceFraction * Math.pow(10, exponent);
      }; // Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/


      helpers$1.requestAnimFrame = function () {
        if (typeof window === 'undefined') {
          return function (callback) {
            callback();
          };
        }

        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
          return window.setTimeout(callback, 1000 / 60);
        };
      }(); // -- DOM methods


      helpers$1.getRelativePosition = function (evt, chart) {
        var mouseX, mouseY;
        var e = evt.originalEvent || evt;
        var canvas = evt.target || evt.srcElement;
        var boundingRect = canvas.getBoundingClientRect();
        var touches = e.touches;

        if (touches && touches.length > 0) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        } // Scale mouse coordinates into canvas coordinates
        // by following the pattern laid out by 'jerryj' in the comments of
        // https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/


        var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));
        var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));
        var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));
        var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));
        var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
        var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom; // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
        // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here

        mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
        mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
        return {
          x: mouseX,
          y: mouseY
        };
      }; // Private helper function to convert max-width/max-height values that may be percentages into a number


      function parseMaxStyle(styleValue, node, parentProperty) {
        var valueInPixels;

        if (typeof styleValue === 'string') {
          valueInPixels = parseInt(styleValue, 10);

          if (styleValue.indexOf('%') !== -1) {
            // percentage * size in dimension
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
        } else {
          valueInPixels = styleValue;
        }

        return valueInPixels;
      }
      /**
       * Returns if the given value contains an effective constraint.
       * @private
       */


      function isConstrainedValue(value) {
        return value !== undefined && value !== null && value !== 'none';
      }
      /**
       * Returns the max width or height of the given DOM node in a cross-browser compatible fashion
       * @param {HTMLElement} domNode - the node to check the constraint on
       * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')
       * @param {string} percentageProperty - property of parent to use when calculating width as a percentage
       * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}
       */


      function getConstraintDimension(domNode, maxStyle, percentageProperty) {
        var view = document.defaultView;

        var parentNode = helpers$1._getParentNode(domNode);

        var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
        var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
        var hasCNode = isConstrainedValue(constrainedNode);
        var hasCContainer = isConstrainedValue(constrainedContainer);
        var infinity = Number.POSITIVE_INFINITY;

        if (hasCNode || hasCContainer) {
          return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
        }

        return 'none';
      } // returns Number or undefined if no constraint


      helpers$1.getConstraintWidth = function (domNode) {
        return getConstraintDimension(domNode, 'max-width', 'clientWidth');
      }; // returns Number or undefined if no constraint


      helpers$1.getConstraintHeight = function (domNode) {
        return getConstraintDimension(domNode, 'max-height', 'clientHeight');
      };
      /**
       * @private
      	 */


      helpers$1._calculatePadding = function (container, padding, parentDimension) {
        padding = helpers$1.getStyle(container, padding);
        return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
      };
      /**
       * @private
       */


      helpers$1._getParentNode = function (domNode) {
        var parent = domNode.parentNode;

        if (parent && parent.toString() === '[object ShadowRoot]') {
          parent = parent.host;
        }

        return parent;
      };

      helpers$1.getMaximumWidth = function (domNode) {
        var container = helpers$1._getParentNode(domNode);

        if (!container) {
          return domNode.clientWidth;
        }

        var clientWidth = container.clientWidth;

        var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);

        var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);

        var w = clientWidth - paddingLeft - paddingRight;
        var cw = helpers$1.getConstraintWidth(domNode);
        return isNaN(cw) ? w : Math.min(w, cw);
      };

      helpers$1.getMaximumHeight = function (domNode) {
        var container = helpers$1._getParentNode(domNode);

        if (!container) {
          return domNode.clientHeight;
        }

        var clientHeight = container.clientHeight;

        var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);

        var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);

        var h = clientHeight - paddingTop - paddingBottom;
        var ch = helpers$1.getConstraintHeight(domNode);
        return isNaN(ch) ? h : Math.min(h, ch);
      };

      helpers$1.getStyle = function (el, property) {
        return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
      };

      helpers$1.retinaScale = function (chart, forceRatio) {
        var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;

        if (pixelRatio === 1) {
          return;
        }

        var canvas = chart.canvas;
        var height = chart.height;
        var width = chart.width;
        canvas.height = height * pixelRatio;
        canvas.width = width * pixelRatio;
        chart.ctx.scale(pixelRatio, pixelRatio); // If no style has been set on the canvas, the render size is used as display size,
        // making the chart visually bigger, so let's enforce it to the "correct" values.
        // See https://github.com/chartjs/Chart.js/issues/3575

        if (!canvas.style.height && !canvas.style.width) {
          canvas.style.height = height + 'px';
          canvas.style.width = width + 'px';
        }
      }; // -- Canvas methods


      helpers$1.fontString = function (pixelSize, fontStyle, fontFamily) {
        return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
      };

      helpers$1.longestText = function (ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        var data = cache.data = cache.data || {};
        var gc = cache.garbageCollect = cache.garbageCollect || [];

        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
        }

        ctx.font = font;
        var longest = 0;
        helpers$1.each(arrayOfThings, function (thing) {
          // Undefined strings and arrays should not be measured
          if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {
            longest = helpers$1.measureText(ctx, data, gc, longest, thing);
          } else if (helpers$1.isArray(thing)) {
            // if it is an array lets measure each element
            // to do maybe simplify this function a bit so we can do this more recursively?
            helpers$1.each(thing, function (nestedThing) {
              // Undefined strings and arrays should not be measured
              if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
              }
            });
          }
        });
        var gcLen = gc.length / 2;

        if (gcLen > arrayOfThings.length) {
          for (var i = 0; i < gcLen; i++) {
            delete data[gc[i]];
          }

          gc.splice(0, gcLen);
        }

        return longest;
      };

      helpers$1.measureText = function (ctx, data, gc, longest, string) {
        var textWidth = data[string];

        if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string);
        }

        if (textWidth > longest) {
          longest = textWidth;
        }

        return longest;
      };

      helpers$1.numberOfLabelLines = function (arrayOfThings) {
        var numberOfLines = 1;
        helpers$1.each(arrayOfThings, function (thing) {
          if (helpers$1.isArray(thing)) {
            if (thing.length > numberOfLines) {
              numberOfLines = thing.length;
            }
          }
        });
        return numberOfLines;
      };

      helpers$1.color = !chartjsColor ? function (value) {
        console.error('Color.js not found!');
        return value;
      } : function (value) {
        /* global CanvasGradient */
        if (value instanceof CanvasGradient) {
          value = core_defaults.global.defaultColor;
        }

        return chartjsColor(value);
      };

      helpers$1.getHoverColor = function (colorValue) {
        /* global CanvasPattern */
        return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
      };
    };

    function abstract() {
      throw new Error('This method is not implemented: either no adapter can ' + 'be found or an incomplete integration was provided.');
    }
    /**
     * Date adapter (current used by the time scale)
     * @namespace Chart._adapters._date
     * @memberof Chart._adapters
     * @private
     */

    /**
     * Currently supported unit string values.
     * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}
     * @memberof Chart._adapters._date
     * @name Unit
     */

    /**
     * @class
     */


    function DateAdapter(options) {
      this.options = options || {};
    }

    helpers$1.extend(DateAdapter.prototype,
    /** @lends DateAdapter */
    {
      /**
       * Returns a map of time formats for the supported formatting units defined
       * in Unit as well as 'datetime' representing a detailed date/time string.
       * @returns {{string: string}}
       */
      formats: abstract,

      /**
       * Parses the given `value` and return the associated timestamp.
       * @param {any} value - the value to parse (usually comes from the data)
       * @param {string} [format] - the expected data format
       * @returns {(number|null)}
       * @function
       */
      parse: abstract,

      /**
       * Returns the formatted date in the specified `format` for a given `timestamp`.
       * @param {number} timestamp - the timestamp to format
       * @param {string} format - the date/time token
       * @return {string}
       * @function
       */
      format: abstract,

      /**
       * Adds the specified `amount` of `unit` to the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {number} amount - the amount to add
       * @param {Unit} unit - the unit as string
       * @return {number}
       * @function
       */
      add: abstract,

      /**
       * Returns the number of `unit` between the given timestamps.
       * @param {number} max - the input timestamp (reference)
       * @param {number} min - the timestamp to substract
       * @param {Unit} unit - the unit as string
       * @return {number}
       * @function
       */
      diff: abstract,

      /**
       * Returns start of `unit` for the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {Unit} unit - the unit as string
       * @param {number} [weekday] - the ISO day of the week with 1 being Monday
       * and 7 being Sunday (only needed if param *unit* is `isoWeek`).
       * @function
       */
      startOf: abstract,

      /**
       * Returns end of `unit` for the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {Unit} unit - the unit as string
       * @function
       */
      endOf: abstract,
      // DEPRECATIONS

      /**
       * Provided for backward compatibility for scale.getValueForPixel(),
       * this method should be overridden only by the moment adapter.
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
      _create: function (value) {
        return value;
      }
    });

    DateAdapter.override = function (members) {
      helpers$1.extend(DateAdapter.prototype, members);
    };

    var _date = DateAdapter;
    var core_adapters = {
      _date: _date
    };
    /**
     * Namespace to hold static tick generation functions
     * @namespace Chart.Ticks
     */

    var core_ticks = {
      /**
       * Namespace to hold formatters for different types of ticks
       * @namespace Chart.Ticks.formatters
       */
      formatters: {
        /**
         * Formatter for value labels
         * @method Chart.Ticks.formatters.values
         * @param value the value to display
         * @return {string|string[]} the label to display
         */
        values: function (value) {
          return helpers$1.isArray(value) ? value : '' + value;
        },

        /**
         * Formatter for linear numeric ticks
         * @method Chart.Ticks.formatters.linear
         * @param tickValue {number} the value to be formatted
         * @param index {number} the position of the tickValue parameter in the ticks array
         * @param ticks {number[]} the list of ticks being converted
         * @return {string} string representation of the tickValue parameter
         */
        linear: function (tickValue, index, ticks) {
          // If we have lots of ticks, don't use the ones
          var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need

          if (Math.abs(delta) > 1) {
            if (tickValue !== Math.floor(tickValue)) {
              // not an integer
              delta = tickValue - Math.floor(tickValue);
            }
          }

          var logDelta = helpers$1.log10(Math.abs(delta));
          var tickString = '';

          if (tickValue !== 0) {
            var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));

            if (maxTick < 1e-4) {
              // all ticks are small numbers; use scientific notation
              var logTick = helpers$1.log10(Math.abs(tickValue));
              tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
            } else {
              var numDecimal = -1 * Math.floor(logDelta);
              numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places

              tickString = tickValue.toFixed(numDecimal);
            }
          } else {
            tickString = '0'; // never show decimal places for 0
          }

          return tickString;
        },
        logarithmic: function (tickValue, index, ticks) {
          var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));

          if (tickValue === 0) {
            return '0';
          } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
            return tickValue.toExponential();
          }

          return '';
        }
      }
    };
    var valueOrDefault$9 = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;

    core_defaults._set('scale', {
      display: true,
      position: 'left',
      offset: false,
      // grid line settings
      gridLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        drawBorder: true,
        drawOnChartArea: true,
        drawTicks: true,
        tickMarkLength: 10,
        zeroLineWidth: 1,
        zeroLineColor: 'rgba(0,0,0,0.25)',
        zeroLineBorderDash: [],
        zeroLineBorderDashOffset: 0.0,
        offsetGridLines: false,
        borderDash: [],
        borderDashOffset: 0.0
      },
      // scale label
      scaleLabel: {
        // display property
        display: false,
        // actual label
        labelString: '',
        // top/bottom padding
        padding: {
          top: 4,
          bottom: 4
        }
      },
      // label settings
      ticks: {
        beginAtZero: false,
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        padding: 0,
        reverse: false,
        display: true,
        autoSkip: true,
        autoSkipPadding: 0,
        labelOffset: 0,
        // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
        callback: core_ticks.formatters.values,
        minor: {},
        major: {}
      }
    });

    function labelsFromTicks(ticks) {
      var labels = [];
      var i, ilen;

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        labels.push(ticks[i].label);
      }

      return labels;
    }

    function getPixelForGridLine(scale, index, offsetGridLines) {
      var lineValue = scale.getPixelForTick(index);

      if (offsetGridLines) {
        if (scale.getTicks().length === 1) {
          lineValue -= scale.isHorizontal() ? Math.max(lineValue - scale.left, scale.right - lineValue) : Math.max(lineValue - scale.top, scale.bottom - lineValue);
        } else if (index === 0) {
          lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
          lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
        }
      }

      return lineValue;
    }

    function computeTextSize(context, tick, font) {
      return helpers$1.isArray(tick) ? helpers$1.longestText(context, font, tick) : context.measureText(tick).width;
    }

    var core_scale = core_element.extend({
      /**
       * Get the padding needed for the scale
       * @method getPadding
       * @private
       * @returns {Padding} the necessary padding
       */
      getPadding: function () {
        var me = this;
        return {
          left: me.paddingLeft || 0,
          top: me.paddingTop || 0,
          right: me.paddingRight || 0,
          bottom: me.paddingBottom || 0
        };
      },

      /**
       * Returns the scale tick objects ({label, major})
       * @since 2.7
       */
      getTicks: function () {
        return this._ticks;
      },
      // These methods are ordered by lifecyle. Utilities then follow.
      // Any function defined here is inherited by all scale types.
      // Any function can be extended by the scale type
      mergeTicksOptions: function () {
        var ticks = this.options.ticks;

        if (ticks.minor === false) {
          ticks.minor = {
            display: false
          };
        }

        if (ticks.major === false) {
          ticks.major = {
            display: false
          };
        }

        for (var key in ticks) {
          if (key !== 'major' && key !== 'minor') {
            if (typeof ticks.minor[key] === 'undefined') {
              ticks.minor[key] = ticks[key];
            }

            if (typeof ticks.major[key] === 'undefined') {
              ticks.major[key] = ticks[key];
            }
          }
        }
      },
      beforeUpdate: function () {
        helpers$1.callback(this.options.beforeUpdate, [this]);
      },
      update: function (maxWidth, maxHeight, margins) {
        var me = this;
        var i, ilen, labels, label, ticks, tick; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = helpers$1.extend({
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, margins);
        me._maxLabelLines = 0;
        me.longestLabelWidth = 0;
        me.longestTextCache = me.longestTextCache || {}; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Data min/max

        me.beforeDataLimits();
        me.determineDataLimits();
        me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!
        // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
        // and must not be accessed directly from outside this class. `this.ticks` being
        // around for long time and not marked as private, we can't change its structure
        // without unexpected breaking changes. If you need to access the scale ticks,
        // use scale.getTicks() instead.

        me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,
        // we still support no return (`this.ticks` internally set by calling this method).

        ticks = me.buildTicks() || []; // Allow modification of ticks in callback.

        ticks = me.afterBuildTicks(ticks) || ticks;
        me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD
        // COMPAT, we still support no return (`this.ticks` internally changed by calling
        // this method and supposed to contain only string values).

        labels = me.convertTicksToLabels(ticks) || me.ticks;
        me.afterTickToLabelConversion();
        me.ticks = labels; // BACKWARD COMPATIBILITY
        // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!
        // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)

        for (i = 0, ilen = labels.length; i < ilen; ++i) {
          label = labels[i];
          tick = ticks[i];

          if (!tick) {
            ticks.push(tick = {
              label: label,
              major: false
            });
          } else {
            tick.label = label;
          }
        }

        me._ticks = ticks; // Tick Rotation

        me.beforeCalculateTickRotation();
        me.calculateTickRotation();
        me.afterCalculateTickRotation(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: function () {
        helpers$1.callback(this.options.afterUpdate, [this]);
      },
      //
      beforeSetDimensions: function () {
        helpers$1.callback(this.options.beforeSetDimensions, [this]);
      },
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0;
      },
      afterSetDimensions: function () {
        helpers$1.callback(this.options.afterSetDimensions, [this]);
      },
      // Data limits
      beforeDataLimits: function () {
        helpers$1.callback(this.options.beforeDataLimits, [this]);
      },
      determineDataLimits: helpers$1.noop,
      afterDataLimits: function () {
        helpers$1.callback(this.options.afterDataLimits, [this]);
      },
      //
      beforeBuildTicks: function () {
        helpers$1.callback(this.options.beforeBuildTicks, [this]);
      },
      buildTicks: helpers$1.noop,
      afterBuildTicks: function (ticks) {
        var me = this; // ticks is empty for old axis implementations here

        if (helpers$1.isArray(ticks) && ticks.length) {
          return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
        } // Support old implementations (that modified `this.ticks` directly in buildTicks)


        me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
        return ticks;
      },
      beforeTickToLabelConversion: function () {
        helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
      },
      convertTicksToLabels: function () {
        var me = this; // Convert ticks to strings

        var tickOpts = me.options.ticks;
        me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
      },
      afterTickToLabelConversion: function () {
        helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
      },
      //
      beforeCalculateTickRotation: function () {
        helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
      },
      calculateTickRotation: function () {
        var me = this;
        var context = me.ctx;
        var tickOpts = me.options.ticks;
        var labels = labelsFromTicks(me._ticks); // Get the width of each grid by calculating the difference
        // between x offsets between 0 and 1.

        var tickFont = helpers$1.options._parseFont(tickOpts);

        context.font = tickFont.string;
        var labelRotation = tickOpts.minRotation || 0;

        if (labels.length && me.options.display && me.isHorizontal()) {
          var originalLabelWidth = helpers$1.longestText(context, tickFont.string, labels, me.longestTextCache);
          var labelWidth = originalLabelWidth;
          var cosRotation, sinRotation; // Allow 3 pixels x2 padding either side for label readability

          var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6; // Max label rotation can be set or default to 90 - also act as a loop counter

          while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
            var angleRadians = helpers$1.toRadians(labelRotation);
            cosRotation = Math.cos(angleRadians);
            sinRotation = Math.sin(angleRadians);

            if (sinRotation * originalLabelWidth > me.maxHeight) {
              // go back one step
              labelRotation--;
              break;
            }

            labelRotation++;
            labelWidth = cosRotation * originalLabelWidth;
          }
        }

        me.labelRotation = labelRotation;
      },
      afterCalculateTickRotation: function () {
        helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
      },
      //
      beforeFit: function () {
        helpers$1.callback(this.options.beforeFit, [this]);
      },
      fit: function () {
        var me = this; // Reset

        var minSize = me.minSize = {
          width: 0,
          height: 0
        };
        var labels = labelsFromTicks(me._ticks);
        var opts = me.options;
        var tickOpts = opts.ticks;
        var scaleLabelOpts = opts.scaleLabel;
        var gridLineOpts = opts.gridLines;

        var display = me._isVisible();

        var position = opts.position;
        var isHorizontal = me.isHorizontal();
        var parseFont = helpers$1.options._parseFont;
        var tickFont = parseFont(tickOpts);
        var tickMarkLength = opts.gridLines.tickMarkLength; // Width

        if (isHorizontal) {
          // subtract the margins to line up with the chartArea if we are a full width scale
          minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
        } else {
          minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
        } // height


        if (isHorizontal) {
          minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
        } else {
          minSize.height = me.maxHeight; // fill all the height
        } // Are we showing a title for the scale?


        if (scaleLabelOpts.display && display) {
          var scaleLabelFont = parseFont(scaleLabelOpts);
          var scaleLabelPadding = helpers$1.options.toPadding(scaleLabelOpts.padding);
          var deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;

          if (isHorizontal) {
            minSize.height += deltaHeight;
          } else {
            minSize.width += deltaHeight;
          }
        } // Don't bother fitting the ticks if we are not showing the labels


        if (tickOpts.display && display) {
          var largestTextWidth = helpers$1.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);
          var tallestLabelHeightInLines = helpers$1.numberOfLabelLines(labels);
          var lineSpace = tickFont.size * 0.5;
          var tickPadding = me.options.ticks.padding; // Store max number of lines and widest label for _autoSkip

          me._maxLabelLines = tallestLabelHeightInLines;
          me.longestLabelWidth = largestTextWidth;

          if (isHorizontal) {
            var angleRadians = helpers$1.toRadians(me.labelRotation);
            var cosRotation = Math.cos(angleRadians);
            var sinRotation = Math.sin(angleRadians); // TODO - improve this calculation

            var labelHeight = sinRotation * largestTextWidth + tickFont.lineHeight * tallestLabelHeightInLines + lineSpace; // padding

            minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
            me.ctx.font = tickFont.string;
            var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);
            var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);
            var offsetLeft = me.getPixelForTick(0) - me.left;
            var offsetRight = me.right - me.getPixelForTick(labels.length - 1);
            var paddingLeft, paddingRight; // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
            // which means that the right padding is dominated by the font height

            if (me.labelRotation !== 0) {
              paddingLeft = position === 'bottom' ? cosRotation * firstLabelWidth : cosRotation * lineSpace;
              paddingRight = position === 'bottom' ? cosRotation * lineSpace : cosRotation * lastLabelWidth;
            } else {
              paddingLeft = firstLabelWidth / 2;
              paddingRight = lastLabelWidth / 2;
            }

            me.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges

            me.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;
          } else {
            // A vertical axis is more constrained by the width. Labels are the
            // dominant factor here, so get that length first and account for padding
            if (tickOpts.mirror) {
              largestTextWidth = 0;
            } else {
              // use lineSpace for consistency with horizontal axis
              // tickPadding is not implemented for horizontal
              largestTextWidth += tickPadding + lineSpace;
            }

            minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
            me.paddingTop = tickFont.size / 2;
            me.paddingBottom = tickFont.size / 2;
          }
        }

        me.handleMargins();
        me.width = minSize.width;
        me.height = minSize.height;
      },

      /**
       * Handle margins and padding interactions
       * @private
       */
      handleMargins: function () {
        var me = this;

        if (me.margins) {
          me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
          me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
          me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
          me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
        }
      },
      afterFit: function () {
        helpers$1.callback(this.options.afterFit, [this]);
      },
      // Shared Methods
      isHorizontal: function () {
        return this.options.position === 'top' || this.options.position === 'bottom';
      },
      isFullWidth: function () {
        return this.options.fullWidth;
      },
      // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
      getRightValue: function (rawValue) {
        // Null and undefined values first
        if (helpers$1.isNullOrUndef(rawValue)) {
          return NaN;
        } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values


        if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {
          return NaN;
        } // If it is in fact an object, dive in one more level


        if (rawValue) {
          if (this.isHorizontal()) {
            if (rawValue.x !== undefined) {
              return this.getRightValue(rawValue.x);
            }
          } else if (rawValue.y !== undefined) {
            return this.getRightValue(rawValue.y);
          }
        } // Value is good, return it


        return rawValue;
      },

      /**
       * Used to get the value to display in the tooltip for the data at the given index
       * @param index
       * @param datasetIndex
       */
      getLabelForIndex: helpers$1.noop,

      /**
       * Returns the location of the given data point. Value can either be an index or a numerical value
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       * @param value
       * @param index
       * @param datasetIndex
       */
      getPixelForValue: helpers$1.noop,

      /**
       * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       * @param pixel
       */
      getValueForPixel: helpers$1.noop,

      /**
       * Returns the location of the tick at the given index
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getPixelForTick: function (index) {
        var me = this;
        var offset = me.options.offset;

        if (me.isHorizontal()) {
          var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
          var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
          var pixel = tickWidth * index + me.paddingLeft;

          if (offset) {
            pixel += tickWidth / 2;
          }

          var finalVal = me.left + pixel;
          finalVal += me.isFullWidth() ? me.margins.left : 0;
          return finalVal;
        }

        var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
        return me.top + index * (innerHeight / (me._ticks.length - 1));
      },

      /**
       * Utility for getting the pixel location of a percentage of scale
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getPixelForDecimal: function (decimal) {
        var me = this;

        if (me.isHorizontal()) {
          var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
          var valueOffset = innerWidth * decimal + me.paddingLeft;
          var finalVal = me.left + valueOffset;
          finalVal += me.isFullWidth() ? me.margins.left : 0;
          return finalVal;
        }

        return me.top + decimal * me.height;
      },

      /**
       * Returns the pixel for the minimum chart value
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getBasePixel: function () {
        return this.getPixelForValue(this.getBaseValue());
      },
      getBaseValue: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
      },

      /**
       * Returns a subset of ticks to be plotted to avoid overlapping labels.
       * @private
       */
      _autoSkip: function (ticks) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var optionTicks = me.options.ticks.minor;
        var tickCount = ticks.length;
        var skipRatio = false;
        var maxTicks = optionTicks.maxTicksLimit; // Total space needed to display all ticks. First and last ticks are
        // drawn as their center at end of axis, so tickCount-1

        var ticksLength = me._tickSize() * (tickCount - 1); // Axis length

        var axisLength = isHorizontal ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.PaddingBottom);
        var result = [];
        var i, tick;

        if (ticksLength > axisLength) {
          skipRatio = 1 + Math.floor(ticksLength / axisLength);
        } // if they defined a max number of optionTicks,
        // increase skipRatio until that number is met


        if (tickCount > maxTicks) {
          skipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));
        }

        for (i = 0; i < tickCount; i++) {
          tick = ticks[i];

          if (skipRatio > 1 && i % skipRatio > 0) {
            // leave tick in place but make sure it's not displayed (#4635)
            delete tick.label;
          }

          result.push(tick);
        }

        return result;
      },

      /**
       * @private
       */
      _tickSize: function () {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var optionTicks = me.options.ticks.minor; // Calculate space needed by label in axis direction.

        var rot = helpers$1.toRadians(me.labelRotation);
        var cos = Math.abs(Math.cos(rot));
        var sin = Math.abs(Math.sin(rot));
        var padding = optionTicks.autoSkipPadding || 0;
        var w = me.longestLabelWidth + padding || 0;

        var tickFont = helpers$1.options._parseFont(optionTicks);

        var h = me._maxLabelLines * tickFont.lineHeight + padding || 0; // Calculate space needed for 1 tick in axis direction.

        return isHorizontal ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
      },

      /**
       * @private
       */
      _isVisible: function () {
        var me = this;
        var chart = me.chart;
        var display = me.options.display;
        var i, ilen, meta;

        if (display !== 'auto') {
          return !!display;
        } // When 'auto', the scale is visible if at least one associated dataset is visible.


        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);

            if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
              return true;
            }
          }
        }

        return false;
      },

      /**
       * Actually draw the scale on the canvas
       * @param {object} chartArea - the area of the chart to draw full grid lines on
       */
      draw: function (chartArea) {
        var me = this;
        var options = me.options;

        if (!me._isVisible()) {
          return;
        }

        var chart = me.chart;
        var context = me.ctx;
        var globalDefaults = core_defaults.global;
        var defaultFontColor = globalDefaults.defaultFontColor;
        var optionTicks = options.ticks.minor;
        var optionMajorTicks = options.ticks.major || optionTicks;
        var gridLines = options.gridLines;
        var scaleLabel = options.scaleLabel;
        var position = options.position;
        var isRotated = me.labelRotation !== 0;
        var isMirrored = optionTicks.mirror;
        var isHorizontal = me.isHorizontal();
        var parseFont = helpers$1.options._parseFont;
        var ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
        var tickFontColor = valueOrDefault$9(optionTicks.fontColor, defaultFontColor);
        var tickFont = parseFont(optionTicks);
        var lineHeight = tickFont.lineHeight;
        var majorTickFontColor = valueOrDefault$9(optionMajorTicks.fontColor, defaultFontColor);
        var majorTickFont = parseFont(optionMajorTicks);
        var tickPadding = optionTicks.padding;
        var labelOffset = optionTicks.labelOffset;
        var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
        var scaleLabelFontColor = valueOrDefault$9(scaleLabel.fontColor, defaultFontColor);
        var scaleLabelFont = parseFont(scaleLabel);
        var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
        var labelRotationRadians = helpers$1.toRadians(me.labelRotation);
        var itemsToDraw = [];
        var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
        var alignPixel = helpers$1._alignPixel;
        var borderValue, tickStart, tickEnd;

        if (position === 'top') {
          borderValue = alignPixel(chart, me.bottom, axisWidth);
          tickStart = me.bottom - tl;
          tickEnd = borderValue - axisWidth / 2;
        } else if (position === 'bottom') {
          borderValue = alignPixel(chart, me.top, axisWidth);
          tickStart = borderValue + axisWidth / 2;
          tickEnd = me.top + tl;
        } else if (position === 'left') {
          borderValue = alignPixel(chart, me.right, axisWidth);
          tickStart = me.right - tl;
          tickEnd = borderValue - axisWidth / 2;
        } else {
          borderValue = alignPixel(chart, me.left, axisWidth);
          tickStart = borderValue + axisWidth / 2;
          tickEnd = me.left + tl;
        }

        var epsilon = 0.0000001; // 0.0000001 is margin in pixels for Accumulated error.

        helpers$1.each(ticks, function (tick, index) {
          // autoskipper skipped this tick (#4635)
          if (helpers$1.isNullOrUndef(tick.label)) {
            return;
          }

          var label = tick.label;
          var lineWidth, lineColor, borderDash, borderDashOffset;

          if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
            // Draw the first index specially
            lineWidth = gridLines.zeroLineWidth;
            lineColor = gridLines.zeroLineColor;
            borderDash = gridLines.zeroLineBorderDash || [];
            borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;
          } else {
            lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);
            lineColor = valueAtIndexOrDefault(gridLines.color, index);
            borderDash = gridLines.borderDash || [];
            borderDashOffset = gridLines.borderDashOffset || 0.0;
          } // Common properties


          var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;
          var labelCount = helpers$1.isArray(label) ? label.length : 1;
          var lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);

          if (isHorizontal) {
            var labelYOffset = tl + tickPadding;

            if (lineValue < me.left - epsilon) {
              lineColor = 'rgba(0,0,0,0)';
            }

            tx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);
            ty1 = tickStart;
            ty2 = tickEnd;
            labelX = me.getPixelForTick(index) + labelOffset; // x values for optionTicks (need to consider offsetLabel option)

            if (position === 'top') {
              y1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;
              y2 = chartArea.bottom;
              textOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;
              textAlign = !isRotated ? 'center' : 'left';
              labelY = me.bottom - labelYOffset;
            } else {
              y1 = chartArea.top;
              y2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;
              textOffset = (!isRotated ? 0.5 : 0) * lineHeight;
              textAlign = !isRotated ? 'center' : 'right';
              labelY = me.top + labelYOffset;
            }
          } else {
            var labelXOffset = (isMirrored ? 0 : tl) + tickPadding;

            if (lineValue < me.top - epsilon) {
              lineColor = 'rgba(0,0,0,0)';
            }

            tx1 = tickStart;
            tx2 = tickEnd;
            ty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);
            labelY = me.getPixelForTick(index) + labelOffset;
            textOffset = (1 - labelCount) * lineHeight / 2;

            if (position === 'left') {
              x1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;
              x2 = chartArea.right;
              textAlign = isMirrored ? 'left' : 'right';
              labelX = me.right - labelXOffset;
            } else {
              x1 = chartArea.left;
              x2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;
              textAlign = isMirrored ? 'right' : 'left';
              labelX = me.left + labelXOffset;
            }
          }

          itemsToDraw.push({
            tx1: tx1,
            ty1: ty1,
            tx2: tx2,
            ty2: ty2,
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            labelX: labelX,
            labelY: labelY,
            glWidth: lineWidth,
            glColor: lineColor,
            glBorderDash: borderDash,
            glBorderDashOffset: borderDashOffset,
            rotation: -1 * labelRotationRadians,
            label: label,
            major: tick.major,
            textOffset: textOffset,
            textAlign: textAlign
          });
        }); // Draw all of the tick labels, tick marks, and grid lines at the correct places

        helpers$1.each(itemsToDraw, function (itemToDraw) {
          var glWidth = itemToDraw.glWidth;
          var glColor = itemToDraw.glColor;

          if (gridLines.display && glWidth && glColor) {
            context.save();
            context.lineWidth = glWidth;
            context.strokeStyle = glColor;

            if (context.setLineDash) {
              context.setLineDash(itemToDraw.glBorderDash);
              context.lineDashOffset = itemToDraw.glBorderDashOffset;
            }

            context.beginPath();

            if (gridLines.drawTicks) {
              context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
              context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
            }

            if (gridLines.drawOnChartArea) {
              context.moveTo(itemToDraw.x1, itemToDraw.y1);
              context.lineTo(itemToDraw.x2, itemToDraw.y2);
            }

            context.stroke();
            context.restore();
          }

          if (optionTicks.display) {
            // Make sure we draw text in the correct color and font
            context.save();
            context.translate(itemToDraw.labelX, itemToDraw.labelY);
            context.rotate(itemToDraw.rotation);
            context.font = itemToDraw.major ? majorTickFont.string : tickFont.string;
            context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
            context.textBaseline = 'middle';
            context.textAlign = itemToDraw.textAlign;
            var label = itemToDraw.label;
            var y = itemToDraw.textOffset;

            if (helpers$1.isArray(label)) {
              for (var i = 0; i < label.length; ++i) {
                // We just make sure the multiline element is a string here..
                context.fillText('' + label[i], 0, y);
                y += lineHeight;
              }
            } else {
              context.fillText(label, 0, y);
            }

            context.restore();
          }
        });

        if (scaleLabel.display) {
          // Draw the scale label
          var scaleLabelX;
          var scaleLabelY;
          var rotation = 0;
          var halfLineHeight = scaleLabelFont.lineHeight / 2;

          if (isHorizontal) {
            scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width

            scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
          } else {
            var isLeft = position === 'left';
            scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
            scaleLabelY = me.top + (me.bottom - me.top) / 2;
            rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
          }

          context.save();
          context.translate(scaleLabelX, scaleLabelY);
          context.rotate(rotation);
          context.textAlign = 'center';
          context.textBaseline = 'middle';
          context.fillStyle = scaleLabelFontColor; // render in correct colour

          context.font = scaleLabelFont.string;
          context.fillText(scaleLabel.labelString, 0, 0);
          context.restore();
        }

        if (axisWidth) {
          // Draw the line at the edge of the axis
          var firstLineWidth = axisWidth;
          var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);
          var x1, x2, y1, y2;

          if (isHorizontal) {
            x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
            x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
          } else {
            y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
            y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
          }

          context.lineWidth = axisWidth;
          context.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
          context.beginPath();
          context.moveTo(x1, y1);
          context.lineTo(x2, y2);
          context.stroke();
        }
      }
    });
    var defaultConfig = {
      position: 'bottom'
    };
    var scale_category = core_scale.extend({
      /**
      * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
      * else fall back to data.labels
      * @private
      */
      getLabels: function () {
        var data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
      },
      determineDataLimits: function () {
        var me = this;
        var labels = me.getLabels();
        me.minIndex = 0;
        me.maxIndex = labels.length - 1;
        var findIndex;

        if (me.options.ticks.min !== undefined) {
          // user specified min value
          findIndex = labels.indexOf(me.options.ticks.min);
          me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
        }

        if (me.options.ticks.max !== undefined) {
          // user specified max value
          findIndex = labels.indexOf(me.options.ticks.max);
          me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
        }

        me.min = labels[me.minIndex];
        me.max = labels[me.maxIndex];
      },
      buildTicks: function () {
        var me = this;
        var labels = me.getLabels(); // If we are viewing some subset of labels, slice the original array

        me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
      },
      getLabelForIndex: function (index, datasetIndex) {
        var me = this;
        var chart = me.chart;

        if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
          return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
        }

        return me.ticks[index - me.minIndex];
      },
      // Used to get data value locations.  Value can either be an index or a numerical value
      getPixelForValue: function (value, index) {
        var me = this;
        var offset = me.options.offset; // 1 is added because we need the length but we have the indexes

        var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1); // If value is a data object, then index is the index in the data array,
        // not the index of the scale. We need to change that.

        var valueCategory;

        if (value !== undefined && value !== null) {
          valueCategory = me.isHorizontal() ? value.x : value.y;
        }

        if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
          var labels = me.getLabels();
          value = valueCategory || value;
          var idx = labels.indexOf(value);
          index = idx !== -1 ? idx : index;
        }

        if (me.isHorizontal()) {
          var valueWidth = me.width / offsetAmt;
          var widthOffset = valueWidth * (index - me.minIndex);

          if (offset) {
            widthOffset += valueWidth / 2;
          }

          return me.left + widthOffset;
        }

        var valueHeight = me.height / offsetAmt;
        var heightOffset = valueHeight * (index - me.minIndex);

        if (offset) {
          heightOffset += valueHeight / 2;
        }

        return me.top + heightOffset;
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var offset = me.options.offset;
        var value;
        var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
        var horz = me.isHorizontal();
        var valueDimension = (horz ? me.width : me.height) / offsetAmt;
        pixel -= horz ? me.left : me.top;

        if (offset) {
          pixel -= valueDimension / 2;
        }

        if (pixel <= 0) {
          value = 0;
        } else {
          value = Math.round(pixel / valueDimension);
        }

        return value + me.minIndex;
      },
      getBasePixel: function () {
        return this.bottom;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults = defaultConfig;
    scale_category._defaults = _defaults;
    var noop = helpers$1.noop;
    var isNullOrUndef = helpers$1.isNullOrUndef;
    /**
     * Generate a set of linear ticks
     * @param generationOptions the options used to generate the ticks
     * @param dataRange the range of the data
     * @returns {number[]} array of tick values
     */

    function generateTicks(generationOptions, dataRange) {
      var ticks = []; // To get a "nice" value for the tick spacing, we will use the appropriately named
      // "nice number" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
      // for details.

      var MIN_SPACING = 1e-14;
      var stepSize = generationOptions.stepSize;
      var unit = stepSize || 1;
      var maxNumSpaces = generationOptions.maxTicks - 1;
      var min = generationOptions.min;
      var max = generationOptions.max;
      var precision = generationOptions.precision;
      var rmin = dataRange.min;
      var rmax = dataRange.max;
      var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
      var factor, niceMin, niceMax, numSpaces; // Beyond MIN_SPACING floating point numbers being to lose precision
      // such that we can't do the math necessary to generate ticks

      if (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {
        return [rmin, rmax];
      }

      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);

      if (numSpaces > maxNumSpaces) {
        // If the calculated num of spaces exceeds maxNumSpaces, recalculate it
        spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
      }

      if (stepSize || isNullOrUndef(precision)) {
        // If a precision is not specified, calculate factor based on spacing
        factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
      } else {
        // If the user specified a precision, round to that number of decimal places
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
      }

      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.

      if (stepSize) {
        // If very close to our whole number, use it.
        if (!isNullOrUndef(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {
          niceMin = min;
        }

        if (!isNullOrUndef(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {
          niceMax = max;
        }
      }

      numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.

      if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }

      niceMin = Math.round(niceMin * factor) / factor;
      niceMax = Math.round(niceMax * factor) / factor;
      ticks.push(isNullOrUndef(min) ? niceMin : min);

      for (var j = 1; j < numSpaces; ++j) {
        ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
      }

      ticks.push(isNullOrUndef(max) ? niceMax : max);
      return ticks;
    }

    var scale_linearbase = core_scale.extend({
      getRightValue: function (value) {
        if (typeof value === 'string') {
          return +value;
        }

        return core_scale.prototype.getRightValue.call(this, value);
      },
      handleTickRangeOptions: function () {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
        // do nothing since that would make the chart weird. If the user really wants a weird chart
        // axis, they can manually override it

        if (tickOpts.beginAtZero) {
          var minSign = helpers$1.sign(me.min);
          var maxSign = helpers$1.sign(me.max);

          if (minSign < 0 && maxSign < 0) {
            // move the top up to 0
            me.max = 0;
          } else if (minSign > 0 && maxSign > 0) {
            // move the bottom down to 0
            me.min = 0;
          }
        }

        var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
        var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

        if (tickOpts.min !== undefined) {
          me.min = tickOpts.min;
        } else if (tickOpts.suggestedMin !== undefined) {
          if (me.min === null) {
            me.min = tickOpts.suggestedMin;
          } else {
            me.min = Math.min(me.min, tickOpts.suggestedMin);
          }
        }

        if (tickOpts.max !== undefined) {
          me.max = tickOpts.max;
        } else if (tickOpts.suggestedMax !== undefined) {
          if (me.max === null) {
            me.max = tickOpts.suggestedMax;
          } else {
            me.max = Math.max(me.max, tickOpts.suggestedMax);
          }
        }

        if (setMin !== setMax) {
          // We set the min or the max but not both.
          // So ensure that our range is good
          // Inverted or 0 length range can happen when
          // ticks.min is set, and no datasets are visible
          if (me.min >= me.max) {
            if (setMin) {
              me.max = me.min + 1;
            } else {
              me.min = me.max - 1;
            }
          }
        }

        if (me.min === me.max) {
          me.max++;

          if (!tickOpts.beginAtZero) {
            me.min--;
          }
        }
      },
      getTickLimit: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var stepSize = tickOpts.stepSize;
        var maxTicksLimit = tickOpts.maxTicksLimit;
        var maxTicks;

        if (stepSize) {
          maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
        } else {
          maxTicks = me._computeTickLimit();
          maxTicksLimit = maxTicksLimit || 11;
        }

        if (maxTicksLimit) {
          maxTicks = Math.min(maxTicksLimit, maxTicks);
        }

        return maxTicks;
      },
      _computeTickLimit: function () {
        return Number.POSITIVE_INFINITY;
      },
      handleDirectionalChanges: noop,
      buildTicks: function () {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of
        // the axis area. For now, we say that the minimum tick spacing in pixels must be 40
        // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
        // the graph. Make sure we always have at least 2 ticks

        var maxTicks = me.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        var numericGeneratorOptions = {
          maxTicks: maxTicks,
          min: tickOpts.min,
          max: tickOpts.max,
          precision: tickOpts.precision,
          stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
        };
        var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
        me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the
        // range of the scale

        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);

        if (tickOpts.reverse) {
          ticks.reverse();
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }
      },
      convertTicksToLabels: function () {
        var me = this;
        me.ticksAsNumbers = me.ticks.slice();
        me.zeroLineIndex = me.ticks.indexOf(0);
        core_scale.prototype.convertTicksToLabels.call(me);
      }
    });
    var defaultConfig$1 = {
      position: 'left',
      ticks: {
        callback: core_ticks.formatters.linear
      }
    };
    var scale_linear = scale_linearbase.extend({
      determineDataLimits: function () {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var data = chart.data;
        var datasets = data.datasets;
        var isHorizontal = me.isHorizontal();
        var DEFAULT_MIN = 0;
        var DEFAULT_MAX = 1;

        function IDMatches(meta) {
          return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
        } // First Calculate the range


        me.min = null;
        me.max = null;
        var hasStacks = opts.stacked;

        if (hasStacks === undefined) {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            if (hasStacks) {
              return;
            }

            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
              hasStacks = true;
            }
          });
        }

        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

            if (valuesPerStack[key] === undefined) {
              valuesPerStack[key] = {
                positiveValues: [],
                negativeValues: []
              };
            } // Store these per type


            var positiveValues = valuesPerStack[key].positiveValues;
            var negativeValues = valuesPerStack[key].negativeValues;

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                positiveValues[index] = positiveValues[index] || 0;
                negativeValues[index] = negativeValues[index] || 0;

                if (opts.relativePoints) {
                  positiveValues[index] = 100;
                } else if (value < 0) {
                  negativeValues[index] += value;
                } else {
                  positiveValues[index] += value;
                }
              });
            }
          });
          helpers$1.each(valuesPerStack, function (valuesForType) {
            var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
            var minVal = helpers$1.min(values);
            var maxVal = helpers$1.max(values);
            me.min = me.min === null ? minVal : Math.min(me.min, minVal);
            me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
          });
        } else {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                if (me.min === null) {
                  me.min = value;
                } else if (value < me.min) {
                  me.min = value;
                }

                if (me.max === null) {
                  me.max = value;
                } else if (value > me.max) {
                  me.max = value;
                }
              });
            }
          });
        }

        me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
        me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

        this.handleTickRangeOptions();
      },
      // Returns the maximum number of ticks based on the scale dimension
      _computeTickLimit: function () {
        var me = this;
        var tickFont;

        if (me.isHorizontal()) {
          return Math.ceil(me.width / 40);
        }

        tickFont = helpers$1.options._parseFont(me.options.ticks);
        return Math.ceil(me.height / tickFont.lineHeight);
      },
      // Called after the ticks are built. We need
      handleDirectionalChanges: function () {
        if (!this.isHorizontal()) {
          // We are in a vertical orientation. The top value is the highest. So reverse the array
          this.ticks.reverse();
        }
      },
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      // Utils
      getPixelForValue: function (value) {
        // This must be called after fit has been run so that
        // this.left, this.top, this.right, and this.bottom have been defined
        var me = this;
        var start = me.start;
        var rightValue = +me.getRightValue(value);
        var pixel;
        var range = me.end - start;

        if (me.isHorizontal()) {
          pixel = me.left + me.width / range * (rightValue - start);
        } else {
          pixel = me.bottom - me.height / range * (rightValue - start);
        }

        return pixel;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var innerDimension = isHorizontal ? me.width : me.height;
        var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
        return me.start + (me.end - me.start) * offset;
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.ticksAsNumbers[index]);
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$1 = defaultConfig$1;
    scale_linear._defaults = _defaults$1;
    var valueOrDefault$a = helpers$1.valueOrDefault;
    /**
     * Generate a set of logarithmic ticks
     * @param generationOptions the options used to generate the ticks
     * @param dataRange the range of the data
     * @returns {number[]} array of tick values
     */

    function generateTicks$1(generationOptions, dataRange) {
      var ticks = [];
      var tickVal = valueOrDefault$a(generationOptions.min, Math.pow(10, Math.floor(helpers$1.log10(dataRange.min))));
      var endExp = Math.floor(helpers$1.log10(dataRange.max));
      var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
      var exp, significand;

      if (tickVal === 0) {
        exp = Math.floor(helpers$1.log10(dataRange.minNotZero));
        significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
        ticks.push(tickVal);
        tickVal = significand * Math.pow(10, exp);
      } else {
        exp = Math.floor(helpers$1.log10(tickVal));
        significand = Math.floor(tickVal / Math.pow(10, exp));
      }

      var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

      do {
        ticks.push(tickVal);
        ++significand;

        if (significand === 10) {
          significand = 1;
          ++exp;
          precision = exp >= 0 ? 1 : precision;
        }

        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
      } while (exp < endExp || exp === endExp && significand < endSignificand);

      var lastTick = valueOrDefault$a(generationOptions.max, tickVal);
      ticks.push(lastTick);
      return ticks;
    }

    var defaultConfig$2 = {
      position: 'left',
      // label settings
      ticks: {
        callback: core_ticks.formatters.logarithmic
      }
    }; // TODO(v3): change this to positiveOrDefault

    function nonNegativeOrDefault(value, defaultValue) {
      return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
    }

    var scale_logarithmic = core_scale.extend({
      determineDataLimits: function () {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var data = chart.data;
        var datasets = data.datasets;
        var isHorizontal = me.isHorizontal();

        function IDMatches(meta) {
          return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
        } // Calculate Range


        me.min = null;
        me.max = null;
        me.minNotZero = null;
        var hasStacks = opts.stacked;

        if (hasStacks === undefined) {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            if (hasStacks) {
              return;
            }

            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
              hasStacks = true;
            }
          });
        }

        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              if (valuesPerStack[key] === undefined) {
                valuesPerStack[key] = [];
              }

              helpers$1.each(dataset.data, function (rawValue, index) {
                var values = valuesPerStack[key];
                var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                if (isNaN(value) || meta.data[index].hidden || value < 0) {
                  return;
                }

                values[index] = values[index] || 0;
                values[index] += value;
              });
            }
          });
          helpers$1.each(valuesPerStack, function (valuesForType) {
            if (valuesForType.length > 0) {
              var minVal = helpers$1.min(valuesForType);
              var maxVal = helpers$1.max(valuesForType);
              me.min = me.min === null ? minVal : Math.min(me.min, minVal);
              me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
            }
          });
        } else {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                if (isNaN(value) || meta.data[index].hidden || value < 0) {
                  return;
                }

                if (me.min === null) {
                  me.min = value;
                } else if (value < me.min) {
                  me.min = value;
                }

                if (me.max === null) {
                  me.max = value;
                } else if (value > me.max) {
                  me.max = value;
                }

                if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                  me.minNotZero = value;
                }
              });
            }
          });
        } // Common base implementation to handle ticks.min, ticks.max


        this.handleTickRangeOptions();
      },
      handleTickRangeOptions: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var DEFAULT_MIN = 1;
        var DEFAULT_MAX = 10;
        me.min = nonNegativeOrDefault(tickOpts.min, me.min);
        me.max = nonNegativeOrDefault(tickOpts.max, me.max);

        if (me.min === me.max) {
          if (me.min !== 0 && me.min !== null) {
            me.min = Math.pow(10, Math.floor(helpers$1.log10(me.min)) - 1);
            me.max = Math.pow(10, Math.floor(helpers$1.log10(me.max)) + 1);
          } else {
            me.min = DEFAULT_MIN;
            me.max = DEFAULT_MAX;
          }
        }

        if (me.min === null) {
          me.min = Math.pow(10, Math.floor(helpers$1.log10(me.max)) - 1);
        }

        if (me.max === null) {
          me.max = me.min !== 0 ? Math.pow(10, Math.floor(helpers$1.log10(me.min)) + 1) : DEFAULT_MAX;
        }

        if (me.minNotZero === null) {
          if (me.min > 0) {
            me.minNotZero = me.min;
          } else if (me.max < 1) {
            me.minNotZero = Math.pow(10, Math.floor(helpers$1.log10(me.max)));
          } else {
            me.minNotZero = DEFAULT_MIN;
          }
        }
      },
      buildTicks: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = !me.isHorizontal();
        var generationOptions = {
          min: nonNegativeOrDefault(tickOpts.min),
          max: nonNegativeOrDefault(tickOpts.max)
        };
        var ticks = me.ticks = generateTicks$1(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the
        // range of the scale

        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);

        if (tickOpts.reverse) {
          reverse = !reverse;
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }

        if (reverse) {
          ticks.reverse();
        }
      },
      convertTicksToLabels: function () {
        this.tickValues = this.ticks.slice();
        core_scale.prototype.convertTicksToLabels.call(this);
      },
      // Get the correct tooltip label
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.tickValues[index]);
      },

      /**
       * Returns the value of the first tick.
       * @param {number} value - The minimum not zero value.
       * @return {number} The first tick value.
       * @private
       */
      _getFirstTickValue: function (value) {
        var exp = Math.floor(helpers$1.log10(value));
        var significand = Math.floor(value / Math.pow(10, exp));
        return significand * Math.pow(10, exp);
      },
      getPixelForValue: function (value) {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = tickOpts.reverse;
        var log10 = helpers$1.log10;

        var firstTickValue = me._getFirstTickValue(me.minNotZero);

        var offset = 0;
        var innerDimension, pixel, start, end, sign;
        value = +me.getRightValue(value);

        if (reverse) {
          start = me.end;
          end = me.start;
          sign = -1;
        } else {
          start = me.start;
          end = me.end;
          sign = 1;
        }

        if (me.isHorizontal()) {
          innerDimension = me.width;
          pixel = reverse ? me.right : me.left;
        } else {
          innerDimension = me.height;
          sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)

          pixel = reverse ? me.top : me.bottom;
        }

        if (value !== start) {
          if (start === 0) {
            // include zero tick
            offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
            innerDimension -= offset;
            start = firstTickValue;
          }

          if (value !== 0) {
            offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
          }

          pixel += sign * offset;
        }

        return pixel;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = tickOpts.reverse;
        var log10 = helpers$1.log10;

        var firstTickValue = me._getFirstTickValue(me.minNotZero);

        var innerDimension, start, end, value;

        if (reverse) {
          start = me.end;
          end = me.start;
        } else {
          start = me.start;
          end = me.end;
        }

        if (me.isHorizontal()) {
          innerDimension = me.width;
          value = reverse ? me.right - pixel : pixel - me.left;
        } else {
          innerDimension = me.height;
          value = reverse ? pixel - me.top : me.bottom - pixel;
        }

        if (value !== start) {
          if (start === 0) {
            // include zero tick
            var offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
            value -= offset;
            innerDimension -= offset;
            start = firstTickValue;
          }

          value *= log10(end) - log10(start);
          value /= innerDimension;
          value = Math.pow(10, log10(start) + value);
        }

        return value;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$2 = defaultConfig$2;
    scale_logarithmic._defaults = _defaults$2;
    var valueOrDefault$b = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
    var resolve$7 = helpers$1.options.resolve;
    var defaultConfig$3 = {
      display: true,
      // Boolean - Whether to animate scaling the chart from the centre
      animate: true,
      position: 'chartArea',
      angleLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0.0
      },
      gridLines: {
        circular: false
      },
      // label settings
      ticks: {
        // Boolean - Show a backdrop to the scale label
        showLabelBackdrop: true,
        // String - The colour of the label backdrop
        backdropColor: 'rgba(255,255,255,0.75)',
        // Number - The backdrop padding above & below the label in pixels
        backdropPaddingY: 2,
        // Number - The backdrop padding to the side of the label in pixels
        backdropPaddingX: 2,
        callback: core_ticks.formatters.linear
      },
      pointLabels: {
        // Boolean - if true, show point labels
        display: true,
        // Number - Point label font size in pixels
        fontSize: 10,
        // Function - Used to convert point labels
        callback: function (label) {
          return label;
        }
      }
    };

    function getValueCount(scale) {
      var opts = scale.options;
      return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
    }

    function getTickBackdropHeight(opts) {
      var tickOpts = opts.ticks;

      if (tickOpts.display && opts.display) {
        return valueOrDefault$b(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
      }

      return 0;
    }

    function measureLabelSize(ctx, lineHeight, label) {
      if (helpers$1.isArray(label)) {
        return {
          w: helpers$1.longestText(ctx, ctx.font, label),
          h: label.length * lineHeight
        };
      }

      return {
        w: ctx.measureText(label).width,
        h: lineHeight
      };
    }

    function determineLimits(angle, pos, size, min, max) {
      if (angle === min || angle === max) {
        return {
          start: pos - size / 2,
          end: pos + size / 2
        };
      } else if (angle < min || angle > max) {
        return {
          start: pos - size,
          end: pos
        };
      }

      return {
        start: pos,
        end: pos + size
      };
    }
    /**
     * Helper function to fit a radial linear scale with point labels
     */


    function fitWithPointLabels(scale) {
      // Right, this is really confusing and there is a lot of maths going on here
      // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
      //
      // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
      //
      // Solution:
      //
      // We assume the radius of the polygon is half the size of the canvas at first
      // at each index we check if the text overlaps.
      //
      // Where it does, we store that angle and that index.
      //
      // After finding the largest index and angle we calculate how much we need to remove
      // from the shape radius to move the point inwards by that x.
      //
      // We average the left and right distances to get the maximum shape radius that can fit in the box
      // along with labels.
      //
      // Once we have that, we can find the centre point for the chart, by taking the x text protrusion
      // on each side, removing that from the size, halving it and adding the left x protrusion width.
      //
      // This will mean we have a shape fitted to the canvas, as large as it can be with the labels
      // and position it in the most space efficient manner
      //
      // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
      var plFont = helpers$1.options._parseFont(scale.options.pointLabels); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
      // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points


      var furthestLimits = {
        l: 0,
        r: scale.width,
        t: 0,
        b: scale.height - scale.paddingTop
      };
      var furthestAngles = {};
      var i, textSize, pointPosition;
      scale.ctx.font = plFont.string;
      scale._pointLabelSizes = [];
      var valueCount = getValueCount(scale);

      for (i = 0; i < valueCount; i++) {
        pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
        textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');
        scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle

        var angleRadians = scale.getIndexAngle(i);
        var angle = helpers$1.toDegrees(angleRadians) % 360;
        var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

        if (hLimits.start < furthestLimits.l) {
          furthestLimits.l = hLimits.start;
          furthestAngles.l = angleRadians;
        }

        if (hLimits.end > furthestLimits.r) {
          furthestLimits.r = hLimits.end;
          furthestAngles.r = angleRadians;
        }

        if (vLimits.start < furthestLimits.t) {
          furthestLimits.t = vLimits.start;
          furthestAngles.t = angleRadians;
        }

        if (vLimits.end > furthestLimits.b) {
          furthestLimits.b = vLimits.end;
          furthestAngles.b = angleRadians;
        }
      }

      scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
    }

    function getTextAlignForAngle(angle) {
      if (angle === 0 || angle === 180) {
        return 'center';
      } else if (angle < 180) {
        return 'left';
      }

      return 'right';
    }

    function fillText(ctx, text, position, lineHeight) {
      var y = position.y + lineHeight / 2;
      var i, ilen;

      if (helpers$1.isArray(text)) {
        for (i = 0, ilen = text.length; i < ilen; ++i) {
          ctx.fillText(text[i], position.x, y);
          y += lineHeight;
        }
      } else {
        ctx.fillText(text, position.x, y);
      }
    }

    function adjustPointPositionForLabelHeight(angle, textSize, position) {
      if (angle === 90 || angle === 270) {
        position.y -= textSize.h / 2;
      } else if (angle > 270 || angle < 90) {
        position.y -= textSize.h;
      }
    }

    function drawPointLabels(scale) {
      var ctx = scale.ctx;
      var opts = scale.options;
      var angleLineOpts = opts.angleLines;
      var gridLineOpts = opts.gridLines;
      var pointLabelOpts = opts.pointLabels;
      var lineWidth = valueOrDefault$b(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
      var lineColor = valueOrDefault$b(angleLineOpts.color, gridLineOpts.color);
      var tickBackdropHeight = getTickBackdropHeight(opts);
      ctx.save();
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = lineColor;

      if (ctx.setLineDash) {
        ctx.setLineDash(resolve$7([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
        ctx.lineDashOffset = resolve$7([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);
      }

      var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max); // Point Label Font

      var plFont = helpers$1.options._parseFont(pointLabelOpts);

      ctx.font = plFont.string;
      ctx.textBaseline = 'middle';

      for (var i = getValueCount(scale) - 1; i >= 0; i--) {
        if (angleLineOpts.display && lineWidth && lineColor) {
          var outerPosition = scale.getPointPosition(i, outerDistance);
          ctx.beginPath();
          ctx.moveTo(scale.xCenter, scale.yCenter);
          ctx.lineTo(outerPosition.x, outerPosition.y);
          ctx.stroke();
        }

        if (pointLabelOpts.display) {
          // Extra pixels out for some label spacing
          var extra = i === 0 ? tickBackdropHeight / 2 : 0;
          var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5); // Keep this in loop since we may support array properties here

          var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
          ctx.fillStyle = pointLabelFontColor;
          var angleRadians = scale.getIndexAngle(i);
          var angle = helpers$1.toDegrees(angleRadians);
          ctx.textAlign = getTextAlignForAngle(angle);
          adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
          fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);
        }
      }

      ctx.restore();
    }

    function drawRadiusLine(scale, gridLineOpts, radius, index) {
      var ctx = scale.ctx;
      var circular = gridLineOpts.circular;
      var valueCount = getValueCount(scale);
      var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
      var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
      var pointPosition;

      if (!circular && !valueCount || !lineColor || !lineWidth) {
        return;
      }

      ctx.save();
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = lineWidth;

      if (ctx.setLineDash) {
        ctx.setLineDash(gridLineOpts.borderDash || []);
        ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;
      }

      ctx.beginPath();

      if (circular) {
        // Draw circular arcs between the points
        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
      } else {
        // Draw straight lines connecting each index
        pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);

        for (var i = 1; i < valueCount; i++) {
          pointPosition = scale.getPointPosition(i, radius);
          ctx.lineTo(pointPosition.x, pointPosition.y);
        }
      }

      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    function numberOrZero(param) {
      return helpers$1.isNumber(param) ? param : 0;
    }

    var scale_radialLinear = scale_linearbase.extend({
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        me.width = me.maxWidth;
        me.height = me.maxHeight;
        me.paddingTop = getTickBackdropHeight(me.options) / 2;
        me.xCenter = Math.floor(me.width / 2);
        me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
        me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
      },
      determineDataLimits: function () {
        var me = this;
        var chart = me.chart;
        var min = Number.POSITIVE_INFINITY;
        var max = Number.NEGATIVE_INFINITY;
        helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {
          if (chart.isDatasetVisible(datasetIndex)) {
            var meta = chart.getDatasetMeta(datasetIndex);
            helpers$1.each(dataset.data, function (rawValue, index) {
              var value = +me.getRightValue(rawValue);

              if (isNaN(value) || meta.data[index].hidden) {
                return;
              }

              min = Math.min(value, min);
              max = Math.max(value, max);
            });
          }
        });
        me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
        me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

        me.handleTickRangeOptions();
      },
      // Returns the maximum number of ticks based on the scale dimension
      _computeTickLimit: function () {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
      },
      convertTicksToLabels: function () {
        var me = this;
        scale_linearbase.prototype.convertTicksToLabels.call(me); // Point labels

        me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
      },
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      fit: function () {
        var me = this;
        var opts = me.options;

        if (opts.display && opts.pointLabels.display) {
          fitWithPointLabels(me);
        } else {
          me.setCenterPoint(0, 0, 0, 0);
        }
      },

      /**
       * Set radius reductions and determine new radius and center point
       * @private
       */
      setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {
        var me = this;
        var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
        var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
        var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
        var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
        radiusReductionLeft = numberOrZero(radiusReductionLeft);
        radiusReductionRight = numberOrZero(radiusReductionRight);
        radiusReductionTop = numberOrZero(radiusReductionTop);
        radiusReductionBottom = numberOrZero(radiusReductionBottom);
        me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
        me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
      },
      setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {
        var me = this;
        var maxRight = me.width - rightMovement - me.drawingArea;
        var maxLeft = leftMovement + me.drawingArea;
        var maxTop = topMovement + me.drawingArea;
        var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
        me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
        me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
      },
      getIndexAngle: function (index) {
        var angleMultiplier = Math.PI * 2 / getValueCount(this);
        var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
        var startAngleRadians = startAngle * Math.PI * 2 / 360; // Start from the top instead of right, so remove a quarter of the circle

        return index * angleMultiplier + startAngleRadians;
      },
      getDistanceFromCenterForValue: function (value) {
        var me = this;

        if (value === null) {
          return 0; // null always in center
        } // Take into account half font size + the yPadding of the top value


        var scalingFactor = me.drawingArea / (me.max - me.min);

        if (me.options.ticks.reverse) {
          return (me.max - value) * scalingFactor;
        }

        return (value - me.min) * scalingFactor;
      },
      getPointPosition: function (index, distanceFromCenter) {
        var me = this;
        var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
        return {
          x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
          y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
        };
      },
      getPointPositionForValue: function (index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
      },
      getBasePosition: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
      },
      draw: function () {
        var me = this;
        var opts = me.options;
        var gridLineOpts = opts.gridLines;
        var tickOpts = opts.ticks;

        if (opts.display) {
          var ctx = me.ctx;
          var startAngle = this.getIndexAngle(0);

          var tickFont = helpers$1.options._parseFont(tickOpts);

          if (opts.angleLines.display || opts.pointLabels.display) {
            drawPointLabels(me);
          }

          helpers$1.each(me.ticks, function (label, index) {
            // Don't draw a centre value (if it is minimum)
            if (index > 0 || tickOpts.reverse) {
              var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]); // Draw circular lines around the scale

              if (gridLineOpts.display && index !== 0) {
                drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
              }

              if (tickOpts.display) {
                var tickFontColor = valueOrDefault$b(tickOpts.fontColor, core_defaults.global.defaultFontColor);
                ctx.font = tickFont.string;
                ctx.save();
                ctx.translate(me.xCenter, me.yCenter);
                ctx.rotate(startAngle);

                if (tickOpts.showLabelBackdrop) {
                  var labelWidth = ctx.measureText(label).width;
                  ctx.fillStyle = tickOpts.backdropColor;
                  ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
                }

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = tickFontColor;
                ctx.fillText(label, 0, -yCenterOffset);
                ctx.restore();
              }
            }
          });
        }
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$3 = defaultConfig$3;
    scale_radialLinear._defaults = _defaults$3;
    var valueOrDefault$c = helpers$1.valueOrDefault; // Integer constants are from the ES6 spec.

    var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var INTERVALS = {
      millisecond: {
        common: true,
        size: 1,
        steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
      },
      second: {
        common: true,
        size: 1000,
        steps: [1, 2, 5, 10, 15, 30]
      },
      minute: {
        common: true,
        size: 60000,
        steps: [1, 2, 5, 10, 15, 30]
      },
      hour: {
        common: true,
        size: 3600000,
        steps: [1, 2, 3, 6, 12]
      },
      day: {
        common: true,
        size: 86400000,
        steps: [1, 2, 5]
      },
      week: {
        common: false,
        size: 604800000,
        steps: [1, 2, 3, 4]
      },
      month: {
        common: true,
        size: 2.628e9,
        steps: [1, 2, 3]
      },
      quarter: {
        common: false,
        size: 7.884e9,
        steps: [1, 2, 3, 4]
      },
      year: {
        common: true,
        size: 3.154e10
      }
    };
    var UNITS = Object.keys(INTERVALS);

    function sorter(a, b) {
      return a - b;
    }

    function arrayUnique(items) {
      var hash = {};
      var out = [];
      var i, ilen, item;

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];

        if (!hash[item]) {
          hash[item] = true;
          out.push(item);
        }
      }

      return out;
    }
    /**
     * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
     * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
     * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
     * extremity (left + width or top + height). Note that it would be more optimized to directly
     * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
     * to create the lookup table. The table ALWAYS contains at least two items: min and max.
     *
     * @param {number[]} timestamps - timestamps sorted from lowest to highest.
     * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min
     * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
     * If 'series', timestamps will be positioned at the same distance from each other. In this
     * case, only timestamps that break the time linearity are registered, meaning that in the
     * best case, all timestamps are linear, the table contains only min and max.
     */


    function buildLookupTable(timestamps, min, max, distribution) {
      if (distribution === 'linear' || !timestamps.length) {
        return [{
          time: min,
          pos: 0
        }, {
          time: max,
          pos: 1
        }];
      }

      var table = [];
      var items = [min];
      var i, ilen, prev, curr, next;

      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];

        if (curr > min && curr < max) {
          items.push(curr);
        }
      }

      items.push(max);

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i]; // only add points that breaks the scale linearity

        if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i / (ilen - 1)
          });
        }
      }

      return table;
    } // @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/


    function lookup(table, key, value) {
      var lo = 0;
      var hi = table.length - 1;
      var mid, i0, i1;

      while (lo >= 0 && lo <= hi) {
        mid = lo + hi >> 1;
        i0 = table[mid - 1] || null;
        i1 = table[mid];

        if (!i0) {
          // given value is outside table (before first item)
          return {
            lo: null,
            hi: i1
          };
        } else if (i1[key] < value) {
          lo = mid + 1;
        } else if (i0[key] > value) {
          hi = mid - 1;
        } else {
          return {
            lo: i0,
            hi: i1
          };
        }
      } // given value is outside table (after last item)


      return {
        lo: i1,
        hi: null
      };
    }
    /**
     * Linearly interpolates the given source `value` using the table items `skey` values and
     * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
     * returns the position for a timestamp equal to 42. If value is out of bounds, values at
     * index [0, 1] or [n - 1, n] are used for the interpolation.
     */


    function interpolate$1(table, skey, sval, tkey) {
      var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)

      var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
      var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
      var span = next[skey] - prev[skey];
      var ratio = span ? (sval - prev[skey]) / span : 0;
      var offset = (next[tkey] - prev[tkey]) * ratio;
      return prev[tkey] + offset;
    }

    function toTimestamp(scale, input) {
      var adapter = scale._adapter;
      var options = scale.options.time;
      var parser = options.parser;
      var format = parser || options.format;
      var value = input;

      if (typeof parser === 'function') {
        value = parser(value);
      } // Only parse if its not a timestamp already


      if (!helpers$1.isFinite(value)) {
        value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);
      }

      if (value !== null) {
        return +value;
      } // Labels are in an incompatible format and no `parser` has been provided.
      // The user might still use the deprecated `format` option for parsing.


      if (!parser && typeof format === 'function') {
        value = format(input); // `format` could return something else than a timestamp, if so, parse it

        if (!helpers$1.isFinite(value)) {
          value = adapter.parse(value);
        }
      }

      return value;
    }

    function parse(scale, input) {
      if (helpers$1.isNullOrUndef(input)) {
        return null;
      }

      var options = scale.options.time;
      var value = toTimestamp(scale, scale.getRightValue(input));

      if (value === null) {
        return value;
      }

      if (options.round) {
        value = +scale._adapter.startOf(value, options.round);
      }

      return value;
    }
    /**
     * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
     * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
     */


    function determineStepSize(min, max, unit, capacity) {
      var range = max - min;
      var interval = INTERVALS[unit];
      var milliseconds = interval.size;
      var steps = interval.steps;
      var i, ilen, factor;

      if (!steps) {
        return Math.ceil(range / (capacity * milliseconds));
      }

      for (i = 0, ilen = steps.length; i < ilen; ++i) {
        factor = steps[i];

        if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
          break;
        }
      }

      return factor;
    }
    /**
     * Figures out what unit results in an appropriate number of auto-generated ticks
     */


    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
      var ilen = UNITS.length;
      var i, interval, factor;

      for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
        interval = INTERVALS[UNITS[i]];
        factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
          return UNITS[i];
        }
      }

      return UNITS[ilen - 1];
    }
    /**
     * Figures out what unit to format a set of ticks with
     */


    function determineUnitForFormatting(scale, ticks, minUnit, min, max) {
      var ilen = UNITS.length;
      var i, unit;

      for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
        unit = UNITS[i];

        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= ticks.length) {
          return unit;
        }
      }

      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }

    function determineMajorUnit(unit) {
      for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
        if (INTERVALS[UNITS[i]].common) {
          return UNITS[i];
        }
      }
    }
    /**
     * Generates a maximum of `capacity` timestamps between min and max, rounded to the
     * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
     * Important: this method can return ticks outside the min and max range, it's the
     * responsibility of the calling code to clamp values if needed.
     */


    function generate(scale, min, max, capacity) {
      var adapter = scale._adapter;
      var options = scale.options;
      var timeOpts = options.time;
      var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
      var major = determineMajorUnit(minor);
      var stepSize = valueOrDefault$c(timeOpts.stepSize, timeOpts.unitStepSize);
      var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
      var majorTicksEnabled = options.ticks.major.enabled;
      var interval = INTERVALS[minor];
      var first = min;
      var last = max;
      var ticks = [];
      var time;

      if (!stepSize) {
        stepSize = determineStepSize(min, max, minor, capacity);
      } // For 'week' unit, handle the first day of week option


      if (weekday) {
        first = +adapter.startOf(first, 'isoWeek', weekday);
        last = +adapter.startOf(last, 'isoWeek', weekday);
      } // Align first/last ticks on unit


      first = +adapter.startOf(first, weekday ? 'day' : minor);
      last = +adapter.startOf(last, weekday ? 'day' : minor); // Make sure that the last tick include max

      if (last < max) {
        last = +adapter.add(last, 1, minor);
      }

      time = first;

      if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
        // Align the first tick on the previous `minor` unit aligned on the `major` unit:
        // we first aligned time on the previous `major` unit then add the number of full
        // stepSize there is between first and the previous major time.
        time = +adapter.startOf(time, major);
        time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
      }

      for (; time < last; time = +adapter.add(time, stepSize, minor)) {
        ticks.push(+time);
      }

      ticks.push(+time);
      return ticks;
    }
    /**
     * Returns the start and end offsets from edges in the form of {start, end}
     * where each value is a relative width to the scale and ranges between 0 and 1.
     * They add extra margins on the both sides by scaling down the original scale.
     * Offsets are added when the `offset` option is true.
     */


    function computeOffsets(table, ticks, min, max, options) {
      var start = 0;
      var end = 0;
      var first, last;

      if (options.offset && ticks.length) {
        if (!options.time.min) {
          first = interpolate$1(table, 'time', ticks[0], 'pos');

          if (ticks.length === 1) {
            start = 1 - first;
          } else {
            start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;
          }
        }

        if (!options.time.max) {
          last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');

          if (ticks.length === 1) {
            end = last;
          } else {
            end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;
          }
        }
      }

      return {
        start: start,
        end: end
      };
    }

    function ticksFromTimestamps(scale, values, majorUnit) {
      var ticks = [];
      var i, ilen, value, major;

      for (i = 0, ilen = values.length; i < ilen; ++i) {
        value = values[i];
        major = majorUnit ? value === +scale._adapter.startOf(value, majorUnit) : false;
        ticks.push({
          value: value,
          major: major
        });
      }

      return ticks;
    }

    var defaultConfig$4 = {
      position: 'bottom',

      /**
       * Data distribution along the scale:
       * - 'linear': data are spread according to their time (distances can vary),
       * - 'series': data are spread at the same distance from each other.
       * @see https://github.com/chartjs/Chart.js/pull/4507
       * @since 2.7.0
       */
      distribution: 'linear',

      /**
       * Scale boundary strategy (bypassed by min/max time options)
       * - `data`: make sure data are fully visible, ticks outside are removed
       * - `ticks`: make sure ticks are fully visible, data outside are truncated
       * @see https://github.com/chartjs/Chart.js/pull/4556
       * @since 2.7.0
       */
      bounds: 'data',
      adapters: {},
      time: {
        parser: false,
        // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
        format: false,
        // DEPRECATED false == date objects, moment object, callback or a pattern string from https://momentjs.com/docs/#/parsing/string-format/
        unit: false,
        // false == automatic or override with week, month, year, etc.
        round: false,
        // none, or override with week, month, year, etc.
        displayFormat: false,
        // DEPRECATED
        isoWeekday: false,
        // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/
        minUnit: 'millisecond',
        displayFormats: {}
      },
      ticks: {
        autoSkip: false,

        /**
         * Ticks generation input values:
         * - 'auto': generates "optimal" ticks based on scale size and time options.
         * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
         * - 'labels': generates ticks from user given `data.labels` values ONLY.
         * @see https://github.com/chartjs/Chart.js/pull/4507
         * @since 2.7.0
         */
        source: 'auto',
        major: {
          enabled: false
        }
      }
    };
    var scale_time = core_scale.extend({
      initialize: function () {
        this.mergeTicksOptions();
        core_scale.prototype.initialize.call(this);
      },
      update: function () {
        var me = this;
        var options = me.options;
        var time = options.time || (options.time = {});
        var adapter = me._adapter = new core_adapters._date(options.adapters.date); // DEPRECATIONS: output a message only one time per update

        if (time.format) {
          console.warn('options.time.format is deprecated and replaced by options.time.parser.');
        } // Backward compatibility: before introducing adapter, `displayFormats` was
        // supposed to contain *all* unit/string pairs but this can't be resolved
        // when loading the scale (adapters are loaded afterward), so let's populate
        // missing formats on update


        helpers$1.mergeIf(time.displayFormats, adapter.formats());
        return core_scale.prototype.update.apply(me, arguments);
      },

      /**
       * Allows data to be referenced via 't' attribute
       */
      getRightValue: function (rawValue) {
        if (rawValue && rawValue.t !== undefined) {
          rawValue = rawValue.t;
        }

        return core_scale.prototype.getRightValue.call(this, rawValue);
      },
      determineDataLimits: function () {
        var me = this;
        var chart = me.chart;
        var adapter = me._adapter;
        var timeOpts = me.options.time;
        var unit = timeOpts.unit || 'day';
        var min = MAX_INTEGER;
        var max = MIN_INTEGER;
        var timestamps = [];
        var datasets = [];
        var labels = [];
        var i, j, ilen, jlen, data, timestamp;
        var dataLabels = chart.data.labels || []; // Convert labels to timestamps

        for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
          labels.push(parse(me, dataLabels[i]));
        } // Convert data to timestamps


        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            data = chart.data.datasets[i].data; // Let's consider that all data have the same format.

            if (helpers$1.isObject(data[0])) {
              datasets[i] = [];

              for (j = 0, jlen = data.length; j < jlen; ++j) {
                timestamp = parse(me, data[j]);
                timestamps.push(timestamp);
                datasets[i][j] = timestamp;
              }
            } else {
              for (j = 0, jlen = labels.length; j < jlen; ++j) {
                timestamps.push(labels[j]);
              }

              datasets[i] = labels.slice(0);
            }
          } else {
            datasets[i] = [];
          }
        }

        if (labels.length) {
          // Sort labels **after** data have been converted
          labels = arrayUnique(labels).sort(sorter);
          min = Math.min(min, labels[0]);
          max = Math.max(max, labels[labels.length - 1]);
        }

        if (timestamps.length) {
          timestamps = arrayUnique(timestamps).sort(sorter);
          min = Math.min(min, timestamps[0]);
          max = Math.max(max, timestamps[timestamps.length - 1]);
        }

        min = parse(me, timeOpts.min) || min;
        max = parse(me, timeOpts.max) || max; // In case there is no valid min/max, set limits based on unit time option

        min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
        max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)

        me.min = Math.min(min, max);
        me.max = Math.max(min + 1, max); // PRIVATE

        me._horizontal = me.isHorizontal();
        me._table = [];
        me._timestamps = {
          data: timestamps,
          datasets: datasets,
          labels: labels
        };
      },
      buildTicks: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        var options = me.options;
        var timeOpts = options.time;
        var timestamps = [];
        var ticks = [];
        var i, ilen, timestamp;

        switch (options.ticks.source) {
          case 'data':
            timestamps = me._timestamps.data;
            break;

          case 'labels':
            timestamps = me._timestamps.labels;
            break;

          case 'auto':
          default:
            timestamps = generate(me, min, max, me.getLabelCapacity(min), options);
        }

        if (options.bounds === 'ticks' && timestamps.length) {
          min = timestamps[0];
          max = timestamps[timestamps.length - 1];
        } // Enforce limits with user min/max options


        min = parse(me, timeOpts.min) || min;
        max = parse(me, timeOpts.max) || max; // Remove ticks outside the min/max range

        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
          timestamp = timestamps[i];

          if (timestamp >= min && timestamp <= max) {
            ticks.push(timestamp);
          }
        }

        me.min = min;
        me.max = max; // PRIVATE

        me._unit = timeOpts.unit || determineUnitForFormatting(me, ticks, timeOpts.minUnit, me.min, me.max);
        me._majorUnit = determineMajorUnit(me._unit);
        me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
        me._offsets = computeOffsets(me._table, ticks, min, max, options);

        if (options.ticks.reverse) {
          ticks.reverse();
        }

        return ticksFromTimestamps(me, ticks, me._majorUnit);
      },
      getLabelForIndex: function (index, datasetIndex) {
        var me = this;
        var adapter = me._adapter;
        var data = me.chart.data;
        var timeOpts = me.options.time;
        var label = data.labels && index < data.labels.length ? data.labels[index] : '';
        var value = data.datasets[datasetIndex].data[index];

        if (helpers$1.isObject(value)) {
          label = me.getRightValue(value);
        }

        if (timeOpts.tooltipFormat) {
          return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
        }

        if (typeof label === 'string') {
          return label;
        }

        return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
      },

      /**
       * Function to format an individual tick mark
       * @private
       */
      tickFormatFunction: function (time, index, ticks, format) {
        var me = this;
        var adapter = me._adapter;
        var options = me.options;
        var formats = options.time.displayFormats;
        var minorFormat = formats[me._unit];
        var majorUnit = me._majorUnit;
        var majorFormat = formats[majorUnit];
        var majorTime = +adapter.startOf(time, majorUnit);
        var majorTickOpts = options.ticks.major;
        var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
        var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
        var tickOpts = major ? majorTickOpts : options.ticks.minor;
        var formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);
        return formatter ? formatter(label, index, ticks) : label;
      },
      convertTicksToLabels: function (ticks) {
        var labels = [];
        var i, ilen;

        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
        }

        return labels;
      },

      /**
       * @private
       */
      getPixelForOffset: function (time) {
        var me = this;
        var isReverse = me.options.ticks.reverse;
        var size = me._horizontal ? me.width : me.height;
        var start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;
        var pos = interpolate$1(me._table, 'time', time, 'pos');
        var offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);
        return isReverse ? start - offset : start + offset;
      },
      getPixelForValue: function (value, index, datasetIndex) {
        var me = this;
        var time = null;

        if (index !== undefined && datasetIndex !== undefined) {
          time = me._timestamps.datasets[datasetIndex][index];
        }

        if (time === null) {
          time = parse(me, value);
        }

        if (time !== null) {
          return me.getPixelForOffset(time);
        }
      },
      getPixelForTick: function (index) {
        var ticks = this.getTicks();
        return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var size = me._horizontal ? me.width : me.height;
        var start = me._horizontal ? me.left : me.top;
        var pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;
        var time = interpolate$1(me._table, 'pos', pos, 'time'); // DEPRECATION, we should return time directly

        return me._adapter._create(time);
      },

      /**
       * Crude approximation of what the label width might be
       * @private
       */
      getLabelWidth: function (label) {
        var me = this;
        var ticksOpts = me.options.ticks;
        var tickLabelWidth = me.ctx.measureText(label).width;
        var angle = helpers$1.toRadians(ticksOpts.maxRotation);
        var cosRotation = Math.cos(angle);
        var sinRotation = Math.sin(angle);
        var tickFontSize = valueOrDefault$c(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
        return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
      },

      /**
       * @private
       */
      getLabelCapacity: function (exampleTime) {
        var me = this; // pick the longest format (milliseconds) for guestimation

        var format = me.options.time.displayFormats.millisecond;
        var exampleLabel = me.tickFormatFunction(exampleTime, 0, [], format);
        var tickLabelWidth = me.getLabelWidth(exampleLabel);
        var innerWidth = me.isHorizontal() ? me.width : me.height;
        var capacity = Math.floor(innerWidth / tickLabelWidth);
        return capacity > 0 ? capacity : 1;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$4 = defaultConfig$4;
    scale_time._defaults = _defaults$4;
    var scales = {
      category: scale_category,
      linear: scale_linear,
      logarithmic: scale_logarithmic,
      radialLinear: scale_radialLinear,
      time: scale_time
    };
    var FORMATS = {
      datetime: 'MMM D, YYYY, h:mm:ss a',
      millisecond: 'h:mm:ss.SSS a',
      second: 'h:mm:ss a',
      minute: 'h:mm a',
      hour: 'hA',
      day: 'MMM D',
      week: 'll',
      month: 'MMM YYYY',
      quarter: '[Q]Q - YYYY',
      year: 'YYYY'
    };

    core_adapters._date.override(typeof moment === 'function' ? {
      _id: 'moment',
      // DEBUG ONLY
      formats: function () {
        return FORMATS;
      },
      parse: function (value, format) {
        if (typeof value === 'string' && typeof format === 'string') {
          value = moment(value, format);
        } else if (!(value instanceof moment)) {
          value = moment(value);
        }

        return value.isValid() ? value.valueOf() : null;
      },
      format: function (time, format) {
        return moment(time).format(format);
      },
      add: function (time, amount, unit) {
        return moment(time).add(amount, unit).valueOf();
      },
      diff: function (max, min, unit) {
        return moment.duration(moment(max).diff(moment(min))).as(unit);
      },
      startOf: function (time, unit, weekday) {
        time = moment(time);

        if (unit === 'isoWeek') {
          return time.isoWeekday(weekday).valueOf();
        }

        return time.startOf(unit).valueOf();
      },
      endOf: function (time, unit) {
        return moment(time).endOf(unit).valueOf();
      },
      // DEPRECATIONS

      /**
       * Provided for backward compatibility with scale.getValueForPixel().
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
      _create: function (time) {
        return moment(time);
      }
    } : {});

    core_defaults._set('global', {
      plugins: {
        filler: {
          propagate: true
        }
      }
    });

    var mappers = {
      dataset: function (source) {
        var index = source.fill;
        var chart = source.chart;
        var meta = chart.getDatasetMeta(index);
        var visible = meta && chart.isDatasetVisible(index);
        var points = visible && meta.dataset._children || [];
        var length = points.length || 0;
        return !length ? null : function (point, i) {
          return i < length && points[i]._view || null;
        };
      },
      boundary: function (source) {
        var boundary = source.boundary;
        var x = boundary ? boundary.x : null;
        var y = boundary ? boundary.y : null;
        return function (point) {
          return {
            x: x === null ? point.x : x,
            y: y === null ? point.y : y
          };
        };
      }
    }; // @todo if (fill[0] === '#')

    function decodeFill(el, index, count) {
      var model = el._model || {};
      var fill = model.fill;
      var target;

      if (fill === undefined) {
        fill = !!model.backgroundColor;
      }

      if (fill === false || fill === null) {
        return false;
      }

      if (fill === true) {
        return 'origin';
      }

      target = parseFloat(fill, 10);

      if (isFinite(target) && Math.floor(target) === target) {
        if (fill[0] === '-' || fill[0] === '+') {
          target = index + target;
        }

        if (target === index || target < 0 || target >= count) {
          return false;
        }

        return target;
      }

      switch (fill) {
        // compatibility
        case 'bottom':
          return 'start';

        case 'top':
          return 'end';

        case 'zero':
          return 'origin';
        // supported boundaries

        case 'origin':
        case 'start':
        case 'end':
          return fill;
        // invalid fill values

        default:
          return false;
      }
    }

    function computeBoundary(source) {
      var model = source.el._model || {};
      var scale = source.el._scale || {};
      var fill = source.fill;
      var target = null;
      var horizontal;

      if (isFinite(fill)) {
        return null;
      } // Backward compatibility: until v3, we still need to support boundary values set on
      // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
      // controllers might still use it (e.g. the Smith chart).


      if (fill === 'start') {
        target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
      } else if (fill === 'end') {
        target = model.scaleTop === undefined ? scale.top : model.scaleTop;
      } else if (model.scaleZero !== undefined) {
        target = model.scaleZero;
      } else if (scale.getBasePosition) {
        target = scale.getBasePosition();
      } else if (scale.getBasePixel) {
        target = scale.getBasePixel();
      }

      if (target !== undefined && target !== null) {
        if (target.x !== undefined && target.y !== undefined) {
          return target;
        }

        if (helpers$1.isFinite(target)) {
          horizontal = scale.isHorizontal();
          return {
            x: horizontal ? target : null,
            y: horizontal ? null : target
          };
        }
      }

      return null;
    }

    function resolveTarget(sources, index, propagate) {
      var source = sources[index];
      var fill = source.fill;
      var visited = [index];
      var target;

      if (!propagate) {
        return fill;
      }

      while (fill !== false && visited.indexOf(fill) === -1) {
        if (!isFinite(fill)) {
          return fill;
        }

        target = sources[fill];

        if (!target) {
          return false;
        }

        if (target.visible) {
          return fill;
        }

        visited.push(fill);
        fill = target.fill;
      }

      return false;
    }

    function createMapper(source) {
      var fill = source.fill;
      var type = 'dataset';

      if (fill === false) {
        return null;
      }

      if (!isFinite(fill)) {
        type = 'boundary';
      }

      return mappers[type](source);
    }

    function isDrawable(point) {
      return point && !point.skip;
    }

    function drawArea(ctx, curve0, curve1, len0, len1) {
      var i;

      if (!len0 || !len1) {
        return;
      } // building first area curve (normal)


      ctx.moveTo(curve0[0].x, curve0[0].y);

      for (i = 1; i < len0; ++i) {
        helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
      } // joining the two area curves


      ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)

      for (i = len1 - 1; i > 0; --i) {
        helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
      }
    }

    function doFill(ctx, points, mapper, view, color, loop) {
      var count = points.length;
      var span = view.spanGaps;
      var curve0 = [];
      var curve1 = [];
      var len0 = 0;
      var len1 = 0;
      var i, ilen, index, p0, p1, d0, d1;
      ctx.beginPath();

      for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
        index = i % count;
        p0 = points[index]._view;
        p1 = mapper(p0, index, view);
        d0 = isDrawable(p0);
        d1 = isDrawable(p1);

        if (d0 && d1) {
          len0 = curve0.push(p0);
          len1 = curve1.push(p1);
        } else if (len0 && len1) {
          if (!span) {
            drawArea(ctx, curve0, curve1, len0, len1);
            len0 = len1 = 0;
            curve0 = [];
            curve1 = [];
          } else {
            if (d0) {
              curve0.push(p0);
            }

            if (d1) {
              curve1.push(p1);
            }
          }
        }
      }

      drawArea(ctx, curve0, curve1, len0, len1);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    var plugin_filler = {
      id: 'filler',
      afterDatasetsUpdate: function (chart, options) {
        var count = (chart.data.datasets || []).length;
        var propagate = options.propagate;
        var sources = [];
        var meta, i, el, source;

        for (i = 0; i < count; ++i) {
          meta = chart.getDatasetMeta(i);
          el = meta.dataset;
          source = null;

          if (el && el._model && el instanceof elements.Line) {
            source = {
              visible: chart.isDatasetVisible(i),
              fill: decodeFill(el, i, count),
              chart: chart,
              el: el
            };
          }

          meta.$filler = source;
          sources.push(source);
        }

        for (i = 0; i < count; ++i) {
          source = sources[i];

          if (!source) {
            continue;
          }

          source.fill = resolveTarget(sources, i, propagate);
          source.boundary = computeBoundary(source);
          source.mapper = createMapper(source);
        }
      },
      beforeDatasetDraw: function (chart, args) {
        var meta = args.meta.$filler;

        if (!meta) {
          return;
        }

        var ctx = chart.ctx;
        var el = meta.el;
        var view = el._view;
        var points = el._children || [];
        var mapper = meta.mapper;
        var color = view.backgroundColor || core_defaults.global.defaultColor;

        if (mapper && color && points.length) {
          helpers$1.canvas.clipArea(ctx, chart.chartArea);
          doFill(ctx, points, mapper, view, color, el._loop);
          helpers$1.canvas.unclipArea(ctx);
        }
      }
    };
    var noop$1 = helpers$1.noop;
    var valueOrDefault$d = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      legend: {
        display: true,
        position: 'top',
        fullWidth: true,
        reverse: false,
        weight: 1000,
        // a callback that will handle
        onClick: function (e, legendItem) {
          var index = legendItem.datasetIndex;
          var ci = this.chart;
          var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment

          meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart

          ci.update();
        },
        onHover: null,
        onLeave: null,
        labels: {
          boxWidth: 40,
          padding: 10,
          // Generates labels shown in the legend
          // Valid properties to return:
          // text : text to display
          // fillStyle : fill of coloured box
          // strokeStyle: stroke of coloured box
          // hidden : if this legend item refers to a hidden item
          // lineCap : cap style for line
          // lineDash
          // lineDashOffset :
          // lineJoin :
          // lineWidth :
          generateLabels: function (chart) {
            var data = chart.data;
            return helpers$1.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
              return {
                text: dataset.label,
                fillStyle: !helpers$1.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
                hidden: !chart.isDatasetVisible(i),
                lineCap: dataset.borderCapStyle,
                lineDash: dataset.borderDash,
                lineDashOffset: dataset.borderDashOffset,
                lineJoin: dataset.borderJoinStyle,
                lineWidth: dataset.borderWidth,
                strokeStyle: dataset.borderColor,
                pointStyle: dataset.pointStyle,
                // Below is extra data used for toggling the datasets
                datasetIndex: i
              };
            }, this) : [];
          }
        }
      },
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');

        for (var i = 0; i < chart.data.datasets.length; i++) {
          text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');

          if (chart.data.datasets[i].label) {
            text.push(chart.data.datasets[i].label);
          }

          text.push('</li>');
        }

        text.push('</ul>');
        return text.join('');
      }
    });
    /**
     * Helper function to get the box width based on the usePointStyle option
     * @param {object} labelopts - the label options on the legend
     * @param {number} fontSize - the label font size
     * @return {number} width of the color box area
     */


    function getBoxWidth(labelOpts, fontSize) {
      return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
    }
    /**
     * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
     */


    var Legend = core_element.extend({
      initialize: function (config) {
        helpers$1.extend(this, config); // Contains hit boxes for each dataset (in dataset order)

        this.legendHitBoxes = [];
        /**
        	 * @private
        	 */

        this._hoveredItem = null; // Are we in doughnut mode which has a different data type

        this.doughnutMode = false;
      },
      // These methods are ordered by lifecycle. Utilities then follow.
      // Any function defined here is inherited by all legend types.
      // Any function can be extended by the legend type
      beforeUpdate: noop$1,
      update: function (maxWidth, maxHeight, margins) {
        var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Labels

        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$1,
      //
      beforeSetDimensions: noop$1,
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0; // Reset minSize

        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$1,
      //
      beforeBuildLabels: noop$1,
      buildLabels: function () {
        var me = this;
        var labelOpts = me.options.labels || {};
        var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];

        if (labelOpts.filter) {
          legendItems = legendItems.filter(function (item) {
            return labelOpts.filter(item, me.chart.data);
          });
        }

        if (me.options.reverse) {
          legendItems.reverse();
        }

        me.legendItems = legendItems;
      },
      afterBuildLabels: noop$1,
      //
      beforeFit: noop$1,
      fit: function () {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var display = opts.display;
        var ctx = me.ctx;

        var labelFont = helpers$1.options._parseFont(labelOpts);

        var fontSize = labelFont.size; // Reset hit boxes

        var hitboxes = me.legendHitBoxes = [];
        var minSize = me.minSize;
        var isHorizontal = me.isHorizontal();

        if (isHorizontal) {
          minSize.width = me.maxWidth; // fill all the width

          minSize.height = display ? 10 : 0;
        } else {
          minSize.width = display ? 10 : 0;
          minSize.height = me.maxHeight; // fill all the height
        } // Increase sizes here


        if (display) {
          ctx.font = labelFont.string;

          if (isHorizontal) {
            // Labels
            // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
            var lineWidths = me.lineWidths = [0];
            var totalHeight = 0;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var boxWidth = getBoxWidth(labelOpts, fontSize);
              var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

              if (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {
                totalHeight += fontSize + labelOpts.padding;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;
              } // Store the hitbox width and height here. Final position will be updated in `draw`


              hitboxes[i] = {
                left: 0,
                top: 0,
                width: width,
                height: fontSize
              };
              lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
            });
            minSize.height += totalHeight;
          } else {
            var vPadding = labelOpts.padding;
            var columnWidths = me.columnWidths = [];
            var totalWidth = labelOpts.padding;
            var currentColWidth = 0;
            var currentColHeight = 0;
            var itemHeight = fontSize + vPadding;
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var boxWidth = getBoxWidth(labelOpts, fontSize);
              var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column

              if (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {
                totalWidth += currentColWidth + labelOpts.padding;
                columnWidths.push(currentColWidth); // previous column width

                currentColWidth = 0;
                currentColHeight = 0;
              } // Get max width


              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`

              hitboxes[i] = {
                left: 0,
                top: 0,
                width: itemWidth,
                height: fontSize
              };
            });
            totalWidth += currentColWidth;
            columnWidths.push(currentColWidth);
            minSize.width += totalWidth;
          }
        }

        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$1,
      // Shared Methods
      isHorizontal: function () {
        return this.options.position === 'top' || this.options.position === 'bottom';
      },
      // Actually draw the legend on the canvas
      draw: function () {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var globalDefaults = core_defaults.global;
        var defaultColor = globalDefaults.defaultColor;
        var lineDefault = globalDefaults.elements.line;
        var legendWidth = me.width;
        var lineWidths = me.lineWidths;

        if (opts.display) {
          var ctx = me.ctx;
          var fontColor = valueOrDefault$d(labelOpts.fontColor, globalDefaults.defaultFontColor);

          var labelFont = helpers$1.options._parseFont(labelOpts);

          var fontSize = labelFont.size;
          var cursor; // Canvas setup

          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.lineWidth = 0.5;
          ctx.strokeStyle = fontColor; // for strikethrough effect

          ctx.fillStyle = fontColor; // render in correct colour

          ctx.font = labelFont.string;
          var boxWidth = getBoxWidth(labelOpts, fontSize);
          var hitboxes = me.legendHitBoxes; // current position

          var drawLegendBox = function (x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0) {
              return;
            } // Set the ctx for the box


            ctx.save();
            var lineWidth = valueOrDefault$d(legendItem.lineWidth, lineDefault.borderWidth);
            ctx.fillStyle = valueOrDefault$d(legendItem.fillStyle, defaultColor);
            ctx.lineCap = valueOrDefault$d(legendItem.lineCap, lineDefault.borderCapStyle);
            ctx.lineDashOffset = valueOrDefault$d(legendItem.lineDashOffset, lineDefault.borderDashOffset);
            ctx.lineJoin = valueOrDefault$d(legendItem.lineJoin, lineDefault.borderJoinStyle);
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = valueOrDefault$d(legendItem.strokeStyle, defaultColor);

            if (ctx.setLineDash) {
              // IE 9 and 10 do not support line dash
              ctx.setLineDash(valueOrDefault$d(legendItem.lineDash, lineDefault.borderDash));
            }

            if (opts.labels && opts.labels.usePointStyle) {
              // Recalculate x and y for drawPoint() because its expecting
              // x and y to be center of figure (instead of top left)
              var radius = boxWidth * Math.SQRT2 / 2;
              var centerX = x + boxWidth / 2;
              var centerY = y + fontSize / 2; // Draw pointStyle as legend symbol

              helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
            } else {
              // Draw box as legend symbol
              if (lineWidth !== 0) {
                ctx.strokeRect(x, y, boxWidth, fontSize);
              }

              ctx.fillRect(x, y, boxWidth, fontSize);
            }

            ctx.restore();
          };

          var fillText = function (x, y, legendItem, textWidth) {
            var halfFontSize = fontSize / 2;
            var xLeft = boxWidth + halfFontSize + x;
            var yMiddle = y + halfFontSize;
            ctx.fillText(legendItem.text, xLeft, yMiddle);

            if (legendItem.hidden) {
              // Strikethrough the text if hidden
              ctx.beginPath();
              ctx.lineWidth = 2;
              ctx.moveTo(xLeft, yMiddle);
              ctx.lineTo(xLeft + textWidth, yMiddle);
              ctx.stroke();
            }
          }; // Horizontal


          var isHorizontal = me.isHorizontal();

          if (isHorizontal) {
            cursor = {
              x: me.left + (legendWidth - lineWidths[0]) / 2 + labelOpts.padding,
              y: me.top + labelOpts.padding,
              line: 0
            };
          } else {
            cursor = {
              x: me.left + labelOpts.padding,
              y: me.top + labelOpts.padding,
              line: 0
            };
          }

          var itemHeight = fontSize + labelOpts.padding;
          helpers$1.each(me.legendItems, function (legendItem, i) {
            var textWidth = ctx.measureText(legendItem.text).width;
            var width = boxWidth + fontSize / 2 + textWidth;
            var x = cursor.x;
            var y = cursor.y; // Use (me.left + me.minSize.width) and (me.top + me.minSize.height)
            // instead of me.right and me.bottom because me.width and me.height
            // may have been changed since me.minSize was calculated

            if (isHorizontal) {
              if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                y = cursor.y += itemHeight;
                cursor.line++;
                x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2 + labelOpts.padding;
              }
            } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
              x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
              y = cursor.y = me.top + labelOpts.padding;
              cursor.line++;
            }

            drawLegendBox(x, y, legendItem);
            hitboxes[i].left = x;
            hitboxes[i].top = y; // Fill the actual label

            fillText(x, y, legendItem, textWidth);

            if (isHorizontal) {
              cursor.x += width + labelOpts.padding;
            } else {
              cursor.y += itemHeight;
            }
          });
        }
      },

      /**
       * @private
       */
      _getLegendItemAt: function (x, y) {
        var me = this;
        var i, hitBox, lh;

        if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
          // See if we are touching one of the dataset boxes
          lh = me.legendHitBoxes;

          for (i = 0; i < lh.length; ++i) {
            hitBox = lh[i];

            if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
              // Touching an element
              return me.legendItems[i];
            }
          }
        }

        return null;
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event - The event to handle
       */
      handleEvent: function (e) {
        var me = this;
        var opts = me.options;
        var type = e.type === 'mouseup' ? 'click' : e.type;
        var hoveredItem;

        if (type === 'mousemove') {
          if (!opts.onHover && !opts.onLeave) {
            return;
          }
        } else if (type === 'click') {
          if (!opts.onClick) {
            return;
          }
        } else {
          return;
        } // Chart event already has relative position in it


        hoveredItem = me._getLegendItemAt(e.x, e.y);

        if (type === 'click') {
          if (hoveredItem && opts.onClick) {
            // use e.native for backwards compatibility
            opts.onClick.call(me, e.native, hoveredItem);
          }
        } else {
          if (opts.onLeave && hoveredItem !== me._hoveredItem) {
            if (me._hoveredItem) {
              opts.onLeave.call(me, e.native, me._hoveredItem);
            }

            me._hoveredItem = hoveredItem;
          }

          if (opts.onHover && hoveredItem) {
            // use e.native for backwards compatibility
            opts.onHover.call(me, e.native, hoveredItem);
          }
        }
      }
    });

    function createNewLegendAndAttach(chart, legendOpts) {
      var legend = new Legend({
        ctx: chart.ctx,
        options: legendOpts,
        chart: chart
      });
      core_layouts.configure(chart, legend, legendOpts);
      core_layouts.addBox(chart, legend);
      chart.legend = legend;
    }

    var plugin_legend = {
      id: 'legend',

      /**
       * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
       * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
       * the plugin, which one will be re-exposed in the chart.js file.
       * https://github.com/chartjs/Chart.js/pull/2640
       * @private
       */
      _element: Legend,
      beforeInit: function (chart) {
        var legendOpts = chart.options.legend;

        if (legendOpts) {
          createNewLegendAndAttach(chart, legendOpts);
        }
      },
      beforeUpdate: function (chart) {
        var legendOpts = chart.options.legend;
        var legend = chart.legend;

        if (legendOpts) {
          helpers$1.mergeIf(legendOpts, core_defaults.global.legend);

          if (legend) {
            core_layouts.configure(chart, legend, legendOpts);
            legend.options = legendOpts;
          } else {
            createNewLegendAndAttach(chart, legendOpts);
          }
        } else if (legend) {
          core_layouts.removeBox(chart, legend);
          delete chart.legend;
        }
      },
      afterEvent: function (chart, e) {
        var legend = chart.legend;

        if (legend) {
          legend.handleEvent(e);
        }
      }
    };
    var noop$2 = helpers$1.noop;

    core_defaults._set('global', {
      title: {
        display: false,
        fontStyle: 'bold',
        fullWidth: true,
        padding: 10,
        position: 'top',
        text: '',
        weight: 2000 // by default greater than legend (1000) to be above

      }
    });
    /**
     * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
     */


    var Title = core_element.extend({
      initialize: function (config) {
        var me = this;
        helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)

        me.legendHitBoxes = [];
      },
      // These methods are ordered by lifecycle. Utilities then follow.
      beforeUpdate: noop$2,
      update: function (maxWidth, maxHeight, margins) {
        var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Labels

        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$2,
      //
      beforeSetDimensions: noop$2,
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0; // Reset minSize

        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$2,
      //
      beforeBuildLabels: noop$2,
      buildLabels: noop$2,
      afterBuildLabels: noop$2,
      //
      beforeFit: noop$2,
      fit: function () {
        var me = this;
        var opts = me.options;
        var display = opts.display;
        var minSize = me.minSize;
        var lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;

        var fontOpts = helpers$1.options._parseFont(opts);

        var textSize = display ? lineCount * fontOpts.lineHeight + opts.padding * 2 : 0;

        if (me.isHorizontal()) {
          minSize.width = me.maxWidth; // fill all the width

          minSize.height = textSize;
        } else {
          minSize.width = textSize;
          minSize.height = me.maxHeight; // fill all the height
        }

        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$2,
      // Shared Methods
      isHorizontal: function () {
        var pos = this.options.position;
        return pos === 'top' || pos === 'bottom';
      },
      // Actually draw the title block on the canvas
      draw: function () {
        var me = this;
        var ctx = me.ctx;
        var opts = me.options;

        if (opts.display) {
          var fontOpts = helpers$1.options._parseFont(opts);

          var lineHeight = fontOpts.lineHeight;
          var offset = lineHeight / 2 + opts.padding;
          var rotation = 0;
          var top = me.top;
          var left = me.left;
          var bottom = me.bottom;
          var right = me.right;
          var maxWidth, titleX, titleY;
          ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour

          ctx.font = fontOpts.string; // Horizontal

          if (me.isHorizontal()) {
            titleX = left + (right - left) / 2; // midpoint of the width

            titleY = top + offset;
            maxWidth = right - left;
          } else {
            titleX = opts.position === 'left' ? left + offset : right - offset;
            titleY = top + (bottom - top) / 2;
            maxWidth = bottom - top;
            rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
          }

          ctx.save();
          ctx.translate(titleX, titleY);
          ctx.rotate(rotation);
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          var text = opts.text;

          if (helpers$1.isArray(text)) {
            var y = 0;

            for (var i = 0; i < text.length; ++i) {
              ctx.fillText(text[i], 0, y, maxWidth);
              y += lineHeight;
            }
          } else {
            ctx.fillText(text, 0, 0, maxWidth);
          }

          ctx.restore();
        }
      }
    });

    function createNewTitleBlockAndAttach(chart, titleOpts) {
      var title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart: chart
      });
      core_layouts.configure(chart, title, titleOpts);
      core_layouts.addBox(chart, title);
      chart.titleBlock = title;
    }

    var plugin_title = {
      id: 'title',

      /**
       * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
       * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
       * the plugin, which one will be re-exposed in the chart.js file.
       * https://github.com/chartjs/Chart.js/pull/2640
       * @private
       */
      _element: Title,
      beforeInit: function (chart) {
        var titleOpts = chart.options.title;

        if (titleOpts) {
          createNewTitleBlockAndAttach(chart, titleOpts);
        }
      },
      beforeUpdate: function (chart) {
        var titleOpts = chart.options.title;
        var titleBlock = chart.titleBlock;

        if (titleOpts) {
          helpers$1.mergeIf(titleOpts, core_defaults.global.title);

          if (titleBlock) {
            core_layouts.configure(chart, titleBlock, titleOpts);
            titleBlock.options = titleOpts;
          } else {
            createNewTitleBlockAndAttach(chart, titleOpts);
          }
        } else if (titleBlock) {
          core_layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
        }
      }
    };
    var plugins = {};
    var filler = plugin_filler;
    var legend = plugin_legend;
    var title = plugin_title;
    plugins.filler = filler;
    plugins.legend = legend;
    plugins.title = title;
    /**
     * @namespace Chart
     */

    core_controller.helpers = helpers$1; // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!

    core_helpers(core_controller);
    core_controller._adapters = core_adapters;
    core_controller.Animation = core_animation;
    core_controller.animationService = core_animations;
    core_controller.controllers = controllers;
    core_controller.DatasetController = core_datasetController;
    core_controller.defaults = core_defaults;
    core_controller.Element = core_element;
    core_controller.elements = elements;
    core_controller.Interaction = core_interaction;
    core_controller.layouts = core_layouts;
    core_controller.platform = platform;
    core_controller.plugins = core_plugins;
    core_controller.Scale = core_scale;
    core_controller.scaleService = core_scaleService;
    core_controller.Ticks = core_ticks;
    core_controller.Tooltip = core_tooltip; // Register built-in scales

    core_controller.helpers.each(scales, function (scale, type) {
      core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
    }); // Load to register built-in adapters (as side effects)
    // Loading built-in plugins

    for (var k in plugins) {
      if (plugins.hasOwnProperty(k)) {
        core_controller.plugins.register(plugins[k]);
      }
    }

    core_controller.platform.initialize();
    var src = core_controller;

    if (typeof window !== 'undefined') {
      window.Chart = core_controller;
    } // DEPRECATIONS

    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Chart
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */


    core_controller.Chart = core_controller;
    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Legend
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.Legend = plugins.legend._element;
    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Title
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.Title = plugins.title._element;
    /**
     * Provided for backward compatibility, use Chart.plugins instead
     * @namespace Chart.pluginService
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.pluginService = core_controller.plugins;
    /**
     * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
     * effect, instead simply create/register plugins via plain JavaScript objects.
     * @interface Chart.PluginBase
     * @deprecated since version 2.5.0
     * @todo remove at version 3
     * @private
     */

    core_controller.PluginBase = core_controller.Element.extend({});
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas instead.
     * @namespace Chart.canvasHelpers
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    core_controller.canvasHelpers = core_controller.helpers.canvas;
    /**
     * Provided for backward compatibility, use Chart.layouts instead.
     * @namespace Chart.layoutService
     * @deprecated since version 2.7.3
     * @todo remove at version 3
     * @private
     */

    core_controller.layoutService = core_controller.layouts;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.LinearScaleBase
     * @deprecated since version 2.8
     * @todo remove at version 3
     * @private
     */

    core_controller.LinearScaleBase = scale_linearbase;
    /**
     * Provided for backward compatibility, instead we should create a new Chart
     * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     */

    core_controller.helpers.each(['Bar', 'Bubble', 'Doughnut', 'Line', 'PolarArea', 'Radar', 'Scatter'], function (klass) {
      core_controller[klass] = function (ctx, cfg) {
        return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
          type: klass.charAt(0).toLowerCase() + klass.slice(1)
        }));
      };
    });
    return src;
  });
});

function generateChart(chartId, chartType) {
  return {
    render: function render(createElement) {
      return createElement('div', {
        style: this.styles,
        class: this.cssClasses
      }, [createElement('canvas', {
        attrs: {
          id: this.chartId,
          width: this.width,
          height: this.height
        },
        ref: 'canvas'
      })]);
    },
    props: {
      chartId: {
        default: chartId,
        type: String
      },
      width: {
        default: 400,
        type: Number
      },
      height: {
        default: 400,
        type: Number
      },
      cssClasses: {
        type: String,
        default: ''
      },
      styles: {
        type: Object
      },
      plugins: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    data: function data() {
      return {
        _chart: null,
        _plugins: this.plugins
      };
    },
    methods: {
      addPlugin: function addPlugin(plugin) {
        this.$data._plugins.push(plugin);
      },
      generateLegend: function generateLegend() {
        if (this.$data._chart) {
          return this.$data._chart.generateLegend();
        }
      },
      renderChart: function renderChart(data, options) {
        if (this.$data._chart) {
          this.$data._chart.destroy();
        }

        this.$data._chart = new Chart$1(this.$refs.canvas.getContext('2d'), {
          type: chartType,
          data: data,
          options: options,
          plugins: this.$data._plugins
        });
      }
    },
    beforeDestroy: function beforeDestroy() {
      if (this.$data._chart) {
        this.$data._chart.destroy();
      }
    }
  };
}
var Bar = generateChart('bar-chart', 'bar');
var HorizontalBar = generateChart('horizontalbar-chart', 'horizontalBar');
var Line = generateChart('line-chart', 'line');
var Pie = generateChart('pie-chart', 'pie');

var reactiveProp$1 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$1 = {
  "extends": Bar,
  mixins: [reactiveProp$1],
  props: {
    options: {
      type: Object,
      "default": function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$1 = script$1;

/* template */

  /* style */
  var __vue_inject_styles__$1 = undefined;
  /* scoped */
  var __vue_scope_id__$1 = undefined;
  /* module identifier */
  var __vue_module_identifier__$1 = undefined;
  /* functional template */
  var __vue_is_functional_template__$1 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent = normalizeComponent_1(
    {},
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1,
    __vue_module_identifier__$1,
    undefined,
    undefined
  );

var chartLabels = ['1980', '1990', '2000', '2010', '2020'];
var chartDataList = [6542564, 7322564, 8008278, 8175133, 5475133];
var ChartData = {
  data: {
    labels: chartLabels,
    datasets: [{
      data: chartDataList,
      fill: false,
      // used by line chart
      backgroundColor: ['#2F334F', '#3155A6', '#F2695D', '#EBBCD8', '#F9A137'],
      borderColor: ['#ACAEB9'],
      borderWidth: 1
    }]
  },
  bar: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: false
      },
      lineTension: 1,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Years'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Population'
          },
          ticks: {
            padding: 25
          }
        }]
      }
    }
  },
  horizontalBar: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: false
      },
      lineTension: 1,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Population'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Years'
          },
          ticks: {
            padding: 25
          }
        }]
      }
    }
  },
  pie: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: true
      },
      lineTension: 1
    }
  }
};

var chartType = 'bar';

var ChartBar = function ChartBar(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartBar.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType, ChartComponent);
  new Vue({
    el: "[data-js=\"chart-" + chartType + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.bar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartBar.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$2 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$2 = {
  "extends": HorizontalBar,
  mixins: [reactiveProp$2],
  props: {
    options: {
      type: Object,
      "default": function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$2 = script$2;

/* template */

  /* style */
  var __vue_inject_styles__$2 = undefined;
  /* scoped */
  var __vue_scope_id__$2 = undefined;
  /* module identifier */
  var __vue_module_identifier__$2 = undefined;
  /* functional template */
  var __vue_is_functional_template__$2 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$1 = normalizeComponent_1(
    {},
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2,
    __vue_module_identifier__$2,
    undefined,
    undefined
  );

var chartType$1 = 'horizontal-bar';

var ChartHorizontalBar = function ChartHorizontalBar(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartHorizontalBar.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$1, ChartComponent$1);
  new Vue({
    el: "[data-js=\"chart-" + chartType$1 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.horizontalBar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartHorizontalBar.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$3 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$3 = {
  "extends": Line,
  mixins: [reactiveProp$3],
  props: {
    options: {
      type: Object,
      "default": function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$3 = script$3;

/* template */

  /* style */
  var __vue_inject_styles__$3 = undefined;
  /* scoped */
  var __vue_scope_id__$3 = undefined;
  /* module identifier */
  var __vue_module_identifier__$3 = undefined;
  /* functional template */
  var __vue_is_functional_template__$3 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$2 = normalizeComponent_1(
    {},
    __vue_inject_styles__$3,
    __vue_script__$3,
    __vue_scope_id__$3,
    __vue_is_functional_template__$3,
    __vue_module_identifier__$3,
    undefined,
    undefined
  );

var chartType$2 = 'line';

var ChartLine = function ChartLine(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartLine.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$2, ChartComponent$2);
  new Vue({
    el: "[data-js=\"chart-" + chartType$2 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.bar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartLine.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$4 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$4 = {
  "extends": Pie,
  mixins: [reactiveProp$4],
  props: {
    options: {
      type: Object,
      "default": function default$1() {
        return {
          legend: {
            display: true
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$4 = script$4;

/* template */

  /* style */
  var __vue_inject_styles__$4 = undefined;
  /* scoped */
  var __vue_scope_id__$4 = undefined;
  /* module identifier */
  var __vue_module_identifier__$4 = undefined;
  /* functional template */
  var __vue_is_functional_template__$4 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$3 = normalizeComponent_1(
    {},
    __vue_inject_styles__$4,
    __vue_script__$4,
    __vue_scope_id__$4,
    __vue_is_functional_template__$4,
    __vue_module_identifier__$4,
    undefined,
    undefined
  );

var chartType$3 = 'pie';

var ChartPie = function ChartPie(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartPie.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$3, ChartComponent$3);
  new Vue({
    el: "[data-js=\"chart-" + chartType$3 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.pie.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartPie.prototype._constants = function _constants(param) {
  console.dir(param);
};

/** import modules here as they are written */

/**
 * Methods for the global NycoPatterns instance
 */

var nyco = function nyco() {};

nyco.prototype.icons = function icons(path) {
  return new Icons(path);
};
/**
 * Method for the Feed Object
 * @param {Object}settingsSetting for the feed
 * @return{Object}          Feed instance
 */


nyco.prototype.feed = function feed(settings) {
  return new Feed(settings);
};
/**
 * Method for the Toggle Utility
 * @return{Object} Toggle instance
 */


nyco.prototype.toggle = function toggle(settings) {
  return new Toggle();
};
/**
 * Method for the Track Module
 * @return{Object} Track Module
 */


nyco.prototype.track = function track(settings) {
  return new Track();
};

nyco.prototype.select = function select() {
  return new Select();
};
/**
 * Method for the Chart Objects
 * @return{Object} Chart instance
 */


nyco.prototype.chart = function chart(type) {
  if (type === 'bar') {
    return new ChartBar();
  }

  if (type === 'horizontalBar') {
    return new ChartHorizontalBar();
  }

  if (type === 'line') {
    return new ChartLine();
  }

  if (type === 'pie') {
    return new ChartPie();
  }
};

module.exports = nyco;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTnljb1BhdHRlcm5zLmNvbW1vbi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2pzL21vZHVsZXMvdXRpbGl0eS5qcyIsIi4uLy4uL3NyYy9lbGVtZW50cy9pY29ucy9JY29ucy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc01hc2tlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvU291cmNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VmFsdWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXROYXRpdmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NpZ25WYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlPYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXBwbHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyUmVzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY29uc3RhbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaG9ydE91dC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFRvU3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJlc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUFzc2lnbmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5c0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Fzc2lnbkluV2l0aC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRXJyb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2F0dGVtcHQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXNjYXBlU3RyaW5nQ2hhci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlSW50ZXJwb2xhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUHJvcGVydHlPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZUh0bWxDaGFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUb1N0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VzY2FwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlRXNjYXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVFdmFsdWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGVTZXR0aW5ncy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUVhY2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUZvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGb3JPd24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRWFjaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdEZ1bmN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9mb3JFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlQ2xlYXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NvY0luZGV4T2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19MaXN0Q2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0NsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlQ3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaENsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0hhc2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXlhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TWFwRGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwQ2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja1NldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N0YWNrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzaWduTWVyZ2VWYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fVWludDhBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVR5cGVkQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQ3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lT2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZU9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NhZmVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWVyZ2VEZWVwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1lcmdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9tZXJnZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0Q2FjaGVBZGQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1NldENhY2hlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTb21lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEFycmF5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcFRvQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRUb0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxCeVRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5UHVzaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlGaWx0ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFN5bWJvbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxPYmplY3RzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fRGF0YVZpZXcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19Qcm9taXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fV2Vha01hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTWF0Y2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1N0cmljdENvbXBhcmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXRjaERhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNYXRjaGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21lbW9pemUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tZW1vaXplQ2FwcGVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaW5nVG9QYXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdFBhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b0tleS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VIYXNJbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc1BhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2hhc0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3Byb3BlcnR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUl0ZXJhdGVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTb3J0QnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb21wYXJlQXNjZW5kaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29tcGFyZU11bHRpcGxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU9yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL29yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRmluZEluZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmFOLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaWN0SW5kZXhPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub29wLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlU2V0LmpzIiwiLi4vLi4vc3JjL29iamVjdHMvZmVlZC9GZWVkLmpzIiwiLi4vLi4vc3JjL3V0aWxpdGllcy90b2dnbGUvVG9nZ2xlLmpzIiwiLi4vLi4vc3JjL3V0aWxpdGllcy90cmFjay9UcmFjay5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLmJyb3dzZXIuanMiLCIuLi8uLi9zcmMvZWxlbWVudHMvc2VsZWN0L3NlbGVjdC52dWUiLCIuLi8uLi9zcmMvZWxlbWVudHMvc2VsZWN0L3NlbGVjdC5kYXRhLmpzIiwiLi4vLi4vc3JjL2VsZW1lbnRzL3NlbGVjdC9zZWxlY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWNoYXJ0anMvZXMvbWl4aW5zL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9DaGFydC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUtY2hhcnRqcy9lcy9CYXNlQ2hhcnRzLmpzIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1iYXIudnVlIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LmRhdGEuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWJhci5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0taG9yaXpvbnRhbC1iYXIudnVlIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1ob3Jpem9udGFsLWJhci5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0tbGluZS52dWUiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWxpbmUuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLXBpZS52dWUiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLXBpZS5qcyIsIi4uLy4uL3NyYy9qcy9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgVXRpbGl0eSBjbGFzc1xuICogQGNsYXNzXG4gKi9cbmNsYXNzIFV0aWxpdHkge1xuICAvKipcbiAgICogVGhlIFV0aWxpdHkgY29uc3RydWN0b3JcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgVXRpbGl0eSBjbGFzc1xuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLyoqXG4gKiBCb29sZWFuIGZvciBkZWJ1ZyBtb2RlXG4gKiBAcmV0dXJuIHtib29sZWFufSB3ZXRoZXIgb3Igbm90IHRoZSBmcm9udC1lbmQgaXMgaW4gZGVidWcgbW9kZS5cbiAqL1xuVXRpbGl0eS5kZWJ1ZyA9ICgpID0+IChVdGlsaXR5LmdldFVybFBhcmFtZXRlcihVdGlsaXR5LlBBUkFNUy5ERUJVRykgPT09ICcxJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBnaXZlbiBrZXkgaW4gYSBVUkwgcXVlcnkgc3RyaW5nLiBJZiBubyBVUkwgcXVlcnlcbiAqIHN0cmluZyBpcyBwcm92aWRlZCwgdGhlIGN1cnJlbnQgVVJMIGxvY2F0aW9uIGlzIHVzZWQuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lICAgICAgICAtIEtleSBuYW1lLlxuICogQHBhcmFtICB7P3N0cmluZ30gcXVlcnlTdHJpbmcgLSBPcHRpb25hbCBxdWVyeSBzdHJpbmcgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBRdWVyeSBwYXJhbWV0ZXIgdmFsdWUuXG4gKi9cblV0aWxpdHkuZ2V0VXJsUGFyYW1ldGVyID0gKG5hbWUsIHF1ZXJ5U3RyaW5nKSA9PiB7XG4gIGNvbnN0IHF1ZXJ5ID0gcXVlcnlTdHJpbmcgfHwgd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcbiAgY29uc3QgcGFyYW0gPSBuYW1lLnJlcGxhY2UoL1tcXFtdLywgJ1xcXFxbJykucmVwbGFjZSgvW1xcXV0vLCAnXFxcXF0nKTtcbiAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKCdbXFxcXD8mXScgKyBwYXJhbSArICc9KFteJiNdKiknKTtcbiAgY29uc3QgcmVzdWx0cyA9IHJlZ2V4LmV4ZWMocXVlcnkpO1xuXG4gIHJldHVybiByZXN1bHRzID09PSBudWxsID8gJycgOlxuICAgIGRlY29kZVVSSUNvbXBvbmVudChyZXN1bHRzWzFdLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbn07XG5cbi8qKlxuICogRm9yIHRyYW5zbGF0aW5nIHN0cmluZ3MsIHRoZXJlIGlzIGEgZ2xvYmFsIExPQ0FMSVpFRF9TVFJJTkdTIGFycmF5IHRoYXRcbiAqIGlzIGRlZmluZWQgb24gdGhlIEhUTUwgdGVtcGxhdGUgbGV2ZWwgc28gdGhhdCB0aG9zZSBzdHJpbmdzIGFyZSBleHBvc2VkIHRvXG4gKiBXUE1MIHRyYW5zbGF0aW9uLiBUaGUgTE9DQUxJWkVEX1NUUklOR1MgYXJyYXkgaXMgY29tcG9zZWQgb2Ygb2JqZWN0cyB3aXRoIGFcbiAqIGBzbHVnYCBrZXkgd2hvc2UgdmFsdWUgaXMgc29tZSBjb25zdGFudCwgYW5kIGEgYGxhYmVsYCB2YWx1ZSB3aGljaCBpcyB0aGVcbiAqIHRyYW5zbGF0ZWQgZXF1aXZhbGVudC4gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIHNsdWcgbmFtZSBhbmQgcmV0dXJucyB0aGVcbiAqIGxhYmVsLlxuICogQHBhcmFtICB7c3RyaW5nfSBzbHVnXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGxvY2FsaXplZCB2YWx1ZVxuICovXG5VdGlsaXR5LmxvY2FsaXplID0gZnVuY3Rpb24oc2x1Zykge1xuICBsZXQgdGV4dCA9IHNsdWcgfHwgJyc7XG4gIGNvbnN0IHN0cmluZ3MgPSB3aW5kb3cuTE9DQUxJWkVEX1NUUklOR1MgfHwgW107XG4gIGNvbnN0IG1hdGNoID0gc3RyaW5ncy5maWx0ZXIoXG4gICAgKHMpID0+IChzLmhhc093blByb3BlcnR5KCdzbHVnJykgJiYgc1snc2x1ZyddID09PSBzbHVnKSA/IHMgOiBmYWxzZVxuICApO1xuICByZXR1cm4gKG1hdGNoWzBdICYmIG1hdGNoWzBdLmhhc093blByb3BlcnR5KCdsYWJlbCcpKSA/IG1hdGNoWzBdLmxhYmVsIDogdGV4dDtcbn07XG5cbi8qKlxuICogQXBwbGljYXRpb24gcGFyYW1ldGVyc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuVXRpbGl0eS5QQVJBTVMgPSB7XG4gIERFQlVHOiAnZGVidWcnXG59O1xuXG4vKipcbiAqIFNlbGVjdG9ycyBmb3IgdGhlIFV0aWxpdHkgbW9kdWxlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5VdGlsaXR5LlNFTEVDVE9SUyA9IHtcbiAgcGFyc2VNYXJrZG93bjogJ1tkYXRhLWpzPVwibWFya2Rvd25cIl0nXG59O1xuXG5leHBvcnQgZGVmYXVsdCBVdGlsaXR5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVXRpbGl0eSBmcm9tICcuLi8uLi9qcy9tb2R1bGVzL3V0aWxpdHknO1xuXG4vKipcbiAqIFRoZSBJY29uIG1vZHVsZVxuICogQGNsYXNzXG4gKi9cbmNsYXNzIEljb25zIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIGljb24gZmlsZVxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBjbGFzc1xuICAgKi9cbiAgY29uc3RydWN0b3IocGF0aCkge1xuICAgIHBhdGggPSAocGF0aCkgPyBwYXRoIDogSWNvbnMucGF0aDtcblxuICAgIGZldGNoKHBhdGgpXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKVxuICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKHJlc3BvbnNlKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKGVycm9yKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBzcHJpdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc3ByaXRlLmlubmVySFRNTCA9IGRhdGE7XG4gICAgICAgIHNwcml0ZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gICAgICAgIHNwcml0ZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ByaXRlKTtcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBwYXRoIG9mIHRoZSBpY29uIGZpbGUgKi9cbkljb25zLnBhdGggPSAnaWNvbnMuc3ZnJztcblxuZXhwb3J0IGRlZmF1bHQgSWNvbnM7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRnVuY3Rpb247XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZUpzRGF0YTtcbiIsImltcG9ydCBjb3JlSnNEYXRhIGZyb20gJy4vX2NvcmVKc0RhdGEuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Tb3VyY2U7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTWFza2VkIGZyb20gJy4vX2lzTWFza2VkLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hdGl2ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRWYWx1ZTtcbiIsImltcG9ydCBiYXNlSXNOYXRpdmUgZnJvbSAnLi9fYmFzZUlzTmF0aXZlLmpzJztcbmltcG9ydCBnZXRWYWx1ZSBmcm9tICcuL19nZXRWYWx1ZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE5hdGl2ZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZVByb3BlcnR5O1xuIiwiaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZVByb3BlcnR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUFzc2lnblZhbHVlO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxO1xuIiwiaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ25WYWx1ZTtcbiIsImltcG9ydCBhc3NpZ25WYWx1ZSBmcm9tICcuL19hc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5T2JqZWN0O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaWRlbnRpdHk7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFwcGx5O1xuIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlclJlc3Q7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29uc3RhbnQ7XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSAnLi9jb25zdGFudC5qcyc7XG5pbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSAnLi9fZGVmaW5lUHJvcGVydHkuanMnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaG9ydE91dDtcbiIsImltcG9ydCBiYXNlU2V0VG9TdHJpbmcgZnJvbSAnLi9fYmFzZVNldFRvU3RyaW5nLmpzJztcbmltcG9ydCBzaG9ydE91dCBmcm9tICcuL19zaG9ydE91dC5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbmV4cG9ydCBkZWZhdWx0IHNldFRvU3RyaW5nO1xuIiwiaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IG92ZXJSZXN0IGZyb20gJy4vX292ZXJSZXN0LmpzJztcbmltcG9ydCBzZXRUb1N0cmluZyBmcm9tICcuL19zZXRUb1N0cmluZy5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUmVzdDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNMZW5ndGg7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2U7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSW5kZXg7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0l0ZXJhdGVlQ2FsbDtcbiIsImltcG9ydCBiYXNlUmVzdCBmcm9tICcuL19iYXNlUmVzdC5qcyc7XG5pbXBvcnQgaXNJdGVyYXRlZUNhbGwgZnJvbSAnLi9faXNJdGVyYXRlZUNhbGwuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVBc3NpZ25lcjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUaW1lcztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdExpa2U7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNBcmd1bWVudHM7XG4iLCJpbXBvcnQgYmFzZUlzQXJndW1lbnRzIGZyb20gJy4vX2Jhc2VJc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuaW1wb3J0IHN0dWJGYWxzZSBmcm9tICcuL3N0dWJGYWxzZS5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCdWZmZXI7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VVbmFyeTtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBub2RlVXRpbDtcbiIsImltcG9ydCBiYXNlSXNUeXBlZEFycmF5IGZyb20gJy4vX2Jhc2VJc1R5cGVkQXJyYXkuanMnO1xuaW1wb3J0IGJhc2VVbmFyeSBmcm9tICcuL19iYXNlVW5hcnkuanMnO1xuaW1wb3J0IG5vZGVVdGlsIGZyb20gJy4vX25vZGVVdGlsLmpzJztcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzVHlwZWRBcnJheTtcbiIsImltcG9ydCBiYXNlVGltZXMgZnJvbSAnLi9fYmFzZVRpbWVzLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TGlrZUtleXM7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJvdG90eXBlO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXNJbjtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5c0luIGZyb20gJy4vX25hdGl2ZUtleXNJbi5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzSW47XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5c0luIGZyb20gJy4vX2Jhc2VLZXlzSW4uanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5c0luO1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuaW1wb3J0IGtleXNJbiBmcm9tICcuL2tleXNJbi5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGFsaWFzIGV4dGVuZFdpdGhcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICogfVxuICpcbiAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAqXG4gKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ25JbldpdGg7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0UHJvdG90eXBlO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1BsYWluT2JqZWN0O1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJy4vaXNQbGFpbk9iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBkb21FeGNUYWcgPSAnW29iamVjdCBET01FeGNlcHRpb25dJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Vycm9yKEVycm9yKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XG4gICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRXJyb3I7XG4iLCJpbXBvcnQgYXBwbHkgZnJvbSAnLi9fYXBwbHkuanMnO1xuaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBpc0Vycm9yIGZyb20gJy4vaXNFcnJvci5qcyc7XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9ycy5cbiAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gKiB9LCAnPl8+Jyk7XG4gKlxuICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcbiAqICAgZWxlbWVudHMgPSBbXTtcbiAqIH1cbiAqL1xudmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHVuZGVmaW5lZCwgYXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhdHRlbXB0O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlNYXA7XG4iLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVZhbHVlcztcbiIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqVmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGN1c3RvbURlZmF1bHRzQXNzaWduSW47XG4iLCIvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAnXFxcXCc6ICdcXFxcJyxcbiAgXCInXCI6IFwiJ1wiLFxuICAnXFxuJzogJ24nLFxuICAnXFxyJzogJ3InLFxuICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICdcXHUyMDI5JzogJ3UyMDI5J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVzY2FwZVN0cmluZ0NoYXI7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVLZXlzO1xuIiwiaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzIGZyb20gJy4vX25hdGl2ZUtleXMuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG5leHBvcnQgZGVmYXVsdCByZUludGVycG9sYXRlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHlPZjtcbiIsImltcG9ydCBiYXNlUHJvcGVydHlPZiBmcm9tICcuL19iYXNlUHJvcGVydHlPZi5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG52YXIgaHRtbEVzY2FwZXMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5Oydcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xudmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGVIdG1sQ2hhcjtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRvU3RyaW5nO1xuIiwiaW1wb3J0IGJhc2VUb1N0cmluZyBmcm9tICcuL19iYXNlVG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU3RyaW5nO1xuIiwiaW1wb3J0IGVzY2FwZUh0bWxDaGFyIGZyb20gJy4vX2VzY2FwZUh0bWxDaGFyLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAqXG4gKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICpcbiAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICogWFNTIHZlY3RvcnMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICA6IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXNjYXBlO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nO1xuXG5leHBvcnQgZGVmYXVsdCByZUVzY2FwZTtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2c7XG5cbmV4cG9ydCBkZWZhdWx0IHJlRXZhbHVhdGU7XG4iLCJpbXBvcnQgZXNjYXBlIGZyb20gJy4vZXNjYXBlLmpzJztcbmltcG9ydCByZUVzY2FwZSBmcm9tICcuL19yZUVzY2FwZS5qcyc7XG5pbXBvcnQgcmVFdmFsdWF0ZSBmcm9tICcuL19yZUV2YWx1YXRlLmpzJztcbmltcG9ydCByZUludGVycG9sYXRlIGZyb20gJy4vX3JlSW50ZXJwb2xhdGUuanMnO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAndmFyaWFibGUnOiAnJyxcblxuICAvKipcbiAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICAnaW1wb3J0cyc6IHtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICAnXyc6IHsgJ2VzY2FwZSc6IGVzY2FwZSB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHRlbXBsYXRlU2V0dGluZ3M7XG4iLCJpbXBvcnQgYXNzaWduSW5XaXRoIGZyb20gJy4vYXNzaWduSW5XaXRoLmpzJztcbmltcG9ydCBhdHRlbXB0IGZyb20gJy4vYXR0ZW1wdC5qcyc7XG5pbXBvcnQgYmFzZVZhbHVlcyBmcm9tICcuL19iYXNlVmFsdWVzLmpzJztcbmltcG9ydCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluIGZyb20gJy4vX2N1c3RvbURlZmF1bHRzQXNzaWduSW4uanMnO1xuaW1wb3J0IGVzY2FwZVN0cmluZ0NoYXIgZnJvbSAnLi9fZXNjYXBlU3RyaW5nQ2hhci5qcyc7XG5pbXBvcnQgaXNFcnJvciBmcm9tICcuL2lzRXJyb3IuanMnO1xuaW1wb3J0IGlzSXRlcmF0ZWVDYWxsIGZyb20gJy4vX2lzSXRlcmF0ZWVDYWxsLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5pbXBvcnQgcmVJbnRlcnBvbGF0ZSBmcm9tICcuL19yZUludGVycG9sYXRlLmpzJztcbmltcG9ydCB0ZW1wbGF0ZVNldHRpbmdzIGZyb20gJy4vdGVtcGxhdGVTZXR0aW5ncy5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG52YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaFxuICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAqL1xudmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xudmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gKlxuICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J3RlbXBsYXRlU291cmNlc1tuXSddXG4gKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICpcbiAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICpcbiAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gKlxuICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gKlxuICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gKlxuICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAqIGNvbXBpbGVkKGRhdGEpO1xuICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAqXG4gKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAqIGNvbXBpbGVkLnNvdXJjZTtcbiAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAqIC8vICAgcmV0dXJuIF9fcDtcbiAqIC8vIH1cbiAqXG4gKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAqICAgdmFyIEpTVCA9IHtcXFxuICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gKiAgIH07XFxcbiAqICcpO1xuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgdmFyIHNldHRpbmdzID0gdGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzLl8udGVtcGxhdGVTZXR0aW5ncyB8fCB0ZW1wbGF0ZVNldHRpbmdzO1xuXG4gIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuXG4gIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gIHZhciBpc0VzY2FwaW5nLFxuICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgLCAnZycpO1xuXG4gIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgdmFyIHNvdXJjZVVSTCA9ICdzb3VyY2VVUkwnIGluIG9wdGlvbnMgPyAnLy8jIHNvdXJjZVVSTD0nICsgb3B0aW9ucy5zb3VyY2VVUkwgKyAnXFxuJyA6ICcnO1xuXG4gIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICB9XG4gICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgIH1cbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcblxuICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlO1xuICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gIH1cbiAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAodmFyaWFibGVcbiAgICAgID8gJydcbiAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICApICtcbiAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgIChpc0VzY2FwaW5nXG4gICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICA6ICcnXG4gICAgKSArXG4gICAgKGlzRXZhbHVhdGluZ1xuICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgOiAnO1xcbidcbiAgICApICtcbiAgICBzb3VyY2UgK1xuICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgfSk7XG5cbiAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICB0aHJvdyByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5RWFjaDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCYXNlRm9yO1xuIiwiaW1wb3J0IGNyZWF0ZUJhc2VGb3IgZnJvbSAnLi9fY3JlYXRlQmFzZUZvci5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUZvcjtcbiIsImltcG9ydCBiYXNlRm9yIGZyb20gJy4vX2Jhc2VGb3IuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlRm9yT3duO1xuIiwiaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCYXNlRWFjaDtcbiIsImltcG9ydCBiYXNlRm9yT3duIGZyb20gJy4vX2Jhc2VGb3JPd24uanMnO1xuaW1wb3J0IGNyZWF0ZUJhc2VFYWNoIGZyb20gJy4vX2NyZWF0ZUJhc2VFYWNoLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VFYWNoO1xuIiwiaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYXN0RnVuY3Rpb247XG4iLCJpbXBvcnQgYXJyYXlFYWNoIGZyb20gJy4vX2FycmF5RWFjaC5qcyc7XG5pbXBvcnQgYmFzZUVhY2ggZnJvbSAnLi9fYmFzZUVhY2guanMnO1xuaW1wb3J0IGNhc3RGdW5jdGlvbiBmcm9tICcuL19jYXN0RnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvckVhY2g7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUNsZWFyO1xuIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NvY0luZGV4T2Y7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVHZXQ7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVIYXM7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlU2V0O1xuIiwiaW1wb3J0IGxpc3RDYWNoZUNsZWFyIGZyb20gJy4vX2xpc3RDYWNoZUNsZWFyLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVEZWxldGUgZnJvbSAnLi9fbGlzdENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVHZXQgZnJvbSAnLi9fbGlzdENhY2hlR2V0LmpzJztcbmltcG9ydCBsaXN0Q2FjaGVIYXMgZnJvbSAnLi9fbGlzdENhY2hlSGFzLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVTZXQgZnJvbSAnLi9fbGlzdENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBMaXN0Q2FjaGU7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrSGFzO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5leHBvcnQgZGVmYXVsdCBNYXA7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUNyZWF0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hEZWxldGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEdldDtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoSGFzO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaFNldDtcbiIsImltcG9ydCBoYXNoQ2xlYXIgZnJvbSAnLi9faGFzaENsZWFyLmpzJztcbmltcG9ydCBoYXNoRGVsZXRlIGZyb20gJy4vX2hhc2hEZWxldGUuanMnO1xuaW1wb3J0IGhhc2hHZXQgZnJvbSAnLi9faGFzaEdldC5qcyc7XG5pbXBvcnQgaGFzaEhhcyBmcm9tICcuL19oYXNoSGFzLmpzJztcbmltcG9ydCBoYXNoU2V0IGZyb20gJy4vX2hhc2hTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuZXhwb3J0IGRlZmF1bHQgSGFzaDtcbiIsImltcG9ydCBIYXNoIGZyb20gJy4vX0hhc2guanMnO1xuaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlQ2xlYXI7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzS2V5YWJsZTtcbiIsImltcG9ydCBpc0tleWFibGUgZnJvbSAnLi9faXNLZXlhYmxlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRNYXBEYXRhO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZURlbGV0ZTtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlR2V0O1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlSGFzO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVTZXQ7XG4iLCJpbXBvcnQgbWFwQ2FjaGVDbGVhciBmcm9tICcuL19tYXBDYWNoZUNsZWFyLmpzJztcbmltcG9ydCBtYXBDYWNoZURlbGV0ZSBmcm9tICcuL19tYXBDYWNoZURlbGV0ZS5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVHZXQgZnJvbSAnLi9fbWFwQ2FjaGVHZXQuanMnO1xuaW1wb3J0IG1hcENhY2hlSGFzIGZyb20gJy4vX21hcENhY2hlSGFzLmpzJztcbmltcG9ydCBtYXBDYWNoZVNldCBmcm9tICcuL19tYXBDYWNoZVNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBNYXBDYWNoZTtcbiIsImltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcbmltcG9ydCBNYXBDYWNoZSBmcm9tICcuL19NYXBDYWNoZS5qcyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja1NldDtcbiIsImltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBzdGFja0NsZWFyIGZyb20gJy4vX3N0YWNrQ2xlYXIuanMnO1xuaW1wb3J0IHN0YWNrRGVsZXRlIGZyb20gJy4vX3N0YWNrRGVsZXRlLmpzJztcbmltcG9ydCBzdGFja0dldCBmcm9tICcuL19zdGFja0dldC5qcyc7XG5pbXBvcnQgc3RhY2tIYXMgZnJvbSAnLi9fc3RhY2tIYXMuanMnO1xuaW1wb3J0IHN0YWNrU2V0IGZyb20gJy4vX3N0YWNrU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBTdGFjaztcbiIsImltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduTWVyZ2VWYWx1ZTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZUJ1ZmZlcjtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBVaW50OEFycmF5O1xuIiwiaW1wb3J0IFVpbnQ4QXJyYXkgZnJvbSAnLi9fVWludDhBcnJheS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVBcnJheUJ1ZmZlcjtcbiIsImltcG9ydCBjbG9uZUFycmF5QnVmZmVyIGZyb20gJy4vX2Nsb25lQXJyYXlCdWZmZXIuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZVR5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weUFycmF5O1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlQ3JlYXRlO1xuIiwiaW1wb3J0IGJhc2VDcmVhdGUgZnJvbSAnLi9fYmFzZUNyZWF0ZS5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluaXRDbG9uZU9iamVjdDtcbiIsImltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNhZmVHZXQ7XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvUGxhaW5PYmplY3Q7XG4iLCJpbXBvcnQgYXNzaWduTWVyZ2VWYWx1ZSBmcm9tICcuL19hc3NpZ25NZXJnZVZhbHVlLmpzJztcbmltcG9ydCBjbG9uZUJ1ZmZlciBmcm9tICcuL19jbG9uZUJ1ZmZlci5qcyc7XG5pbXBvcnQgY2xvbmVUeXBlZEFycmF5IGZyb20gJy4vX2Nsb25lVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgY29weUFycmF5IGZyb20gJy4vX2NvcHlBcnJheS5qcyc7XG5pbXBvcnQgaW5pdENsb25lT2JqZWN0IGZyb20gJy4vX2luaXRDbG9uZU9iamVjdC5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlT2JqZWN0IGZyb20gJy4vaXNBcnJheUxpa2VPYmplY3QuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJy4vaXNQbGFpbk9iamVjdC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBzYWZlR2V0IGZyb20gJy4vX3NhZmVHZXQuanMnO1xuaW1wb3J0IHRvUGxhaW5PYmplY3QgZnJvbSAnLi90b1BsYWluT2JqZWN0LmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1lcmdlRGVlcDtcbiIsImltcG9ydCBTdGFjayBmcm9tICcuL19TdGFjay5qcyc7XG5pbXBvcnQgYXNzaWduTWVyZ2VWYWx1ZSBmcm9tICcuL19hc3NpZ25NZXJnZVZhbHVlLmpzJztcbmltcG9ydCBiYXNlRm9yIGZyb20gJy4vX2Jhc2VGb3IuanMnO1xuaW1wb3J0IGJhc2VNZXJnZURlZXAgZnJvbSAnLi9fYmFzZU1lcmdlRGVlcC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcbmltcG9ydCBzYWZlR2V0IGZyb20gJy4vX3NhZmVHZXQuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1lcmdlO1xuIiwiaW1wb3J0IGJhc2VNZXJnZSBmcm9tICcuL19iYXNlTWVyZ2UuanMnO1xuaW1wb3J0IGNyZWF0ZUFzc2lnbmVyIGZyb20gJy4vX2NyZWF0ZUFzc2lnbmVyLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1lcmdlO1xuIiwiaW1wb3J0IGJhc2VWYWx1ZXMgZnJvbSAnLi9fYmFzZVZhbHVlcy5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsdWVzO1xuIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRDYWNoZUhhcztcbiIsImltcG9ydCBNYXBDYWNoZSBmcm9tICcuL19NYXBDYWNoZS5qcyc7XG5pbXBvcnQgc2V0Q2FjaGVBZGQgZnJvbSAnLi9fc2V0Q2FjaGVBZGQuanMnO1xuaW1wb3J0IHNldENhY2hlSGFzIGZyb20gJy4vX3NldENhY2hlSGFzLmpzJztcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5leHBvcnQgZGVmYXVsdCBTZXRDYWNoZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5U29tZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYWNoZUhhcztcbiIsImltcG9ydCBTZXRDYWNoZSBmcm9tICcuL19TZXRDYWNoZS5qcyc7XG5pbXBvcnQgYXJyYXlTb21lIGZyb20gJy4vX2FycmF5U29tZS5qcyc7XG5pbXBvcnQgY2FjaGVIYXMgZnJvbSAnLi9fY2FjaGVIYXMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcXVhbEFycmF5cztcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRUb0FycmF5O1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IFVpbnQ4QXJyYXkgZnJvbSAnLi9fVWludDhBcnJheS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5pbXBvcnQgZXF1YWxBcnJheXMgZnJvbSAnLi9fZXF1YWxBcnJheXMuanMnO1xuaW1wb3J0IG1hcFRvQXJyYXkgZnJvbSAnLi9fbWFwVG9BcnJheS5qcyc7XG5pbXBvcnQgc2V0VG9BcnJheSBmcm9tICcuL19zZXRUb0FycmF5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxCeVRhZztcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlQdXNoO1xuIiwiaW1wb3J0IGFycmF5UHVzaCBmcm9tICcuL19hcnJheVB1c2guanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0QWxsS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlGaWx0ZXI7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViQXJyYXk7XG4iLCJpbXBvcnQgYXJyYXlGaWx0ZXIgZnJvbSAnLi9fYXJyYXlGaWx0ZXIuanMnO1xuaW1wb3J0IHN0dWJBcnJheSBmcm9tICcuL3N0dWJBcnJheS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0U3ltYm9scztcbiIsImltcG9ydCBiYXNlR2V0QWxsS2V5cyBmcm9tICcuL19iYXNlR2V0QWxsS2V5cy5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9scyBmcm9tICcuL19nZXRTeW1ib2xzLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldEFsbEtleXM7XG4iLCJpbXBvcnQgZ2V0QWxsS2V5cyBmcm9tICcuL19nZXRBbGxLZXlzLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsT2JqZWN0cztcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFWaWV3O1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IFByb21pc2U7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbmV4cG9ydCBkZWZhdWx0IFNldDtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5leHBvcnQgZGVmYXVsdCBXZWFrTWFwO1xuIiwiaW1wb3J0IERhdGFWaWV3IGZyb20gJy4vX0RhdGFWaWV3LmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4vX1Byb21pc2UuanMnO1xuaW1wb3J0IFNldCBmcm9tICcuL19TZXQuanMnO1xuaW1wb3J0IFdlYWtNYXAgZnJvbSAnLi9fV2Vha01hcC5qcyc7XG5pbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFRhZztcbiIsImltcG9ydCBTdGFjayBmcm9tICcuL19TdGFjay5qcyc7XG5pbXBvcnQgZXF1YWxBcnJheXMgZnJvbSAnLi9fZXF1YWxBcnJheXMuanMnO1xuaW1wb3J0IGVxdWFsQnlUYWcgZnJvbSAnLi9fZXF1YWxCeVRhZy5qcyc7XG5pbXBvcnQgZXF1YWxPYmplY3RzIGZyb20gJy4vX2VxdWFsT2JqZWN0cy5qcyc7XG5pbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNFcXVhbERlZXA7XG4iLCJpbXBvcnQgYmFzZUlzRXF1YWxEZWVwIGZyb20gJy4vX2Jhc2VJc0VxdWFsRGVlcC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0VxdWFsO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBiYXNlSXNFcXVhbCBmcm9tICcuL19iYXNlSXNFcXVhbC5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNNYXRjaDtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N0cmljdENvbXBhcmFibGU7XG4iLCJpbXBvcnQgaXNTdHJpY3RDb21wYXJhYmxlIGZyb20gJy4vX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TWF0Y2hEYXRhO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsImltcG9ydCBiYXNlSXNNYXRjaCBmcm9tICcuL19iYXNlSXNNYXRjaC5qcyc7XG5pbXBvcnQgZ2V0TWF0Y2hEYXRhIGZyb20gJy4vX2dldE1hdGNoRGF0YS5qcyc7XG5pbXBvcnQgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1hdGNoZXM7XG4iLCJpbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzS2V5O1xuIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplO1xuIiwiaW1wb3J0IG1lbW9pemUgZnJvbSAnLi9tZW1vaXplLmpzJztcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplQ2FwcGVkO1xuIiwiaW1wb3J0IG1lbW9pemVDYXBwZWQgZnJvbSAnLi9fbWVtb2l6ZUNhcHBlZC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5nVG9QYXRoO1xuIiwiaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgc3RyaW5nVG9QYXRoIGZyb20gJy4vX3N0cmluZ1RvUGF0aC5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhc3RQYXRoO1xuIiwiaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9LZXk7XG4iLCJpbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldDtcbiIsImltcG9ydCBiYXNlR2V0IGZyb20gJy4vX2Jhc2VHZXQuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSGFzSW47XG4iLCJpbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc1BhdGg7XG4iLCJpbXBvcnQgYmFzZUhhc0luIGZyb20gJy4vX2Jhc2VIYXNJbi5qcyc7XG5pbXBvcnQgaGFzUGF0aCBmcm9tICcuL19oYXNQYXRoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNJbjtcbiIsImltcG9ydCBiYXNlSXNFcXVhbCBmcm9tICcuL19iYXNlSXNFcXVhbC5qcyc7XG5pbXBvcnQgZ2V0IGZyb20gJy4vZ2V0LmpzJztcbmltcG9ydCBoYXNJbiBmcm9tICcuL2hhc0luLmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgaXNTdHJpY3RDb21wYXJhYmxlIGZyb20gJy4vX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5pbXBvcnQgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVByb3BlcnR5O1xuIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHlEZWVwO1xuIiwiaW1wb3J0IGJhc2VQcm9wZXJ0eSBmcm9tICcuL19iYXNlUHJvcGVydHkuanMnO1xuaW1wb3J0IGJhc2VQcm9wZXJ0eURlZXAgZnJvbSAnLi9fYmFzZVByb3BlcnR5RGVlcC5qcyc7XG5pbXBvcnQgaXNLZXkgZnJvbSAnLi9faXNLZXkuanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcm9wZXJ0eTtcbiIsImltcG9ydCBiYXNlTWF0Y2hlcyBmcm9tICcuL19iYXNlTWF0Y2hlcy5qcyc7XG5pbXBvcnQgYmFzZU1hdGNoZXNQcm9wZXJ0eSBmcm9tICcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgcHJvcGVydHkgZnJvbSAnLi9wcm9wZXJ0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJdGVyYXRlZTtcbiIsImltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNYXA7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU29ydEJ5O1xuIiwiaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKipcbiAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBhcmVBc2NlbmRpbmc7XG4iLCJpbXBvcnQgY29tcGFyZUFzY2VuZGluZyBmcm9tICcuL19jb21wYXJlQXNjZW5kaW5nLmpzJztcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICpcbiAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICB9XG4gIH1cbiAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgLy9cbiAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29tcGFyZU11bHRpcGxlO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBiYXNlTWFwIGZyb20gJy4vX2Jhc2VNYXAuanMnO1xuaW1wb3J0IGJhc2VTb3J0QnkgZnJvbSAnLi9fYmFzZVNvcnRCeS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgY29tcGFyZU11bHRpcGxlIGZyb20gJy4vX2NvbXBhcmVNdWx0aXBsZS5qcyc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoID8gaXRlcmF0ZWVzIDogW2lkZW50aXR5XSwgYmFzZVVuYXJ5KGJhc2VJdGVyYXRlZSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcblxuICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlT3JkZXJCeTtcbiIsImltcG9ydCBiYXNlT3JkZXJCeSBmcm9tICcuL19iYXNlT3JkZXJCeS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGUgc29ydFxuICogb3JkZXJzIG9mIHRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS4gSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXNcbiAqIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yXG4gKiBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FycmF5W118RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gKiBdO1xuICpcbiAqIC8vIFNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAqIF8ub3JkZXJCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbJ2FzYycsICdkZXNjJ10pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gKi9cbmZ1bmN0aW9uIG9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gIH1cbiAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBvcmRlcnM7XG4gIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuICB9XG4gIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9yZGVyQnk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUZpbmRJbmRleDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hTjtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaWN0SW5kZXhPZjtcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5SW5jbHVkZXNXaXRoO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm9vcDtcbiIsImltcG9ydCBTZXQgZnJvbSAnLi9fU2V0LmpzJztcbmltcG9ydCBub29wIGZyb20gJy4vbm9vcC5qcyc7XG5pbXBvcnQgc2V0VG9BcnJheSBmcm9tICcuL19zZXRUb0FycmF5LmpzJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICovXG52YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU2V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgX3RlbXBsYXRlIGZyb20gJ2xvZGFzaC1lcy90ZW1wbGF0ZSc7XG5pbXBvcnQgX2ZvckVhY2ggZnJvbSAnbG9kYXNoLWVzL2ZvckVhY2gnO1xuaW1wb3J0IF9tZXJnZSBmcm9tICdsb2Rhc2gtZXMvbWVyZ2UnO1xuaW1wb3J0IF92YWx1ZXMgZnJvbSAnbG9kYXNoLWVzL3ZhbHVlcyc7XG5pbXBvcnQgX29yZGVyQnkgZnJvbSAnbG9kYXNoLWVzL29yZGVyQnknO1xuaW1wb3J0IF91bmlxQnkgZnJvbSAnbG9kYXNoLWVzL3VuaXFCeSc7XG5cbi8qKlxuICpcbiAqL1xuY2xhc3MgRmVlZCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuZGVmYXVsdCA9IEZlZWQuZGVmYXVsdDtcblxuICAgIHRoaXMuX3NldHRpbmdzID0gX21lcmdlKHt9LCBGZWVkLmRlZmF1bHQsIGNvbmZpZyk7XG5cbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIGxldCBkYXRhID0gW107XG4gICAgbGV0IGZlZWQgPSB0aGlzLl9zZXR0aW5ncy5mZWVkO1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICByc3NUb0pzb246IEZlZWQucnNzVG9Kc29uLFxuICAgICAgcnNzVXJsOiAoQXJyYXkuaXNBcnJheShmZWVkKSkgPyBmZWVkIDogW2ZlZWRdXG4gICAgfTtcblxuICAgIC8vIEdvIHRocm91Z2ggZWFjaCBmZWVkXG4gICAgX2ZvckVhY2goY29uZmlnLnJzc1VybCwgKHVybCwgaW5kZXgpID0+IHtcbiAgICAgIC8vIE1ha2UgdGhlIHJlcXVlc3RcbiAgICAgIHRoaXMuX3JlcXVlc3QoY29uZmlnLCB1cmwpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgLy8gUHJvY2VzcyB0aGUgZGF0YVxuICAgICAgICAgIGRhdGEucHVzaCh0aGlzLl9wcm9jZXNzKEpTT04ucGFyc2UocmVzcG9uc2UpLCB0aGlzLl9zZXR0aW5ncykpO1xuICAgICAgICAgIC8vIFdoZW4gYWxsIGZlZWRzIGhhdmUgYmVlbiByZXF1ZXN0ZWQsIG1lcmdlIHRoZSBkYXRhIGFuZCBjb21waWxlXG4gICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSBjb25maWcucnNzVXJsLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fbWVyZ2UoZGF0YSwgdGhpcy5fc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICBsZXQgY29tcGlsZWQgPSB0aGlzLl9yZW5kZXIoXG4gICAgICAgICAgICAgIHRoaXMuX21lcmdlKGRhdGEsIHRoaXMuX3NldHRpbmdzKSxcbiAgICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxldCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fc2V0dGluZ3Muc2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKGVsKSBlbC5pbm5lckhUTUwgPSBjb21waWxlZDtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBYSFIgcmVxdWVzdCBmb3IgdGhlIGZlZWQgZGF0YVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGNvbmZpZyBUaGUgcmVxdWVzdCBkYXRhXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdXJsICAgIFRoZSByZXF1ZXN0IHVybFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICBSZXNvbHZlcyB3aGVuIHRoZSByZXNwb25zZSBpcyByZWFkeSwgcmVqZWN0cyB3aGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvcGVyYXRpb24gdGltZXMgb3V0IG9yIHRoZXJlIGlzIGFuIGVycm9yLlxuICAgKi9cbiAgX3JlcXVlc3QoY29uZmlnLCB1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGxldCBfeGhyID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAoX3hoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgaWYgKF94aHIuc3RhdHVzID49IDIwMCAmJiBfeGhyLnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShfeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihfeGhyLnN0YXR1cykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGhlIEZlZWQgcmVxdWVzdCB0aW1lZCBvdXQnKSk7XG4gICAgICB9O1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIGAke2NvbmZpZy5yc3NUb0pzb259P3Jzc191cmw9JHt1cmx9YCwgdHJ1ZSk7XG4gICAgICB4aHIuc2VuZCgpO1xuICAgICAgeGhyID0gbnVsbDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXNzIGRhdGEgdG8gdGhlIGFwcHJvcHJpYXRlIHByb2Nlc3NpbmcgZnVuY3Rpb24gYmFzZWQgb24gdHlwZVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGRhdGEgICAgIFRoZSByZXF1ZXN0ZWQgZmVlZCBkYXRhIHRvIHBhc3NcbiAgICogQHBhcmFtICB7b2JqZWN0fSBzZXR0aW5ncyBUaGUgYXBwbGljYXRpb24gc2V0dGluZ3NcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBUaGUgcHJvY2Vzc2VkIGRhdGFcbiAgICovXG4gIF9wcm9jZXNzKGRhdGEsIHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIEZlZWQucHJvY2Vzc1tzZXR0aW5ncy50eXBlXShkYXRhLCBzZXR0aW5ncyk7XG4gIH1cblxuICAvKipcbiAgICogUGFzcyBkYXRhIHRvIHRoZSBhcHByb3ByaWF0ZSBtZXJnZSBmdW5jdGlvbiBiYXNlZCBvbiB0eXBlXG4gICAqIEBwYXJhbSAge29iamVjdH0gZGF0YSAgICAgVGhlIHJlcXVlc3RlZCBmZWVkIGRhdGEgdG8gcGFzc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9IHNldHRpbmdzIFRoZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIFRoZSBtZXJnZWQgZmVlZCBkYXRhXG4gICAqL1xuICBfbWVyZ2UoZGF0YSwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gRmVlZC5tZXJnZVtzZXR0aW5ncy50eXBlXShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lIHRlbXBsYXRlIGNvbXBvbmVudHMsIHBhc3MgZGF0YSwgYW5kIHJldHVybiBjb21waWxlZCB0ZW1sYXRlXG4gICAqIEBwYXJhbSAge29iamVjdH0gZGF0YSAgICAgVGhlIHJlcXVlc3RlZCBmZWVkIGRhdGEgdG8gcGFzc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9IHNldHRpbmdzIFRoZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgIFRoZSBjb21wbGllZCBodG1sIHN0cmluZ1xuICAgKi9cbiAgX3JlbmRlcihkYXRhLCBzZXR0aW5ncykge1xuICAgIGRhdGEuc2V0dGluZ3MgPSBzZXR0aW5ncztcblxuICAgIGlmIChzZXR0aW5ncy5sb2cpXG4gICAgICBjb25zb2xlLmRpcihkYXRhKTtcblxuICAgIGxldCB0ZW1wbGF0ZSA9IF92YWx1ZXMoc2V0dGluZ3MudGVtcGxhdGVzKS5qb2luKCcnKTtcbiAgICBsZXQgY29tcGlsZWQgPSBfdGVtcGxhdGUoXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIHtcbiAgICAgICAgJ2ltcG9ydHMnOiB7XG4gICAgICAgICAgJ19lYWNoJzogX2ZvckVhY2hcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbXBpbGVkKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogQW4gb3BlbiBSU1MgdG8gSlNPTiBhcGksIHNlZSBodHRwczovL3JzczJqc29uLmNvbVxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuRmVlZC5yc3NUb0pzb24gPSAnaHR0cHM6Ly9hcGkucnNzMmpzb24uY29tL3YxL2FwaS5qc29uJztcblxuLyoqXG4gKiBUaGUgdGVtcGxhdGUgZm9yIHRoZSB3aWRnZXQuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5GZWVkLnRlbXBsYXRlcyA9IHtcbiAgbWVkaXVtOiB7XG4gICAgb3BlbmVyOiBbXG4gICAgICAnPHNlY3Rpb24gY2xhc3M9XCJvLWZlZWQgPCUtIHNldHRpbmdzLmNsYXNzZXMud3JhcHBlciAlPlwiIHN0eWxlPVwiJyxcbiAgICAgICAgJzwlIGlmIChzZXR0aW5ncy5mb250U2l6ZSkgeyAlPmZvbnQtc2l6ZTogPCUtIHNldHRpbmdzLmZvbnRTaXplICU+OzwlIH0gJT4nLFxuICAgICAgICAnPCUgaWYgKHNldHRpbmdzLnBvc3RCb3JkZXJDb2xvcikgeyAlPmJvcmRlci1jb2xvcjogPCUtIHNldHRpbmdzLnBvc3RCb3JkZXJDb2xvciAlPjs8JSB9ICU+JyxcbiAgICAgICdcIj4nXG4gICAgXSxcbiAgICBoZWFkZXI6IFtcbiAgICAgICc8aGVhZGVyIGNsYXNzPVwiby1mZWVkX19oZWFkZXIgPCUtIHNldHRpbmdzLmNsYXNzZXMuaGVhZGVyICU+XCI+JyxcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJvLWZlZWRfX2F2YXRhciA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5hdmF0YXIgJT5cIj4nLFxuICAgICAgICAgICc8aW1nIHNyYz1cIicsXG4gICAgICAgICAgICAgICAgJzwlIGlmIChzZXR0aW5ncy5wcm9maWxlSW1nICE9PSBcIlwiKSB7ICU+JyxcbiAgICAgICAgICAgICAgICAgICc8JS0gc2V0dGluZ3MucHJvZmlsZUltZyAlPicsXG4gICAgICAgICAgICAgICAgJzwlIH0gZWxzZSB7ICU+JyxcbiAgICAgICAgICAgICAgICAgICc8JS0gZmVlZC5wcm9maWxlSW1nICU+JyxcbiAgICAgICAgICAgICAgICAnPCUgfSAlPlwiICcsXG4gICAgICAgICAgICAgICAnd2lkdGg9XCI8JS0gc2V0dGluZ3MucmF0aW9Qcm9maWxlWzBdICU+XCIgJyxcbiAgICAgICAgICAgICAgICdoZWlnaHQ9XCI8JS0gc2V0dGluZ3MucmF0aW9Qcm9maWxlWzFdICU+XCI+JyxcbiAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICc8YSBjbGFzcz1cIm8tZmVlZF9fdXJsIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmF2YXRhciAlPlwiICcsXG4gICAgICAgICAgJ2hyZWY9XCI8JSBpZiAoc2V0dGluZ3MudGl0bGVVcmwgIT09IFwiXCIpIHsgJT4nLFxuICAgICAgICAgICAgJzwlLSBzZXR0aW5ncy50aXRsZVVybCAlPicsXG4gICAgICAgICAgJzwlIH0gZWxzZSB7ICU+JyxcbiAgICAgICAgICAgICc8JS0gZmVlZC51cmwgJT4nLFxuICAgICAgICAgICc8JSB9ICU+XCIgJyxcbiAgICAgICAgICAgJ3RhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXIgbm9mb2xsb3dcIj4nLFxuICAgICAgICAgICc8JSBpZiAoc2V0dGluZ3MudGl0bGUgIT09IFwiXCIpIHsgJT4nLFxuICAgICAgICAgICAgJzwlLSBzZXR0aW5ncy50aXRsZSAlPicsXG4gICAgICAgICAgJzwlIH0gZWxzZSB7ICU+JyxcbiAgICAgICAgICAgICc8JS0gZmVlZC50aXRsZSAlPicsXG4gICAgICAgICAgJzwlIH0gJT4nLFxuICAgICAgICAnPC9hPicsXG4gICAgICAnPC9oZWFkZXI+J1xuICAgIF0sXG4gICAgcG9zdHM6IFtcbiAgICAgICc8ZGl2IGNsYXNzPVwiby1mZWVkX19pdGVtc1wiIHN0eWxlPVwiJyxcbiAgICAgICAgJ2JvcmRlci1jb2xvcjogPCUtIHNldHRpbmdzLnBvc3RCb3JkZXJDb2xvciAlPjsnLFxuICAgICAgJ1wiPicsXG4gICAgICAgICc8JSBfZWFjaChpdGVtcywgZnVuY3Rpb24ocG9zdCkgeyAlPicsXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJjLWZlZWQtaXRlbSA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5mZWVkSXRlbSAlPlwiPicsXG4gICAgICAgICAgICAnPGg0IGNsYXNzPVwiYy1mZWVkLWl0ZW1fX3RpdGxlIDwlLSBzZXR0aW5ncy5jbGFzc2VzLnRpdGxlICU+XCI+JyxcbiAgICAgICAgICAgICAgJzxhIGNsYXNzPVwiYy1mZWVkLWl0ZW1fX2xpbmsgPCUtIHNldHRpbmdzLmNsYXNzZXMubGluayAlPlwiJyxcbiAgICAgICAgICAgICAgICAgJ2hyZWY9XCI8JS0gcG9zdC5ndWlkICU+XCInLFxuICAgICAgICAgICAgICAgICAndGFyZ2V0PVwiX2JsYW5rXCInLFxuICAgICAgICAgICAgICAgICAncmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvd1wiPicsXG4gICAgICAgICAgICAgICAgJzwlLSBwb3N0LnRpdGxlICU+JyxcbiAgICAgICAgICAgICAgJzwvYT4nLFxuICAgICAgICAgICAgJzwvaDQ+JyxcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImMtZmVlZC1pdGVtX19kYXRlIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmRhdGUgJT5cIiAnLFxuICAgICAgICAgICAgICAgICAgJ3RpdGxlPVwiPCUtIHNldHRpbmdzLnBvc3REYXRlVGl0bGUgJT5cIj4nLFxuICAgICAgICAgICAgICAnPCUtIHBvc3QuZGF0ZSAlPicsXG4gICAgICAgICAgICAnPC9zcGFuPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImMtZmVlZC1pdGVtX190aHVtYm5haWwgPCUtIHNldHRpbmdzLmNsYXNzZXMudGh1bWJuYWlsICU+XCInLFxuICAgICAgICAgICAgICAgICAnc3R5bGU9XCInLFxuICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZTogdXJsKDwlLSBwb3N0LnRodW1ibmFpbCAlPik7JyxcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodDogPCUtIHNldHRpbmdzLnBvc3RJbWdIZWlnaHQgJT47XCInLFxuICAgICAgICAgICAgICAgICAnYXJpYS1oaWRkZW49XCJ0cnVlXCI+JyxcbiAgICAgICAgICAgICAgJzxpbWcgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiIHNyYz1cIjwlLSBwb3N0LnRodW1ibmFpbCAlPlwiIGFsdD1cIjwlLSBwb3N0LnRpdGxlICU+XCI+JyxcbiAgICAgICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAgICAgJzxwIGNsYXNzPVwiYy1mZWVkLWl0ZW1fX2V4Y2VycHQgPCUtIHNldHRpbmdzLmNsYXNzZXMuZXhjZXJwdCAlPlwiPicsXG4gICAgICAgICAgICAgICc8JS0gcG9zdC5leGNlcnB0ICU+PCUtIHNldHRpbmdzLnBvc3RFeGNlcnB0VHJhaWwgJT4nLFxuICAgICAgICAgICAgJzwvcD4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJjLWZlZWQtaXRlbV9fZm9vdGVyIDwlLSBzZXR0aW5ncy5jbGFzc2VzLml0ZW1Gb290ZXIgJT5cIj4nLFxuICAgICAgICAgICAgICAnPGEgY2xhc3M9XCJjLWZlZWQtaXRlbV9fY3RhIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmN0YSAlPlwiICcsXG4gICAgICAgICAgICAgICAgICdocmVmPVwiPCUtIHBvc3QuZ3VpZCAlPlwiICcsXG4gICAgICAgICAgICAgICAgICd0YXJnZXQ9XCJfYmxhbmtcIiAnLFxuICAgICAgICAgICAgICAgICAncmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvd1wiPicsXG4gICAgICAgICAgICAgICAgJzwlLSBzZXR0aW5ncy5wb3N0Q3RhVGV4dCAlPicsXG4gICAgICAgICAgICAgICc8L2E+JyxcbiAgICAgICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAnPCUgfSk7ICU+JyxcbiAgICAgICc8L2Rpdj4nXG4gICAgXSxcbiAgICBjbG9zZXI6IFtcbiAgICAgICc8L3NlY3Rpb24+J1xuICAgIF1cbiAgfVxufTtcblxuLyoqXG4gKiBGdW5jdGlvbnMgZm9yIHByb2Nlc3NpbmcgdGhlIGRhdGEgYmFzZWQgb24gdGhlIGZlZWQgdHlwZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkZlZWQucHJvY2VzcyA9IHtcbiAgbWVkaXVtOiBmdW5jdGlvbihkYXRhLCBzZXR0aW5ncykge1xuICAgIGxldCBsZW5ndGggPSBzZXR0aW5ncy5wb3N0RXhjZXJwdExlbmd0aDtcblxuICAgIF9mb3JFYWNoKGRhdGEuaXRlbXMsIGZ1bmN0aW9uKHBvc3QsIGluZGV4KSB7XG4gICAgICBsZXQgZXhjZXJwdCA9ICcnO1xuICAgICAgbGV0IGRhdGUgPSAnJztcblxuICAgICAgLy8gUmVtb3ZlIGZpZ3VyZXMgZmlyc3RcbiAgICAgIGV4Y2VycHQgPSBwb3N0LmRlc2NyaXB0aW9uXG4gICAgICAgIC5yZXBsYWNlKC88ZmlndXJlLio+Lio/PFxcL2ZpZ3VyZT4vZywgJycpO1xuXG4gICAgICAvLyBSZW1vdmUgYWxsIHRhZ3NcbiAgICAgIGV4Y2VycHQgPSBleGNlcnB0LnJlcGxhY2UoLzwoLnxcXG4pKj8+L2csICcnKTtcblxuICAgICAgLy8gVHJpbSB0aGUgZXhjZXJwdFxuICAgICAgZXhjZXJwdCA9IGV4Y2VycHQuc3Vic3RyKDAsIGxlbmd0aCk7XG4gICAgICBleGNlcnB0ID0gZXhjZXJwdC5zdWJzdHIoMCxcbiAgICAgICAgTWF0aC5taW4oZXhjZXJwdC5sZW5ndGgsIGV4Y2VycHQubGFzdEluZGV4T2YoJyAnKSlcbiAgICAgICk7XG5cbiAgICAgIHBvc3QuZXhjZXJwdCA9IGV4Y2VycHQ7XG5cbiAgICAgIC8vIEZvcm1hdCB0aGUgZGF0ZVxuICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUucGFyc2UocG9zdC5wdWJEYXRlLnJlcGxhY2UoJyAnLCAnVCcpKSlcbiAgICAgICAgLnRvTG9jYWxlRGF0ZVN0cmluZyhzZXR0aW5ncy5wb3N0RGF0ZUxvY2FsLCBzZXR0aW5ncy5wb3N0RGF0ZUZvcm1hdCk7XG5cbiAgICAgIHBvc3QuZGF0ZSA9IGRhdGU7XG5cbiAgICAgIHJldHVybiBwb3N0O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxuLyoqXG4gKiBGdW5jdGlvbnMgZm9yIG1lcmdpbmcgdGhlIGRhdGEgZmVlZHMgdG9nZXRoZXIsIGJhc2VkIG9uIHRoZSBmZWVkIHR5cGUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5GZWVkLm1lcmdlID0ge1xuICBtZWRpdW06IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBsZXQgbWVyZ2VkID0ge307XG4gICAgbGV0IGl0ZW1zID0gW107XG5cbiAgICAvLyBDb21iaW5lIHRoZSBwb3N0IGl0ZW1zXG4gICAgZGF0YS5mb3JFYWNoKChmZWVkKSA9PiB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChmZWVkLml0ZW1zKTtcbiAgICB9KTtcblxuICAgIC8vIE1lcmdlIHRoZSBkYXRhLCB0aGlzIHdpbGwgb3ZlcnJpZGUgdmFsdWVzLCBpdCBwcm9iYWJseSB3b24ndCBiZVxuICAgIC8vIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIGZlZWRzIHRoYXQgYXJlIHRoZSBzYW1lLCBidXQgcG90ZW50aWFsbHlcbiAgICAvLyBkaWZmZXJlbnQgZmVlZCB0eXBlcyBjb3VsZCB1c2UgdGhpcyBhbmQgY29tYmluZSB1bmlxdWUgZGF0YVxuICAgIGRhdGEuZm9yRWFjaCgoZmVlZCkgPT4ge1xuICAgICAgbWVyZ2VkID0gX21lcmdlKG1lcmdlZCwgZmVlZCk7XG4gICAgfSk7XG5cbiAgICAvLyBHZXQgdW5pcXVlIHBvc3RzXG4gICAgLy8gaXRlbXMgPSBfdW5pcUJ5KGl0ZW1zLCAoaXRlbSkgPT4gaXRlbS5ndWlkKTtcblxuICAgIG1lcmdlZC5pdGVtcyA9IF9vcmRlckJ5KGl0ZW1zLCAncHViRGF0ZScsICdkZXNjJyk7XG5cbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG59XG5cbi8qKlxuICogU2VlIGh0dHBzOi8vcnNzMmpzb24uY29tL2RvY3MgZm9yIGRldGFpbHMgb24gZGVmYXVsdCBwYXJhbWV0ZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5GZWVkLmRlZmF1bHQgPSB7XG4gIGZlZWQ6ICcnLFxuICBzZWxlY3RvcjogJyNqcy1mZWVkJyxcbiAgdHlwZTogJ21lZGl1bScsXG4gIHRpdGxlOiAnJyxcbiAgdGl0bGVVcmw6ICcnLFxuICBwcm9maWxlSW1nOiAnJyxcbiAgZm9udFNpemU6ICcnLFxuICByYXRpb1Byb2ZpbGU6IFsnNTAnLCAnNTAnXSxcbiAgcG9zdEJvcmRlckNvbG9yOiAnbGlnaHRzdGVlbGJsdWUnLFxuICBwb3N0SW1nSGVpZ2h0OiAnMjAwcHgnLFxuICBwb3N0RXhjZXJwdExlbmd0aDogMTIwLFxuICBwb3N0RXhjZXJwdFRyYWlsOiAn4oCmJyxcbiAgcG9zdEN0YVRleHQ6ICdSZWFkIHRoZSBmdWxsIHBvc3QnLFxuICBwb3N0RGF0ZUxvY2FsOiAnZW4tVVMnLFxuICBwb3N0RGF0ZUZvcm1hdDoge1xuICAgIHllYXI6ICdudW1lcmljJyxcbiAgICBtb250aDogJ2xvbmcnLFxuICAgIGRheTogJ251bWVyaWMnXG4gIH0sXG4gIHBvc3REYXRlVGl0bGU6ICdQdWJsaXNoZWQgRGF0ZScsXG4gIGNsYXNzZXM6IHtcbiAgICB3cmFwcGVyOiAnJyxcbiAgICBoZWFkZXI6ICcnLFxuICAgIHVybDogJycsXG4gICAgZmVlZEl0ZW06ICcnLFxuICAgIHRpdGxlOiAnJyxcbiAgICBsaW5rOiAnJyxcbiAgICB0aHVtYm5haWw6ICcnLFxuICAgIGV4Y2VycHQ6ICcnLFxuICAgIGl0ZW1Gb290ZXI6ICcnLFxuICAgIGN0YTogJycsXG4gICAgZGF0ZTogJydcbiAgfSxcbiAgdGVtcGxhdGVzOiB7XG4gICAgb3BlbmVyOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0ub3BlbmVyLmpvaW4oJycpLFxuICAgIGhlYWRlcjogRmVlZC50ZW1wbGF0ZXMubWVkaXVtLmhlYWRlci5qb2luKCcnKSxcbiAgICBwb3N0czogRmVlZC50ZW1wbGF0ZXMubWVkaXVtLnBvc3RzLmpvaW4oJycpLFxuICAgIGNsb3NlcjogRmVlZC50ZW1wbGF0ZXMubWVkaXVtLmNsb3Nlci5qb2luKCcnKVxuICB9LFxuICBsb2c6IGZhbHNlLFxuICB1bmlxdWU6IGZhbHNlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBGZWVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSBTaW1wbGUgVG9nZ2xlIGNsYXNzLiBUaGlzIHdpbGwgdG9nZ2xlIHRoZSBjbGFzcyAnYWN0aXZlJyBhbmQgJ2hpZGRlbidcbiAqIG9uIHRhcmdldCBlbGVtZW50cywgZGV0ZXJtaW5lZCBieSBhIGNsaWNrIGV2ZW50IG9uIGEgc2VsZWN0ZWQgbGluayBvclxuICogZWxlbWVudC4gVGhpcyB3aWxsIGFsc28gdG9nZ2xlIHRoZSBhcmlhLWhpZGRlbiBhdHRyaWJ1dGUgZm9yIHRhcmdldGVkXG4gKiBlbGVtZW50cyB0byBzdXBwb3J0IHNjcmVlbiByZWFkZXJzLiBUYXJnZXQgc2V0dGluZ3MgYW5kIG90aGVyIGZ1bmN0aW9uYWxpdHlcbiAqIGNhbiBiZSBjb250cm9sbGVkIHRocm91Z2ggZGF0YSBhdHRyaWJ1dGVzLlxuICpcbiAqIFRoaXMgdXNlcyB0aGUgLm1hdGNoZXMoKSBtZXRob2Qgd2hpY2ggd2lsbCByZXF1aXJlIGEgcG9seWZpbGwgZm9yIElFXG4gKiBodHRwczovL3BvbHlmaWxsLmlvL3YyL2RvY3MvZmVhdHVyZXMvI0VsZW1lbnRfcHJvdG90eXBlX21hdGNoZXNcbiAqXG4gKiBCYXNpYyBVc2FnZTtcbiAqXG4gKiBqYXZhc2NyaXB0OlxuICogICBuZXcgVG9nZ2xlKCkuaW5pdCgpO1xuICpcbiAqIFRvZ2dsaW5nIEFuY2hvciBsaW5rczpcbiAqICAgPGEgZGF0YS1qcz0ndG9nZ2xlJyBocmVmPScjbWFpbi1tZW51Jz5NZW51PC9hPlxuICogICA8ZGl2IGlkPSdtYWluLW1lbnUnIGFyaWEtaGlkZGVuPSd0cnVlJz4gLi4uIDwvZGl2PlxuICpcbiAqIFRvZ2dsaW5nIGFyaWEtY29udHJvbCBlbGVtZW50czpcbiAqXG4gKiAgIDxidXR0b24gZGF0YS1qcz0ndG9nZ2xlJyBhcmlhLWNvbnRyb2xzPScjbWFpbi1tZW51JyBhcmlhLXByZXNzZWQ9J2ZhbHNlJz5cbiAqICAgICAgTWVudVxuICogICA8L2J1dHRvbj5cbiAqICAgPGRpdiBpZD0nbWFpbi1tZW51JyBhcmlhLWhpZGRlbj0ndHJ1ZSc+IC4uLiA8L2Rpdj5cbiAqXG4gKiBDcmVhdGUgXCJVbmRvXCIgRXZlbnQgKHRvIGNsb3NlIGEgZGlhbG9ndWUpO1xuICogICA8YSBocmVmPScjbWFpbi1tZW51JyBkYXRhLWpzPSd0b2dnbGUnIGRhdGEtdG9nZ2xlLXVuZG89JyNjbG9zZSc+TWVudTwvYT5cbiAqICAgPGRpdiBpZD0nbWFpbi1tZW51JyBhcmlhLWhpZGRlbj0ndHJ1ZSc+XG4gKiAgICAgPGEgaWQ9XCJjbG9zZVwiPkNsb3NlPC9hPlxuICogICA8L2Rpdj5cbiAqIEBjbGFzc1xuICovXG5jbGFzcyBUb2dnbGUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge29iamVjdH0gcyBTZXR0aW5ncyBmb3IgdGhpcyBUb2dnbGUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBjbGFzc1xuICAgKi9cbiAgY29uc3RydWN0b3Iocykge1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG5cbiAgICBzID0gKCFzKSA/IHt9IDogcztcblxuICAgIHRoaXMuX3NldHRpbmdzID0ge1xuICAgICAgc2VsZWN0b3I6IChzLnNlbGVjdG9yKSA/IHMuc2VsZWN0b3IgOiBUb2dnbGUuc2VsZWN0b3IsXG4gICAgICBuYW1lc3BhY2U6IChzLm5hbWVzcGFjZSkgPyBzLm5hbWVzcGFjZSA6IFRvZ2dsZS5uYW1lc3BhY2UsXG4gICAgICBpbmFjdGl2ZUNsYXNzOiAocy5pbmFjdGl2ZUNsYXNzKSA/IHMuaW5hY3RpdmVDbGFzcyA6IFRvZ2dsZS5pbmFjdGl2ZUNsYXNzLFxuICAgICAgYWN0aXZlQ2xhc3M6IChzLmFjdGl2ZUNsYXNzKSA/IHMuYWN0aXZlQ2xhc3MgOiBUb2dnbGUuYWN0aXZlQ2xhc3MsXG4gICAgfTtcblxuICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghZXZlbnQudGFyZ2V0Lm1hdGNoZXModGhpcy5fc2V0dGluZ3Muc2VsZWN0b3IpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHRoaXMuX3RvZ2dsZShldmVudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBldmVudCAgVGhlIG1haW4gY2xpY2sgZXZlbnRcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgVGhlIGNsYXNzXG4gICAqL1xuICBfdG9nZ2xlKGV2ZW50KSB7XG4gICAgbGV0IGVsID0gZXZlbnQudGFyZ2V0O1xuICAgIGxldCB0YXJnZXQgPSBmYWxzZTtcblxuICAgIC8qKiBBbmNob3IgTGlua3MgKi9cbiAgICB0YXJnZXQgPSAoZWwuZ2V0QXR0cmlidXRlKCdocmVmJykpID9cbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwuZ2V0QXR0cmlidXRlKCdocmVmJykpIDogdGFyZ2V0O1xuXG4gICAgLyoqIFRvZ2dsZSBDb250cm9scyAqL1xuICAgIC8vIGNvbnNvbGUuZGlyKGVsLmdldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpKTtcbiAgICB0YXJnZXQgPSAoZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJykpID9cbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke2VsLmdldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpfWApIDogdGFyZ2V0O1xuXG4gICAgLyoqIE1haW4gRnVuY3Rpb25hbGl0eSAqL1xuICAgIGlmICghdGFyZ2V0KSByZXR1cm4gdGhpcztcbiAgICB0aGlzLmVsZW1lbnRUb2dnbGUoZWwsIHRhcmdldCk7XG5cbiAgICAvKiogVW5kbyAqL1xuICAgIGlmIChlbC5kYXRhc2V0W2Ake3RoaXMuX3NldHRpbmdzLm5hbWVzcGFjZX1VbmRvYF0pIHtcbiAgICAgIGNvbnN0IHVuZG8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBlbC5kYXRhc2V0W2Ake3RoaXMuX3NldHRpbmdzLm5hbWVzcGFjZX1VbmRvYF1cbiAgICAgICk7XG5cbiAgICAgIHVuZG8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50VG9nZ2xlKGVsLCB0YXJnZXQpO1xuICAgICAgICB1bmRvLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWFpbiB0b2dnbGluZyBtZXRob2RcbiAgICogQHBhcmFtICB7b2JqZWN0fSBlbCAgICAgVGhlIGN1cnJlbnQgZWxlbWVudCB0byB0b2dnbGUgYWN0aXZlXG4gICAqIEBwYXJhbSAge29iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgZWxlbWVudCB0byB0b2dnbGUgYWN0aXZlL2hpZGRlblxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICBUaGUgY2xhc3NcbiAgICovXG4gIGVsZW1lbnRUb2dnbGUoZWwsIHRhcmdldCkge1xuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcyAhPT0gJycpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC50b2dnbGUodGhpcy5fc2V0dGluZ3MuYWN0aXZlQ2xhc3MpO1xuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUodGhpcy5fc2V0dGluZ3MuYWN0aXZlQ2xhc3MpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5pbmFjdGl2ZUNsYXNzICE9PSAnJykge1xuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUodGhpcy5fc2V0dGluZ3MuaW5hY3RpdmVDbGFzcyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhlIGVsZW1lbnQgZm9yIGRlZmluZWQgYXJpYSByb2xlcyBhbmQgdG9nZ2xlIHRoZW0gaWYgdGhleSBleGlzdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVG9nZ2xlLmVsQXJpYVJvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKFRvZ2dsZS5lbEFyaWFSb2xlc1tpXSkpXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShUb2dnbGUuZWxBcmlhUm9sZXNbaV0sXG4gICAgICAgICAgIShlbC5nZXRBdHRyaWJ1dGUoVG9nZ2xlLmVsQXJpYVJvbGVzW2ldKSA9PT0gJ3RydWUnKSk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhlIHRhcmdldCBmb3IgZGVmaW5lZCBhcmlhIHJvbGVzIGFuZCB0b2dnbGUgdGhlbSBpZiB0aGV5IGV4aXN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUb2dnbGUudGFyZ2V0QXJpYVJvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZShUb2dnbGUudGFyZ2V0QXJpYVJvbGVzW2ldKSlcbiAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShUb2dnbGUudGFyZ2V0QXJpYVJvbGVzW2ldLFxuICAgICAgICAgICEodGFyZ2V0LmdldEF0dHJpYnV0ZShUb2dnbGUudGFyZ2V0QXJpYVJvbGVzW2ldKSA9PT0gJ3RydWUnKSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgZWwuZ2V0QXR0cmlidXRlKCdocmVmJykgJiZcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5fc2V0dGluZ3MuYWN0aXZlQ2xhc3MpKVxuICAgIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgbWFpbiBzZWxlY3RvciB0byBhZGQgdGhlIHRvZ2dsaW5nIGZ1bmN0aW9uIHRvICovXG5Ub2dnbGUuc2VsZWN0b3IgPSAnW2RhdGEtanMqPVwidG9nZ2xlXCJdJztcblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBuYW1lc3BhY2UgZm9yIG91ciBkYXRhIGF0dHJpYnV0ZSBzZXR0aW5ncyAqL1xuVG9nZ2xlLm5hbWVzcGFjZSA9ICd0b2dnbGUnO1xuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIGhpZGUgY2xhc3MgKi9cblRvZ2dsZS5pbmFjdGl2ZUNsYXNzID0gJ2hpZGRlbic7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgYWN0aXZlIGNsYXNzICovXG5Ub2dnbGUuYWN0aXZlQ2xhc3MgPSAnYWN0aXZlJztcblxuLyoqIEB0eXBlIHtBcnJheX0gQXJpYSByb2xlcyB0byB0b2dnbGUgdHJ1ZS9mYWxzZSBvbiB0aGUgdG9nZ2xpbmcgZWxlbWVudCAqL1xuVG9nZ2xlLmVsQXJpYVJvbGVzID0gWydhcmlhLXByZXNzZWQnLCAnYXJpYS1leHBhbmRlZCddO1xuXG4vKiogQHR5cGUge0FycmF5fSBBcmlhIHJvbGVzIHRvIHRvZ2dsZSB0cnVlL2ZhbHNlIG9uIHRoZSB0YXJnZXQgZWxlbWVudCAqL1xuVG9nZ2xlLnRhcmdldEFyaWFSb2xlcyA9IFsnYXJpYS1oaWRkZW4nXTtcblxuZXhwb3J0IGRlZmF1bHQgVG9nZ2xlOyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFV0aWxpdHkgZnJvbSAnLi4vLi4vanMvbW9kdWxlcy91dGlsaXR5JztcblxuLyoqXG4gKiBUcmFja2luZyBidXMgZm9yIEdvb2dsZSBhbmFseXRpY3MgYW5kIFdlYnRyZW5kcy5cbiAqL1xuY2xhc3MgVHJhY2sge1xuICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcblxuICAgIHMgPSAoIXMpID8ge30gOiBzO1xuXG4gICAgdGhpcy5fc2V0dGluZ3MgPSB7XG4gICAgICBzZWxlY3RvcjogKHMuc2VsZWN0b3IpID8gcy5zZWxlY3RvciA6IFRyYWNrLnNlbGVjdG9yLFxuICAgIH07XG5cbiAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKHRoaXMuX3NldHRpbmdzLnNlbGVjdG9yKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBsZXQga2V5ID0gZXZlbnQudGFyZ2V0LmRhdGFzZXQudHJhY2tLZXk7XG4gICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQudGFyZ2V0LmRhdGFzZXQudHJhY2tEYXRhKTtcblxuICAgICAgdGhpcy5jbGljayhrZXksIGRhdGEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVHJhY2tpbmcgZnVuY3Rpb24gd3JhcHBlclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBrZXkgIFRoZSBrZXkgb3IgZXZlbnQgb2YgdGhlIGRhdGFcbiAgICogQHBhcmFtICB7Y29sbGVjdGlvbn0gZGF0YSBUaGUgZGF0YSB0byB0cmFja1xuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIFRoZSBmaW5hbCBkYXRhIG9iamVjdFxuICAgKi9cbiAgY2xpY2soa2V5LCBkYXRhKSB7XG4gICAgLy8gU2V0IHRoZSBwYXRoIG5hbWUgYmFzZWQgb24gdGhlIGxvY2F0aW9uXG4gICAgY29uc3QgZCA9IGRhdGEubWFwKGVsID0+IHtcbiAgICAgICAgaWYgKGVsLmhhc093blByb3BlcnR5KFRyYWNrLmtleSkpXG4gICAgICAgICAgZWxbVHJhY2sua2V5XSA9IGAke3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZX0vJHtlbFtUcmFjay5rZXldfWBcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfSk7XG5cbiAgICBsZXQgd3QgPSB0aGlzLndlYnRyZW5kcyhrZXksIGQpO1xuICAgIGxldCBnYSA9IHRoaXMuZ3RhZyhrZXksIGQpO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpXG4gICAgICBjb25zb2xlLmRpcih7J1RyYWNrJzogW3d0LCBnYV19KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuICAgIHJldHVybiBkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEYXRhIGJ1cyBmb3IgdHJhY2tpbmcgdmlld3MgaW4gV2VidHJlbmRzIGFuZCBHb29nbGUgQW5hbHl0aWNzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGFwcCAgVGhlIG5hbWUgb2YgdGhlIFNpbmdsZSBQYWdlIEFwcGxpY2F0aW9uIHRvIHRyYWNrXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKiBAcGFyYW0gIHtjb2xsZWN0aW9ufSBkYXRhIFRoZSBkYXRhIHRvIHRyYWNrXG4gICAqL1xuICB2aWV3KGFwcCwga2V5LCBkYXRhKSB7XG4gICAgbGV0IHd0ID0gdGhpcy53ZWJ0cmVuZHMoa2V5LCBkYXRhKTtcbiAgICBsZXQgZ2EgPSB0aGlzLmd0YWdWaWV3KGFwcCwga2V5KTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKVxuICAgICAgY29uc29sZS5kaXIoeydUcmFjayc6IFt3dCwgZ2FdfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIH07XG5cbiAgLyoqXG4gICAqIFB1c2ggRXZlbnRzIHRvIFdlYnRyZW5kc1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBrZXkgIFRoZSBrZXkgb3IgZXZlbnQgb2YgdGhlIGRhdGFcbiAgICogQHBhcmFtICB7Y29sbGVjdGlvbn0gZGF0YSBUaGUgZGF0YSB0byB0cmFja1xuICAgKi9cbiAgd2VidHJlbmRzKGtleSwgZGF0YSkge1xuICAgIGxldCBldmVudCA9IFt7XG4gICAgICAnV1QudGknOiBrZXlcbiAgICB9XTtcblxuICAgIGlmIChkYXRhWzBdICYmIGRhdGFbMF0uaGFzT3duUHJvcGVydHkoVHJhY2sua2V5KSkge1xuICAgICAgZXZlbnQucHVzaCh7XG4gICAgICAgICdEQ1MuZGNzdXJpJzogZGF0YVswXVtUcmFjay5rZXldXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbihldmVudCwgZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IGRhdGEgZm9yIFdlYnRyZW5kc1xuICAgIGxldCB3dGQgPSB7YXJnc2E6IGV2ZW50LmZsYXRNYXAoZSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZSkuZmxhdE1hcChrID0+IFtrLCBlW2tdXSk7XG4gICAgfSl9O1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICBpZiAodHlwZW9mIFdlYnRyZW5kcyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICBXZWJ0cmVuZHMubXVsdGlUcmFjayh3dGQpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5cbiAgICByZXR1cm4gWydXZWJ0cmVuZHMnLCB3dGRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdXNoIENsaWNrIEV2ZW50cyB0byBHb29nbGUgQW5hbHl0aWNzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKiBAcGFyYW0gIHtjb2xsZWN0aW9ufSBkYXRhIFRoZSBkYXRhIHRvIHRyYWNrXG4gICAqL1xuICBndGFnKGtleSwgZGF0YSkge1xuICAgIGxldCB1cmkgPSBkYXRhLmZpbmQoKGVsZW1lbnQpID0+IGVsZW1lbnQuaGFzT3duUHJvcGVydHkoVHJhY2sua2V5KSk7XG5cbiAgICBsZXQgZXZlbnQgPSB7XG4gICAgICAnZXZlbnRfY2F0ZWdvcnknOiBrZXlcbiAgICB9O1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICBpZiAodHlwZW9mIGd0YWcgIT09ICd1bmRlZmluZWQnKVxuICAgICAgZ3RhZyhUcmFjay5rZXksIHVyaVtUcmFjay5rZXldLCBldmVudCk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuXG4gICAgcmV0dXJuIFsnZ3RhZycsIFRyYWNrLmtleSwgdXJpW1RyYWNrLmtleV0sIGV2ZW50XTtcbiAgfTtcblxuICAvKipcbiAgICogUHVzaCBTY3JlZW4gVmlldyBFdmVudHMgdG8gR29vZ2xlIEFuYWx5dGljc1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBhcHAgIFRoZSBuYW1lIG9mIHRoZSBhcHBsaWNhdGlvblxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBrZXkgIFRoZSBrZXkgb3IgZXZlbnQgb2YgdGhlIGRhdGFcbiAgICovXG4gIGd0YWdWaWV3KGFwcCwga2V5KSB7XG4gICAgbGV0IHZpZXcgPSB7XG4gICAgICBhcHBfbmFtZTogYXBwLFxuICAgICAgc2NyZWVuX25hbWU6IGtleVxuICAgIH07XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgIGlmICh0eXBlb2YgZ3RhZyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICBndGFnKCdldmVudCcsICdzY3JlZW5fdmlldycsIHZpZXcpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYgKi9cblxuICAgIHJldHVybiBbJ2d0YWcnLCBUcmFjay5rZXksICdzY3JlZW5fdmlldycsIHZpZXddO1xuICB9O1xufVxuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIG1haW4gc2VsZWN0b3IgdG8gYWRkIHRoZSB0cmFja2luZyBmdW5jdGlvbiB0byAqL1xuVHJhY2suc2VsZWN0b3IgPSAnW2RhdGEtanMqPVwidHJhY2tcIl0nO1xuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIG1haW4gZXZlbnQgdHJhY2tpbmcga2V5IHRvIG1hcCB0byBXZWJ0cmVuZHMgRENTLnVyaSAqL1xuVHJhY2sua2V5ID0gJ2V2ZW50JztcblxuZXhwb3J0IGRlZmF1bHQgVHJhY2s7IiwiLyohXG4gKiBWdWUuanMgdjIuNi42XG4gKiAoYykgMjAxNC0yMDE5IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG5jb25zdCBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vLyBUaGVzZSBoZWxwZXJzIHByb2R1Y2UgYmV0dGVyIFZNIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmcuXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlLlxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cbiAqL1xuY29uc3QgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIGNvbnN0IG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgcmV0dXJuIChcbiAgICBpc0RlZih2YWwpICYmXG4gICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyB2YWwgPT4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXVxuICAgIDogdmFsID0+IG1hcFt2YWxdXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbmNvbnN0IGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG5jb25zdCBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIGNvbnN0IGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZWQoKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJylcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZWQoKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZWQoKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsXG4gKiBlLmcuLCBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICogQnV0IHJlbW92aW5nIGl0IHdvdWxkIG1lYW4gYnJlYWtpbmcgY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpblxuICogUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cblxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZuLmJpbmQoY3R4KVxufVxuXG5jb25zdCBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgPyBuYXRpdmVCaW5kXG4gIDogcG9seWZpbGxCaW5kO1xuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGxldCBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICBjb25zdCByZXMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKS5cbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG5jb25zdCBubyA9IChhLCBiLCBjKSA9PiBmYWxzZTtcblxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xuY29uc3QgaWRlbnRpdHkgPSAoXykgPT4gXztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0cmluZyBjb250YWluaW5nIHN0YXRpYyBrZXlzIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoKGtleXMsIG0pID0+IHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlXG4gIGNvbnN0IGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICBjb25zdCBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgY29uc3QgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoZSwgaSkgPT4ge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICBjb25zdCBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoa2V5ID0+IHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgbG9vc2VseSBlcXVhbCB2YWx1ZSBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBhcnJheSAoaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIHRoZSBhcnJheSBtdXN0XG4gKiBjb250YWluIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZSksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICovXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSByZXR1cm4gaVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxuY29uc3QgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbmNvbnN0IExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnLFxuICAnc2VydmVyUHJlZmV0Y2gnXG5dO1xuXG4vKiAgKi9cblxuXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXG4gICAqL1xuICBhc3luYzogdHJ1ZSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbi8qKlxuICogdW5pY29kZSBsZXR0ZXJzIHVzZWQgZm9yIHBhcnNpbmcgaHRtbCB0YWdzLCBjb21wb25lbnQgbmFtZXMgYW5kIHByb3BlcnR5IHBhdGhzLlxuICogdXNpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zZW1hbnRpY3Mtc2NyaXB0aW5nLmh0bWwjcG90ZW50aWFsY3VzdG9tZWxlbWVudG5hbWVcbiAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcbiAqL1xuY29uc3QgdW5pY29kZUxldHRlcnMgPSAnYS16QS1aXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICBjb25zdCBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbmNvbnN0IGJhaWxSRSA9IG5ldyBSZWdFeHAoYFteJHt1bmljb2RlTGV0dGVyc30uJF9cXFxcZF1gKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgcmV0dXJuXG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xuY29uc3QgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xuY29uc3QgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBpbldlZXggPSB0eXBlb2YgV1hFbnZpcm9ubWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFXWEVudmlyb25tZW50LnBsYXRmb3JtO1xuY29uc3Qgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbmNvbnN0IFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG5jb25zdCBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG5jb25zdCBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xuY29uc3QgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG5jb25zdCBpc0FuZHJvaWQgPSAoVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMCkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbmNvbnN0IGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5jb25zdCBpc1BoYW50b21KUyA9IFVBICYmIC9waGFudG9tanMvLnRlc3QoVUEpO1xuY29uc3QgaXNGRiA9IFVBICYmIFVBLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyk7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbmNvbnN0IG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxubGV0IHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICB0cnkge1xuICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0ICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbmxldCBfaXNTZXJ2ZXI7XG5jb25zdCBpc1NlcnZlclJlbmRlcmluZyA9ICgpID0+IHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXSAmJiBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbmNvbnN0IGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbmNvbnN0IGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbmxldCBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSBjbGFzcyBTZXQgICB7XG4gICAgXG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9XG4gICAgYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH1cbiAgICBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IHdhcm4gPSBub29wO1xubGV0IHRpcCA9IG5vb3A7XG5sZXQgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IChub29wKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xubGV0IGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbntcbiAgY29uc3QgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgY29uc3QgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgY29uc3QgY2xhc3NpZnkgPSBzdHIgPT4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgYyA9PiBjLnRvVXBwZXJDYXNlKCkpXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpO1xuXG4gIHdhcm4gPSAobXNnLCB2bSkgPT4ge1xuICAgIGNvbnN0IHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbVnVlIHdhcm5dOiAke21zZ30ke3RyYWNlfWApO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSAobXNnLCB2bSkgPT4ge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW1Z1ZSB0aXBdOiAke21zZ31gICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gKHZtLCBpbmNsdWRlRmlsZSkgPT4ge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICA/IHZtLm9wdGlvbnNcbiAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICA6IHZtO1xuICAgIGxldCBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICBjb25zdCBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gYDwke2NsYXNzaWZ5KG5hbWUpfT5gIDogYDxBbm9ueW1vdXM+YCkgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gYCBhdCAke2ZpbGV9YCA6ICcnKVxuICAgIClcbiAgfTtcblxuICBjb25zdCByZXBlYXQgPSAoc3RyLCBuKSA9PiB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHJlcyArPSBzdHI7XG4gICAgICBpZiAobiA+IDEpIHN0ciArPSBzdHI7XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IHZtID0+IHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIGNvbnN0IHRyZWUgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcCgodm0sIGkpID0+IGAke1xuICAgICAgICAgIGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKVxuICAgICAgICB9JHtcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyBgJHtmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKX0uLi4gKCR7dm1bMV19IHJlY3Vyc2l2ZSBjYWxscylgXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pXG4gICAgICAgIH1gKVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBcXG5cXG4oZm91bmQgaW4gJHtmb3JtYXRDb21wb25lbnROYW1lKHZtKX0pYFxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmxldCB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xuY2xhc3MgRGVwIHtcbiAgXG4gIFxuICBcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5pZCA9IHVpZCsrO1xuICAgIHRoaXMuc3VicyA9IFtdO1xuICB9XG5cbiAgYWRkU3ViIChzdWIpIHtcbiAgICB0aGlzLnN1YnMucHVzaChzdWIpO1xuICB9XG5cbiAgcmVtb3ZlU3ViIChzdWIpIHtcbiAgICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xuICB9XG5cbiAgZGVwZW5kICgpIHtcbiAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgbm90aWZ5ICgpIHtcbiAgICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICAgIGNvbnN0IHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgLy8gc3VicyBhcmVuJ3Qgc29ydGVkIGluIHNjaGVkdWxlciBpZiBub3QgcnVubmluZyBhc3luY1xuICAgICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxuICAgICAgLy8gb3JkZXJcbiAgICAgIHN1YnMuc29ydCgoYSwgYikgPT4gYS5pZCAtIGIuaWQpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcbi8vIGNhbiBiZSBldmFsdWF0ZWQgYXQgYSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG5jb25zdCB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0ICh0YXJnZXQpIHtcbiAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICB0YXJnZXRTdGFjay5wb3AoKTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrW3RhcmdldFN0YWNrLmxlbmd0aCAtIDFdO1xufVxuXG4vKiAgKi9cblxuY2xhc3MgVk5vZGUge1xuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICAgLy8gcmVuZGVyZWQgaW4gdGhpcyBjb21wb25lbnQncyBzY29wZVxuICBcbiAgXG4gICAvLyBjb21wb25lbnQgaW5zdGFuY2VcbiAgIC8vIGNvbXBvbmVudCBwbGFjZWhvbGRlciBub2RlXG5cbiAgLy8gc3RyaWN0bHkgaW50ZXJuYWxcbiAgIC8vIGNvbnRhaW5zIHJhdyBIVE1MPyAoc2VydmVyIG9ubHkpXG4gICAvLyBob2lzdGVkIHN0YXRpYyBub2RlXG4gICAvLyBuZWNlc3NhcnkgZm9yIGVudGVyIHRyYW5zaXRpb24gY2hlY2tcbiAgIC8vIGVtcHR5IGNvbW1lbnQgcGxhY2Vob2xkZXI/XG4gICAvLyBpcyBhIGNsb25lZCBub2RlP1xuICAgLy8gaXMgYSB2LW9uY2Ugbm9kZT9cbiAgIC8vIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5IGZ1bmN0aW9uXG4gIFxuICBcbiAgXG4gICAvLyByZWFsIGNvbnRleHQgdm0gZm9yIGZ1bmN0aW9uYWwgbm9kZXNcbiAgIC8vIGZvciBTU1IgY2FjaGluZ1xuICAgLy8gdXNlZCB0byBzdG9yZSBmdW5jdGlvbmFsIHJlbmRlciBjb250ZXh0IGZvciBkZXZ0b29sc1xuICAgLy8gZnVuY3Rpb25hbCBzY29wZSBpZCBzdXBwb3J0XG5cbiAgY29uc3RydWN0b3IgKFxuICAgIHRhZyxcbiAgICBkYXRhLFxuICAgIGNoaWxkcmVuLFxuICAgIHRleHQsXG4gICAgZWxtLFxuICAgIGNvbnRleHQsXG4gICAgY29tcG9uZW50T3B0aW9ucyxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKSB7XG4gICAgdGhpcy50YWcgPSB0YWc7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmVsbSA9IGVsbTtcbiAgICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICAgIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gICAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJhdyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gICAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gICAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xuICB9XG5cbiAgLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgY2hpbGQgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG4gIH1cbn1cblxuY29uc3QgY3JlYXRlRW1wdHlWTm9kZSA9ICh0ZXh0ID0gJycpID0+IHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgY29uc3QgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIC8vICM3OTc1XG4gICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXG4gICAgLy8gYSBjaGlsZC5cbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xuICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbmNvbnN0IGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5jb25zdCBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuXG5jb25zdCBtZXRob2RzVG9QYXRjaCA9IFtcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl07XG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgY29uc3Qgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoLi4uYXJncykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIGNvbnN0IG9iID0gdGhpcy5fX29iX187XG4gICAgbGV0IGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTtcbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbmNvbnN0IGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gKiB1cGRhdGUgY29tcHV0YXRpb24uXG4gKi9cbmxldCBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nICh2YWx1ZSkge1xuICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gKi9cbmNsYXNzIE9ic2VydmVyIHtcbiAgXG4gIFxuICAgLy8gbnVtYmVyIG9mIHZtcyB0aGF0IGhhdmUgdGhpcyBvYmplY3QgYXMgcm9vdCAkZGF0YVxuXG4gIGNvbnN0cnVjdG9yICh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgICB0aGlzLnZtQ291bnQgPSAwO1xuICAgIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKGhhc1Byb3RvKSB7XG4gICAgICAgIHByb3RvQXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlBdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cbiAgICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gICAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICAgKi9cbiAgd2FsayAob2JqKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAgICovXG4gIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gICAgfVxuICB9XG59XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBzaG91bGRPYnNlcnZlICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgY29uc3QgZGVwID0gbmV3IERlcCgpO1xuXG4gIGNvbnN0IHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgY29uc3QgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICBjb25zdCBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG4gIGlmICgoIWdldHRlciB8fCBzZXR0ZXIpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YWwgPSBvYmpba2V5XTtcbiAgfVxuXG4gIGxldCBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcbiAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgcmV0dXJuXG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldClcbiAgKSB7XG4gICAgd2FybihgQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogJHsodGFyZ2V0KX1gKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgY29uc3Qgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldClcbiAgKSB7XG4gICAgd2FybihgQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogJHsodGFyZ2V0KX1gKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAobGV0IGUsIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG5jb25zdCBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xue1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgb3B0aW9uIFwiJHtrZXl9XCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgYCArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHJldHVybiB0b1xuICBsZXQga2V5LCB0b1ZhbCwgZnJvbVZhbDtcblxuICBjb25zdCBrZXlzID0gaGFzU3ltYm9sXG4gICAgPyBSZWZsZWN0Lm93bktleXMoZnJvbSlcbiAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgLy8gaW4gY2FzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgb2JzZXJ2ZWQuLi5cbiAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgY29udGludWVcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbClcbiAgICApIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgY29uc3QgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICBjb25zdCBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgY29uc3QgcmVzID0gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsO1xuICByZXR1cm4gcmVzXG4gICAgPyBkZWR1cGVIb29rcyhyZXMpXG4gICAgOiByZXNcbn1cblxuZnVuY3Rpb24gZGVkdXBlSG9va3MgKGhvb2tzKSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlcy5pbmRleE9mKGhvb2tzW2ldKSA9PT0gLTEpIHtcbiAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChob29rID0+IHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGNvbnN0IHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbkFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cbiAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHBhcmVudFZhbCA9IHVuZGVmaW5lZDtcbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgY2hpbGRWYWwgPSB1bmRlZmluZWQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbClcbiAge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWxcbiAgY29uc3QgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAoY29uc3Qga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgbGV0IHBhcmVudCA9IHJldFtrZXldO1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWxcbiAgY29uc3QgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXRcbn07XG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xuY29uc3QgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCFuZXcgUmVnRXhwKGBeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV8ke3VuaWNvZGVMZXR0ZXJzfV0qJGApLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJ1xuICAgICk7XG4gIH1cbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICdpZDogJyArIG5hbWVcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucywgdm0pIHtcbiAgY29uc3QgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSByZXR1cm5cbiAgY29uc3QgcmVzID0ge307XG4gIGxldCBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3YXJuKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcInByb3BzXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgYCArXG4gICAgICBgYnV0IGdvdCAke3RvUmF3VHlwZShwcm9wcyl9LmAsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgY29uc3QgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmICghaW5qZWN0KSByZXR1cm5cbiAgY29uc3Qgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICBjb25zdCB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2FybihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXCJpbmplY3RcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBgICtcbiAgICAgIGBidXQgZ290ICR7dG9SYXdUeXBlKGluamVjdCl9LmAsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIGNvbnN0IGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGlycykge1xuICAgICAgY29uc3QgZGVmJCQxID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYkJDEsIHVwZGF0ZTogZGVmJCQxIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXCIke25hbWV9XCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgYCArXG4gICAgICBgYnV0IGdvdCAke3RvUmF3VHlwZSh2YWx1ZSl9LmAsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcblxuICAvLyBBcHBseSBleHRlbmRzIGFuZCBtaXhpbnMgb24gdGhlIGNoaWxkIG9wdGlvbnMsXG4gIC8vIGJ1dCBvbmx5IGlmIGl0IGlzIGEgcmF3IG9wdGlvbnMgb2JqZWN0IHRoYXQgaXNuJ3RcbiAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxuICAvLyBPbmx5IG1lcmdlZCBvcHRpb25zIGhhcyB0aGUgX2Jhc2UgcHJvcGVydHkuXG4gIGlmICghY2hpbGQuX2Jhc2UpIHtcbiAgICBpZiAoY2hpbGQuZXh0ZW5kcykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQuZXh0ZW5kcywgdm0pO1xuICAgIH1cbiAgICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICBsZXQga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgY29uc3Qgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSByZXR1cm4gYXNzZXRzW2lkXVxuICBjb25zdCBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF1cbiAgY29uc3QgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIGNvbnN0IHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgY29uc3QgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIGNvbnN0IGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICBsZXQgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gIGNvbnN0IGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICBjb25zdCBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgY29uc3QgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICB9XG4gIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIGNvbnN0IGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAoaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCB0eXBlID0gcHJvcC50eXBlO1xuICBsZXQgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICBjb25zdCBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICBjb25zdCBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIGxldCB2YWxpZDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICBjb25zdCBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xuICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXggKHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTFcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlIChuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xuICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLmAgK1xuICAgIGAgRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpfWA7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICBjb25zdCByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcbiAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XG4gIH1cbiAgbWVzc2FnZSArPSBgLCBnb3QgJHtyZWNlaXZlZFR5cGV9IGA7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcbiAgfVxuICByZXR1cm4gbWVzc2FnZVxufVxuXG5mdW5jdGlvbiBzdHlsZVZhbHVlICh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImBcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuICAgIHJldHVybiBgJHtOdW1iZXIodmFsdWUpfWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9YFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSAodmFsdWUpIHtcbiAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoZWxlbSA9PiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtKVxufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4gKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3Muc29tZShlbGVtID0+IGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2xlYW4nKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHZtKSB7XG4gICAgbGV0IGN1ciA9IHZtO1xuICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICBjb25zdCBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgcmV0dXJuXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyAoXG4gIGhhbmRsZXIsXG4gIGNvbnRleHQsXG4gIGFyZ3MsXG4gIHZtLFxuICBpbmZvXG4pIHtcbiAgbGV0IHJlcztcbiAgdHJ5IHtcbiAgICByZXMgPSBhcmdzID8gaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKSA6IGhhbmRsZXIuY2FsbChjb250ZXh0KTtcbiAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICByZXMuY2F0Y2goZSA9PiBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyArIGAgKFByb21pc2UvYXN5bmMpYCkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IHRocm93cyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gdGhlIGhhbmRsZXIsXG4gICAgICAvLyBkbyBub3QgbG9nIGl0IHR3aWNlXG4gICAgICBpZiAoZSAhPT0gZXJyKSB7XG4gICAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICB7XG4gICAgd2FybihgRXJyb3IgaW4gJHtpbmZvfTogXCIke2Vyci50b1N0cmluZygpfVwiYCwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuXG5sZXQgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xuXG5jb25zdCBjYWxsYmFja3MgPSBbXTtcbmxldCBwZW5kaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgcGVuZGluZyA9IGZhbHNlO1xuICBjb25zdCBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbi8vIEluIDIuNSB3ZSB1c2VkIChtYWNybykgdGFza3MgKGluIGNvbWJpbmF0aW9uIHdpdGggbWljcm90YXNrcykuXG4vLyBIb3dldmVyLCBpdCBoYXMgc3VidGxlIHByb2JsZW1zIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludFxuLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBBbHNvLCB1c2luZyAobWFjcm8pIHRhc2tzIGluIGV2ZW50IGhhbmRsZXIgd291bGQgY2F1c2Ugc29tZSB3ZWlyZCBiZWhhdmlvcnNcbi8vIHRoYXQgY2Fubm90IGJlIGNpcmN1bXZlbnRlZCAoZS5nLiAjNzEwOSwgIzcxNTMsICM3NTQ2LCAjNzgzNCwgIzgxMDkpLlxuLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuLy8gQSBtYWpvciBkcmF3YmFjayBvZiB0aGlzIHRyYWRlb2ZmIGlzIHRoYXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zXG4vLyB3aGVyZSBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbi8vIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZSBldmVudCAoIzY1NjYpLlxubGV0IHRpbWVyRnVuYztcblxuLy8gVGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbi8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4vLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICBjb25zdCBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHRpbWVyRnVuYyA9ICgpID0+IHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIEluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSBzZXRUaW1lb3V0KG5vb3ApO1xuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAoIWlzSUUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbikpIHtcbiAgLy8gVXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgLy8gZS5nLiBQaGFudG9tSlMsIGlPUzcsIEFuZHJvaWQgNC40XG4gIC8vICgjNjQ2NiBNdXRhdGlvbk9ic2VydmVyIGlzIHVucmVsaWFibGUgaW4gSUUxMSlcbiAgbGV0IGNvdW50ZXIgPSAxO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoQ2FsbGJhY2tzKTtcbiAgY29uc3QgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICB9KTtcbiAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXG4gIC8vIFRlY2hpbmljYWxseSBpdCBsZXZlcmFnZXMgdGhlIChtYWNybykgdGFzayBxdWV1ZSxcbiAgLy8gYnV0IGl0IGlzIHN0aWxsIGEgYmV0dGVyIGNob2ljZSB0aGFuIHNldFRpbWVvdXQuXG4gIHRpbWVyRnVuYyA9ICgpID0+IHtcbiAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gRmFsbGJhY2sgdG8gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGN0eCkge1xuICBsZXQgX3Jlc29sdmU7XG4gIGNhbGxiYWNrcy5wdXNoKCgpID0+IHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZShjdHgpO1xuICAgIH1cbiAgfSk7XG4gIGlmICghcGVuZGluZykge1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIHRpbWVyRnVuYygpO1xuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG5sZXQgbWFyaztcbmxldCBtZWFzdXJlO1xuXG57XG4gIGNvbnN0IHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IHRhZyA9PiBwZXJmLm1hcmsodGFnKTtcbiAgICBtZWFzdXJlID0gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpID0+IHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIC8vIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKVxuICAgIH07XG4gIH1cbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbmxldCBpbml0UHJveHk7XG5cbntcbiAgY29uc3QgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgY29uc3Qgd2Fybk5vblByZXNlbnQgPSAodGFyZ2V0LCBrZXkpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYFByb3BlcnR5IG9yIG1ldGhvZCBcIiR7a2V5fVwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgYCArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgY29uc3Qgd2FyblJlc2VydmVkUHJlZml4ID0gKHRhcmdldCwga2V5KSA9PiB7XG4gICAgd2FybihcbiAgICAgIGBQcm9wZXJ0eSBcIiR7a2V5fVwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcIiRkYXRhLiR7a2V5fVwiIGJlY2F1c2UgYCArXG4gICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xuICAgICAgJ3ByZXZlbnQgY29uZmxpY3RzIHdpdGggVnVlIGludGVybmFscycgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvYXBpLyNkYXRhJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgY29uc3QgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJveHkpO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIGNvbnN0IGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybihgQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuJHtrZXl9YCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBoYXNIYW5kbGVyID0ge1xuICAgIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGNvbnN0IGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICBjb25zdCBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8XG4gICAgICAgICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkuY2hhckF0KDApID09PSAnXycgJiYgIShrZXkgaW4gdGFyZ2V0LiRkYXRhKSk7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKSB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpO1xuICAgICAgICBlbHNlIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRIYW5kbGVyID0ge1xuICAgIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKSB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpO1xuICAgICAgICBlbHNlIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIGNvbnN0IGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmNvbnN0IHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICBsZXQgaSwga2V5cztcbiAgY29uc3QgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICBjb25zdCBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pO1xuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuY29uc3Qgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoKG5hbWUpID0+IHtcbiAgY29uc3QgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIGNvbnN0IG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIGNvbnN0IGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlLFxuICAgIHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zLCB2bSkge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICBjb25zdCBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICBjb25zdCBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNsb25lZFtpXSwgbnVsbCwgYXJndW1lbnRzLCB2bSwgYHYtb24gaGFuZGxlcmApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGZucywgbnVsbCwgYXJndW1lbnRzLCB2bSwgYHYtb24gaGFuZGxlcmApXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICBjcmVhdGVPbmNlSGFuZGxlcixcbiAgdm1cbikge1xuICBsZXQgbmFtZSwgZGVmJCQxLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYEludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXCIke2V2ZW50Lm5hbWV9XCI6IGdvdCBgICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgbGV0IGludm9rZXI7XG4gIGNvbnN0IG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgY29uc3QgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBjb25zdCB7IGF0dHJzLCBwcm9wcyB9ID0gZGF0YTtcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgY29uc3QgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgYFByb3AgXCIke2tleUluTG93ZXJDYXNlfVwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgYCArXG4gICAgICAgICAgICBgJHtmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKX0sIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzYCArXG4gICAgICAgICAgICBgIFwiJHtrZXl9XCIuIGAgK1xuICAgICAgICAgICAgYE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgYCArXG4gICAgICAgICAgICBgcHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBgICtcbiAgICAgICAgICAgIGB0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHthbHRLZXl9XCIgaW5zdGVhZCBvZiBcIiR7a2V5fVwiLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICBjb25zdCByZXMgPSBbXTtcbiAgbGV0IGksIGMsIGxhc3RJbmRleCwgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIGNvbnRpbnVlXG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCBgJHtuZXN0ZWRJbmRleCB8fCAnJ31fJHtpfWApO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBgX192bGlzdCR7bmVzdGVkSW5kZXh9XyR7aX1fX2A7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICBjb25zdCBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sICgpID0+IHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgYCArXG4gICAgICAgICAgICBgb3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBgICtcbiAgICAgICAgICAgIGBpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXCIke2tleX1cImAsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgLy8gIzY1NzQgaW4gY2FzZSB0aGUgaW5qZWN0IG9iamVjdCBpcyBvYnNlcnZlZC4uLlxuICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIGNvbnRpbnVlXG4gICAgICBjb25zdCBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIGxldCBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgaGFzT3duKHNvdXJjZS5fcHJvdmlkZWQsIHByb3ZpZGVLZXkpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgY29uc3QgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXG4gICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oYEluamVjdGlvbiBcIiR7a2V5fVwiIG5vdCBmb3VuZGAsIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cbiAgY29uc3Qgc2xvdHMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICBjb25zdCBuYW1lID0gZGF0YS5zbG90O1xuICAgICAgY29uc3Qgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgZm9yIChjb25zdCBuYW1lIGluIHNsb3RzKSB7XG4gICAgaWYgKHNsb3RzW25hbWVdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgIGRlbGV0ZSBzbG90c1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIG5vcm1hbFNsb3RzLFxuICBwcmV2U2xvdHNcbikge1xuICBsZXQgcmVzO1xuICBpZiAoIXNsb3RzKSB7XG4gICAgcmVzID0ge307XG4gIH0gZWxzZSBpZiAoc2xvdHMuX25vcm1hbGl6ZWQpIHtcbiAgICAvLyBmYXN0IHBhdGggMTogY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlciBvbmx5LCBwYXJlbnQgZGlkIG5vdCBjaGFuZ2VcbiAgICByZXR1cm4gc2xvdHMuX25vcm1hbGl6ZWRcbiAgfSBlbHNlIGlmIChcbiAgICBzbG90cy4kc3RhYmxlICYmXG4gICAgcHJldlNsb3RzICYmXG4gICAgcHJldlNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgIE9iamVjdC5rZXlzKG5vcm1hbFNsb3RzKS5sZW5ndGggPT09IDBcbiAgKSB7XG4gICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxuICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgIHJldHVybiBwcmV2U2xvdHNcbiAgfSBlbHNlIHtcbiAgICByZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgaWYgKHNsb3RzW2tleV0gJiYga2V5WzBdICE9PSAnJCcpIHtcbiAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXksIHNsb3RzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBleHBvc2Ugbm9ybWFsIHNsb3RzIG9uIHNjb3BlZFNsb3RzXG4gIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbFNsb3RzKSB7XG4gICAgaWYgKCEoa2V5IGluIHJlcykpIHtcbiAgICAgIHJlc1trZXldID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBhdm9yaWF6IHNlZW1zIHRvIG1vY2sgYSBub24tZXh0ZW5zaWJsZSAkc2NvcGVkU2xvdHMgb2JqZWN0XG4gIC8vIGFuZCB3aGVuIHRoYXQgaXMgcGFzc2VkIGRvd24gdGhpcyB3b3VsZCBjYXVzZSBhbiBlcnJvclxuICBpZiAoc2xvdHMgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShzbG90cykpIHtcbiAgICAoc2xvdHMpLl9ub3JtYWxpemVkID0gcmVzO1xuICB9XG4gIGRlZihyZXMsICckc3RhYmxlJywgc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiB0cnVlKTtcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPyBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpIDogZm4oe30pO1xuICAgIHJlcyA9IHJlcyAmJiB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShyZXMpXG4gICAgICA/IFtyZXNdIC8vIHNpbmdsZSB2bm9kZVxuICAgICAgOiBub3JtYWxpemVDaGlsZHJlbihyZXMpO1xuICAgIHJldHVybiByZXMgJiYgcmVzLmxlbmd0aCA9PT0gMFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogcmVzXG4gIH07XG4gIC8vIHRoaXMgaXMgYSBzbG90IHVzaW5nIHRoZSBuZXcgdi1zbG90IHN5bnRheCB3aXRob3V0IHNjb3BlLiBhbHRob3VnaCBpdCBpc1xuICAvLyBjb21waWxlZCBhcyBhIHNjb3BlZCBzbG90LCByZW5kZXIgZm4gdXNlcnMgd291bGQgZXhwZWN0IGl0IHRvIGJlIHByZXNlbnRcbiAgLy8gb24gdGhpcy4kc2xvdHMgYmVjYXVzZSB0aGUgdXNhZ2UgaXMgc2VtYW50aWNhbGx5IGEgbm9ybWFsIHNsb3QuXG4gIGlmIChmbi5wcm94eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxTbG90cywga2V5LCB7XG4gICAgICBnZXQ6IG5vcm1hbGl6ZWQsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRcbn1cblxuZnVuY3Rpb24gcHJveHlOb3JtYWxTbG90KHNsb3RzLCBrZXkpIHtcbiAgcmV0dXJuICgpID0+IHNsb3RzW2tleV1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgbGV0IHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBpZiAoaGFzU3ltYm9sICYmIHZhbFtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBbXTtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIGNvbnN0IHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBsZXQgbm9kZXM7XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIG5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV0gfHwgZmFsbGJhY2s7XG4gIH1cblxuICBjb25zdCB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xuICBpZiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2ggKGV4cGVjdCwgYWN0dWFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdCkpIHtcbiAgICByZXR1cm4gZXhwZWN0LmluZGV4T2YoYWN0dWFsKSA9PT0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhwZWN0ICE9PSBhY3R1YWxcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbktleUNvZGUsXG4gIGV2ZW50S2V5TmFtZSxcbiAgYnVpbHRJbktleU5hbWVcbikge1xuICBjb25zdCBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgbGV0IGhhc2g7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSAmJiAhKGNhbWVsaXplZEtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvbltgdXBkYXRlOiR7Y2FtZWxpemVkS2V5fWBdID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgY29uc3QgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICBsZXQgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCBgX19zdGF0aWNfXyR7aW5kZXh9YCwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCBgX19vbmNlX18ke2luZGV4fSR7a2V5ID8gYF8ke2tleX1gIDogYGB9YCwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgYCR7a2V5fV8ke2l9YCwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIGNvbnN0IG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgaGFzRHluYW1pY0tleXMsXG4gIHJlc1xuKSB7XG4gIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNsb3QgPSBmbnNbaV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2xvdCkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhzbG90LCBoYXNEeW5hbWljS2V5cywgcmVzKTtcbiAgICB9IGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgIC8vIG1hcmtlciBmb3IgcmV2ZXJzZSBwcm94eWluZyB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgICAgaWYgKHNsb3QucHJveHkpIHtcbiAgICAgICAgc2xvdC5mbi5wcm94eSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXNbc2xvdC5rZXldID0gc2xvdC5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBjb25zdCBrZXkgPSB2YWx1ZXNbaV07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICB9IGVsc2UgaWYgKGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAvLyBudWxsIGlzIGEgc3BlaWNhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgIHdhcm4oXG4gICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCAoZXhwZWN0ZWQgc3RyaW5nIG9yIG51bGwpOiAke2tleX1gLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZU9ialxufVxuXG4vLyBoZWxwZXIgdG8gZHluYW1pY2FsbHkgYXBwZW5kIG1vZGlmaWVyIHJ1bnRpbWUgbWFya2VycyB0byBldmVudCBuYW1lcy5cbi8vIGVuc3VyZSBvbmx5IGFwcGVuZCB3aGVuIHZhbHVlIGlzIGFscmVhZHkgc3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYXN0XG4vLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXIgKHZhbHVlLCBzeW1ib2wpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzeW1ib2wgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xuICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XG4gIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICBjb25zdCBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgbGV0IGNvbnRleHRWbTtcbiAgaWYgKGhhc093bihwYXJlbnQsICdfdWlkJykpIHtcbiAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgY29udGV4dFZtLl9vcmlnaW5hbCA9IHBhcmVudDtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cbiAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcbiAgICAvLyByZWFsIGNvbnRleHQgaW5zdGFuY2UuXG4gICAgY29udGV4dFZtID0gcGFyZW50O1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gIH1cbiAgY29uc3QgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIGNvbnN0IG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLiRzbG90cykge1xuICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIGRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHRoaXMuJHNsb3RzID0gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kc2xvdHNcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywgKHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldCAoKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKVxuICAgIH1cbiAgfSkpO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSAoYSwgYiwgYywgZCkgPT4ge1xuICAgICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSAoYSwgYiwgYywgZCkgPT4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgY29uc3QgcHJvcHMgPSB7fTtcbiAgY29uc3QgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTtcbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpO1xuICB9XG5cbiAgY29uc3QgcmVuZGVyQ29udGV4dCA9IG5ldyBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChcbiAgICBkYXRhLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbnRleHRWbSxcbiAgICBDdG9yXG4gICk7XG5cbiAgY29uc3Qgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgY29uc3Qgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW2ldID0gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZXNbaV0sIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQgKHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpIHtcbiAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcbiAgLy8gKGUuZy4gaXQgd2FzIGZyb20gYSBjYWNoZWQgbm9ybWFsIHNsb3QpIHRoZSBmbkNvbnRleHQgY2F1c2VzIG5hbWVkIHNsb3RzXG4gIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxuICBjb25zdCBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIHtcbiAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcbiAgfVxuICBpZiAoZGF0YS5zbG90KSB7XG4gICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbmNvbnN0IGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICBpZiAoXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICApIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgY29uc3QgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGNvbnN0IGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQgKHZub2RlKSB7XG4gICAgY29uc3QgeyBjb250ZXh0LCBjb21wb25lbnRJbnN0YW5jZSB9ID0gdm5vZGU7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgY29uc3QgeyBjb21wb25lbnRJbnN0YW5jZSB9ID0gdm5vZGU7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuY29uc3QgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHdhcm4oYEludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246ICR7U3RyaW5nKEN0b3IpfWAsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICBsZXQgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3Rvcik7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIGNvbnN0IHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICBjb25zdCBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgY29uc3Qgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5zdGFsbCBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICBjb25zdCBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICBjb25zdCB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICBgdnVlLWNvbXBvbmVudC0ke0N0b3IuY2lkfSR7bmFtZSA/IGAtJHtuYW1lfWAgOiAnJ31gLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yLCBwcm9wc0RhdGEsIGxpc3RlbmVycywgdGFnLCBjaGlsZHJlbiB9LFxuICAgIGFzeW5jRmFjdG9yeVxuICApO1xuXG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgcGFyZW50XG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIGNvbnN0IGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyAoZGF0YSkge1xuICBjb25zdCBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICBjb25zdCBleGlzdGluZyA9IGhvb2tzW2tleV07XG4gICAgY29uc3QgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xuICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKGYxLCBmMikge1xuICBjb25zdCBtZXJnZWQgPSAoYSwgYikgPT4ge1xuICAgIC8vIGZsb3cgY29tcGxhaW5zIGFib3V0IGV4dHJhIGFyZ3Mgd2hpY2ggaXMgd2h5IHdlIHVzZSBhbnlcbiAgICBmMShhLCBiKTtcbiAgICBmMihhLCBiKTtcbiAgfTtcbiAgbWVyZ2VkLl9tZXJnZWQgPSB0cnVlO1xuICByZXR1cm4gbWVyZ2VkXG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgY29uc3QgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgY29uc3QgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnXG4gIDsoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICBjb25zdCBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGNvbnN0IGV4aXN0aW5nID0gb25bZXZlbnRdO1xuICBjb25zdCBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIGlmIChpc0RlZihleGlzdGluZykpIHtcbiAgICBpZiAoXG4gICAgICBBcnJheS5pc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxuICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFja1xuICAgICkge1xuICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBjYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxuY29uc3QgU0lNUExFX05PUk1BTElaRSA9IDE7XG5jb25zdCBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHdhcm4oXG4gICAgICBgQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1cXG5gICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgbGV0IHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgbGV0IEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKCFkYXRhIHx8ICFkYXRhLnByZSkgJiYgaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChpc0RlZihucykpIGFwcGx5TlModm5vZGUsIG5zKTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpO1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIGZvcmNlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICBjb25zdCBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICBjb25zdCByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gKGEsIGIsIGMsIGQpID0+IGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IChhLCBiLCBjLCBkKSA9PiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIGNvbnN0IHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgKCkgPT4ge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKGAkYXR0cnMgaXMgcmVhZG9ubHkuYCwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgKCkgPT4ge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKGAkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LmAsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfVxufVxuXG5sZXQgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcmVuZGVyLCBfcGFyZW50Vm5vZGUgfSA9IHZtLiRvcHRpb25zO1xuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICB2bS4kc2xvdHMsXG4gICAgICAgIHZtLiRzY29wZWRTbG90c1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgbGV0IHZub2RlO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gbWFpbnRhaW4gYSBzdGFjayBiZWNhdWVzIGFsbCByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHNlcGFyYXRlbHkgZnJvbSBvbmUgYW5vdGhlci4gTmVzdGVkIGNvbXBvbmVudCdzIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gd2hlbiBwYXJlbnQgY29tcG9uZW50IGlzIHBhdGNoZWQuXG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGByZW5kZXJgKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgYHJlbmRlckVycm9yYCk7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgcmV0dXJuZWQgYXJyYXkgY29udGFpbnMgb25seSBhIHNpbmdsZSBub2RlLCBhbGxvdyBpdFxuICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZub2RlID0gdm5vZGVbMF07XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGNvbnN0IG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3Jcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBjb25zdCBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKGlzRGVmKGZhY3Rvcnkub3duZXJzKSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcbiAgICBsZXQgc3luYyA9IHRydWU7XG5cbiAgICBjb25zdCBmb3JjZVJlbmRlciA9IChyZW5kZXJDb21wbGV0ZWQpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAob3duZXJzW2ldKS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVzb2x2ZSA9IG9uY2UoKHJlcykgPT4ge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHJlamVjdCA9IG9uY2UocmVhc29uID0+IHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6ICR7U3RyaW5nKGZhY3RvcnkpfWAgK1xuICAgICAgICAocmVhc29uID8gYFxcblJlYXNvbjogJHtyZWFzb259YCA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UocmVzLmNvbXBvbmVudCkpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgYHRpbWVvdXQgKCR7cmVzLnRpbWVvdXR9bXMpYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgY29uc3QgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG5sZXQgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGV2ZW50LCBmbikge1xuICBjb25zdCBfdGFyZ2V0ID0gdGFyZ2V0O1xuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIGNvbnN0IHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICBjb25zdCBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdm0uJG9mZihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgY29uc3QgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoIWZuKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIGxldCBjYjtcbiAgICBsZXQgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIHtcbiAgICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgYCArXG4gICAgICAgICAgYCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bSl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIGAgK1xuICAgICAgICAgIGBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBgICtcbiAgICAgICAgICBgdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIGAgK1xuICAgICAgICAgIGBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7aHlwaGVuYXRlKGV2ZW50KX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIGNvbnN0IGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBjb25zdCBpbmZvID0gYGV2ZW50IGhhbmRsZXIgZm9yIFwiJHtldmVudH1cImA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2JzW2ldLCB2bSwgYXJncywgdm0sIGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbmxldCBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5sZXQgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XG4gIGNvbnN0IHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICBsZXQgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBjb25zdCBwcmV2RWwgPSB2bS4kZWw7XG4gICAgY29uc3QgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIGNvbnN0IHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHZtKTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyh2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIGNvbnN0IHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIGxldCBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgbGV0IHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIGNvbnN0IGlkID0gdm0uX3VpZDtcbiAgICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS1wZXJmLXN0YXJ0OiR7aWR9YDtcbiAgICAgIGNvbnN0IGVuZFRhZyA9IGB2dWUtcGVyZi1lbmQ6JHtpZH1gO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIGNvbnN0IHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZShgdnVlICR7bmFtZX0gcmVuZGVyYCwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoYHZ1ZSAke25hbWV9IHBhdGNoYCwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB7XG4gICAgYmVmb3JlICgpIHtcbiAgICAgIGlmICh2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRydWUgLyogaXNSZW5kZXJXYXRjaGVyICovKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cblxuICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZHluYW1pYyBzY29wZWRTbG90cyAoaGFuZC13cml0dGVuIG9yIGNvbXBpbGVkIGJ1dCB3aXRoXG4gIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXG4gIC8vIFwiJHN0YWJsZVwiIG1hcmtlci5cbiAgY29uc3QgaGFzRHluYW1pY1Njb3BlZFNsb3QgPSAhIShcbiAgICAocGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyAmJiAhcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgICh2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmICF2bS4kc2NvcGVkU2xvdHMuJHN0YWJsZSlcbiAgKTtcblxuICAvLyBBbnkgc3RhdGljIHNsb3QgY2hpbGRyZW4gZnJvbSB0aGUgcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgZHVyaW5nIHBhcmVudCdzXG4gIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxuICAvLyB1cGRhdGUgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBjb3JyZWN0bmVzcy5cbiAgY29uc3QgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgaGFzRHluYW1pY1Njb3BlZFNsb3RcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgY29uc3QgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgY29uc3QgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBjb25zdCBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIGNvbnN0IG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuXG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIGNvbnN0IGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGNvbnN0IGluZm8gPSBgJHtob29rfSBob29rYDtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGhhbmRsZXJzW2ldLCB2bSwgbnVsbCwgdm0sIGluZm8pO1xuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbn1cblxuLyogICovXG5cbmNvbnN0IE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbmNvbnN0IHF1ZXVlID0gW107XG5jb25zdCBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xubGV0IGhhcyA9IHt9O1xubGV0IGNpcmN1bGFyID0ge307XG5sZXQgd2FpdGluZyA9IGZhbHNlO1xubGV0IGZsdXNoaW5nID0gZmFsc2U7XG5sZXQgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBBc3luYyBlZGdlIGNhc2UgIzY1NjYgcmVxdWlyZXMgc2F2aW5nIHRoZSB0aW1lc3RhbXAgd2hlbiBldmVudCBsaXN0ZW5lcnMgYXJlXG4vLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcbi8vIGlmIHRoZSBwYWdlIGhhcyB0aG91c2FuZHMgb2YgZXZlbnQgbGlzdGVuZXJzLiBJbnN0ZWFkLCB3ZSB0YWtlIGEgdGltZXN0YW1wXG4vLyBldmVyeSB0aW1lIHRoZSBzY2hlZHVsZXIgZmx1c2hlcyBhbmQgdXNlIHRoYXQgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnNcbi8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxubGV0IGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IDA7XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG5sZXQgZ2V0Tm93ID0gRGF0ZS5ub3c7XG5cbi8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXG4vLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXG5pZiAoaW5Ccm93c2VyICYmIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wKSB7XG4gIC8vIGlmIHRoZSBsb3ctcmVzIHRpbWVzdGFtcCB3aGljaCBpcyBiaWdnZXIgdGhhbiB0aGUgZXZlbnQgdGltZXN0YW1wXG4gIC8vICh3aGljaCBpcyBldmFsdWF0ZWQgQUZURVIpIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIHVzZSB0aGUgaGktcmVzIHZlcnNpb24gZm9yIGV2ZW50IGxpc3RlbmVycyBhcyB3ZWxsLlxuICBnZXROb3cgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIGxldCB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xuICAgICAgd2F0Y2hlci5iZWZvcmUoKTtcbiAgICB9XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IE1BWF9VUERBVEVfQ09VTlQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyBgaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXCIke3dhdGNoZXIuZXhwcmVzc2lvbn1cImBcbiAgICAgICAgICAgICAgOiBgaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLmBcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIGNvbnN0IGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgY29uc3QgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cbiAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGxldCBpID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIGNvbnN0IHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICBjb25zdCBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgbGV0IGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgZmx1c2hTY2hlZHVsZXJRdWV1ZSgpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbmxldCB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbmNsYXNzIFdhdGNoZXIge1xuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG5cbiAgY29uc3RydWN0b3IgKFxuICAgIHZtLFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9ucyxcbiAgICBpc1JlbmRlcldhdGNoZXJcbiAgKSB7XG4gICAgdGhpcy52bSA9IHZtO1xuICAgIGlmIChpc1JlbmRlcldhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgICB9XG4gICAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gICAgLy8gb3B0aW9uc1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmNiID0gY2I7XG4gICAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gICAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cE9yRm4udG9TdHJpbmcoKTtcbiAgICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICAgIHRoaXMuZ2V0dGVyID0gbm9vcDtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFwiJHtleHBPckZufVwiIGAgK1xuICAgICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiB0aGlzLmdldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGdldCAoKSB7XG4gICAgcHVzaFRhcmdldCh0aGlzKTtcbiAgICBsZXQgdmFsdWU7XG4gICAgY29uc3Qgdm0gPSB0aGlzLnZtO1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBgZ2V0dGVyIGZvciB3YXRjaGVyIFwiJHt0aGlzLmV4cHJlc3Npb259XCJgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gICAqL1xuICBhZGREZXAgKGRlcCkge1xuICAgIGNvbnN0IGlkID0gZGVwLmlkO1xuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAgICovXG4gIGNsZWFudXBEZXBzICgpIHtcbiAgICBsZXQgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY29uc3QgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgdG1wID0gdGhpcy5kZXBJZHM7XG4gICAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICAgIHRtcCA9IHRoaXMuZGVwcztcbiAgICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gICAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICAgIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICAgKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICAgKi9cbiAgdXBkYXRlICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0aGlzLmxhenkpIHtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgICB0aGlzLnJ1bigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICAgKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICAgKi9cbiAgcnVuICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgdGhpcy5kZWVwXG4gICAgICApIHtcbiAgICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCBgY2FsbGJhY2sgZm9yIHdhdGNoZXIgXCIke3RoaXMuZXhwcmVzc2lvbn1cImApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gICAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAgICovXG4gIGV2YWx1YXRlICgpIHtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gICAqL1xuICBkZXBlbmQgKCkge1xuICAgIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICAgKi9cbiAgdGVhcmRvd24gKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgICAgfVxuICAgICAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmNvbnN0IHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICBjb25zdCBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpO1xuICBpZiAob3B0cy5tZXRob2RzKSBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTtcbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgY29uc3QgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICBjb25zdCBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgY29uc3Qga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICBjb25zdCBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIGlmICghaXNSb290KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICB7XG4gICAgICBjb25zdCBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBcIiR7aHlwaGVuYXRlZEtleX1cIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuYCxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsICgpID0+IHtcbiAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIGAgK1xuICAgICAgICAgICAgYG92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIGAgK1xuICAgICAgICAgICAgYEluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBgICtcbiAgICAgICAgICAgIGB2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgYF9wcm9wc2AsIGtleSk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIGxldCBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICBjb25zdCBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBjb25zdCBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5gLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBUaGUgZGF0YSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBgICtcbiAgICAgICAgYFVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5gLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBgX2RhdGFgLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBgZGF0YSgpYCk7XG4gICAgcmV0dXJuIHt9XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxuY29uc3QgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgY29uc3Qgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIGNvbnN0IGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZCkge1xuICAgIGNvbnN0IHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIGNvbnN0IGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgYEdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiLmAsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgIHZtLFxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybihgVGhlIGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuYCwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybihgVGhlIGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5gLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgdGFyZ2V0LFxuICBrZXksXG4gIHVzZXJEZWZcbikge1xuICBjb25zdCBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xuICB9XG4gIGlmIChzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5gLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgY29uc3Qgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHRoaXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIGNvbnN0IHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZHNba2V5XX1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIGAgK1xuICAgICAgICAgIGBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2AsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5gLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIGAgK1xuICAgICAgICAgIGBBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdm1ba2V5XSA9IHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaCkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIGNvbnN0IGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIGNvbnN0IHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKGAkcHJvcHMgaXMgcmVhZG9ubHkuYCwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgY29uc3Qgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVycm9yLCB2bSwgYGNhbGxiYWNrIGZvciBpbW1lZGlhdGUgd2F0Y2hlciBcIiR7d2F0Y2hlci5leHByZXNzaW9ufVwiYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmxldCB1aWQkMyA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgbGV0IHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IGB2dWUtcGVyZi1zdGFydDoke3ZtLl91aWR9YDtcbiAgICAgIGVuZFRhZyA9IGB2dWUtcGVyZi1lbmQ6JHt2bS5fdWlkfWA7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKGB2dWUgJHt2bS5fbmFtZX0gaW5pdGAsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgY29uc3QgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICBjb25zdCB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIGxldCBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIGNvbnN0IHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgY29uc3QgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgY29uc3QgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIGxldCBtb2RpZmllZDtcbiAgY29uc3QgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICBjb25zdCBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAoY29uc3Qga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIG1vZGlmaWVkID0ge307XG4gICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBWdWUgKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5yZW5kZXJNaXhpbihWdWUpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICBjb25zdCBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgbGV0IGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBTdXBlciA9IHRoaXM7XG4gICAgY29uc3QgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICBjb25zdCBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIGNvbnN0IFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgY29uc3QgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIGBfcHJvcHNgLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIGNvbnN0IGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgY29uc3QgeyBjYWNoZSwga2V5cywgX3Zub2RlIH0gPSBrZWVwQWxpdmVJbnN0YW5jZTtcbiAgZm9yIChjb25zdCBrZXkgaW4gY2FjaGUpIHtcbiAgICBjb25zdCBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXG4gIGNhY2hlLFxuICBrZXksXG4gIGtleXMsXG4gIGN1cnJlbnRcbikge1xuICBjb25zdCBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICBpZiAoY2FjaGVkJCQxICYmICghY3VycmVudCB8fCBjYWNoZWQkJDEudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZVtrZXldID0gbnVsbDtcbiAgcmVtb3ZlKGtleXMsIGtleSk7XG59XG5cbmNvbnN0IHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQgKCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQgKCkge1xuICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgdmFsID0+IHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcywgbmFtZSA9PiBtYXRjaGVzKHZhbCwgbmFtZSkpO1xuICAgIH0pO1xuICAgIHRoaXMuJHdhdGNoKCdleGNsdWRlJywgdmFsID0+IHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcywgbmFtZSA9PiAhbWF0Y2hlcyh2YWwsIG5hbWUpKTtcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGNvbnN0IHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICBjb25zdCBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUgfSA9IHRoaXM7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgY2FjaGUsIGtleXMgfSA9IHRoaXM7XG4gICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IGA6OiR7Y29tcG9uZW50T3B0aW9ucy50YWd9YCA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIGNvbnN0IGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gKCkgPT4gY29uZmlnO1xuICB7XG4gICAgY29uZmlnRGVmLnNldCA9ICgpID0+IHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm4sXG4gICAgZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgVnVlLm9ic2VydmFibGUgPSAob2JqKSA9PiB7XG4gICAgb2JzZXJ2ZShvYmopO1xuICAgIHJldHVybiBvYmpcbiAgfTtcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2godHlwZSA9PiB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxufSk7XG5cblZ1ZS52ZXJzaW9uID0gJzIuNi42JztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG5jb25zdCBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbmNvbnN0IGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xuY29uc3QgbXVzdFVzZVByb3AgPSAodGFnLCB0eXBlLCBhdHRyKSA9PiB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxuY29uc3QgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG5jb25zdCBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUgPSBtYWtlTWFwKCdldmVudHMsY2FyZXQsdHlwaW5nLHBsYWludGV4dC1vbmx5Jyk7XG5cbmNvbnN0IGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICByZXR1cm4gaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZSdcbiAgICA/ICdmYWxzZSdcbiAgICAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcbiAgICA6IGtleSA9PT0gJ2NvbnRlbnRlZGl0YWJsZScgJiYgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlKHZhbHVlKVxuICAgICAgPyB2YWx1ZVxuICAgICAgOiAndHJ1ZSdcbn07XG5cbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG5jb25zdCB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG5jb25zdCBpc1hsaW5rID0gKG5hbWUpID0+IHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxuY29uc3QgZ2V0WGxpbmtQcm9wID0gKG5hbWUpID0+IHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG5jb25zdCBpc0ZhbHN5QXR0clZhbHVlID0gKHZhbCkgPT4ge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIGxldCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgbGV0IHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgbGV0IGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICBsZXQgcmVzID0gJyc7XG4gIGxldCBzdHJpbmdpZmllZDtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgcmVzICs9ICcgJztcbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gIGxldCByZXMgPSAnJztcbiAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgcmVzICs9ICcgJztcbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmNvbnN0IG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbmNvbnN0IGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxuY29uc3QgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxuY29uc3QgaXNQcmVUYWcgPSAodGFnKSA9PiB0YWcgPT09ICdwcmUnO1xuXG5jb25zdCBpc1Jlc2VydmVkVGFnID0gKHRhZykgPT4ge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxuY29uc3QgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbmNvbnN0IGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgY29uc3QgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xufVxuXG52YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgdGFnTmFtZTogdGFnTmFtZSxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICBzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIGNvbnN0IGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWlzRGVmKGtleSkpIHJldHVyblxuXG4gIGNvbnN0IHZtID0gdm5vZGUuY29udGV4dDtcbiAgY29uc3QgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICBjb25zdCByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG5jb25zdCBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbmNvbnN0IGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHJldHVybiB0cnVlXG4gIGxldCBpO1xuICBjb25zdCB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIGNvbnN0IHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIGxldCBpLCBrZXk7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgbWFwW2tleV0gPSBpO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICBsZXQgaSwgajtcbiAgY29uc3QgY2JzID0ge307XG5cbiAgY29uc3QgeyBtb2R1bGVzLCBub2RlT3BzIH0gPSBiYWNrZW5kO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoaWdub3JlID0+IHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgbGV0IGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICBmdW5jdGlvbiBjcmVhdGVFbG0gKFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtLFxuICAgIG5lc3RlZCxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4XG4gICkge1xuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGxldCBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGNvbnN0IGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgbGV0IGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIGxldCBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUsIGNoaWxkcmVuLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUudGV4dCkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIGxldCBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICBsZXQgaSwgajtcbiAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgaSh2bm9kZSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIGNicy5kZXN0cm95W2ldKHZub2RlKTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNvbnN0IGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIGxldCBpO1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBsZXQgb2xkU3RhcnRJZHggPSAwO1xuICAgIGxldCBuZXdTdGFydElkeCA9IDA7XG4gICAgbGV0IG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgbGV0IG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICBsZXQgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIGxldCBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIGxldCBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgbGV0IG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICBsZXQgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgY29uc3QgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAge1xuICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcbiAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxuICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGVUb01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgY29uc3Qgc2VlbktleXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29uc3Qga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYER1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnJHtrZXl9Jy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLmAsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChcbiAgICBvbGRWbm9kZSxcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleCxcbiAgICByZW1vdmVPbmx5XG4gICkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBjbG9uZSByZXVzZWQgdm5vZGVcbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBpO1xuICAgIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICBjb25zdCBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpIHtcbiAgICBsZXQgaTtcbiAgICBjb25zdCB7IHRhZywgZGF0YSwgY2hpbGRyZW4gfSA9IHZub2RlO1xuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgbGV0IGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgY29uc3QgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgY29uc3Qgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICBjb25zdCBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICBsZXQgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgY29uc3QgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICBjb25zdCBpbnNlcnQgPSBhbmNlc3Rvci5kYXRhLmhvb2suaW5zZXJ0O1xuICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGluZGV4IDEgdG8gYXZvaWQgcmUtaW52b2tpbmcgY29tcG9uZW50IG1vdW50ZWQgaG9va1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGNvbnN0IGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgY29uc3QgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgY29uc3Qgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICBjb25zdCBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgY29uc3QgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgY29uc3QgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICBsZXQga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGRpci5vbGRBcmcgPSBvbGREaXIuYXJnO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgY29uc3QgY2FsbEluc2VydCA9ICgpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsICgpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICBjb25zdCByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgbGV0IGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgYCR7ZGlyLm5hbWV9LiR7T2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpfWBcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICBjb25zdCBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgYGRpcmVjdGl2ZSAke2Rpci5uYW1lfSAke2hvb2t9IGhvb2tgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGNvbnN0IG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQga2V5LCBjdXIsIG9sZDtcbiAgY29uc3QgZWxtID0gdm5vZGUuZWxtO1xuICBjb25zdCBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIGxldCBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICBjb25zdCBibG9ja2VyID0gZSA9PiB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICBjb25zdCBlbCA9IHZub2RlLmVsbTtcbiAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gIGNvbnN0IG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICBjb25zdCB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbmNvbnN0IHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIGxldCBpblNpbmdsZSA9IGZhbHNlO1xuICBsZXQgaW5Eb3VibGUgPSBmYWxzZTtcbiAgbGV0IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgbGV0IGluUmVnZXggPSBmYWxzZTtcbiAgbGV0IGN1cmx5ID0gMDtcbiAgbGV0IHNxdWFyZSA9IDA7XG4gIGxldCBwYXJlbiA9IDA7XG4gIGxldCBsYXN0RmlsdGVySW5kZXggPSAwO1xuICBsZXQgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSBpbkRvdWJsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgaW5SZWdleCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgbGV0IGogPSBpIC0gMTtcbiAgICAgICAgbGV0IHA7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgY29uc3QgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIGBfZihcIiR7ZmlsdGVyfVwiKSgke2V4cH0pYFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgY29uc3QgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIGBfZihcIiR7bmFtZX1cIikoJHtleHB9JHthcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJnc31gXG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZywgcmFuZ2UpIHtcbiAgY29uc29sZS5lcnJvcihgW1Z1ZSBjb21waWxlcl06ICR7bXNnfWApO1xufVxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKG0gPT4gbVtrZXldKS5maWx0ZXIoXyA9PiBfKVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWUsIHZhbHVlLCBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgY29uc3QgYXR0cnMgPSBkeW5hbWljXG4gICAgPyAoZWwuZHluYW1pY0F0dHJzIHx8IChlbC5keW5hbWljQXR0cnMgPSBbXSkpXG4gICAgOiAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKTtcbiAgYXR0cnMucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lLCB2YWx1ZSwgZHluYW1pYyB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG4vLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcbmZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UpIHtcbiAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcbiAgZWwuYXR0cnNMaXN0LnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZSwgdmFsdWUgfSwgcmFuZ2UpKTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIGlzRHluYW1pY0FyZyxcbiAgbW9kaWZpZXJzLFxuICByYW5nZVxuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7XG4gICAgbmFtZSxcbiAgICByYXdOYW1lLFxuICAgIHZhbHVlLFxuICAgIGFyZyxcbiAgICBpc0R5bmFtaWNBcmcsXG4gICAgbW9kaWZpZXJzXG4gIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllck1hcmtlciAoc3ltYm9sLCBuYW1lLCBkeW5hbWljKSB7XG4gIHJldHVybiBkeW5hbWljXG4gICAgPyBgX3AoJHtuYW1lfSxcIiR7c3ltYm9sfVwiKWBcbiAgICA6IHN5bWJvbCArIG5hbWUgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gIGVsLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzLFxuICBpbXBvcnRhbnQsXG4gIHdhcm4sXG4gIHJhbmdlLFxuICBkeW5hbWljXG4pIHtcbiAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICB3YXJuICYmXG4gICAgbW9kaWZpZXJzLnByZXZlbnQgJiYgbW9kaWZpZXJzLnBhc3NpdmVcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdwYXNzaXZlIGFuZCBwcmV2ZW50IGNhblxcJ3QgYmUgdXNlZCB0b2dldGhlci4gJyArXG4gICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LicsXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cblxuICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcbiAgLy8gdGhpcyBpcyB0ZWNobmljYWxseSBicm93c2VyLXNwZWNpZmljLCBidXQgYXQgbGVhc3QgZm9yIG5vdyBicm93c2VycyBhcmVcbiAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gIGlmIChtb2RpZmllcnMucmlnaHQpIHtcbiAgICBpZiAoZHluYW1pYykge1xuICAgICAgbmFtZSA9IGAoJHtuYW1lfSk9PT0nY2xpY2snPydjb250ZXh0bWVudSc6KCR7bmFtZX0pYDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gYCgke25hbWV9KT09PSdjbGljayc/J21vdXNldXAnOigke25hbWV9KWA7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyEnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignficsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignJicsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG5cbiAgbGV0IGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIGNvbnN0IG5ld0hhbmRsZXIgPSByYW5nZVNldEl0ZW0oeyB2YWx1ZTogdmFsdWUudHJpbSgpLCBkeW5hbWljIH0sIHJhbmdlKTtcbiAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcbiAgICBuZXdIYW5kbGVyLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG5cbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmF3QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHJldHVybiBlbC5yYXdBdHRyc01hcFsnOicgKyBuYW1lXSB8fFxuICAgIGVsLnJhd0F0dHJzTWFwWyd2LWJpbmQ6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbbmFtZV1cbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgY29uc3QgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgY29uc3Qgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vLyBub3RlOiB0aGlzIG9ubHkgcmVtb3ZlcyB0aGUgYXR0ciBmcm9tIHRoZSBBcnJheSAoYXR0cnNMaXN0KSBzbyB0aGF0IGl0XG4vLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4vLyBuZWVkZWQgZHVyaW5nIGNvZGVnZW4uXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJlbW92ZUZyb21NYXBcbikge1xuICBsZXQgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgY29uc3QgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlRnJvbU1hcCkge1xuICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IChcbiAgZWwsXG4gIG5hbWVcbikge1xuICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgYXR0ciA9IGxpc3RbaV07XG4gICAgaWYgKG5hbWUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgIHJldHVybiBhdHRyXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJhbmdlU2V0SXRlbSAoXG4gIGl0ZW0sXG4gIHJhbmdlXG4pIHtcbiAgaWYgKHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgIGl0ZW0uc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICB9XG4gICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XG4gICAgICBpdGVtLmVuZCA9IHJhbmdlLmVuZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW1cbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgeyBudW1iZXIsIHRyaW0gfSA9IG1vZGlmaWVycyB8fCB7fTtcblxuICBjb25zdCBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIGxldCB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBgKHR5cGVvZiAke2Jhc2VWYWx1ZUV4cHJlc3Npb259ID09PSAnc3RyaW5nJ2AgK1xuICAgICAgYD8gJHtiYXNlVmFsdWVFeHByZXNzaW9ufS50cmltKClgICtcbiAgICAgIGA6ICR7YmFzZVZhbHVlRXhwcmVzc2lvbn0pYDtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gYF9uKCR7dmFsdWVFeHByZXNzaW9ufSlgO1xuICB9XG4gIGNvbnN0IGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogYCgke3ZhbHVlfSlgLFxuICAgIGV4cHJlc3Npb246IEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgICBjYWxsYmFjazogYGZ1bmN0aW9uICgke2Jhc2VWYWx1ZUV4cHJlc3Npb259KSB7JHthc3NpZ25tZW50fX1gXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICBjb25zdCByZXMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKHJlcy5rZXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9PSR7YXNzaWdubWVudH1gXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAkc2V0KCR7cmVzLmV4cH0sICR7cmVzLmtleX0sICR7YXNzaWdubWVudH0pYFxuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSB2LW1vZGVsIGV4cHJlc3Npb24gaW50byBhIGJhc2UgcGF0aCBhbmQgYSBmaW5hbCBrZXkgc2VnbWVudC5cbiAqIEhhbmRsZXMgYm90aCBkb3QtcGF0aCBhbmQgcG9zc2libGUgc3F1YXJlIGJyYWNrZXRzLlxuICpcbiAqIFBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2tleV1cbiAqIC0gdGVzdFt0ZXN0MVtrZXldXVxuICogLSB0ZXN0W1wiYVwiXVtrZXldXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFba2V5XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtrZXldXVxuICpcbiAqL1xuXG5sZXQgbGVuLCBzdHIsIGNociwgaW5kZXgkMSwgZXhwcmVzc2lvblBvcywgZXhwcmVzc2lvbkVuZFBvcztcblxuXG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICAvLyBGaXggaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9wdWxsLzc3MzBcbiAgLy8gYWxsb3cgdi1tb2RlbD1cIm9iai52YWwgXCIgKHRyYWlsaW5nIHdoaXRlc3BhY2UpXG4gIHZhbCA9IHZhbC50cmltKCk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwsXG4gICAgICAgIGtleTogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0ciA9IHZhbDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXG4gICAga2V5OiB2YWwuc2xpY2UoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgbGV0IGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSBpbkJyYWNrZXQrKztcbiAgICBpZiAoY2hyID09PSAweDVEKSBpbkJyYWNrZXQtLTtcbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgY29uc3Qgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5sZXQgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxuY29uc3QgUkFOR0VfVE9LRU4gPSAnX19yJztcbmNvbnN0IENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgY29uc3QgdmFsdWUgPSBkaXIudmFsdWU7XG4gIGNvbnN0IG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIGNvbnN0IHRhZyA9IGVsLnRhZztcbiAgY29uc3QgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAge1xuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYDwke2VsLnRhZ30gdi1tb2RlbD1cIiR7dmFsdWV9XCIgdHlwZT1cImZpbGVcIj46XFxuYCArXG4gICAgICAgIGBGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLmAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHdhcm4kMShcbiAgICAgIGA8JHtlbC50YWd9IHYtbW9kZWw9XCIke3ZhbHVlfVwiPjogYCArXG4gICAgICBgdi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBgICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LicsXG4gICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICBjb25zdCBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgY29uc3QgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgY29uc3QgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgY29uc3QgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIGBBcnJheS5pc0FycmF5KCR7dmFsdWV9KWAgK1xuICAgIGA/X2koJHt2YWx1ZX0sJHt2YWx1ZUJpbmRpbmd9KT4tMWAgKyAoXG4gICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgPyBgOigke3ZhbHVlfSlgXG4gICAgICAgIDogYDpfcSgke3ZhbHVlfSwke3RydWVWYWx1ZUJpbmRpbmd9KWBcbiAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLFxuICAgIGB2YXIgJCRhPSR7dmFsdWV9LGAgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBgJCRjPSQkZWwuY2hlY2tlZD8oJHt0cnVlVmFsdWVCaW5kaW5nfSk6KCR7ZmFsc2VWYWx1ZUJpbmRpbmd9KTtgICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIGB2YXIgJCR2PSR7bnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmd9LGAgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBgaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKCR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuY29uY2F0KFskJHZdKScpfSl9YCArXG4gICAgICBgZWxzZXskJGk+LTEmJigke2dlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKX0pfWAgK1xuICAgIGB9ZWxzZXske2dlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJyl9fWAsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICBjb25zdCBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgbGV0IHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IGBfbigke3ZhbHVlQmluZGluZ30pYCA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCBgX3EoJHt2YWx1ZX0sJHt2YWx1ZUJpbmRpbmd9KWApO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGNvbnN0IG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICBjb25zdCBzZWxlY3RlZFZhbCA9IGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCArXG4gICAgYC5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pYCArXG4gICAgYC5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFwiX3ZhbHVlXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtgICtcbiAgICBgcmV0dXJuICR7bnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCd9fSlgO1xuXG4gIGNvbnN0IGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgbGV0IGNvZGUgPSBgdmFyICQkc2VsZWN0ZWRWYWwgPSAke3NlbGVjdGVkVmFsfTtgO1xuICBjb2RlID0gYCR7Y29kZX0gJHtnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCl9YDtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGNvbnN0IHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgLy8gZXhjZXB0IGZvciBpbnB1dHMgd2l0aCB2LWJpbmQ6dHlwZVxuICB7XG4gICAgY29uc3QgdmFsdWUgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gfHwgZWwuYXR0cnNNYXBbJzp2YWx1ZSddO1xuICAgIGNvbnN0IHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHZhbHVlICYmICF0eXBlQmluZGluZykge1xuICAgICAgY29uc3QgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGAke2JpbmRpbmd9PVwiJHt2YWx1ZX1cIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgYCArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5JyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgeyBsYXp5LCBudW1iZXIsIHRyaW0gfSA9IG1vZGlmaWVycyB8fCB7fTtcbiAgY29uc3QgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICBjb25zdCBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgbGV0IHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBgJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClgO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBgX24oJHt2YWx1ZUV4cHJlc3Npb259KWA7XG4gIH1cblxuICBsZXQgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gYGlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjske2NvZGV9YDtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIGAoJHt2YWx1ZX0pYCk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIGNvbnN0IGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxubGV0IHRhcmdldCQxO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciQxIChldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xuICBjb25zdCBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgY29uc3QgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbi8vICM5NDQ2OiBGaXJlZm94IDw9IDUzIChpbiBwYXJ0aWN1bGFyLCBFU1IgNTIpIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXG5jb25zdCB1c2VNaWNyb3Rhc2tGaXggPSBpc1VzaW5nTWljcm9UYXNrICYmICEoaXNGRiAmJiBOdW1iZXIoaXNGRlsxXSkgPD0gNTMpO1xuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIG5hbWUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICAvLyBhc3luYyBlZGdlIGNhc2UgIzY1NjY6IGlubmVyIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHBhdGNoLCBldmVudCBoYW5kbGVyXG4gIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXG4gIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAvLyB0aGUgc29sdXRpb24gaXMgc2ltcGxlOiB3ZSBzYXZlIHRoZSB0aW1lc3RhbXAgd2hlbiBhIGhhbmRsZXIgaXMgYXR0YWNoZWQsXG4gIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcbiAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxuICBpZiAodXNlTWljcm90YXNrRml4KSB7XG4gICAgY29uc3QgYXR0YWNoZWRUaW1lc3RhbXAgPSBjdXJyZW50Rmx1c2hUaW1lc3RhbXA7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vIGJ1YmJsaW5nLCBzaG91bGQgYWx3YXlzIGZpcmUuXG4gICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICBlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8XG4gICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAvLyAjOTQ2MiBiYWlsIGZvciBpT1MgOSBidWc6IGV2ZW50LnRpbWVTdGFtcCBpcyAwIGFmdGVyIGhpc3RvcnkucHVzaFN0YXRlXG4gICAgICAgIGUudGltZVN0YW1wID09PSAwIHx8XG4gICAgICAgIC8vICM5NDQ4IGJhaWwgaWYgZXZlbnQgaXMgZmlyZWQgaW4gYW5vdGhlciBkb2N1bWVudCBpbiBhIG11bHRpLXBhZ2VcbiAgICAgICAgLy8gZWxlY3Ryb24vbncuanMgYXBwLCBzaW5jZSBldmVudC50aW1lU3RhbXAgd2lsbCBiZSB1c2luZyBhIGRpZmZlcmVudFxuICAgICAgICAvLyBzdGFydGluZyByZWZlcmVuY2VcbiAgICAgICAgZS50YXJnZXQub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnRcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZSwgcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLl93cmFwcGVyIHx8IGhhbmRsZXIsXG4gICAgY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICBjb25zdCBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxubGV0IHN2Z0NvbnRhaW5lcjtcblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IGtleSwgY3VyO1xuICBjb25zdCBlbG0gPSB2bm9kZS5lbG07XG4gIGNvbnN0IG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgbGV0IHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgY29udGludWVcbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXG4gICAgLy8gdGhlIG9ubHkgZXhjZXB0aW9uIGlzIGB2YWx1ZWAgd2hlcmUgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAvLyBvdXQgb2Ygc3luYyB3aXRoIFZET00gc3RhdGUgZHVlIHRvIGZvY3VzLCBjb21wb3NpdGlvbiBhbmQgbW9kaWZpZXJzLlxuICAgIC8vIFRoaXMgYWxzbyBjb3ZlcnMgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNhcnJ5IGBjaGVja2VkYCB1cGRhdGUuXG4gICAgaWYgKGtleSAhPT0gJ3ZhbHVlJyAmJiBjdXIgPT09IG9sZFByb3BzW2tleV0pIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIGNvbnN0IHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiYgaXNTVkcoZWxtLnRhZ05hbWUpICYmIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IGA8c3ZnPiR7Y3VyfTwvc3ZnPmA7XG4gICAgICBjb25zdCBzdmcgPSBzdmdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlIChlbG0uZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5hcHBlbmRDaGlsZChzdmcuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIGxldCBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIGNvbnN0IHZhbHVlID0gZWxtLnZhbHVlO1xuICBjb25zdCBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG5jb25zdCBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICBjb25zdCByZXMgPSB7fTtcbiAgY29uc3QgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIGNvbnN0IHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIGNvbnN0IHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICBjb25zdCByZXMgPSB7fTtcbiAgbGV0IHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIGxldCBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgbGV0IHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5jb25zdCBjc3NWYXJSRSA9IC9eLS0vO1xuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbmNvbnN0IHNldFByb3AgPSAoZWwsIG5hbWUsIHZhbCkgPT4ge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxubGV0IGVtcHR5U3R5bGU7XG5jb25zdCBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICBjb25zdCBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgY29uc3Qgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBjdXIsIG5hbWU7XG4gIGNvbnN0IGVsID0gdm5vZGUuZWxtO1xuICBjb25zdCBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIGNvbnN0IG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgY29uc3Qgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgY29uc3Qgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgY29uc3QgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbmNvbnN0IHdoaXRlc3BhY2VSRSA9IC9cXHMrLztcblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goYyA9PiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjdXIgPSBgICR7ZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnfSBgO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGMgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBjdXIgPSBgICR7ZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnfSBgO1xuICAgIGNvbnN0IHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxuY29uc3QgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQobmFtZSA9PiB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogYCR7bmFtZX0tZW50ZXJgLFxuICAgIGVudGVyVG9DbGFzczogYCR7bmFtZX0tZW50ZXItdG9gLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsXG4gICAgbGVhdmVDbGFzczogYCR7bmFtZX0tbGVhdmVgLFxuICAgIGxlYXZlVG9DbGFzczogYCR7bmFtZX0tbGVhdmUtdG9gLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IGAke25hbWV9LWxlYXZlLWFjdGl2ZWBcbiAgfVxufSk7XG5cbmNvbnN0IGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xuY29uc3QgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbmNvbnN0IEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG5sZXQgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG5sZXQgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xubGV0IGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbmxldCBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxuY29uc3QgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmbiA9PiBmbigpO1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZigoKSA9PiB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICBpZiAoIXR5cGUpIHJldHVybiBjYigpXG4gIGNvbnN0IGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICBsZXQgZW5kZWQgPSAwO1xuICBjb25zdCBlbmQgPSAoKSA9PiB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIGNvbnN0IG9uRW5kID0gZSA9PiB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG5jb25zdCB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xuICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICBjb25zdCBhbmltYXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICBsZXQgdHlwZTtcbiAgbGV0IHRpbWVvdXQgPSAwO1xuICBsZXQgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIGNvbnN0IGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgdGltZW91dCxcbiAgICBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuLy8gT2xkIHZlcnNpb25zIG9mIENocm9taXVtIChiZWxvdyA2MS4wLjMxNjMuMTAwKSBmb3JtYXRzIGZsb2F0aW5nIHBvaW50ZXIgbnVtYmVyc1xuLy8gaW4gYSBsb2NhbGUtZGVwZW5kZW50IHdheSwgdXNpbmcgYSBjb21tYSBpbnN0ZWFkIG9mIGEgZG90LlxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93biAoaS5lLiBhY3Rpbmdcbi8vIGFzIGEgZmxvb3IgZnVuY3Rpb24pIGNhdXNpbmcgdW5leHBlY3RlZCBiZWhhdmlvcnNcbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBjc3MsXG4gICAgdHlwZSxcbiAgICBlbnRlckNsYXNzLFxuICAgIGVudGVyVG9DbGFzcyxcbiAgICBlbnRlckFjdGl2ZUNsYXNzLFxuICAgIGFwcGVhckNsYXNzLFxuICAgIGFwcGVhclRvQ2xhc3MsXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3MsXG4gICAgYmVmb3JlRW50ZXIsXG4gICAgZW50ZXIsXG4gICAgYWZ0ZXJFbnRlcixcbiAgICBlbnRlckNhbmNlbGxlZCxcbiAgICBiZWZvcmVBcHBlYXIsXG4gICAgYXBwZWFyLFxuICAgIGFmdGVyQXBwZWFyLFxuICAgIGFwcGVhckNhbmNlbGxlZCxcbiAgICBkdXJhdGlvblxuICB9ID0gZGF0YTtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgbGV0IGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgbGV0IHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICBjb25zdCBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICBjb25zdCBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgY29uc3QgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICBjb25zdCBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICBjb25zdCBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICBjb25zdCBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIGNvbnN0IGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgY29uc3QgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIGNvbnN0IGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgY29uc3QgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICBjb25zdCBjYiA9IGVsLl9lbnRlckNiID0gb25jZSgoKSA9PiB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgKCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIGNvbnN0IHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIGNvbnN0IGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICBjb25zdCBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBjc3MsXG4gICAgdHlwZSxcbiAgICBsZWF2ZUNsYXNzLFxuICAgIGxlYXZlVG9DbGFzcyxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzLFxuICAgIGJlZm9yZUxlYXZlLFxuICAgIGxlYXZlLFxuICAgIGFmdGVyTGVhdmUsXG4gICAgbGVhdmVDYW5jZWxsZWQsXG4gICAgZGVsYXlMZWF2ZSxcbiAgICBkdXJhdGlvblxuICB9ID0gZGF0YTtcblxuICBjb25zdCBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIGNvbnN0IHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICBjb25zdCBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAoaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICBjb25zdCBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZSgoKSA9PiB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdyAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgYDx0cmFuc2l0aW9uPiBleHBsaWNpdCAke25hbWV9IGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIGAgK1xuICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmAsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgJHtuYW1lfSBkdXJhdGlvbiBpcyBOYU4gLSBgICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgY29uc3QgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxuY29uc3QgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG5jb25zdCBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzLCBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBkaXJlY3RpdmUgPSB7XG4gIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgKCkgPT4ge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgY29uc3QgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICBjb25zdCBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZSgobywgaSkgPT4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pKSkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICBjb25zdCBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKHYgPT4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKSlcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgY29uc3QgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICBjb25zdCBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHdhcm4oXG4gICAgICBgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVwiJHtiaW5kaW5nLmV4cHJlc3Npb259XCI+IGAgK1xuICAgICAgYGV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290ICR7XG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG4gICAgICB9YCxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkobyA9PiAhbG9vc2VFcXVhbChvLCB2YWx1ZSkpXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSByZXR1cm5cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kIChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgY29uc3QgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGNvbnN0IG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgKCkgPT4ge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlIChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHJldHVyblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgY29uc3QgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCAoKSA9PiB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgKCkgPT4ge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogZGlyZWN0aXZlLFxuICBzaG93XG59O1xuXG4vKiAgKi9cblxuY29uc3QgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICBjb25zdCBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICBjb25zdCBkYXRhID0ge307XG4gIGNvbnN0IG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICBjb25zdCBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAoY29uc3Qga2V5IGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5KV0gPSBsaXN0ZW5lcnNba2V5XTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbmNvbnN0IGlzTm90VGV4dE5vZGUgPSAoYykgPT4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpO1xuXG5jb25zdCBpc1ZTaG93RGlyZWN0aXZlID0gZCA9PiBkLm5hbWUgPT09ICdzaG93JztcblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyIChoKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGlzTm90VGV4dE5vZGUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAobW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICBjb25zdCBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgY29uc3QgaWQgPSBgX190cmFuc2l0aW9uLSR7dGhpcy5fdWlkfS1gO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIGNvbnN0IGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICBjb25zdCBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIGNvbnN0IG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICBjb25zdCBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIGxldCBkZWxheWVkTGVhdmU7XG4gICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBsZWF2ZSA9PiB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbmNvbnN0IHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHMsXG5cbiAgYmVmb3JlTW91bnQgKCkge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZTtcbiAgICB0aGlzLl91cGRhdGUgPSAodm5vZGUsIGh5ZHJhdGluZykgPT4ge1xuICAgICAgY29uc3QgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyk7XG4gICAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICAgIHRoaXMua2VwdCxcbiAgICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICAgICk7XG4gICAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgdXBkYXRlLmNhbGwodGhpcywgdm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfSxcblxuICByZW5kZXIgKGgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgY29uc3QgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIGNvbnN0IHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybihgPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDwke25hbWV9PmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgY29uc3Qga2VwdCA9IFtdO1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHByZXZDaGlsZHJlbltpXTtcbiAgICAgICAgYy5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYy5kYXRhLnBvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2Mua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICB1cGRhdGVkICgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIGNvbnN0IG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIGNvbnN0IGVsID0gYy5lbG07XG4gICAgICAgIGNvbnN0IHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaCgoY2xzKSA9PiB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIGNvbnN0IGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgY29uc3Qgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgY29uc3QgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgY29uc3QgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICBjb25zdCBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpbkJyb3dzZXIpIHtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICApIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICBgWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcbmAgK1xuICAgICAgICBgTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcbmAgK1xuICAgICAgICBgU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxgXG4gICAgICApO1xuICAgIH1cbiAgfSwgMCk7XG59XG5cbi8qICAqL1xuXG5jb25zdCBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxyP1xcbikrPylcXH1cXH0vZztcbmNvbnN0IHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG5jb25zdCBidWlsZFJlZ2V4ID0gY2FjaGVkKGRlbGltaXRlcnMgPT4ge1xuICBjb25zdCBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgY29uc3QgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cblxuXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxuICB0ZXh0LFxuICBkZWxpbWl0ZXJzXG4pIHtcbiAgY29uc3QgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGNvbnN0IHJhd1Rva2VucyA9IFtdO1xuICBsZXQgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgbGV0IG1hdGNoLCBpbmRleCwgdG9rZW5WYWx1ZTtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgY29uc3QgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goYF9zKCR7ZXhwfSlgKTtcbiAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgpKTtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBleHByZXNzaW9uOiB0b2tlbnMuam9pbignKycpLFxuICAgIHRva2VuczogcmF3VG9rZW5zXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIGNvbnN0IHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIGNvbnN0IHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGNvbnN0IHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgY2xhc3M9XCIke3N0YXRpY0NsYXNzfVwiOiBgICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ2NsYXNzJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIGNvbnN0IGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIGxldCBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gYHN0YXRpY0NsYXNzOiR7ZWwuc3RhdGljQ2xhc3N9LGA7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gYGNsYXNzOiR7ZWwuY2xhc3NCaW5kaW5nfSxgO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGFcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIGNvbnN0IHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIGNvbnN0IHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIGNvbnN0IHJlcyA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgc3R5bGU9XCIke3N0YXRpY1N0eWxlfVwiOiBgICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnc3R5bGUnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICBjb25zdCBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gIGxldCBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgIGRhdGEgKz0gYHN0YXRpY1N0eWxlOiR7ZWwuc3RhdGljU3R5bGV9LGA7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gYHN0eWxlOigke2VsLnN0eWxlQmluZGluZ30pLGA7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbi8qICAqL1xuXG5sZXQgZGVjb2RlcjtcblxudmFyIGhlID0ge1xuICBkZWNvZGUgKGh0bWwpIHtcbiAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbiAgfVxufTtcblxuLyogICovXG5cbmNvbnN0IGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxuY29uc3QgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG5jb25zdCBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAndGl0bGUsdHIsdHJhY2snXG4pO1xuXG4vKipcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICovXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuY29uc3QgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG5jb25zdCBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XStcXF1bXlxcc1wiJzw+XFwvPV0qKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xuY29uc3QgbmNuYW1lID0gYFthLXpBLVpfXVtcXFxcLVxcXFwuMC05X2EtekEtWiR7dW5pY29kZUxldHRlcnN9XSpgO1xuY29uc3QgcW5hbWVDYXB0dXJlID0gYCgoPzoke25jbmFtZX1cXFxcOik/JHtuY25hbWV9KWA7XG5jb25zdCBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKGBePCR7cW5hbWVDYXB0dXJlfWApO1xuY29uc3Qgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xuY29uc3QgZW5kVGFnID0gbmV3IFJlZ0V4cChgXjxcXFxcLyR7cW5hbWVDYXB0dXJlfVtePl0qPmApO1xuY29uc3QgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xuLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxuY29uc3QgY29tbWVudCA9IC9ePCFcXC0tLztcbmNvbnN0IGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbmNvbnN0IGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xuY29uc3QgcmVDYWNoZSA9IHt9O1xuXG5jb25zdCBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJyxcbiAgJyYjOTsnOiAnXFx0JyxcbiAgJyYjMzk7JzogXCInXCJcbn07XG5jb25zdCBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcbmNvbnN0IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbmNvbnN0IGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xuY29uc3Qgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gKHRhZywgaHRtbCkgPT4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nO1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgY29uc3QgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBtYXRjaCA9PiBkZWNvZGluZ01hcFttYXRjaF0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBjb25zdCBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICBjb25zdCBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICBjb25zdCBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICBsZXQgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIGNvbnN0IGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpLCBpbmRleCwgaW5kZXggKyBjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgY29uc3QgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIGNvbnN0IGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICBjb25zdCBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICBjb25zdCBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhcnRUYWdNYXRjaC50YWdOYW1lLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgdGV4dCwgcmVzdCwgbmV4dDtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgYnJlYWtcbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIGNvbnN0IHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIGNvbnN0IHJlc3QgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3Q7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKGBNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFwiJHtodG1sfVwiYCwgeyBzdGFydDogaW5kZXggKyBodG1sLmxlbmd0aCB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgbGV0IGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChkeW5hbWljQXJnQXR0cmlidXRlKSB8fCBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGF0dHIuc3RhcnQgPSBpbmRleDtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIGF0dHIuZW5kID0gaW5kZXg7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICBjb25zdCB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICBjb25zdCB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICBjb25zdCBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIGNvbnN0IGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgY29uc3Qgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXG4gICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcbiAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gYXJncy5lbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMsIHN0YXJ0OiBtYXRjaC5zdGFydCwgZW5kOiBtYXRjaC5lbmQgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHN0YXJ0ID0gaW5kZXg7XG4gICAgaWYgKGVuZCA9PSBudWxsKSBlbmQgPSBpbmRleDtcblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAobGV0IGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChpID4gcG9zIHx8ICF0YWdOYW1lICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIGB0YWcgPCR7c3RhY2tbaV0udGFnfT4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuYCxcbiAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0IH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmNvbnN0IG9uUkUgPSAvXkB8XnYtb246LztcbmNvbnN0IGRpclJFID0gL152LXxeQHxeOi87XG5jb25zdCBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xuY29uc3QgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbmNvbnN0IHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG5jb25zdCBkeW5hbWljQXJnUkUgPSAvXlxcWy4qXFxdJC87XG5cbmNvbnN0IGFyZ1JFID0gLzooLiopJC87XG5jb25zdCBiaW5kUkUgPSAvXjp8XlxcLnxedi1iaW5kOi87XG5jb25zdCBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbmNvbnN0IHNsb3RSRSA9IC9edi1zbG90KDp8JCl8XiMvO1xuXG5jb25zdCBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XG5jb25zdCB3aGl0ZXNwYWNlUkUkMSA9IC9cXHMrL2c7XG5cbmNvbnN0IGludmFsaWRBdHRyaWJ1dGVSRSA9IC9bXFxzXCInPD5cXC89XS87XG5cbmNvbnN0IGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxuY29uc3QgZW1wdHlTbG90U2NvcGVUb2tlbiA9IGBfZW1wdHlfYDtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG5sZXQgd2FybiQyO1xubGV0IGRlbGltaXRlcnM7XG5sZXQgdHJhbnNmb3JtcztcbmxldCBwcmVUcmFuc2Zvcm1zO1xubGV0IHBvc3RUcmFuc2Zvcm1zO1xubGV0IHBsYXRmb3JtSXNQcmVUYWc7XG5sZXQgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbmxldCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbmxldCBtYXliZUNvbXBvbmVudDtcblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWcsXG4gICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICByYXdBdHRyc01hcDoge30sXG4gICAgcGFyZW50LFxuICAgIGNoaWxkcmVuOiBbXVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICBjb25zdCBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICBtYXliZUNvbXBvbmVudCA9IChlbCkgPT4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTtcblxuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICBjb25zdCBzdGFjayA9IFtdO1xuICBjb25zdCBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIGNvbnN0IHdoaXRlc3BhY2VPcHRpb24gPSBvcHRpb25zLndoaXRlc3BhY2U7XG4gIGxldCByb290O1xuICBsZXQgY3VycmVudFBhcmVudDtcbiAgbGV0IGluVlByZSA9IGZhbHNlO1xuICBsZXQgaW5QcmUgPSBmYWxzZTtcbiAgbGV0IHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2csIHJhbmdlKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnLCByYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VFbGVtZW50IChlbGVtZW50KSB7XG4gICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG4gICAgaWYgKCFpblZQcmUgJiYgIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICBlbGVtZW50ID0gcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgIGlmICghc3RhY2subGVuZ3RoICYmIGVsZW1lbnQgIT09IHJvb3QpIHtcbiAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgYENvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIGAgK1xuICAgICAgICAgIGBJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIGAgK1xuICAgICAgICAgIGB1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5gLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbGVtZW50LnNsb3RTY29wZSkge1xuICAgICAgICAgIC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgLy8ga2VlcCBpdCBpbiB0aGUgY2hpbGRyZW4gbGlzdCBzbyB0aGF0IHYtZWxzZSgtaWYpIGNvbmRpdGlvbnMgY2FuXG4gICAgICAgICAgLy8gZmluZCBpdCBhcyB0aGUgcHJldiBub2RlLlxuICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJ1xuICAgICAgICAgIDsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmFsIGNoaWxkcmVuIGNsZWFudXBcbiAgICAvLyBmaWx0ZXIgb3V0IHNjb3BlZCBzbG90c1xuICAgIGVsZW1lbnQuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuLmZpbHRlcihjID0+ICEoYykuc2xvdFNjb3BlKTtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlIGFnYWluXG4gICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG5cbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvc3RUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaW1FbmRpbmdXaGl0ZXNwYWNlIChlbCkge1xuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGVcbiAgICBpZiAoIWluUHJlKSB7XG4gICAgICBsZXQgbGFzdE5vZGU7XG4gICAgICB3aGlsZSAoXG4gICAgICAgIChsYXN0Tm9kZSA9IGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdKSAmJlxuICAgICAgICBsYXN0Tm9kZS50eXBlID09PSAzICYmXG4gICAgICAgIGxhc3ROb2RlLnRleHQgPT09ICcgJ1xuICAgICAgKSB7XG4gICAgICAgIGVsLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBgQ2Fubm90IHVzZSA8JHtlbC50YWd9PiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IGAgK1xuICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLFxuICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSwgc3RhcnQpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgY29uc3QgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGVsZW1lbnQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICBlbGVtZW50LnJhd0F0dHJzTWFwID0gZWxlbWVudC5hdHRyc0xpc3QucmVkdWNlKChjdW11bGF0ZWQsIGF0dHIpID0+IHtcbiAgICAgICAgICAgIGN1bXVsYXRlZFthdHRyLm5hbWVdID0gYXR0cjtcbiAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMuZm9yRWFjaChhdHRyID0+IHtcbiAgICAgICAgICBpZiAoaW52YWxpZEF0dHJpYnV0ZVJFLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBgSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBgICtcbiAgICAgICAgICAgICAgYHNwYWNlcywgcXVvdGVzLCA8LCA+LCAvIG9yID0uYCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoYFtgKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUubGVuZ3RoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBgPCR7dGFnfT5gICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJyxcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kICh0YWcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcbiAgICAgIH1cbiAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgY2hhcnMgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LicsXG4gICAgICAgICAgICAgIHsgc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgYHRleHQgXCIke3RleHR9XCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLmAsXG4gICAgICAgICAgICAgIHsgc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgaWYgKGluUHJlIHx8IHRleHQudHJpbSgpKSB7XG4gICAgICAgIHRleHQgPSBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAvLyByZW1vdmUgdGhlIHdoaXRlc3BhY2Utb25seSBub2RlIHJpZ2h0IGFmdGVyIGFuIG9wZW5pbmcgdGFnXG4gICAgICAgIHRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAod2hpdGVzcGFjZU9wdGlvbikge1xuICAgICAgICBpZiAod2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xuICAgICAgICAgIC8vIGluIGNvbmRlbnNlIG1vZGUsIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBub2RlIGlmIGl0IGNvbnRhaW5zXG4gICAgICAgICAgLy8gbGluZSBicmVhaywgb3RoZXJ3aXNlIGNvbmRlbnNlIHRvIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgdGV4dCA9IGxpbmVCcmVha1JFLnRlc3QodGV4dCkgPyAnJyA6ICcgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gJyAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gcHJlc2VydmVXaGl0ZXNwYWNlID8gJyAnIDogJyc7XG4gICAgICB9XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBpZiAod2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xuICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSh3aGl0ZXNwYWNlUkUkMSwgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBsZXQgY2hpbGQ7XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAocmVzID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHJlcy5leHByZXNzaW9uLFxuICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgdGV4dFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21tZW50ICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAvLyBhZGRpbmcgYW55dGluZyBhcyBhIHNpYmxpbmcgdG8gdGhlIHJvb3Qgbm9kZSBpcyBmb3JiaWRkZW5cbiAgICAgIC8vIGNvbW1lbnRzIHNob3VsZCBzdGlsbCBiZSBhbGxvd2VkLCBidXQgaWdub3JlZFxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB7XG4gICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICBlbC5wcmUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyAoZWwpIHtcbiAgY29uc3QgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgY29uc3QgbGVuID0gbGlzdC5sZW5ndGg7XG4gIGlmIChsZW4pIHtcbiAgICBjb25zdCBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGxpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGxpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgICAgaWYgKGxpc3RbaV0uc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGxpc3RbaV0uc3RhcnQ7XG4gICAgICAgIGF0dHJzW2ldLmVuZCA9IGxpc3RbaV0uZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRWxlbWVudCAoXG4gIGVsZW1lbnQsXG4gIG9wdGlvbnNcbikge1xuICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICBlbGVtZW50LnBsYWluID0gKFxuICAgICFlbGVtZW50LmtleSAmJlxuICAgICFlbGVtZW50LnNjb3BlZFNsb3RzICYmXG4gICAgIWVsZW1lbnQuYXR0cnNMaXN0Lmxlbmd0aFxuICApO1xuXG4gIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90Q29udGVudChlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RPdXRsZXQoZWxlbWVudCk7XG4gIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgIGVsZW1lbnQgPSB0cmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gIH1cbiAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xuICByZXR1cm4gZWxlbWVudFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xuICBjb25zdCBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAge1xuICAgICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgYDx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5gLFxuICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbC5mb3IpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBlbC5pdGVyYXRvcjIgfHwgZWwuaXRlcmF0b3IxO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgIGlmIChpdGVyYXRvciAmJiBpdGVyYXRvciA9PT0gZXhwICYmIHBhcmVudCAmJiBwYXJlbnQudGFnID09PSAndHJhbnNpdGlvbi1ncm91cCcpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBgRG8gbm90IHVzZSB2LWZvciBpbmRleCBhcyBrZXkgb24gPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuLCBgICtcbiAgICAgICAgICAgIGB0aGlzIGlzIHRoZSBzYW1lIGFzIG5vdCB1c2luZyBrZXlzLmAsXG4gICAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpLFxuICAgICAgICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICBjb25zdCByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgbGV0IGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICBjb25zdCByZXMgPSBwYXJzZUZvcihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQyKFxuICAgICAgICBgSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiAke2V4cH1gLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgY29uc3QgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgaWYgKCFpbk1hdGNoKSByZXR1cm5cbiAgY29uc3QgcmVzID0ge307XG4gIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgY29uc3QgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKTtcbiAgY29uc3QgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIGNvbnN0IGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIGNvbnN0IHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd2FybiQyKFxuICAgICAgYHYtJHtlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZSd9IGAgK1xuICAgICAgYHVzZWQgb24gZWxlbWVudCA8JHtlbC50YWd9PiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5gLFxuICAgICAgZWwucmF3QXR0cnNNYXBbZWwuZWxzZWlmID8gJ3YtZWxzZS1pZicgOiAndi1lbHNlJ11cbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgbGV0IGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIGB0ZXh0IFwiJHtjaGlsZHJlbltpXS50ZXh0LnRyaW0oKX1cIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIGAgK1xuICAgICAgICAgIGB3aWxsIGJlIGlnbm9yZWQuYCxcbiAgICAgICAgICBjaGlsZHJlbltpXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIGNvbnN0IG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBoYW5kbGUgY29udGVudCBiZWluZyBwYXNzZWQgdG8gYSBjb21wb25lbnQgYXMgc2xvdCxcbi8vIGUuZy4gPHRlbXBsYXRlIHNsb3Q9XCJ4eHhcIj4sIDxkaXYgc2xvdC1zY29wZT1cInh4eFwiPlxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RDb250ZW50IChlbCkge1xuICBsZXQgc2xvdFNjb3BlO1xuICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHNsb3RTY29wZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBgdGhlIFwic2NvcGVcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgYCArXG4gICAgICAgIGByZXBsYWNlZCBieSBcInNsb3Qtc2NvcGVcIiBzaW5jZSAyLjUuIFRoZSBuZXcgXCJzbG90LXNjb3BlXCIgYXR0cmlidXRlIGAgK1xuICAgICAgICBgY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIGAgK1xuICAgICAgICBgZGVub3RlIHNjb3BlZCBzbG90cy5gLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2NvcGUnXSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJyk7XG4gIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGBBbWJpZ3VvdXMgY29tYmluZWQgdXNhZ2Ugb2Ygc2xvdC1zY29wZSBhbmQgdi1mb3Igb24gPCR7ZWwudGFnfT4gYCArXG4gICAgICAgIGAodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgYCArXG4gICAgICAgIGBzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuYCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICB9XG5cbiAgLy8gc2xvdD1cInh4eFwiXG4gIGNvbnN0IHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSAhIShlbC5hdHRyc01hcFsnOnNsb3QnXSB8fCBlbC5hdHRyc01hcFsndi1iaW5kOnNsb3QnXSk7XG4gICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHMuXG4gICAgaWYgKGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAnc2xvdCcpKTtcbiAgICB9XG4gIH1cblxuICAvLyAyLjYgdi1zbG90IHN5bnRheFxuICB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgLy8gdi1zbG90IG9uIDx0ZW1wbGF0ZT5cbiAgICAgIGNvbnN0IHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmcpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChlbC5zbG90VGFyZ2V0IHx8IGVsLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBgVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5gLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnBhcmVudCAmJiAhbWF5YmVDb21wb25lbnQoZWwucGFyZW50KSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBgPHRlbXBsYXRlIHYtc2xvdD4gY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSByb290IGxldmVsIGluc2lkZSBgICtcbiAgICAgICAgICAgICAgYHRoZSByZWNlaXZpbmcgdGhlIGNvbXBvbmVudGAsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5hbWUsIGR5bmFtaWMgfSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgZWwuc2xvdFRhcmdldCA9IG5hbWU7XG4gICAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcbiAgICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmcudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjsgLy8gZm9yY2UgaXQgaW50byBhIHNjb3BlZCBzbG90IGZvciBwZXJmXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHYtc2xvdCBvbiBjb21wb25lbnQsIGRlbm90ZXMgZGVmYXVsdCBzbG90XG4gICAgICBjb25zdCBzbG90QmluZGluZyA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgaWYgKHNsb3RCaW5kaW5nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIW1heWJlQ29tcG9uZW50KGVsKSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBgdi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+LmAsXG4gICAgICAgICAgICAgIHNsb3RCaW5kaW5nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc2xvdFNjb3BlIHx8IGVsLnNsb3RUYXJnZXQpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgYFVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuYCxcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBgVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBgICtcbiAgICAgICAgICAgICAgYDx0ZW1wbGF0ZT4gc3ludGF4IHdoZW4gdGhlcmUgYXJlIG90aGVyIG5hbWVkIHNsb3RzLmAsXG4gICAgICAgICAgICAgIHNsb3RCaW5kaW5nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuIHRvIGl0cyBkZWZhdWx0IHNsb3RcbiAgICAgICAgY29uc3Qgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZHluYW1pYyB9ID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICBjb25zdCBzbG90Q29udGFpbmVyID0gc2xvdHNbbmFtZV0gPSBjcmVhdGVBU1RFbGVtZW50KCd0ZW1wbGF0ZScsIFtdLCBlbCk7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldCA9IG5hbWU7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBzbG90Q29udGFpbmVyLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uZmlsdGVyKChjKSA9PiB7XG4gICAgICAgICAgaWYgKCFjLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47XG4gICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBhcyB0aGV5IGFyZSByZXR1cm5lZCBmcm9tIHNjb3BlZFNsb3RzIG5vd1xuICAgICAgICBlbC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvLyBtYXJrIGVsIG5vbi1wbGFpbiBzbyBkYXRhIGdldHMgZ2VuZXJhdGVkXG4gICAgICAgIGVsLnBsYWluID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNsb3ROYW1lIChiaW5kaW5nKSB7XG4gIGxldCBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XG4gIGlmICghbmFtZSkge1xuICAgIGlmIChiaW5kaW5nLm5hbWVbMF0gIT09ICcjJykge1xuICAgICAgbmFtZSA9ICdkZWZhdWx0JztcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQyKFxuICAgICAgICBgdi1zbG90IHNob3J0aGFuZCBzeW50YXggcmVxdWlyZXMgYSBzbG90IG5hbWUuYCxcbiAgICAgICAgYmluZGluZ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpXG4gICAgLy8gZHluYW1pYyBbbmFtZV1cbiAgICA/IHsgbmFtZTogbmFtZS5zbGljZSgxLCAtMSksIGR5bmFtaWM6IHRydWUgfVxuICAgIC8vIHN0YXRpYyBuYW1lXG4gICAgOiB7IG5hbWU6IGBcIiR7bmFtZX1cImAsIGR5bmFtaWM6IGZhbHNlIH1cbn1cblxuLy8gaGFuZGxlIDxzbG90Lz4gb3V0bGV0c1xuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBgXFxga2V5XFxgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgYCArXG4gICAgICAgIGBhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBgICtcbiAgICAgICAgYFVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLmAsXG4gICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIGxldCBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBsZXQgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgc3luY0dlbiwgaXNEeW5hbWljO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUucmVwbGFjZShkaXJSRSwgJycpKTtcbiAgICAgIC8vIHN1cHBvcnQgLmZvbyBzaG9ydGhhbmQgc3ludGF4IGZvciB0aGUgLnByb3AgbW9kaWZpZXJcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHZhbHVlLnRyaW0oKS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgYFRoZSB2YWx1ZSBmb3IgYSB2LWJpbmQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgZW1wdHkuIEZvdW5kIGluIFwidi1iaW5kOiR7bmFtZX1cImBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3AgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSBuYW1lID0gJ2lubmVySFRNTCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYCRldmVudGApO1xuICAgICAgICAgICAgaWYgKCFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBgdXBkYXRlOiR7Y2FtZWxpemUobmFtZSl9YCxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShuYW1lKSAhPT0gY2FtZWxpemUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICBgdXBkYXRlOiR7aHlwaGVuYXRlKG5hbWUpfWAsXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGhhbmRsZXIgdy8gZHluYW1pYyBldmVudCBuYW1lXG4gICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgYFwidXBkYXRlOlwiKygke25hbWV9KWAsXG4gICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICBsaXN0W2ldLFxuICAgICAgICAgICAgICAgIHRydWUgLy8gZHluYW1pY1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJvcCkgfHwgKFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIGNvbnN0IGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIGxldCBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgICAgaWYgKGR5bmFtaWNBcmdSRS50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBpc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAge1xuICAgICAgICBjb25zdCByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgYCR7bmFtZX09XCIke3ZhbHVlfVwiOiBgICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJyxcbiAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIGxpc3RbaV0pO1xuICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnLCBsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgbGV0IHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgY29uc3QgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBtYXRjaC5mb3JFYWNoKG0gPT4geyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICBjb25zdCBtYXAgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0pO1xuICAgIH1cbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xuICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSdcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG5jb25zdCBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xuY29uc3QgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICBsZXQgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGA8JHtlbC50YWd9IHYtbW9kZWw9XCIke3ZhbHVlfVwiPjogYCArXG4gICAgICAgIGBZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gYCArXG4gICAgICAgIGBUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBgICtcbiAgICAgICAgYHdyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIGAgK1xuICAgICAgICBgQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuYCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgIGNvbnN0IG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCB0eXBlQmluZGluZztcbiAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBgKCR7bWFwWyd2LWJpbmQnXX0pLnR5cGVgO1xuICAgIH1cblxuICAgIGlmICh0eXBlQmluZGluZykge1xuICAgICAgY29uc3QgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgY29uc3QgaWZDb25kaXRpb25FeHRyYSA9IGlmQ29uZGl0aW9uID8gYCYmKCR7aWZDb25kaXRpb259KWAgOiBgYDtcbiAgICAgIGNvbnN0IGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIGNvbnN0IGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcbiAgICAgIC8vIDEuIGNoZWNrYm94XG4gICAgICBjb25zdCBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcbiAgICAgIGJyYW5jaDAuaWYgPSBgKCR7dHlwZUJpbmRpbmd9KT09PSdjaGVja2JveCdgICsgaWZDb25kaXRpb25FeHRyYTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBicmFuY2gwLmlmLFxuICAgICAgICBibG9jazogYnJhbmNoMFxuICAgICAgfSk7XG4gICAgICAvLyAyLiBhZGQgcmFkaW8gZWxzZS1pZiBjb25kaXRpb25cbiAgICAgIGNvbnN0IGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGAoJHt0eXBlQmluZGluZ30pPT09J3JhZGlvJ2AgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgY29uc3QgYnJhbmNoMiA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDIsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gyLCAnOnR5cGUnLCB0eXBlQmluZGluZyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gyLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBpZkNvbmRpdGlvbixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDJcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzRWxzZSkge1xuICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbHNlSWZDb25kaXRpb24pIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlaWYgPSBlbHNlSWZDb25kaXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicmFuY2gwXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQVNURWxlbWVudCAoZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUFTVEVsZW1lbnQoZWwudGFnLCBlbC5hdHRyc0xpc3Quc2xpY2UoKSwgZWwucGFyZW50KVxufVxuXG52YXIgbW9kZWwkMSA9IHtcbiAgcHJlVHJhbnNmb3JtTm9kZVxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMSxcbiAgbW9kZWwkMVxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIGBfcygke2Rpci52YWx1ZX0pYCwgZGlyKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIGBfcygke2Rpci52YWx1ZX0pYCwgZGlyKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbCxcbiAgdGV4dCxcbiAgaHRtbFxufTtcblxuLyogICovXG5cbmNvbnN0IGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbmxldCBpc1N0YXRpY0tleTtcbmxldCBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbmNvbnN0IGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSByZXR1cm5cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycyxzdGFydCxlbmQscmF3QXR0cnNNYXAnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMSwgbCA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2ldLmJsb2NrO1xuICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMSwgbCA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaV0uYmxvY2ssIGlzSW5Gb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuY29uc3QgZm5FeHBSRSA9IC9eKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG5jb25zdCBmbkludm9rZVJFID0gL1xcKFteKV0qP1xcKTsqJC87XG5jb25zdCBzaW1wbGVQYXRoUkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJ1teJ10qPyddfFxcW1wiW15cIl0qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKiQvO1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleUNvZGUgYWxpYXNlc1xuY29uc3Qga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXG5jb25zdCBrZXlOYW1lcyA9IHtcbiAgLy8gIzc4ODA6IElFMTEgYW5kIEVkZ2UgdXNlIGBFc2NgIGZvciBFc2NhcGUga2V5IG5hbWUuXG4gIGVzYzogWydFc2MnLCAnRXNjYXBlJ10sXG4gIHRhYjogJ1RhYicsXG4gIGVudGVyOiAnRW50ZXInLFxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBTcGFjZWJhcmAgZm9yIFNwYWNlIGtleSBuYW1lLlxuICBzcGFjZTogWycgJywgJ1NwYWNlYmFyJ10sXG4gIC8vICM3ODA2OiBJRTExIHVzZXMga2V5IG5hbWVzIHdpdGhvdXQgYEFycm93YCBwcmVmaXggZm9yIGFycm93IGtleXMuXG4gIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgbGVmdDogWydMZWZ0JywgJ0Fycm93TGVmdCddLFxuICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXG4gIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgRGVsYCBmb3IgRGVsZXRlIGtleSBuYW1lLlxuICAnZGVsZXRlJzogWydCYWNrc3BhY2UnLCAnRGVsZXRlJywgJ0RlbCddXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxuY29uc3QgZ2VuR3VhcmQgPSBjb25kaXRpb24gPT4gYGlmKCR7Y29uZGl0aW9ufSlyZXR1cm4gbnVsbDtgO1xuXG5jb25zdCBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKGAkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldGApLFxuICBjdHJsOiBnZW5HdWFyZChgISRldmVudC5jdHJsS2V5YCksXG4gIHNoaWZ0OiBnZW5HdWFyZChgISRldmVudC5zaGlmdEtleWApLFxuICBhbHQ6IGdlbkd1YXJkKGAhJGV2ZW50LmFsdEtleWApLFxuICBtZXRhOiBnZW5HdWFyZChgISRldmVudC5tZXRhS2V5YCksXG4gIGxlZnQ6IGdlbkd1YXJkKGAnYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMGApLFxuICBtaWRkbGU6IGdlbkd1YXJkKGAnYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMWApLFxuICByaWdodDogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyYClcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZVxuKSB7XG4gIGNvbnN0IHByZWZpeCA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOicgOiAnb246JztcbiAgbGV0IHN0YXRpY0hhbmRsZXJzID0gYGA7XG4gIGxldCBkeW5hbWljSGFuZGxlcnMgPSBgYDtcbiAgZm9yIChjb25zdCBuYW1lIGluIGV2ZW50cykge1xuICAgIGNvbnN0IGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgIGlmIChldmVudHNbbmFtZV0gJiYgZXZlbnRzW25hbWVdLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNIYW5kbGVycyArPSBgJHtuYW1lfSwke2hhbmRsZXJDb2RlfSxgO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNIYW5kbGVycyArPSBgXCIke25hbWV9XCI6JHtoYW5kbGVyQ29kZX0sYDtcbiAgICB9XG4gIH1cbiAgc3RhdGljSGFuZGxlcnMgPSBgeyR7c3RhdGljSGFuZGxlcnMuc2xpY2UoMCwgLTEpfX1gO1xuICBpZiAoZHluYW1pY0hhbmRsZXJzKSB7XG4gICAgcmV0dXJuIHByZWZpeCArIGBfZCgke3N0YXRpY0hhbmRsZXJzfSxbJHtkeW5hbWljSGFuZGxlcnMuc2xpY2UoMCwgLTEpfV0pYFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmVmaXggKyBzdGF0aWNIYW5kbGVyc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiBgWyR7aGFuZGxlci5tYXAoaGFuZGxlciA9PiBnZW5IYW5kbGVyKGhhbmRsZXIpKS5qb2luKCcsJyl9XWBcbiAgfVxuXG4gIGNvbnN0IGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICBjb25zdCBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgY29uc3QgaXNGdW5jdGlvbkludm9jYXRpb24gPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlLnJlcGxhY2UoZm5JbnZva2VSRSwgJycpKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIudmFsdWVcbiAgICB9XG4gICAgcmV0dXJuIGBmdW5jdGlvbigkZXZlbnQpeyR7XG4gICAgICBpc0Z1bmN0aW9uSW52b2NhdGlvbiA/IGByZXR1cm4gJHtoYW5kbGVyLnZhbHVlfWAgOiBoYW5kbGVyLnZhbHVlXG4gICAgfX1gIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICBsZXQgY29kZSA9ICcnO1xuICAgIGxldCBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdleGFjdCcpIHtcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGtleU1vZGlmaWVyID0+ICFtb2RpZmllcnNba2V5TW9kaWZpZXJdKVxuICAgICAgICAgICAgLm1hcChrZXlNb2RpZmllciA9PiBgJGV2ZW50LiR7a2V5TW9kaWZpZXJ9S2V5YClcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gYHJldHVybiAke2hhbmRsZXIudmFsdWV9KCRldmVudClgXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgID8gYHJldHVybiAoJHtoYW5kbGVyLnZhbHVlfSkoJGV2ZW50KWBcbiAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxuICAgICAgICAgID8gYHJldHVybiAke2hhbmRsZXIudmFsdWV9YFxuICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gYGZ1bmN0aW9uKCRldmVudCl7JHtjb2RlfSR7aGFuZGxlckNvZGV9fWBcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBtYWtlIHN1cmUgdGhlIGtleSBmaWx0ZXJzIG9ubHkgYXBwbHkgdG8gS2V5Ym9hcmRFdmVudHNcbiAgICAvLyAjOTQ0MTogY2FuJ3QgdXNlICdrZXlDb2RlJyBpbiAkZXZlbnQgYmVjYXVzZSBDaHJvbWUgYXV0b2ZpbGwgZmlyZXMgZmFrZVxuICAgIC8vIGtleSBldmVudHMgdGhhdCBkbyBub3QgaGF2ZSBrZXlDb2RlIHByb3BlcnR5Li4uXG4gICAgYGlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmYCArXG4gICAgYCR7a2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKX0pcmV0dXJuIG51bGw7YFxuICApXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICBjb25zdCBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiBgJGV2ZW50LmtleUNvZGUhPT0ke2tleVZhbH1gXG4gIH1cbiAgY29uc3Qga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XG4gIGNvbnN0IGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICByZXR1cm4gKFxuICAgIGBfaygkZXZlbnQua2V5Q29kZSxgICtcbiAgICBgJHtKU09OLnN0cmluZ2lmeShrZXkpfSxgICtcbiAgICBgJHtKU09OLnN0cmluZ2lmeShrZXlDb2RlKX0sYCArXG4gICAgYCRldmVudC5rZXksYCArXG4gICAgYCR7SlNPTi5zdHJpbmdpZnkoa2V5TmFtZSl9YCArXG4gICAgYClgXG4gIClcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gIGlmIChkaXIubW9kaWZpZXJzKSB7XG4gICAgd2Fybihgdi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLmApO1xuICB9XG4gIGVsLndyYXBMaXN0ZW5lcnMgPSAoY29kZSkgPT4gYF9nKCR7Y29kZX0sJHtkaXIudmFsdWV9KWA7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSAoY29kZSkgPT4ge1xuICAgIHJldHVybiBgX2IoJHtjb2RlfSwnJHtlbC50YWd9Jywke2Rpci52YWx1ZX0sJHtcbiAgICAgIGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJ1xuICAgIH0ke1xuICAgICAgZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnN5bmMgPyAnLHRydWUnIDogJydcbiAgICB9KWBcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb24sXG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn07XG5cbi8qICAqL1xuXG5cblxuXG5cbmNsYXNzIENvZGVnZW5TdGF0ZSB7XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG5cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gICAgY29uc3QgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICB0aGlzLm1heWJlQ29tcG9uZW50ID0gKGVsKSA9PiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpO1xuICAgIHRoaXMub25jZUlkID0gMDtcbiAgICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xuICAgIHRoaXMucHJlID0gZmFsc2U7XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgY29uc3Qgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICBjb25zdCBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiBgd2l0aCh0aGlzKXtyZXR1cm4gJHtjb2RlfX1gLFxuICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gIGlmIChlbC5wYXJlbnQpIHtcbiAgICBlbC5wcmUgPSBlbC5wcmUgfHwgZWwucGFyZW50LnByZTtcbiAgfVxuXG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQgJiYgIXN0YXRlLnByZSkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICBsZXQgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRhdGE7XG4gICAgICBpZiAoIWVsLnBsYWluIHx8IChlbC5wcmUgJiYgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpKSkge1xuICAgICAgICBkYXRhID0gZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBgX2MoJyR7ZWwudGFnfScke1xuICAgICAgICBkYXRhID8gYCwke2RhdGF9YCA6ICcnIC8vIGRhdGFcbiAgICAgIH0ke1xuICAgICAgICBjaGlsZHJlbiA/IGAsJHtjaGlsZHJlbn1gIDogJycgLy8gY2hpbGRyZW5cbiAgICAgIH0pYDtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgLy8gU29tZSBlbGVtZW50cyAodGVtcGxhdGVzKSBuZWVkIHRvIGJlaGF2ZSBkaWZmZXJlbnRseSBpbnNpZGUgb2YgYSB2LXByZVxuICAvLyBub2RlLiAgQWxsIHByZSBub2RlcyBhcmUgc3RhdGljIHJvb3RzLCBzbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBsb2NhdGlvbiB0b1xuICAvLyB3cmFwIGEgc3RhdGUgY2hhbmdlIGFuZCByZXNldCBpdCB1cG9uIGV4aXRpbmcgdGhlIHByZSBub2RlLlxuICBjb25zdCBvcmlnaW5hbFByZVN0YXRlID0gc3RhdGUucHJlO1xuICBpZiAoZWwucHJlKSB7XG4gICAgc3RhdGUucHJlID0gZWwucHJlO1xuICB9XG4gIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKGB3aXRoKHRoaXMpe3JldHVybiAke2dlbkVsZW1lbnQoZWwsIHN0YXRlKX19YCk7XG4gIHN0YXRlLnByZSA9IG9yaWdpbmFsUHJlU3RhdGU7XG4gIHJldHVybiBgX20oJHtcbiAgICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMVxuICB9JHtcbiAgICBlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJ1xuICB9KWBcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCwgc3RhdGUpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgbGV0IGtleSA9ICcnO1xuICAgIGxldCBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBzdGF0ZS53YXJuKFxuICAgICAgICBgdi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIGAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW9uY2UnXVxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gICAgcmV0dXJuIGBfbygke2dlbkVsZW1lbnQoZWwsIHN0YXRlKX0sJHtzdGF0ZS5vbmNlSWQrK30sJHtrZXl9KWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICBjb25kaXRpb25zLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gIH1cblxuICBjb25zdCBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIGAoJHtjb25kaXRpb24uZXhwfSk/JHtcbiAgICAgIGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKVxuICAgIH06JHtcbiAgICAgIGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbiAgICB9YFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHtnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jayl9YFxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBhbHRHZW5cbiAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgIDogZWwub25jZVxuICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxuICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRIZWxwZXJcbikge1xuICBjb25zdCBleHAgPSBlbC5mb3I7XG4gIGNvbnN0IGFsaWFzID0gZWwuYWxpYXM7XG4gIGNvbnN0IGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IGAsJHtlbC5pdGVyYXRvcjF9YCA6ICcnO1xuICBjb25zdCBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyBgLCR7ZWwuaXRlcmF0b3IyfWAgOiAnJztcblxuICBpZiAoc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBgPCR7ZWwudGFnfSB2LWZvcj1cIiR7YWxpYXN9IGluICR7ZXhwfVwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggYCArXG4gICAgICBgdi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gYCArXG4gICAgICBgU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5gLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10sXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGAke2FsdEhlbHBlciB8fCAnX2wnfSgoJHtleHB9KSxgICtcbiAgICBgZnVuY3Rpb24oJHthbGlhc30ke2l0ZXJhdG9yMX0ke2l0ZXJhdG9yMn0pe2AgK1xuICAgICAgYHJldHVybiAkeyhhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKX1gICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIGxldCBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIGNvbnN0IGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gIGlmIChkaXJzKSBkYXRhICs9IGRpcnMgKyAnLCc7XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IGBrZXk6JHtlbC5rZXl9LGA7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IGByZWY6JHtlbC5yZWZ9LGA7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBgcmVmSW5Gb3I6dHJ1ZSxgO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBgcHJlOnRydWUsYDtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBgdGFnOlwiJHtlbC50YWd9XCIsYDtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBgYXR0cnM6JHtnZW5Qcm9wcyhlbC5hdHRycyl9LGA7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gYGRvbVByb3BzOiR7Z2VuUHJvcHMoZWwucHJvcHMpfSxgO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IGAke2dlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpfSxgO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IGAke2dlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSl9LGA7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgZGF0YSArPSBgc2xvdDoke2VsLnNsb3RUYXJnZXR9LGA7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gYCR7Z2VuU2NvcGVkU2xvdHMoZWwsIGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSl9LGA7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBgbW9kZWw6e3ZhbHVlOiR7XG4gICAgICBlbC5tb2RlbC52YWx1ZVxuICAgIH0sY2FsbGJhY2s6JHtcbiAgICAgIGVsLm1vZGVsLmNhbGxiYWNrXG4gICAgfSxleHByZXNzaW9uOiR7XG4gICAgICBlbC5tb2RlbC5leHByZXNzaW9uXG4gICAgfX0sYDtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgY29uc3QgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBgJHtpbmxpbmVUZW1wbGF0ZX0sYDtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkeW5hbWljIGFyZ3VtZW50IHdyYXBcbiAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgLy8gbWVyZ2UgaGVscGVyIHNvIHRoYXQgY2xhc3Mvc3R5bGUvbXVzdFVzZVByb3AgYXR0cnMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICBpZiAoZWwuZHluYW1pY0F0dHJzKSB7XG4gICAgZGF0YSA9IGBfYigke2RhdGF9LFwiJHtlbC50YWd9XCIsJHtnZW5Qcm9wcyhlbC5keW5hbWljQXR0cnMpfSlgO1xuICB9XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIC8vIHYtb24gZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gIGNvbnN0IGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHJldHVyblxuICBsZXQgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIGxldCBoYXNSdW50aW1lID0gZmFsc2U7XG4gIGxldCBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICBjb25zdCBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBge25hbWU6XCIke2Rpci5uYW1lfVwiLHJhd05hbWU6XCIke2Rpci5yYXdOYW1lfVwiJHtcbiAgICAgICAgZGlyLnZhbHVlID8gYCx2YWx1ZTooJHtkaXIudmFsdWV9KSxleHByZXNzaW9uOiR7SlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKX1gIDogJydcbiAgICAgIH0ke1xuICAgICAgICBkaXIuYXJnID8gYCxhcmc6JHtkaXIuaXNEeW5hbWljQXJnID8gZGlyLmFyZyA6IGBcIiR7ZGlyLmFyZ31cImB9YCA6ICcnXG4gICAgICB9JHtcbiAgICAgICAgZGlyLm1vZGlmaWVycyA/IGAsbW9kaWZpZXJzOiR7SlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycyl9YCA6ICcnXG4gICAgICB9fSxgO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsLCBzdGF0ZSkge1xuICBjb25zdCBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMSkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICAnSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyxcbiAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICApO1xuICB9XG4gIGlmIChhc3QgJiYgYXN0LnR5cGUgPT09IDEpIHtcbiAgICBjb25zdCBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiBgaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpeyR7XG4gICAgICBpbmxpbmVSZW5kZXJGbnMucmVuZGVyXG4gICAgfX0sc3RhdGljUmVuZGVyRm5zOlske1xuICAgICAgaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoY29kZSA9PiBgZnVuY3Rpb24oKXske2NvZGV9fWApLmpvaW4oJywnKVxuICAgIH1dfWBcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gIGVsLFxuICBzbG90cyxcbiAgc3RhdGVcbikge1xuICAvLyBieSBkZWZhdWx0IHNjb3BlZCBzbG90cyBhcmUgY29uc2lkZXJlZCBcInN0YWJsZVwiLCB0aGlzIGFsbG93cyBjaGlsZFxuICAvLyBjb21wb25lbnRzIHdpdGggb25seSBzY29wZWQgc2xvdHMgdG8gc2tpcCBmb3JjZWQgdXBkYXRlcyBmcm9tIHBhcmVudC5cbiAgLy8gYnV0IGluIHNvbWUgY2FzZXMgd2UgaGF2ZSB0byBiYWlsLW91dCBvZiB0aGlzIG9wdGltaXphdGlvblxuICAvLyBmb3IgZXhhbXBsZSBpZiB0aGUgc2xvdCBjb250YWlucyBkeW5hbWljIG5hbWVzLCBoYXMgdi1pZiBvciB2LWZvciBvbiB0aGVtLi4uXG4gIGxldCBuZWVkc0ZvcmNlVXBkYXRlID0gT2JqZWN0LmtleXMoc2xvdHMpLnNvbWUoa2V5ID0+IHtcbiAgICBjb25zdCBzbG90ID0gc2xvdHNba2V5XTtcbiAgICByZXR1cm4gKFxuICAgICAgc2xvdC5zbG90VGFyZ2V0RHluYW1pYyB8fFxuICAgICAgc2xvdC5pZiB8fFxuICAgICAgc2xvdC5mb3IgfHxcbiAgICAgIGNvbnRhaW5zU2xvdENoaWxkKHNsb3QpIC8vIGlzIHBhc3NpbmcgZG93biBzbG90IGZyb20gcGFyZW50IHdoaWNoIG1heSBiZSBkeW5hbWljXG4gICAgKVxuICB9KTtcbiAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCAodGhlIHJlYWN0aXZpdHkgaXMgZGlzY29ubmVjdGVkKVxuICAvLyAjOTQzOFxuICBpZiAoIW5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICBsZXQgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuc2xvdFNjb3BlICYmIHBhcmVudC5zbG90U2NvcGUgIT09IGVtcHR5U2xvdFNjb3BlVG9rZW4pIHtcbiAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBgc2NvcGVkU2xvdHM6X3UoWyR7XG4gICAgT2JqZWN0LmtleXMoc2xvdHMpLm1hcChrZXkgPT4ge1xuICAgICAgcmV0dXJuIGdlblNjb3BlZFNsb3Qoc2xvdHNba2V5XSwgc3RhdGUpXG4gICAgfSkuam9pbignLCcpXG4gIH1dJHtuZWVkc0ZvcmNlVXBkYXRlID8gYCx0cnVlYCA6IGBgfSlgXG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zU2xvdENoaWxkIChlbCkge1xuICBpZiAoZWwudHlwZSA9PT0gMSkge1xuICAgIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGVsLmNoaWxkcmVuLnNvbWUoY29udGFpbnNTbG90Q2hpbGQpXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxuICBlbCxcbiAgc3RhdGVcbikge1xuICBjb25zdCBpc0xlZ2FjeVN5bnRheCA9IGVsLmF0dHJzTWFwWydzbG90LXNjb3BlJ107XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQgJiYgIWlzTGVnYWN5U3ludGF4KSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdCwgYG51bGxgKVxuICB9XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90KVxuICB9XG4gIGNvbnN0IHNsb3RTY29wZSA9IGVsLnNsb3RTY29wZSA9PT0gZW1wdHlTbG90U2NvcGVUb2tlblxuICAgID8gYGBcbiAgICA6IFN0cmluZyhlbC5zbG90U2NvcGUpO1xuICBjb25zdCBmbiA9IGBmdW5jdGlvbigke3Nsb3RTY29wZX0pe2AgK1xuICAgIGByZXR1cm4gJHtlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZWwuaWYgJiYgaXNMZWdhY3lTeW50YXhcbiAgICAgICAgPyBgKCR7ZWwuaWZ9KT8ke2dlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCd9OnVuZGVmaW5lZGBcbiAgICAgICAgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH19YDtcbiAgLy8gcmV2ZXJzZSBwcm94eSB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICBjb25zdCByZXZlcnNlUHJveHkgPSBzbG90U2NvcGUgPyBgYCA6IGAscHJveHk6dHJ1ZWA7XG4gIHJldHVybiBge2tleToke2VsLnNsb3RUYXJnZXQgfHwgYFwiZGVmYXVsdFwiYH0sZm46JHtmbn0ke3JldmVyc2VQcm94eX19YFxufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGNvbnN0IGVsID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwuZm9yICYmXG4gICAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgIGVsLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICBjb25zdCBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgICA/IHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSA/IGAsMWAgOiBgLDBgXG4gICAgICAgIDogYGA7XG4gICAgICByZXR1cm4gYCR7KGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKX0ke25vcm1hbGl6YXRpb25UeXBlfWBcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIGNvbnN0IGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICByZXR1cm4gYFske2NoaWxkcmVuLm1hcChjID0+IGdlbihjLCBzdGF0ZSkpLmpvaW4oJywnKX1dJHtcbiAgICAgIG5vcm1hbGl6YXRpb25UeXBlID8gYCwke25vcm1hbGl6YXRpb25UeXBlfWAgOiAnJ1xuICAgIH1gXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgbGV0IHJlcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGMgPT4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spKSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoYyA9PiBtYXliZUNvbXBvbmVudChjLmJsb2NrKSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIGBfdigke3RleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKVxuICB9KWBcbn1cblxuZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICByZXR1cm4gYF9lKCR7SlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KX0pYFxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgY29uc3Qgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICBjb25zdCBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSk7XG4gIGxldCByZXMgPSBgX3QoJHtzbG90TmFtZX0ke2NoaWxkcmVuID8gYCwke2NoaWxkcmVufWAgOiAnJ31gO1xuICBjb25zdCBhdHRycyA9IGVsLmF0dHJzIHx8IGVsLmR5bmFtaWNBdHRyc1xuICAgID8gZ2VuUHJvcHMoKGVsLmF0dHJzIHx8IFtdKS5jb25jYXQoZWwuZHluYW1pY0F0dHJzIHx8IFtdKS5tYXAoYXR0ciA9PiAoe1xuICAgICAgICAvLyBzbG90IHByb3BzIGFyZSBjYW1lbGl6ZWRcbiAgICAgICAgbmFtZTogY2FtZWxpemUoYXR0ci5uYW1lKSxcbiAgICAgICAgdmFsdWU6IGF0dHIudmFsdWUsXG4gICAgICAgIGR5bmFtaWM6IGF0dHIuZHluYW1pY1xuICAgICAgfSkpKVxuICAgIDogbnVsbDtcbiAgY29uc3QgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gYCxudWxsYDtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gYCwke2F0dHJzfWA7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gYCR7YXR0cnMgPyAnJyA6ICcsbnVsbCd9LCR7YmluZCQkMX1gO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgY29tcG9uZW50TmFtZSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICByZXR1cm4gYF9jKCR7Y29tcG9uZW50TmFtZX0sJHtnZW5EYXRhJDIoZWwsIHN0YXRlKX0ke1xuICAgIGNoaWxkcmVuID8gYCwke2NoaWxkcmVufWAgOiAnJ1xuICB9KWBcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIGxldCBzdGF0aWNQcm9wcyA9IGBgO1xuICBsZXQgZHluYW1pY1Byb3BzID0gYGA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgY29uc3QgdmFsdWUgPSB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSk7XG4gICAgaWYgKHByb3AuZHluYW1pYykge1xuICAgICAgZHluYW1pY1Byb3BzICs9IGAke3Byb3AubmFtZX0sJHt2YWx1ZX0sYDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGljUHJvcHMgKz0gYFwiJHtwcm9wLm5hbWV9XCI6JHt2YWx1ZX0sYDtcbiAgICB9XG4gIH1cbiAgc3RhdGljUHJvcHMgPSBgeyR7c3RhdGljUHJvcHMuc2xpY2UoMCwgLTEpfX1gO1xuICBpZiAoZHluYW1pY1Byb3BzKSB7XG4gICAgcmV0dXJuIGBfZCgke3N0YXRpY1Byb3BzfSxbJHtkeW5hbWljUHJvcHMuc2xpY2UoMCwgLTEpfV0pYFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0aWNQcm9wc1xuICB9XG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG5cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbmNvbnN0IHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG5jb25zdCB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbmNvbnN0IHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0LCB3YXJuKSB7XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCB3YXJuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIHdhcm4pIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHJhbmdlID0gbm9kZS5yYXdBdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgYHYtZm9yPVwiJHt2YWx1ZX1cImAsIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgYCR7bmFtZX09XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIGAke25hbWV9PVwiJHt2YWx1ZX1cImAsIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgd2Fybik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgd2Fybiwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICBjb25zdCBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICBjb25zdCBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICB3YXJuKFxuICAgICAgYGF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogYCArXG4gICAgICBgXCIke2tleXdvcmRNYXRjaFswXX1cIiBpbiBleHByZXNzaW9uICR7dGV4dC50cmltKCl9YCxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICBpZGVudCxcbiAgdHlwZSxcbiAgdGV4dCxcbiAgd2FybixcbiAgcmFuZ2Vcbikge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oYHZhciAke2lkZW50fT1fYCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihgaW52YWxpZCAke3R5cGV9IFwiJHtpZGVudH1cIiBpbiBleHByZXNzaW9uOiAke3RleHQudHJpbSgpfWAsIHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKGByZXR1cm4gJHtleHB9YCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zdCBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgd2FybihcbiAgICAgICAgYGF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBgICtcbiAgICAgICAgYFwiJHtrZXl3b3JkTWF0Y2hbMF19XCJcXG4gIFJhdyBleHByZXNzaW9uOiAke3RleHQudHJpbSgpfWAsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgaW52YWxpZCBleHByZXNzaW9uOiAke2UubWVzc2FnZX0gaW5cXG5cXG5gICtcbiAgICAgICAgYCAgICAke2V4cH1cXG5cXG5gICtcbiAgICAgICAgYCAgUmF3IGV4cHJlc3Npb246ICR7dGV4dC50cmltKCl9XFxuYCxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCByYW5nZSA9IDI7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lIChcbiAgc291cmNlLFxuICBzdGFydCA9IDAsXG4gIGVuZCA9IHNvdXJjZS5sZW5ndGhcbikge1xuICBjb25zdCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XG4gICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aCkgY29udGludWVcbiAgICAgICAgcmVzLnB1c2goYCR7aiArIDF9JHtyZXBlYXQoYCBgLCAzIC0gU3RyaW5nKGogKyAxKS5sZW5ndGgpfXwgICR7bGluZXNbal19YCk7XG4gICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcbiAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIGxpbmVMZW5ndGgpICsgMTtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcbiAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIHJlcGVhdChgIGAsIHBhZCkgKyByZXBlYXQoYF5gLCBsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyByZXBlYXQoYF5gLCBsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbignXFxuJylcbn1cblxuZnVuY3Rpb24gcmVwZWF0IChzdHIsIG4pIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICB3aGlsZSAodHJ1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKG4gJiAxKSByZXN1bHQgKz0gc3RyO1xuICAgIG4gPj4+PSAxO1xuICAgIGlmIChuIDw9IDApIGJyZWFrXG4gICAgc3RyICs9IHN0cjtcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnIsIGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIGNvbnN0IHdhcm4kJDEgPSBvcHRpb25zLndhcm4gfHwgd2FybjtcbiAgICBkZWxldGUgb3B0aW9ucy53YXJuO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIGNvbnN0IGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICBjb25zdCBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAgIGBFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuJHtlLm1zZ31cXG5cXG5gICtcbiAgICAgICAgICAgICAgZ2VuZXJhdGVDb2RlRnJhbWUodGVtcGxhdGUsIGUuc3RhcnQsIGUuZW5kKSxcbiAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgIGBFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuJHt0ZW1wbGF0ZX1cXG5cXG5gICtcbiAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZSA9PiBgLSAke2V9YCkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZSA9PiB0aXAoZS5tc2csIHZtKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKG1zZyA9PiB0aXAobXNnLCB2bSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgY29uc3QgcmVzID0ge307XG4gICAgY29uc3QgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoY29kZSA9PiB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIGBGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcbmAgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcCgoeyBlcnIsIGNvZGUgfSkgPT4gYCR7ZXJyLnRvU3RyaW5nKCl9IGluXFxuXFxuJHtjb2RlfVxcbmApLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgY29uc3QgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIGNvbnN0IHRpcHMgPSBbXTtcblxuICAgICAgbGV0IHdhcm4gPSAobXNnLCByYW5nZSwgdGlwKSA9PiB7XG4gICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgIGNvbnN0IGxlYWRpbmdTcGFjZUxlbmd0aCA9IHRlbXBsYXRlLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcblxuICAgICAgICAgIHdhcm4gPSAobXNnLCByYW5nZSwgdGlwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0geyBtc2cgfTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuc3RhcnQgPSByYW5nZS5zdGFydCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVuZCA9IHJhbmdlLmVuZCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2goZGF0YSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaW5hbE9wdGlvbnMud2FybiA9IHdhcm47XG5cbiAgICAgIGNvbnN0IGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUudHJpbSgpLCBmaW5hbE9wdGlvbnMpO1xuICAgICAge1xuICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgcmV0dXJuIGNvbXBpbGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBpbGUsXG4gICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxuY29uc3QgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIGNvbnN0IGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLm9wdGltaXplICE9PSBmYWxzZSkge1xuICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIH1cbiAgY29uc3QgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0LFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59KTtcblxuLyogICovXG5cbmNvbnN0IHsgY29tcGlsZSwgY29tcGlsZVRvRnVuY3Rpb25zIH0gPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG5cbi8qICAqL1xuXG4vLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xubGV0IGRpdjtcbmZ1bmN0aW9uIGdldFNob3VsZERlY29kZSAoaHJlZikge1xuICBkaXYgPSBkaXYgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBocmVmID8gYDxhIGhyZWY9XCJcXG5cIi8+YCA6IGA8ZGl2IGE9XCJcXG5cIi8+YDtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZignJiMxMDsnKSA+IDBcbn1cblxuLy8gIzM2NjM6IElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbmNvbnN0IHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxuY29uc3Qgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbi8qICAqL1xuXG5jb25zdCBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoaWQgPT4ge1xuICBjb25zdCBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbmNvbnN0IG1vdW50ID0gVnVlLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHdhcm4oXG4gICAgICBgRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuYFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgbGV0IHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBgVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6ICR7b3B0aW9ucy50ZW1wbGF0ZX1gLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9ID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIG91dHB1dFNvdXJjZVJhbmdlOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKGB2dWUgJHt0aGlzLl9uYW1lfSBjb21waWxlYCwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlO1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2PlxuICAgIDxzZWxlY3QgY2xhc3M9J3NlbGVjdCcgdi1tb2RlbD0nc2VsZWN0ZWQnIEBpbnB1dD0nZXZlbnQgPT4geyAkZW1pdChcImlucHV0XCIsIGV2ZW50LnRhcmdldC52YWx1ZSkgfSc+XG4gICAgICA8b3B0aW9uIHYtZm9yPSdvcHRpb24gaW4gb3B0aW9ucycgOmtleT0nb3B0aW9uLnZhbHVlJyA6dmFsdWU9J29wdGlvbi52YWx1ZSc+XG4gICAgICAgIHt7IG9wdGlvbi50ZXh0IH19XG4gICAgICA8L29wdGlvbj5cbiAgICA8L3NlbGVjdD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c3R5bGU+PC9zdHlsZT5cblxuPHNjcmlwdD5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiBbJ29wdGlvbnMnLCAndmFsdWUnXSxcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0ZWQ6IG51bGwsXG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMudmFsdWU7XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2VsZWN0RGF0YSA9IFtcbiAgeyB0ZXh0OiAnQWxsIEJvcm91Z2hzJywgdmFsdWU6ICdhbGwnIH0sXG4gIHsgdGV4dDogJ0Jyb29rbHluJywgdmFsdWU6ICdicm9va2x5bicgfSxcbiAgeyB0ZXh0OiAnUXVlZW5zJywgdmFsdWU6ICdxdWVlbnMnIH0sXG4gIHsgdGV4dDogJ01hbmhhdHRhbicsIHZhbHVlOiAnbWFuaGF0dGFuJyB9LFxuICB7IHRleHQ6ICdTdGF0ZW4gSXNsYW5kJywgdmFsdWU6ICdzdGF0ZW4gaXNsYW5kJyB9LFxuICB7IHRleHQ6ICdUaGUgQnJvbngnLCB2YWx1ZTogJ2Jyb254JyB9XG5dO1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3REYXRhOyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInOyAvL1xuaW1wb3J0IFNlbGVjdENvbXBvbmVudCBmcm9tICcuL3NlbGVjdC52dWUnOyAvLyBPdXIgY29tcG9uZW50XG5pbXBvcnQgU2VsZWN0RGF0YSBmcm9tICcuL3NlbGVjdC5kYXRhLmpzJzsgLy8gT3VyIHNhbXBsZSBkYXRhXG5cbmNsYXNzIFNlbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgVnVlLmNvbXBvbmVudCgnbnljby1zZWxlY3QnLCBTZWxlY3RDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogJ1tkYXRhLWpzPVwiYXBwXCJdJyxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvcHRpb25zOiBTZWxlY3QuZGF0YSxcbiAgICAgICAgICBzZWxlY3RlZDogJ2FsbCcsXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuU2VsZWN0LmRhdGEgPSBTZWxlY3REYXRhO1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Q7IiwiZnVuY3Rpb24gZGF0YUhhbmRsZXIobmV3RGF0YSwgb2xkRGF0YSkge1xuICBpZiAob2xkRGF0YSkge1xuICAgIHZhciBjaGFydCA9IHRoaXMuJGRhdGEuX2NoYXJ0O1xuICAgIHZhciBuZXdEYXRhc2V0TGFiZWxzID0gbmV3RGF0YS5kYXRhc2V0cy5tYXAoZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhc2V0LmxhYmVsO1xuICAgIH0pO1xuICAgIHZhciBvbGREYXRhc2V0TGFiZWxzID0gb2xkRGF0YS5kYXRhc2V0cy5tYXAoZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhc2V0LmxhYmVsO1xuICAgIH0pO1xuICAgIHZhciBvbGRMYWJlbHMgPSBKU09OLnN0cmluZ2lmeShvbGREYXRhc2V0TGFiZWxzKTtcbiAgICB2YXIgbmV3TGFiZWxzID0gSlNPTi5zdHJpbmdpZnkobmV3RGF0YXNldExhYmVscyk7XG5cbiAgICBpZiAobmV3TGFiZWxzID09PSBvbGRMYWJlbHMgJiYgb2xkRGF0YS5kYXRhc2V0cy5sZW5ndGggPT09IG5ld0RhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICBuZXdEYXRhLmRhdGFzZXRzLmZvckVhY2goZnVuY3Rpb24gKGRhdGFzZXQsIGkpIHtcbiAgICAgICAgdmFyIG9sZERhdGFzZXRLZXlzID0gT2JqZWN0LmtleXMob2xkRGF0YS5kYXRhc2V0c1tpXSk7XG4gICAgICAgIHZhciBuZXdEYXRhc2V0S2V5cyA9IE9iamVjdC5rZXlzKGRhdGFzZXQpO1xuICAgICAgICB2YXIgZGVsZXRpb25LZXlzID0gb2xkRGF0YXNldEtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4ga2V5ICE9PSAnX21ldGEnICYmIG5ld0RhdGFzZXRLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGlvbktleXMuZm9yRWFjaChmdW5jdGlvbiAoZGVsZXRpb25LZXkpIHtcbiAgICAgICAgICBkZWxldGUgY2hhcnQuZGF0YS5kYXRhc2V0c1tpXVtkZWxldGlvbktleV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGF0dHJpYnV0ZSBpbiBkYXRhc2V0KSB7XG4gICAgICAgICAgaWYgKGRhdGFzZXQuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlKSkge1xuICAgICAgICAgICAgY2hhcnQuZGF0YS5kYXRhc2V0c1tpXVthdHRyaWJ1dGVdID0gZGF0YXNldFthdHRyaWJ1dGVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZXdEYXRhLmhhc093blByb3BlcnR5KCdsYWJlbHMnKSkge1xuICAgICAgICBjaGFydC5kYXRhLmxhYmVscyA9IG5ld0RhdGEubGFiZWxzO1xuICAgICAgICB0aGlzLiRlbWl0KCdsYWJlbHM6dXBkYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdEYXRhLmhhc093blByb3BlcnR5KCd4TGFiZWxzJykpIHtcbiAgICAgICAgY2hhcnQuZGF0YS54TGFiZWxzID0gbmV3RGF0YS54TGFiZWxzO1xuICAgICAgICB0aGlzLiRlbWl0KCd4bGFiZWxzOnVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3RGF0YS5oYXNPd25Qcm9wZXJ0eSgneUxhYmVscycpKSB7XG4gICAgICAgIGNoYXJ0LmRhdGEueUxhYmVscyA9IG5ld0RhdGEueUxhYmVscztcbiAgICAgICAgdGhpcy4kZW1pdCgneWxhYmVsczp1cGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFydDp1cGRhdGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNoYXJ0KSB7XG4gICAgICAgIGNoYXJ0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhcnQ6ZGVzdHJveScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMuY2hhcnREYXRhLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy4kZW1pdCgnY2hhcnQ6cmVuZGVyJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLiRkYXRhLl9jaGFydCkge1xuICAgICAgdGhpcy4kZGF0YS5fY2hhcnQuZGVzdHJveSgpO1xuXG4gICAgICB0aGlzLiRlbWl0KCdjaGFydDpkZXN0cm95Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLiRlbWl0KCdjaGFydDpyZW5kZXInKTtcbiAgfVxufVxuXG5leHBvcnQgdmFyIHJlYWN0aXZlRGF0YSA9IHtcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhcnREYXRhOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAnY2hhcnREYXRhJzogZGF0YUhhbmRsZXJcbiAgfVxufTtcbmV4cG9ydCB2YXIgcmVhY3RpdmVQcm9wID0ge1xuICBwcm9wczoge1xuICAgIGNoYXJ0RGF0YToge1xuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgJ2NoYXJ0RGF0YSc6IGRhdGFIYW5kbGVyXG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCB7XG4gIHJlYWN0aXZlRGF0YTogcmVhY3RpdmVEYXRhLFxuICByZWFjdGl2ZVByb3A6IHJlYWN0aXZlUHJvcFxufTsiLCIvLyEgbW9tZW50LmpzXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIGhvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICByZmMyODIyICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHdlZWtkYXlNaXNtYXRjaCA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPSBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcbiAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xuICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcbiAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XG4gICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XG4gICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xuICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xuICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XG4gICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XG4gICAgICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XG4gICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgICAgIC8vIG9iamVjdHMuXG4gICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmIChob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCAoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XG4gICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW107XG4gICAgICAgIGZvciAodmFyIHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG4gICAgdmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbiAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbiAgICB2YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKSA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgIHZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG4gICAgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XXswLDI1Nn1bJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkYwN1xcdUZGMTAtXFx1RkZFRl17MSwyNTZ9fFtcXHUwNjAwLVxcdTA2RkZcXC9dezEsMjU2fShcXHMqP1tcXHUwNjAwLVxcdTA2RkZdezEsMjU2fSl7MSwyfS9pO1xuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMDtcbiAgICB2YXIgTU9OVEggPSAxO1xuICAgIHZhciBEQVRFID0gMjtcbiAgICB2YXIgSE9VUiA9IDM7XG4gICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgdmFyIE1JTExJU0VDT05EID0gNjtcbiAgICB2YXIgV0VFSyA9IDc7XG4gICAgdmFyIFdFRUtEQVkgPSA4O1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICAgICAgbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdGdWxsWWVhcicgJiYgaXNMZWFwWWVhcihtb20ueWVhcigpKSAmJiBtb20ubW9udGgoKSA9PT0gMSAmJiBtb20uZGF0ZSgpID09PSAyOSkge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSwgbW9tLm1vbnRoKCksIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgeCkge1xuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgICAgIHJldHVybiBtb2RNb250aCA9PT0gMSA/IChpc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCkgOiAoMzEgLSBtb2RNb250aCAlIDcgJSAyKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy87XG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHMgOlxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydCA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0W01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBhcmdzWzBdID0geSArIDQwMDtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA2dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuICAgIGZ1bmN0aW9uIHNoaWZ0V2Vla2RheXMgKHdzLCBuKSB7XG4gICAgICAgIHJldHVybiB3cy5zbGljZShuLCA3KS5jb25jYXQod3Muc2xpY2UoMCwgbikpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzIDpcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzWyhtICYmIG0gIT09IHRydWUgJiYgdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpKSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgcmV0dXJuIChtID09PSB0cnVlKSA/IHNoaWZ0V2Vla2RheXMod2Vla2RheXMsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB3ZWVrZGF5c1ttLmRheSgpXSA6IHdlZWtkYXlzO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c1Nob3J0LCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICBtZXJpZGllbSgnQScsIGZhbHNlKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIga0lucHV0ID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAvLyB0aGlzIHJ1bGUuXG4gICAgdmFyIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICB2YXIgbG9jYWxlRmFtaWxpZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICB2YXIgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICAvL3dhcm4gdXNlciBpZiBhcmd1bWVudHMgYXJlIHBhc3NlZCBidXQgdGhlIGxvY2FsZSBjb3VsZCBub3QgYmUgc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTG9jYWxlICcgKyBrZXkgKyAgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShjb25maWcucGFyZW50TG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLCB0bXBMb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICAvLyBNRVJHRVxuICAgICAgICAgICAgdG1wTG9jYWxlID0gbG9hZExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IHRtcExvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGdldExvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyhsb2NhbGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgYVtIT1VSXSAgICAgICAgPCAwIHx8IGFbSE9VUl0gICAgICAgID4gMjQgfHwgKGFbSE9VUl0gPT09IDI0ICYmIChhW01JTlVURV0gIT09IDAgfHwgYVtTRUNPTkRdICE9PSAwIHx8IGFbTUlMTElTRUNPTkRdICE9PSAwKSkgPyBIT1VSIDpcbiAgICAgICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICAgICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSwgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIGV4cGVjdGVkV2Vla2RheSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8IGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAgICAgZXhwZWN0ZWRXZWVrZGF5ID0gY29uZmlnLl91c2VVVEMgPyBjb25maWcuX2QuZ2V0VVRDRGF5KCkgOiBjb25maWcuX2QuZ2V0RGF5KCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJiBjb25maWcuX3cuZCAhPT0gZXhwZWN0ZWRXZWVrZGF5KSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3c7XG5cbiAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgdmFyIGN1cldlZWsgPSB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIGRvdywgZG95KTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCB3ZWVrLlxuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgY3VyV2Vlay53ZWVrKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG4gICAgdmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbiAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgLy8gWVlZWU1NIGlzIE5PVCBhbGxvd2VkIGJ5IHRoZSBzdGFuZGFyZFxuICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L11cbiAgICBdO1xuXG4gICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgIHZhciBpc29UaW1lcyA9IFtcbiAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIJywgL1xcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgdmFyIHJmYzI4MjIgPSAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyh5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHNlY29uZFN0cikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xuICAgICAgICBpZiAoeWVhciA8PSA0OSkge1xuICAgICAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKHllYXIgPD0gOTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTkwMCArIHllYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHllYXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgICAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUocGFyc2VkSW5wdXRbMF0sIHBhcnNlZElucHV0WzFdLCBwYXJzZWRJbnB1dFsyXSkuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG9ic09mZnNldHMgPSB7XG4gICAgICAgIFVUOiAwLFxuICAgICAgICBHTVQ6IDAsXG4gICAgICAgIEVEVDogLTQgKiA2MCxcbiAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICBDRFQ6IC01ICogNjAsXG4gICAgICAgIENTVDogLTYgKiA2MCxcbiAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICBNU1Q6IC03ICogNjAsXG4gICAgICAgIFBEVDogLTcgKiA2MCxcbiAgICAgICAgUFNUOiAtOCAqIDYwXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChvYnNPZmZzZXQsIG1pbGl0YXJ5T2Zmc2V0LCBudW1PZmZzZXQpIHtcbiAgICAgICAgaWYgKG9ic09mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWxpdGFyeU9mZnNldCkge1xuICAgICAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApO1xuICAgICAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKG1hdGNoWzRdLCBtYXRjaFszXSwgbWF0Y2hbMl0sIG1hdGNoWzVdLCBtYXRjaFs2XSwgbWF0Y2hbN10pO1xuICAgICAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcblxuICAgICAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICBob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbiAgICBob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG4gICAgfTtcblxuICAgIHZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG0pIHtcbiAgICAgICAgICAgIGlmICghKGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCBub3JtYWxpemVkSW5wdXQuaXNvV2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcblxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgP1xuICAgICAgICAgIDAgOlxuICAgICAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXihcXC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICB2YXIgaXNvUmVnZXggPSAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBjcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG4gICAgY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgICAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgICAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsRnJvbS5pc1ZhbGlkKCkgJiYgbG9jYWxUby5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIobG9jYWxGcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShsb2NhbEZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZShsb2NhbFRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKGxvY2FsVG8sIHVuaXRzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVPckJlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsXG4gICAgICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMzsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzOyBicmVhazsgLy8gMTAwMFxuICAgICAgICAgICAgY2FzZSAnbWludXRlJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDsgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnaG91cic6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAzNmU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlZmF1bHQ6IG91dHB1dCA9IHRoaXMgLSB0aGF0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZTtcbiAgICAgICAgdmFyIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgICAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCB1dGMgPyAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSArIHRoaXMudXRjT2Zmc2V0KCkgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gICAgICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9ICdtb21lbnQnO1xuICAgICAgICB2YXIgem9uZSA9ICcnO1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZWZpeCA9ICdbJyArIGZ1bmMgKyAnKFwiXSc7XG4gICAgICAgIHZhciB5ZWFyID0gKDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSkgPyAnWVlZWScgOiAnWVlZWVlZJztcbiAgICAgICAgdmFyIGRhdGV0aW1lID0gJy1NTS1ERFtUXUhIOm1tOnNzLlNTUyc7XG4gICAgICAgIHZhciBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4gICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICBmdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgdmFyIE1TX1BFUl9TRUNPTkQgPSAxMDAwO1xuICAgIHZhciBNU19QRVJfTUlOVVRFID0gNjAgKiBNU19QRVJfU0VDT05EO1xuICAgIHZhciBNU19QRVJfSE9VUiA9IDYwICogTVNfUEVSX01JTlVURTtcbiAgICB2YXIgTVNfUEVSXzQwMF9ZRUFSUyA9ICgzNjUgKiA0MDAgKyA5NykgKiAyNCAqIE1TX1BFUl9IT1VSO1xuXG4gICAgLy8gYWN0dWFsIG1vZHVsbyAtIGhhbmRsZXMgbmVnYXRpdmUgbnVtYmVycyAoZm9yIGRhdGVzIGJlZm9yZSAxOTcwKTpcbiAgICBmdW5jdGlvbiBtb2QkMShkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgICByZXR1cm4gKGRpdmlkZW5kICUgZGl2aXNvciArIGRpdmlzb3IpICUgZGl2aXNvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbFN0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXRjU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyBEYXRlLlVUQyByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5LCBtLCBkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSAtIHRoaXMubW9udGgoKSAlIDMsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksIE1TX1BFUl9IT1VSKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB2YXIgdGltZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRPZkRhdGUgPSB0aGlzLl9pc1VUQyA/IHV0Y1N0YXJ0T2ZEYXRlIDogbG9jYWxTdGFydE9mRGF0ZTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCkgKyAxLCAwLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSAtIHRoaXMubW9udGgoKSAlIDMgKyAzLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgKyAxLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKSArIDcpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpICsgNykgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSArIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9IT1VSIC0gbW9kJDEodGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksIE1TX1BFUl9IT1VSKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9NSU5VVEUgLSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9TRUNPTkQgLSBtb2QkMSh0aW1lLCBNU19QRVJfU0VDT05EKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgICAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgICAgICAobG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlKSA6XG4gICAgICAgICAgbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW47XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xuICAgIHByb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG4gICAgcHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbiAgICBwcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbiAgICBwcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkICAgICAgICAgICA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG4gICAgcHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xuICAgIHByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xuICAgIHByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbiAgICBwcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xuICAgIHByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xuICAgIHByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XG4gICAgcHJvdG8uaW5zcGVjdCAgICAgICAgICAgPSBpbnNwZWN0O1xuICAgIHByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcbiAgICBwcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayAgICAgICAgICAgPSBwcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgIHByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgcHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIHByb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBwcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBwcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIHByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBwcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuICAgIHByb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBwcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBwcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICBwcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG4gICAgcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciAgICAgICAgPSBjYWxlbmRhcjtcbiAgICBwcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90byQxLnNldCAgICAgICAgICAgICA9IHNldDtcblxuICAgIHByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvJDEubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICBwcm90byQxLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMSAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBnZXRMb2NhbGUpO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxIChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXlzO1xuICAgICAgICB2YXIgbW9udGhzO1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW9udGgnOiAgIHJldHVybiBtb250aHM7XG4gICAgICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6IHJldHVybiBtb250aHMgLyAzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXInOiAgICByZXR1cm4gbW9udGhzIC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuICAgIGZ1bmN0aW9uIHZhbHVlT2YkMSAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbiAgICB2YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbiAgICB2YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbiAgICB2YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbiAgICB2YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbiAgICB2YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbiAgICB2YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbiAgICB2YXIgYXNRdWFydGVycyAgICAgPSBtYWtlQXMoJ1EnKTtcbiAgICB2YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuICAgIGZ1bmN0aW9uIGNsb25lJDEgKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0JDIgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG4gICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbiAgICB2YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xuICAgIHZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xuICAgIHZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciB0aHJlc2hvbGRzID0ge1xuICAgICAgICBzczogNDQsICAgICAgICAgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXG4gICAgICAgIHMgOiA0NSwgICAgICAgICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICBtIDogNDUsICAgICAgICAgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgIGggOiAyMiwgICAgICAgICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgZCA6IDI2LCAgICAgICAgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgTSA6IDExICAgICAgICAgIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lJDEgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgIHZhciBhID0gc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgIHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgICAmJiBbJ3NzJywgc2Vjb25kc10gfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAgICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICAgJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgICAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAgICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcgKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yocm91bmRpbmdGdW5jdGlvbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgICAgIHJldHVybiAoKHggPiAwKSAtICh4IDwgMCkpIHx8ICt4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSBhYnMkMSh0aGlzLl9kYXlzKTtcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGFicyQxKHRoaXMuX21vbnRocyk7XG4gICAgICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICB2YXIgWSA9IHllYXJzO1xuICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgdmFyIEQgPSBkYXlzO1xuICAgICAgICB2YXIgaCA9IGhvdXJzO1xuICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgIHZhciBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcblxuICAgICAgICByZXR1cm4gdG90YWxTaWduICsgJ1AnICtcbiAgICAgICAgICAgIChZID8geW1TaWduICsgWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IHltU2lnbiArIE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBkYXlzU2lnbiArIEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGggPyBobXNTaWduICsgaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IGhtc1NpZ24gKyBtICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBwcm90byQyLmlzVmFsaWQgICAgICAgID0gaXNWYWxpZCQxO1xuICAgIHByb3RvJDIuYWJzICAgICAgICAgICAgPSBhYnM7XG4gICAgcHJvdG8kMi5hZGQgICAgICAgICAgICA9IGFkZCQxO1xuICAgIHByb3RvJDIuc3VidHJhY3QgICAgICAgPSBzdWJ0cmFjdCQxO1xuICAgIHByb3RvJDIuYXMgICAgICAgICAgICAgPSBhcztcbiAgICBwcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICBwcm90byQyLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xuICAgIHByb3RvJDIuYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xuICAgIHByb3RvJDIuYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgcHJvdG8kMi5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG4gICAgcHJvdG8kMi5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xuICAgIHByb3RvJDIuYXNRdWFydGVycyAgICAgPSBhc1F1YXJ0ZXJzO1xuICAgIHByb3RvJDIuYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgIHByb3RvJDIudmFsdWVPZiAgICAgICAgPSB2YWx1ZU9mJDE7XG4gICAgcHJvdG8kMi5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBwcm90byQyLmNsb25lICAgICAgICAgID0gY2xvbmUkMTtcbiAgICBwcm90byQyLmdldCAgICAgICAgICAgID0gZ2V0JDI7XG4gICAgcHJvdG8kMi5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICBwcm90byQyLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICBwcm90byQyLmhvdXJzICAgICAgICAgID0gaG91cnM7XG4gICAgcHJvdG8kMi5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgcHJvdG8kMi53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgIHByb3RvJDIubW9udGhzICAgICAgICAgPSBtb250aHM7XG4gICAgcHJvdG8kMi55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgIHByb3RvJDIuaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICBwcm90byQyLnRvSVNPU3RyaW5nICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvSlNPTiAgICAgICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xuICAgIHByb3RvJDIubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgcHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCB0b0lTT1N0cmluZyQxKTtcbiAgICBwcm90byQyLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgaG9va3MudmVyc2lvbiA9ICcyLjI0LjAnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuICAgIGhvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IHByb3RvO1xuICAgIGhvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICBob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgaG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuICAgIGhvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVUQztcbiAgICBob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVbml4O1xuICAgIGhvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RNb250aHM7XG4gICAgaG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgIGhvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGdldFNldEdsb2JhbExvY2FsZTtcbiAgICBob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSBjcmVhdGVJbnZhbGlkO1xuICAgIGhvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZUR1cmF0aW9uO1xuICAgIGhvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuICAgIGhvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RXZWVrZGF5cztcbiAgICBob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBjcmVhdGVJblpvbmU7XG4gICAgaG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gZ2V0TG9jYWxlO1xuICAgIGhvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG4gICAgaG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdE1vbnRoc1Nob3J0O1xuICAgIGhvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RXZWVrZGF5c01pbjtcbiAgICBob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG4gICAgaG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xuICAgIGhvb2tzLmxvY2FsZXMgICAgICAgICAgICAgICA9IGxpc3RMb2NhbGVzO1xuICAgIGhvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuICAgIGhvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nICA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICBob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICBob29rcy5wcm90b3R5cGUgICAgICAgICAgICAgPSBwcm90bztcblxuICAgIC8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG4gICAgaG9va3MuSFRNTDVfRk1UID0ge1xuICAgICAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfTVM6ICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTUycsICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIERBVEU6ICdZWVlZLU1NLUREJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIC8+XG4gICAgICAgIFRJTUU6ICdISDptbScsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XG4gICAgICAgIFRJTUVfU0VDT05EUzogJ0hIOm1tOnNzJywgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgV0VFSzogJ0dHR0ctW1ddV1cnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICAgICAgTU9OVEg6ICdZWVlZLU1NJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJtb250aFwiIC8+XG4gICAgfTtcblxuICAgIHJldHVybiBob29rcztcblxufSkpKTtcbiIsIi8qIVxuICogQ2hhcnQuanMgdjIuOC4wXG4gKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICogKGMpIDIwMTkgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShmdW5jdGlvbigpIHsgdHJ5IHsgcmV0dXJuIHJlcXVpcmUoJ21vbWVudCcpOyB9IGNhdGNoKGUpIHsgfSB9KCkpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ3JlcXVpcmUnXSwgZnVuY3Rpb24ocmVxdWlyZSkgeyByZXR1cm4gZmFjdG9yeShmdW5jdGlvbigpIHsgdHJ5IHsgcmV0dXJuIHJlcXVpcmUoJ21vbWVudCcpOyB9IGNhdGNoKGUpIHsgfSB9KCkpOyB9KSA6XG4oZ2xvYmFsLkNoYXJ0ID0gZmFjdG9yeShnbG9iYWwubW9tZW50KSk7XG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcblxubW9tZW50ID0gbW9tZW50ICYmIG1vbWVudC5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpID8gbW9tZW50WydkZWZhdWx0J10gOiBtb21lbnQ7XG5cbi8qIE1JVCBsaWNlbnNlICovXG5cbnZhciBjb252ZXJzaW9ucyA9IHtcbiAgcmdiMmhzbDogcmdiMmhzbCxcbiAgcmdiMmhzdjogcmdiMmhzdixcbiAgcmdiMmh3YjogcmdiMmh3YixcbiAgcmdiMmNteWs6IHJnYjJjbXlrLFxuICByZ2Iya2V5d29yZDogcmdiMmtleXdvcmQsXG4gIHJnYjJ4eXo6IHJnYjJ4eXosXG4gIHJnYjJsYWI6IHJnYjJsYWIsXG4gIHJnYjJsY2g6IHJnYjJsY2gsXG5cbiAgaHNsMnJnYjogaHNsMnJnYixcbiAgaHNsMmhzdjogaHNsMmhzdixcbiAgaHNsMmh3YjogaHNsMmh3YixcbiAgaHNsMmNteWs6IGhzbDJjbXlrLFxuICBoc2wya2V5d29yZDogaHNsMmtleXdvcmQsXG5cbiAgaHN2MnJnYjogaHN2MnJnYixcbiAgaHN2MmhzbDogaHN2MmhzbCxcbiAgaHN2Mmh3YjogaHN2Mmh3YixcbiAgaHN2MmNteWs6IGhzdjJjbXlrLFxuICBoc3Yya2V5d29yZDogaHN2MmtleXdvcmQsXG5cbiAgaHdiMnJnYjogaHdiMnJnYixcbiAgaHdiMmhzbDogaHdiMmhzbCxcbiAgaHdiMmhzdjogaHdiMmhzdixcbiAgaHdiMmNteWs6IGh3YjJjbXlrLFxuICBod2Iya2V5d29yZDogaHdiMmtleXdvcmQsXG5cbiAgY215azJyZ2I6IGNteWsycmdiLFxuICBjbXlrMmhzbDogY215azJoc2wsXG4gIGNteWsyaHN2OiBjbXlrMmhzdixcbiAgY215azJod2I6IGNteWsyaHdiLFxuICBjbXlrMmtleXdvcmQ6IGNteWsya2V5d29yZCxcblxuICBrZXl3b3JkMnJnYjoga2V5d29yZDJyZ2IsXG4gIGtleXdvcmQyaHNsOiBrZXl3b3JkMmhzbCxcbiAga2V5d29yZDJoc3Y6IGtleXdvcmQyaHN2LFxuICBrZXl3b3JkMmh3Yjoga2V5d29yZDJod2IsXG4gIGtleXdvcmQyY215azoga2V5d29yZDJjbXlrLFxuICBrZXl3b3JkMmxhYjoga2V5d29yZDJsYWIsXG4gIGtleXdvcmQyeHl6OiBrZXl3b3JkMnh5eixcblxuICB4eXoycmdiOiB4eXoycmdiLFxuICB4eXoybGFiOiB4eXoybGFiLFxuICB4eXoybGNoOiB4eXoybGNoLFxuXG4gIGxhYjJ4eXo6IGxhYjJ4eXosXG4gIGxhYjJyZ2I6IGxhYjJyZ2IsXG4gIGxhYjJsY2g6IGxhYjJsY2gsXG5cbiAgbGNoMmxhYjogbGNoMmxhYixcbiAgbGNoMnh5ejogbGNoMnh5eixcbiAgbGNoMnJnYjogbGNoMnJnYlxufTtcblxuXG5mdW5jdGlvbiByZ2IyaHNsKHJnYikge1xuICB2YXIgciA9IHJnYlswXS8yNTUsXG4gICAgICBnID0gcmdiWzFdLzI1NSxcbiAgICAgIGIgPSByZ2JbMl0vMjU1LFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgbDtcblxuICBpZiAobWF4ID09IG1pbilcbiAgICBoID0gMDtcbiAgZWxzZSBpZiAociA9PSBtYXgpXG4gICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoZyA9PSBtYXgpXG4gICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGIgPT0gbWF4KVxuICAgIGggPSA0ICsgKHIgLSBnKS8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgbCA9IChtaW4gKyBtYXgpIC8gMjtcblxuICBpZiAobWF4ID09IG1pbilcbiAgICBzID0gMDtcbiAgZWxzZSBpZiAobCA8PSAwLjUpXG4gICAgcyA9IGRlbHRhIC8gKG1heCArIG1pbik7XG4gIGVsc2VcbiAgICBzID0gZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cbiAgcmV0dXJuIFtoLCBzICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gcmdiMmhzdihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgIGgsIHMsIHY7XG5cbiAgaWYgKG1heCA9PSAwKVxuICAgIHMgPSAwO1xuICBlbHNlXG4gICAgcyA9IChkZWx0YS9tYXggKiAxMDAwKS8xMDtcblxuICBpZiAobWF4ID09IG1pbilcbiAgICBoID0gMDtcbiAgZWxzZSBpZiAociA9PSBtYXgpXG4gICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoZyA9PSBtYXgpXG4gICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGIgPT0gbWF4KVxuICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuXG4gIGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cbiAgaWYgKGggPCAwKVxuICAgIGggKz0gMzYwO1xuXG4gIHYgPSAoKG1heCAvIDI1NSkgKiAxMDAwKSAvIDEwO1xuXG4gIHJldHVybiBbaCwgcywgdl07XG59XG5cbmZ1bmN0aW9uIHJnYjJod2IocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLFxuICAgICAgZyA9IHJnYlsxXSxcbiAgICAgIGIgPSByZ2JbMl0sXG4gICAgICBoID0gcmdiMmhzbChyZ2IpWzBdLFxuICAgICAgdyA9IDEvMjU1ICogTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpLFxuICAgICAgYiA9IDEgLSAxLzI1NSAqIE1hdGgubWF4KHIsIE1hdGgubWF4KGcsIGIpKTtcblxuICByZXR1cm4gW2gsIHcgKiAxMDAsIGIgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyY215ayhyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0gLyAyNTUsXG4gICAgICBnID0gcmdiWzFdIC8gMjU1LFxuICAgICAgYiA9IHJnYlsyXSAvIDI1NSxcbiAgICAgIGMsIG0sIHksIGs7XG5cbiAgayA9IE1hdGgubWluKDEgLSByLCAxIC0gZywgMSAtIGIpO1xuICBjID0gKDEgLSByIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIG0gPSAoMSAtIGcgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgeSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICByZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2Iya2V5d29yZChyZ2IpIHtcbiAgcmV0dXJuIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShyZ2IpXTtcbn1cblxuZnVuY3Rpb24gcmdiMnh5eihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0gLyAyNTUsXG4gICAgICBnID0gcmdiWzFdIC8gMjU1LFxuICAgICAgYiA9IHJnYlsyXSAvIDI1NTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKHIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAociAvIDEyLjkyKTtcbiAgZyA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChnICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGcgLyAxMi45Mik7XG4gIGIgPSBiID4gMC4wNDA0NSA/IE1hdGgucG93KCgoYiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChiIC8gMTIuOTIpO1xuXG4gIHZhciB4ID0gKHIgKiAwLjQxMjQpICsgKGcgKiAwLjM1NzYpICsgKGIgKiAwLjE4MDUpO1xuICB2YXIgeSA9IChyICogMC4yMTI2KSArIChnICogMC43MTUyKSArIChiICogMC4wNzIyKTtcbiAgdmFyIHogPSAociAqIDAuMDE5MykgKyAoZyAqIDAuMTE5MikgKyAoYiAqIDAuOTUwNSk7XG5cbiAgcmV0dXJuIFt4ICogMTAwLCB5ICoxMDAsIHogKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IybGFiKHJnYikge1xuICB2YXIgeHl6ID0gcmdiMnh5eihyZ2IpLFxuICAgICAgICB4ID0geHl6WzBdLFxuICAgICAgICB5ID0geHl6WzFdLFxuICAgICAgICB6ID0geHl6WzJdLFxuICAgICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gcmdiMmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHJnYjJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wycmdiKGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSAvIDM2MCxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgdDEsIHQyLCB0MywgcmdiLCB2YWw7XG5cbiAgaWYgKHMgPT0gMCkge1xuICAgIHZhbCA9IGwgKiAyNTU7XG4gICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsXTtcbiAgfVxuXG4gIGlmIChsIDwgMC41KVxuICAgIHQyID0gbCAqICgxICsgcyk7XG4gIGVsc2VcbiAgICB0MiA9IGwgKyBzIC0gbCAqIHM7XG4gIHQxID0gMiAqIGwgLSB0MjtcblxuICByZ2IgPSBbMCwgMCwgMF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgdDMgPSBoICsgMSAvIDMgKiAtIChpIC0gMSk7XG4gICAgdDMgPCAwICYmIHQzKys7XG4gICAgdDMgPiAxICYmIHQzLS07XG5cbiAgICBpZiAoNiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzO1xuICAgIGVsc2UgaWYgKDIgKiB0MyA8IDEpXG4gICAgICB2YWwgPSB0MjtcbiAgICBlbHNlIGlmICgzICogdDMgPCAyKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2O1xuICAgIGVsc2VcbiAgICAgIHZhbCA9IHQxO1xuXG4gICAgcmdiW2ldID0gdmFsICogMjU1O1xuICB9XG5cbiAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gaHNsMmhzdihoc2wpIHtcbiAgdmFyIGggPSBoc2xbMF0sXG4gICAgICBzID0gaHNsWzFdIC8gMTAwLFxuICAgICAgbCA9IGhzbFsyXSAvIDEwMCxcbiAgICAgIHN2LCB2O1xuXG4gIGlmKGwgPT09IDApIHtcbiAgICAgIC8vIG5vIG5lZWQgdG8gZG8gY2FsYyBvbiBibGFja1xuICAgICAgLy8gYWxzbyBhdm9pZHMgZGl2aWRlIGJ5IDAgZXJyb3JcbiAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICBsICo9IDI7XG4gIHMgKj0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHYgPSAobCArIHMpIC8gMjtcbiAgc3YgPSAoMiAqIHMpIC8gKGwgKyBzKTtcbiAgcmV0dXJuIFtoLCBzdiAqIDEwMCwgdiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIGhzbDJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3Yihoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHNsMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGhzbDJyZ2IoYXJncykpO1xufVxuXG5cbmZ1bmN0aW9uIGhzdjJyZ2IoaHN2KSB7XG4gIHZhciBoID0gaHN2WzBdIC8gNjAsXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIGhpID0gTWF0aC5mbG9vcihoKSAlIDY7XG5cbiAgdmFyIGYgPSBoIC0gTWF0aC5mbG9vcihoKSxcbiAgICAgIHAgPSAyNTUgKiB2ICogKDEgLSBzKSxcbiAgICAgIHEgPSAyNTUgKiB2ICogKDEgLSAocyAqIGYpKSxcbiAgICAgIHQgPSAyNTUgKiB2ICogKDEgLSAocyAqICgxIC0gZikpKSxcbiAgICAgIHYgPSAyNTUgKiB2O1xuXG4gIHN3aXRjaChoaSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBbdiwgdCwgcF07XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIFtxLCB2LCBwXTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gW3AsIHYsIHRdO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBbcCwgcSwgdl07XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIFt0LCBwLCB2XTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gW3YsIHAsIHFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhzdjJoc2woaHN2KSB7XG4gIHZhciBoID0gaHN2WzBdLFxuICAgICAgcyA9IGhzdlsxXSAvIDEwMCxcbiAgICAgIHYgPSBoc3ZbMl0gLyAxMDAsXG4gICAgICBzbCwgbDtcblxuICBsID0gKDIgLSBzKSAqIHY7XG4gIHNsID0gcyAqIHY7XG4gIHNsIC89IChsIDw9IDEpID8gbCA6IDIgLSBsO1xuICBzbCA9IHNsIHx8IDA7XG4gIGwgLz0gMjtcbiAgcmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIGhzdjJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3Yihoc3YycmdiKGFyZ3MpKVxufVxuXG5mdW5jdGlvbiBoc3YyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc3YycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHN2MmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHN2MnJnYihhcmdzKSk7XG59XG5cbi8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1jb2xvci8jaHdiLXRvLXJnYlxuZnVuY3Rpb24gaHdiMnJnYihod2IpIHtcbiAgdmFyIGggPSBod2JbMF0gLyAzNjAsXG4gICAgICB3aCA9IGh3YlsxXSAvIDEwMCxcbiAgICAgIGJsID0gaHdiWzJdIC8gMTAwLFxuICAgICAgcmF0aW8gPSB3aCArIGJsLFxuICAgICAgaSwgdiwgZiwgbjtcblxuICAvLyB3aCArIGJsIGNhbnQgYmUgPiAxXG4gIGlmIChyYXRpbyA+IDEpIHtcbiAgICB3aCAvPSByYXRpbztcbiAgICBibCAvPSByYXRpbztcbiAgfVxuXG4gIGkgPSBNYXRoLmZsb29yKDYgKiBoKTtcbiAgdiA9IDEgLSBibDtcbiAgZiA9IDYgKiBoIC0gaTtcbiAgaWYgKChpICYgMHgwMSkgIT0gMCkge1xuICAgIGYgPSAxIC0gZjtcbiAgfVxuICBuID0gd2ggKyBmICogKHYgLSB3aCk7ICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuXG4gIHN3aXRjaCAoaSkge1xuICAgIGRlZmF1bHQ6XG4gICAgY2FzZSA2OlxuICAgIGNhc2UgMDogciA9IHY7IGcgPSBuOyBiID0gd2g7IGJyZWFrO1xuICAgIGNhc2UgMTogciA9IG47IGcgPSB2OyBiID0gd2g7IGJyZWFrO1xuICAgIGNhc2UgMjogciA9IHdoOyBnID0gdjsgYiA9IG47IGJyZWFrO1xuICAgIGNhc2UgMzogciA9IHdoOyBnID0gbjsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNDogciA9IG47IGcgPSB3aDsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNTogciA9IHY7IGcgPSB3aDsgYiA9IG47IGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gaHdiMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBod2IyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBod2Iya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJyZ2IoY215aykge1xuICB2YXIgYyA9IGNteWtbMF0gLyAxMDAsXG4gICAgICBtID0gY215a1sxXSAvIDEwMCxcbiAgICAgIHkgPSBjbXlrWzJdIC8gMTAwLFxuICAgICAgayA9IGNteWtbM10gLyAxMDAsXG4gICAgICByLCBnLCBiO1xuXG4gIHIgPSAxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKTtcbiAgZyA9IDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspO1xuICBiID0gMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgayk7XG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIGNteWsyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmhzdihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHN2KGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3YihjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChjbXlrMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24geHl6MnJnYih4eXopIHtcbiAgdmFyIHggPSB4eXpbMF0gLyAxMDAsXG4gICAgICB5ID0geHl6WzFdIC8gMTAwLFxuICAgICAgeiA9IHh5elsyXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9ICh4ICogMy4yNDA2KSArICh5ICogLTEuNTM3MikgKyAoeiAqIC0wLjQ5ODYpO1xuICBnID0gKHggKiAtMC45Njg5KSArICh5ICogMS44NzU4KSArICh6ICogMC4wNDE1KTtcbiAgYiA9ICh4ICogMC4wNTU3KSArICh5ICogLTAuMjA0MCkgKyAoeiAqIDEuMDU3MCk7XG5cbiAgLy8gYXNzdW1lIHNSR0JcbiAgciA9IHIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3cociwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IHIgPSAociAqIDEyLjkyKTtcblxuICBnID0gZyA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhnLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogZyA9IChnICogMTIuOTIpO1xuXG4gIGIgPSBiID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBiID0gKGIgKiAxMi45Mik7XG5cbiAgciA9IE1hdGgubWluKE1hdGgubWF4KDAsIHIpLCAxKTtcbiAgZyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGcpLCAxKTtcbiAgYiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGIpLCAxKTtcblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiB4eXoybGFiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSxcbiAgICAgIHkgPSB4eXpbMV0sXG4gICAgICB6ID0geHl6WzJdLFxuICAgICAgbCwgYSwgYjtcblxuICB4IC89IDk1LjA0NztcbiAgeSAvPSAxMDA7XG4gIHogLz0gMTA4Ljg4MztcblxuICB4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMS8zKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcbiAgeSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEvMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG4gIHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxLzMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG4gIGwgPSAoMTE2ICogeSkgLSAxNjtcbiAgYSA9IDUwMCAqICh4IC0geSk7XG4gIGIgPSAyMDAgKiAoeSAtIHopO1xuXG4gIHJldHVybiBbbCwgYSwgYl07XG59XG5cbmZ1bmN0aW9uIHh5ejJsY2goYXJncykge1xuICByZXR1cm4gbGFiMmxjaCh4eXoybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eihsYWIpIHtcbiAgdmFyIGwgPSBsYWJbMF0sXG4gICAgICBhID0gbGFiWzFdLFxuICAgICAgYiA9IGxhYlsyXSxcbiAgICAgIHgsIHksIHosIHkyO1xuXG4gIGlmIChsIDw9IDgpIHtcbiAgICB5ID0gKGwgKiAxMDApIC8gOTAzLjM7XG4gICAgeTIgPSAoNy43ODcgKiAoeSAvIDEwMCkpICsgKDE2IC8gMTE2KTtcbiAgfSBlbHNlIHtcbiAgICB5ID0gMTAwICogTWF0aC5wb3coKGwgKyAxNikgLyAxMTYsIDMpO1xuICAgIHkyID0gTWF0aC5wb3coeSAvIDEwMCwgMS8zKTtcbiAgfVxuXG4gIHggPSB4IC8gOTUuMDQ3IDw9IDAuMDA4ODU2ID8geCA9ICg5NS4wNDcgKiAoKGEgLyA1MDApICsgeTIgLSAoMTYgLyAxMTYpKSkgLyA3Ljc4NyA6IDk1LjA0NyAqIE1hdGgucG93KChhIC8gNTAwKSArIHkyLCAzKTtcblxuICB6ID0geiAvIDEwOC44ODMgPD0gMC4wMDg4NTkgPyB6ID0gKDEwOC44ODMgKiAoeTIgLSAoYiAvIDIwMCkgLSAoMTYgLyAxMTYpKSkgLyA3Ljc4NyA6IDEwOC44ODMgKiBNYXRoLnBvdyh5MiAtIChiIC8gMjAwKSwgMyk7XG5cbiAgcmV0dXJuIFt4LCB5LCB6XTtcbn1cblxuZnVuY3Rpb24gbGFiMmxjaChsYWIpIHtcbiAgdmFyIGwgPSBsYWJbMF0sXG4gICAgICBhID0gbGFiWzFdLFxuICAgICAgYiA9IGxhYlsyXSxcbiAgICAgIGhyLCBoLCBjO1xuXG4gIGhyID0gTWF0aC5hdGFuMihiLCBhKTtcbiAgaCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMzYwO1xuICB9XG4gIGMgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gIHJldHVybiBbbCwgYywgaF07XG59XG5cbmZ1bmN0aW9uIGxhYjJyZ2IoYXJncykge1xuICByZXR1cm4geHl6MnJnYihsYWIyeHl6KGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGNoMmxhYihsY2gpIHtcbiAgdmFyIGwgPSBsY2hbMF0sXG4gICAgICBjID0gbGNoWzFdLFxuICAgICAgaCA9IGxjaFsyXSxcbiAgICAgIGEsIGIsIGhyO1xuXG4gIGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuICBhID0gYyAqIE1hdGguY29zKGhyKTtcbiAgYiA9IGMgKiBNYXRoLnNpbihocik7XG4gIHJldHVybiBbbCwgYSwgYl07XG59XG5cbmZ1bmN0aW9uIGxjaDJ4eXooYXJncykge1xuICByZXR1cm4gbGFiMnh5eihsY2gybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGNoMnJnYihhcmdzKSB7XG4gIHJldHVybiBsYWIycmdiKGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMnJnYihrZXl3b3JkKSB7XG4gIHJldHVybiBjc3NLZXl3b3Jkc1trZXl3b3JkXTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3Yoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJsYWIoYXJncykge1xuICByZXR1cm4gcmdiMmxhYihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyeHl6KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJ4eXooa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG52YXIgY3NzS2V5d29yZHMgPSB7XG4gIGFsaWNlYmx1ZTogIFsyNDAsMjQ4LDI1NV0sXG4gIGFudGlxdWV3aGl0ZTogWzI1MCwyMzUsMjE1XSxcbiAgYXF1YTogWzAsMjU1LDI1NV0sXG4gIGFxdWFtYXJpbmU6IFsxMjcsMjU1LDIxMl0sXG4gIGF6dXJlOiAgWzI0MCwyNTUsMjU1XSxcbiAgYmVpZ2U6ICBbMjQ1LDI0NSwyMjBdLFxuICBiaXNxdWU6IFsyNTUsMjI4LDE5Nl0sXG4gIGJsYWNrOiAgWzAsMCwwXSxcbiAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsMjM1LDIwNV0sXG4gIGJsdWU6IFswLDAsMjU1XSxcbiAgYmx1ZXZpb2xldDogWzEzOCw0MywyMjZdLFxuICBicm93bjogIFsxNjUsNDIsNDJdLFxuICBidXJseXdvb2Q6ICBbMjIyLDE4NCwxMzVdLFxuICBjYWRldGJsdWU6ICBbOTUsMTU4LDE2MF0sXG4gIGNoYXJ0cmV1c2U6IFsxMjcsMjU1LDBdLFxuICBjaG9jb2xhdGU6ICBbMjEwLDEwNSwzMF0sXG4gIGNvcmFsOiAgWzI1NSwxMjcsODBdLFxuICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwxNDksMjM3XSxcbiAgY29ybnNpbGs6IFsyNTUsMjQ4LDIyMF0sXG4gIGNyaW1zb246ICBbMjIwLDIwLDYwXSxcbiAgY3lhbjogWzAsMjU1LDI1NV0sXG4gIGRhcmtibHVlOiBbMCwwLDEzOV0sXG4gIGRhcmtjeWFuOiBbMCwxMzksMTM5XSxcbiAgZGFya2dvbGRlbnJvZDogIFsxODQsMTM0LDExXSxcbiAgZGFya2dyYXk6IFsxNjksMTY5LDE2OV0sXG4gIGRhcmtncmVlbjogIFswLDEwMCwwXSxcbiAgZGFya2dyZXk6IFsxNjksMTY5LDE2OV0sXG4gIGRhcmtraGFraTogIFsxODksMTgzLDEwN10sXG4gIGRhcmttYWdlbnRhOiAgWzEzOSwwLDEzOV0sXG4gIGRhcmtvbGl2ZWdyZWVuOiBbODUsMTA3LDQ3XSxcbiAgZGFya29yYW5nZTogWzI1NSwxNDAsMF0sXG4gIGRhcmtvcmNoaWQ6IFsxNTMsNTAsMjA0XSxcbiAgZGFya3JlZDogIFsxMzksMCwwXSxcbiAgZGFya3NhbG1vbjogWzIzMywxNTAsMTIyXSxcbiAgZGFya3NlYWdyZWVuOiBbMTQzLDE4OCwxNDNdLFxuICBkYXJrc2xhdGVibHVlOiAgWzcyLDYxLDEzOV0sXG4gIGRhcmtzbGF0ZWdyYXk6ICBbNDcsNzksNzldLFxuICBkYXJrc2xhdGVncmV5OiAgWzQ3LDc5LDc5XSxcbiAgZGFya3R1cnF1b2lzZTogIFswLDIwNiwyMDldLFxuICBkYXJrdmlvbGV0OiBbMTQ4LDAsMjExXSxcbiAgZGVlcHBpbms6IFsyNTUsMjAsMTQ3XSxcbiAgZGVlcHNreWJsdWU6ICBbMCwxOTEsMjU1XSxcbiAgZGltZ3JheTogIFsxMDUsMTA1LDEwNV0sXG4gIGRpbWdyZXk6ICBbMTA1LDEwNSwxMDVdLFxuICBkb2RnZXJibHVlOiBbMzAsMTQ0LDI1NV0sXG4gIGZpcmVicmljazogIFsxNzgsMzQsMzRdLFxuICBmbG9yYWx3aGl0ZTogIFsyNTUsMjUwLDI0MF0sXG4gIGZvcmVzdGdyZWVuOiAgWzM0LDEzOSwzNF0sXG4gIGZ1Y2hzaWE6ICBbMjU1LDAsMjU1XSxcbiAgZ2FpbnNib3JvOiAgWzIyMCwyMjAsMjIwXSxcbiAgZ2hvc3R3aGl0ZTogWzI0OCwyNDgsMjU1XSxcbiAgZ29sZDogWzI1NSwyMTUsMF0sXG4gIGdvbGRlbnJvZDogIFsyMTgsMTY1LDMyXSxcbiAgZ3JheTogWzEyOCwxMjgsMTI4XSxcbiAgZ3JlZW46ICBbMCwxMjgsMF0sXG4gIGdyZWVueWVsbG93OiAgWzE3MywyNTUsNDddLFxuICBncmV5OiBbMTI4LDEyOCwxMjhdLFxuICBob25leWRldzogWzI0MCwyNTUsMjQwXSxcbiAgaG90cGluazogIFsyNTUsMTA1LDE4MF0sXG4gIGluZGlhbnJlZDogIFsyMDUsOTIsOTJdLFxuICBpbmRpZ286IFs3NSwwLDEzMF0sXG4gIGl2b3J5OiAgWzI1NSwyNTUsMjQwXSxcbiAga2hha2k6ICBbMjQwLDIzMCwxNDBdLFxuICBsYXZlbmRlcjogWzIzMCwyMzAsMjUwXSxcbiAgbGF2ZW5kZXJibHVzaDogIFsyNTUsMjQwLDI0NV0sXG4gIGxhd25ncmVlbjogIFsxMjQsMjUyLDBdLFxuICBsZW1vbmNoaWZmb246IFsyNTUsMjUwLDIwNV0sXG4gIGxpZ2h0Ymx1ZTogIFsxNzMsMjE2LDIzMF0sXG4gIGxpZ2h0Y29yYWw6IFsyNDAsMTI4LDEyOF0sXG4gIGxpZ2h0Y3lhbjogIFsyMjQsMjU1LDI1NV0sXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLDI1MCwyMTBdLFxuICBsaWdodGdyYXk6ICBbMjExLDIxMSwyMTFdLFxuICBsaWdodGdyZWVuOiBbMTQ0LDIzOCwxNDRdLFxuICBsaWdodGdyZXk6ICBbMjExLDIxMSwyMTFdLFxuICBsaWdodHBpbms6ICBbMjU1LDE4MiwxOTNdLFxuICBsaWdodHNhbG1vbjogIFsyNTUsMTYwLDEyMl0sXG4gIGxpZ2h0c2VhZ3JlZW46ICBbMzIsMTc4LDE3MF0sXG4gIGxpZ2h0c2t5Ymx1ZTogWzEzNSwyMDYsMjUwXSxcbiAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c2xhdGVncmV5OiBbMTE5LDEzNiwxNTNdLFxuICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwxOTYsMjIyXSxcbiAgbGlnaHR5ZWxsb3c6ICBbMjU1LDI1NSwyMjRdLFxuICBsaW1lOiBbMCwyNTUsMF0sXG4gIGxpbWVncmVlbjogIFs1MCwyMDUsNTBdLFxuICBsaW5lbjogIFsyNTAsMjQwLDIzMF0sXG4gIG1hZ2VudGE6ICBbMjU1LDAsMjU1XSxcbiAgbWFyb29uOiBbMTI4LDAsMF0sXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsMjA1LDE3MF0sXG4gIG1lZGl1bWJsdWU6IFswLDAsMjA1XSxcbiAgbWVkaXVtb3JjaGlkOiBbMTg2LDg1LDIxMV0sXG4gIG1lZGl1bXB1cnBsZTogWzE0NywxMTIsMjE5XSxcbiAgbWVkaXVtc2VhZ3JlZW46IFs2MCwxNzksMTEzXSxcbiAgbWVkaXVtc2xhdGVibHVlOiAgWzEyMywxMDQsMjM4XSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46ICBbMCwyNTAsMTU0XSxcbiAgbWVkaXVtdHVycXVvaXNlOiAgWzcyLDIwOSwyMDRdLFxuICBtZWRpdW12aW9sZXRyZWQ6ICBbMTk5LDIxLDEzM10sXG4gIG1pZG5pZ2h0Ymx1ZTogWzI1LDI1LDExMl0sXG4gIG1pbnRjcmVhbTogIFsyNDUsMjU1LDI1MF0sXG4gIG1pc3R5cm9zZTogIFsyNTUsMjI4LDIyNV0sXG4gIG1vY2Nhc2luOiBbMjU1LDIyOCwxODFdLFxuICBuYXZham93aGl0ZTogIFsyNTUsMjIyLDE3M10sXG4gIG5hdnk6IFswLDAsMTI4XSxcbiAgb2xkbGFjZTogIFsyNTMsMjQ1LDIzMF0sXG4gIG9saXZlOiAgWzEyOCwxMjgsMF0sXG4gIG9saXZlZHJhYjogIFsxMDcsMTQyLDM1XSxcbiAgb3JhbmdlOiBbMjU1LDE2NSwwXSxcbiAgb3JhbmdlcmVkOiAgWzI1NSw2OSwwXSxcbiAgb3JjaGlkOiBbMjE4LDExMiwyMTRdLFxuICBwYWxlZ29sZGVucm9kOiAgWzIzOCwyMzIsMTcwXSxcbiAgcGFsZWdyZWVuOiAgWzE1MiwyNTEsMTUyXSxcbiAgcGFsZXR1cnF1b2lzZTogIFsxNzUsMjM4LDIzOF0sXG4gIHBhbGV2aW9sZXRyZWQ6ICBbMjE5LDExMiwxNDddLFxuICBwYXBheWF3aGlwOiBbMjU1LDIzOSwyMTNdLFxuICBwZWFjaHB1ZmY6ICBbMjU1LDIxOCwxODVdLFxuICBwZXJ1OiBbMjA1LDEzMyw2M10sXG4gIHBpbms6IFsyNTUsMTkyLDIwM10sXG4gIHBsdW06IFsyMjEsMTYwLDIyMV0sXG4gIHBvd2RlcmJsdWU6IFsxNzYsMjI0LDIzMF0sXG4gIHB1cnBsZTogWzEyOCwwLDEyOF0sXG4gIHJlYmVjY2FwdXJwbGU6IFsxMDIsIDUxLCAxNTNdLFxuICByZWQ6ICBbMjU1LDAsMF0sXG4gIHJvc3licm93bjogIFsxODgsMTQzLDE0M10sXG4gIHJveWFsYmx1ZTogIFs2NSwxMDUsMjI1XSxcbiAgc2FkZGxlYnJvd246ICBbMTM5LDY5LDE5XSxcbiAgc2FsbW9uOiBbMjUwLDEyOCwxMTRdLFxuICBzYW5keWJyb3duOiBbMjQ0LDE2NCw5Nl0sXG4gIHNlYWdyZWVuOiBbNDYsMTM5LDg3XSxcbiAgc2Vhc2hlbGw6IFsyNTUsMjQ1LDIzOF0sXG4gIHNpZW5uYTogWzE2MCw4Miw0NV0sXG4gIHNpbHZlcjogWzE5MiwxOTIsMTkyXSxcbiAgc2t5Ymx1ZTogIFsxMzUsMjA2LDIzNV0sXG4gIHNsYXRlYmx1ZTogIFsxMDYsOTAsMjA1XSxcbiAgc2xhdGVncmF5OiAgWzExMiwxMjgsMTQ0XSxcbiAgc2xhdGVncmV5OiAgWzExMiwxMjgsMTQ0XSxcbiAgc25vdzogWzI1NSwyNTAsMjUwXSxcbiAgc3ByaW5nZ3JlZW46ICBbMCwyNTUsMTI3XSxcbiAgc3RlZWxibHVlOiAgWzcwLDEzMCwxODBdLFxuICB0YW46ICBbMjEwLDE4MCwxNDBdLFxuICB0ZWFsOiBbMCwxMjgsMTI4XSxcbiAgdGhpc3RsZTogIFsyMTYsMTkxLDIxNl0sXG4gIHRvbWF0bzogWzI1NSw5OSw3MV0sXG4gIHR1cnF1b2lzZTogIFs2NCwyMjQsMjA4XSxcbiAgdmlvbGV0OiBbMjM4LDEzMCwyMzhdLFxuICB3aGVhdDogIFsyNDUsMjIyLDE3OV0sXG4gIHdoaXRlOiAgWzI1NSwyNTUsMjU1XSxcbiAgd2hpdGVzbW9rZTogWzI0NSwyNDUsMjQ1XSxcbiAgeWVsbG93OiBbMjU1LDI1NSwwXSxcbiAgeWVsbG93Z3JlZW46ICBbMTU0LDIwNSw1MF1cbn07XG5cbnZhciByZXZlcnNlS2V5d29yZHMgPSB7fTtcbmZvciAodmFyIGtleSBpbiBjc3NLZXl3b3Jkcykge1xuICByZXZlcnNlS2V5d29yZHNbSlNPTi5zdHJpbmdpZnkoY3NzS2V5d29yZHNba2V5XSldID0ga2V5O1xufVxuXG52YXIgY29udmVydCA9IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIG5ldyBDb252ZXJ0ZXIoKTtcbn07XG5cbmZvciAodmFyIGZ1bmMgaW4gY29udmVyc2lvbnMpIHtcbiAgLy8gZXhwb3J0IFJhdyB2ZXJzaW9uc1xuICBjb252ZXJ0W2Z1bmMgKyBcIlJhd1wiXSA9ICAoZnVuY3Rpb24oZnVuYykge1xuICAgIC8vIGFjY2VwdCBhcnJheSBvciBwbGFpbiBhcmdzXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT0gXCJudW1iZXJcIilcbiAgICAgICAgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjb252ZXJzaW9uc1tmdW5jXShhcmcpO1xuICAgIH1cbiAgfSkoZnVuYyk7XG5cbiAgdmFyIHBhaXIgPSAvKFxcdyspMihcXHcrKS8uZXhlYyhmdW5jKSxcbiAgICAgIGZyb20gPSBwYWlyWzFdLFxuICAgICAgdG8gPSBwYWlyWzJdO1xuXG4gIC8vIGV4cG9ydCByZ2IyaHNsIGFuZCBbXCJyZ2JcIl1bXCJoc2xcIl1cbiAgY29udmVydFtmcm9tXSA9IGNvbnZlcnRbZnJvbV0gfHwge307XG5cbiAgY29udmVydFtmcm9tXVt0b10gPSBjb252ZXJ0W2Z1bmNdID0gKGZ1bmN0aW9uKGZ1bmMpIHsgXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT0gXCJudW1iZXJcIilcbiAgICAgICAgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIFxuICAgICAgdmFyIHZhbCA9IGNvbnZlcnNpb25zW2Z1bmNdKGFyZyk7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiIHx8IHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdmFsOyAvLyBrZXl3b3JkXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKVxuICAgICAgICB2YWxbaV0gPSBNYXRoLnJvdW5kKHZhbFtpXSk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSkoZnVuYyk7XG59XG5cblxuLyogQ29udmVydGVyIGRvZXMgbGF6eSBjb252ZXJzaW9uIGFuZCBjYWNoaW5nICovXG52YXIgQ29udmVydGVyID0gZnVuY3Rpb24oKSB7XG4gICB0aGlzLmNvbnZzID0ge307XG59O1xuXG4vKiBFaXRoZXIgZ2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2Ugb3JcbiAgc2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UsIGRlcGVuZGluZyBvbiBhcmdzICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLnJvdXRlU3BhY2UgPSBmdW5jdGlvbihzcGFjZSwgYXJncykge1xuICAgdmFyIHZhbHVlcyA9IGFyZ3NbMF07XG4gICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNvbG9yLnJnYigpXG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuICAgfVxuICAgLy8gY29sb3IucmdiKDEwLCAxMCwgMTApXG4gICBpZiAodHlwZW9mIHZhbHVlcyA9PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTsgICAgICAgIFxuICAgfVxuXG4gICByZXR1cm4gdGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHVlcyk7XG59O1xuICBcbi8qIFNldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLCBpbnZhbGlkYXRpbmcgY2FjaGUgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24oc3BhY2UsIHZhbHVlcykge1xuICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgdGhpcy5jb252cyA9IHt9O1xuICAgdGhpcy5jb252c1tzcGFjZV0gPSB2YWx1ZXM7XG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qIEdldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLiBJZiB0aGVyZSdzIGFscmVhZHlcbiAgYSBjb252ZXJzaW9uIGZvciB0aGUgc3BhY2UsIGZldGNoIGl0LCBvdGhlcndpc2VcbiAgY29tcHV0ZSBpdCAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSkge1xuICAgdmFyIHZhbHMgPSB0aGlzLmNvbnZzW3NwYWNlXTtcbiAgIGlmICghdmFscykge1xuICAgICAgdmFyIGZzcGFjZSA9IHRoaXMuc3BhY2UsXG4gICAgICAgICAgZnJvbSA9IHRoaXMuY29udnNbZnNwYWNlXTtcbiAgICAgIHZhbHMgPSBjb252ZXJ0W2ZzcGFjZV1bc3BhY2VdKGZyb20pO1xuXG4gICAgICB0aGlzLmNvbnZzW3NwYWNlXSA9IHZhbHM7XG4gICB9XG4gIHJldHVybiB2YWxzO1xufTtcblxuW1wicmdiXCIsIFwiaHNsXCIsIFwiaHN2XCIsIFwiY215a1wiLCBcImtleXdvcmRcIl0uZm9yRWFjaChmdW5jdGlvbihzcGFjZSkge1xuICAgQ29udmVydGVyLnByb3RvdHlwZVtzcGFjZV0gPSBmdW5jdGlvbih2YWxzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb3V0ZVNwYWNlKHNwYWNlLCBhcmd1bWVudHMpO1xuICAgfTtcbn0pO1xuXG52YXIgY29sb3JDb252ZXJ0ID0gY29udmVydDtcblxudmFyIGNvbG9yTmFtZSA9IHtcclxuXHRcImFsaWNlYmx1ZVwiOiBbMjQwLCAyNDgsIDI1NV0sXHJcblx0XCJhbnRpcXVld2hpdGVcIjogWzI1MCwgMjM1LCAyMTVdLFxyXG5cdFwiYXF1YVwiOiBbMCwgMjU1LCAyNTVdLFxyXG5cdFwiYXF1YW1hcmluZVwiOiBbMTI3LCAyNTUsIDIxMl0sXHJcblx0XCJhenVyZVwiOiBbMjQwLCAyNTUsIDI1NV0sXHJcblx0XCJiZWlnZVwiOiBbMjQ1LCAyNDUsIDIyMF0sXHJcblx0XCJiaXNxdWVcIjogWzI1NSwgMjI4LCAxOTZdLFxyXG5cdFwiYmxhY2tcIjogWzAsIDAsIDBdLFxyXG5cdFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwgMjM1LCAyMDVdLFxyXG5cdFwiYmx1ZVwiOiBbMCwgMCwgMjU1XSxcclxuXHRcImJsdWV2aW9sZXRcIjogWzEzOCwgNDMsIDIyNl0sXHJcblx0XCJicm93blwiOiBbMTY1LCA0MiwgNDJdLFxyXG5cdFwiYnVybHl3b29kXCI6IFsyMjIsIDE4NCwgMTM1XSxcclxuXHRcImNhZGV0Ymx1ZVwiOiBbOTUsIDE1OCwgMTYwXSxcclxuXHRcImNoYXJ0cmV1c2VcIjogWzEyNywgMjU1LCAwXSxcclxuXHRcImNob2NvbGF0ZVwiOiBbMjEwLCAxMDUsIDMwXSxcclxuXHRcImNvcmFsXCI6IFsyNTUsIDEyNywgODBdLFxyXG5cdFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwgMTQ5LCAyMzddLFxyXG5cdFwiY29ybnNpbGtcIjogWzI1NSwgMjQ4LCAyMjBdLFxyXG5cdFwiY3JpbXNvblwiOiBbMjIwLCAyMCwgNjBdLFxyXG5cdFwiY3lhblwiOiBbMCwgMjU1LCAyNTVdLFxyXG5cdFwiZGFya2JsdWVcIjogWzAsIDAsIDEzOV0sXHJcblx0XCJkYXJrY3lhblwiOiBbMCwgMTM5LCAxMzldLFxyXG5cdFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LCAxMzQsIDExXSxcclxuXHRcImRhcmtncmF5XCI6IFsxNjksIDE2OSwgMTY5XSxcclxuXHRcImRhcmtncmVlblwiOiBbMCwgMTAwLCAwXSxcclxuXHRcImRhcmtncmV5XCI6IFsxNjksIDE2OSwgMTY5XSxcclxuXHRcImRhcmtraGFraVwiOiBbMTg5LCAxODMsIDEwN10sXHJcblx0XCJkYXJrbWFnZW50YVwiOiBbMTM5LCAwLCAxMzldLFxyXG5cdFwiZGFya29saXZlZ3JlZW5cIjogWzg1LCAxMDcsIDQ3XSxcclxuXHRcImRhcmtvcmFuZ2VcIjogWzI1NSwgMTQwLCAwXSxcclxuXHRcImRhcmtvcmNoaWRcIjogWzE1MywgNTAsIDIwNF0sXHJcblx0XCJkYXJrcmVkXCI6IFsxMzksIDAsIDBdLFxyXG5cdFwiZGFya3NhbG1vblwiOiBbMjMzLCAxNTAsIDEyMl0sXHJcblx0XCJkYXJrc2VhZ3JlZW5cIjogWzE0MywgMTg4LCAxNDNdLFxyXG5cdFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsIDYxLCAxMzldLFxyXG5cdFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrc2xhdGVncmV5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmt0dXJxdW9pc2VcIjogWzAsIDIwNiwgMjA5XSxcclxuXHRcImRhcmt2aW9sZXRcIjogWzE0OCwgMCwgMjExXSxcclxuXHRcImRlZXBwaW5rXCI6IFsyNTUsIDIwLCAxNDddLFxyXG5cdFwiZGVlcHNreWJsdWVcIjogWzAsIDE5MSwgMjU1XSxcclxuXHRcImRpbWdyYXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZGltZ3JleVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkb2RnZXJibHVlXCI6IFszMCwgMTQ0LCAyNTVdLFxyXG5cdFwiZmlyZWJyaWNrXCI6IFsxNzgsIDM0LCAzNF0sXHJcblx0XCJmbG9yYWx3aGl0ZVwiOiBbMjU1LCAyNTAsIDI0MF0sXHJcblx0XCJmb3Jlc3RncmVlblwiOiBbMzQsIDEzOSwgMzRdLFxyXG5cdFwiZnVjaHNpYVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwiZ2FpbnNib3JvXCI6IFsyMjAsIDIyMCwgMjIwXSxcclxuXHRcImdob3N0d2hpdGVcIjogWzI0OCwgMjQ4LCAyNTVdLFxyXG5cdFwiZ29sZFwiOiBbMjU1LCAyMTUsIDBdLFxyXG5cdFwiZ29sZGVucm9kXCI6IFsyMTgsIDE2NSwgMzJdLFxyXG5cdFwiZ3JheVwiOiBbMTI4LCAxMjgsIDEyOF0sXHJcblx0XCJncmVlblwiOiBbMCwgMTI4LCAwXSxcclxuXHRcImdyZWVueWVsbG93XCI6IFsxNzMsIDI1NSwgNDddLFxyXG5cdFwiZ3JleVwiOiBbMTI4LCAxMjgsIDEyOF0sXHJcblx0XCJob25leWRld1wiOiBbMjQwLCAyNTUsIDI0MF0sXHJcblx0XCJob3RwaW5rXCI6IFsyNTUsIDEwNSwgMTgwXSxcclxuXHRcImluZGlhbnJlZFwiOiBbMjA1LCA5MiwgOTJdLFxyXG5cdFwiaW5kaWdvXCI6IFs3NSwgMCwgMTMwXSxcclxuXHRcIml2b3J5XCI6IFsyNTUsIDI1NSwgMjQwXSxcclxuXHRcImtoYWtpXCI6IFsyNDAsIDIzMCwgMTQwXSxcclxuXHRcImxhdmVuZGVyXCI6IFsyMzAsIDIzMCwgMjUwXSxcclxuXHRcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwgMjQwLCAyNDVdLFxyXG5cdFwibGF3bmdyZWVuXCI6IFsxMjQsIDI1MiwgMF0sXHJcblx0XCJsZW1vbmNoaWZmb25cIjogWzI1NSwgMjUwLCAyMDVdLFxyXG5cdFwibGlnaHRibHVlXCI6IFsxNzMsIDIxNiwgMjMwXSxcclxuXHRcImxpZ2h0Y29yYWxcIjogWzI0MCwgMTI4LCAxMjhdLFxyXG5cdFwibGlnaHRjeWFuXCI6IFsyMjQsIDI1NSwgMjU1XSxcclxuXHRcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsIDI1MCwgMjEwXSxcclxuXHRcImxpZ2h0Z3JheVwiOiBbMjExLCAyMTEsIDIxMV0sXHJcblx0XCJsaWdodGdyZWVuXCI6IFsxNDQsIDIzOCwgMTQ0XSxcclxuXHRcImxpZ2h0Z3JleVwiOiBbMjExLCAyMTEsIDIxMV0sXHJcblx0XCJsaWdodHBpbmtcIjogWzI1NSwgMTgyLCAxOTNdLFxyXG5cdFwibGlnaHRzYWxtb25cIjogWzI1NSwgMTYwLCAxMjJdLFxyXG5cdFwibGlnaHRzZWFncmVlblwiOiBbMzIsIDE3OCwgMTcwXSxcclxuXHRcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDI1MF0sXHJcblx0XCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LCAxMzYsIDE1M10sXHJcblx0XCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LCAxMzYsIDE1M10sXHJcblx0XCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LCAxOTYsIDIyMl0sXHJcblx0XCJsaWdodHllbGxvd1wiOiBbMjU1LCAyNTUsIDIyNF0sXHJcblx0XCJsaW1lXCI6IFswLCAyNTUsIDBdLFxyXG5cdFwibGltZWdyZWVuXCI6IFs1MCwgMjA1LCA1MF0sXHJcblx0XCJsaW5lblwiOiBbMjUwLCAyNDAsIDIzMF0sXHJcblx0XCJtYWdlbnRhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJtYXJvb25cIjogWzEyOCwgMCwgMF0sXHJcblx0XCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsIDIwNSwgMTcwXSxcclxuXHRcIm1lZGl1bWJsdWVcIjogWzAsIDAsIDIwNV0sXHJcblx0XCJtZWRpdW1vcmNoaWRcIjogWzE4NiwgODUsIDIxMV0sXHJcblx0XCJtZWRpdW1wdXJwbGVcIjogWzE0NywgMTEyLCAyMTldLFxyXG5cdFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLCAxNzksIDExM10sXHJcblx0XCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywgMTA0LCAyMzhdLFxyXG5cdFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsIDI1MCwgMTU0XSxcclxuXHRcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsIDIwOSwgMjA0XSxcclxuXHRcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LCAyMSwgMTMzXSxcclxuXHRcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsIDI1LCAxMTJdLFxyXG5cdFwibWludGNyZWFtXCI6IFsyNDUsIDI1NSwgMjUwXSxcclxuXHRcIm1pc3R5cm9zZVwiOiBbMjU1LCAyMjgsIDIyNV0sXHJcblx0XCJtb2NjYXNpblwiOiBbMjU1LCAyMjgsIDE4MV0sXHJcblx0XCJuYXZham93aGl0ZVwiOiBbMjU1LCAyMjIsIDE3M10sXHJcblx0XCJuYXZ5XCI6IFswLCAwLCAxMjhdLFxyXG5cdFwib2xkbGFjZVwiOiBbMjUzLCAyNDUsIDIzMF0sXHJcblx0XCJvbGl2ZVwiOiBbMTI4LCAxMjgsIDBdLFxyXG5cdFwib2xpdmVkcmFiXCI6IFsxMDcsIDE0MiwgMzVdLFxyXG5cdFwib3JhbmdlXCI6IFsyNTUsIDE2NSwgMF0sXHJcblx0XCJvcmFuZ2VyZWRcIjogWzI1NSwgNjksIDBdLFxyXG5cdFwib3JjaGlkXCI6IFsyMTgsIDExMiwgMjE0XSxcclxuXHRcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwgMjMyLCAxNzBdLFxyXG5cdFwicGFsZWdyZWVuXCI6IFsxNTIsIDI1MSwgMTUyXSxcclxuXHRcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwgMjM4LCAyMzhdLFxyXG5cdFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LCAxMTIsIDE0N10sXHJcblx0XCJwYXBheWF3aGlwXCI6IFsyNTUsIDIzOSwgMjEzXSxcclxuXHRcInBlYWNocHVmZlwiOiBbMjU1LCAyMTgsIDE4NV0sXHJcblx0XCJwZXJ1XCI6IFsyMDUsIDEzMywgNjNdLFxyXG5cdFwicGlua1wiOiBbMjU1LCAxOTIsIDIwM10sXHJcblx0XCJwbHVtXCI6IFsyMjEsIDE2MCwgMjIxXSxcclxuXHRcInBvd2RlcmJsdWVcIjogWzE3NiwgMjI0LCAyMzBdLFxyXG5cdFwicHVycGxlXCI6IFsxMjgsIDAsIDEyOF0sXHJcblx0XCJyZWJlY2NhcHVycGxlXCI6IFsxMDIsIDUxLCAxNTNdLFxyXG5cdFwicmVkXCI6IFsyNTUsIDAsIDBdLFxyXG5cdFwicm9zeWJyb3duXCI6IFsxODgsIDE0MywgMTQzXSxcclxuXHRcInJveWFsYmx1ZVwiOiBbNjUsIDEwNSwgMjI1XSxcclxuXHRcInNhZGRsZWJyb3duXCI6IFsxMzksIDY5LCAxOV0sXHJcblx0XCJzYWxtb25cIjogWzI1MCwgMTI4LCAxMTRdLFxyXG5cdFwic2FuZHlicm93blwiOiBbMjQ0LCAxNjQsIDk2XSxcclxuXHRcInNlYWdyZWVuXCI6IFs0NiwgMTM5LCA4N10sXHJcblx0XCJzZWFzaGVsbFwiOiBbMjU1LCAyNDUsIDIzOF0sXHJcblx0XCJzaWVubmFcIjogWzE2MCwgODIsIDQ1XSxcclxuXHRcInNpbHZlclwiOiBbMTkyLCAxOTIsIDE5Ml0sXHJcblx0XCJza3libHVlXCI6IFsxMzUsIDIwNiwgMjM1XSxcclxuXHRcInNsYXRlYmx1ZVwiOiBbMTA2LCA5MCwgMjA1XSxcclxuXHRcInNsYXRlZ3JheVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbGF0ZWdyZXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic25vd1wiOiBbMjU1LCAyNTAsIDI1MF0sXHJcblx0XCJzcHJpbmdncmVlblwiOiBbMCwgMjU1LCAxMjddLFxyXG5cdFwic3RlZWxibHVlXCI6IFs3MCwgMTMwLCAxODBdLFxyXG5cdFwidGFuXCI6IFsyMTAsIDE4MCwgMTQwXSxcclxuXHRcInRlYWxcIjogWzAsIDEyOCwgMTI4XSxcclxuXHRcInRoaXN0bGVcIjogWzIxNiwgMTkxLCAyMTZdLFxyXG5cdFwidG9tYXRvXCI6IFsyNTUsIDk5LCA3MV0sXHJcblx0XCJ0dXJxdW9pc2VcIjogWzY0LCAyMjQsIDIwOF0sXHJcblx0XCJ2aW9sZXRcIjogWzIzOCwgMTMwLCAyMzhdLFxyXG5cdFwid2hlYXRcIjogWzI0NSwgMjIyLCAxNzldLFxyXG5cdFwid2hpdGVcIjogWzI1NSwgMjU1LCAyNTVdLFxyXG5cdFwid2hpdGVzbW9rZVwiOiBbMjQ1LCAyNDUsIDI0NV0sXHJcblx0XCJ5ZWxsb3dcIjogWzI1NSwgMjU1LCAwXSxcclxuXHRcInllbGxvd2dyZWVuXCI6IFsxNTQsIDIwNSwgNTBdXHJcbn07XG5cbi8qIE1JVCBsaWNlbnNlICovXG5cblxudmFyIGNvbG9yU3RyaW5nID0ge1xuICAgZ2V0UmdiYTogZ2V0UmdiYSxcbiAgIGdldEhzbGE6IGdldEhzbGEsXG4gICBnZXRSZ2I6IGdldFJnYixcbiAgIGdldEhzbDogZ2V0SHNsLFxuICAgZ2V0SHdiOiBnZXRId2IsXG4gICBnZXRBbHBoYTogZ2V0QWxwaGEsXG5cbiAgIGhleFN0cmluZzogaGV4U3RyaW5nLFxuICAgcmdiU3RyaW5nOiByZ2JTdHJpbmcsXG4gICByZ2JhU3RyaW5nOiByZ2JhU3RyaW5nLFxuICAgcGVyY2VudFN0cmluZzogcGVyY2VudFN0cmluZyxcbiAgIHBlcmNlbnRhU3RyaW5nOiBwZXJjZW50YVN0cmluZyxcbiAgIGhzbFN0cmluZzogaHNsU3RyaW5nLFxuICAgaHNsYVN0cmluZzogaHNsYVN0cmluZyxcbiAgIGh3YlN0cmluZzogaHdiU3RyaW5nLFxuICAga2V5d29yZDoga2V5d29yZFxufTtcblxuZnVuY3Rpb24gZ2V0UmdiYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgYWJiciA9ICAvXiMoW2EtZkEtRjAtOV17Myw0fSkkL2ksXG4gICAgICAgaGV4ID0gIC9eIyhbYS1mQS1GMC05XXs2fShbYS1mQS1GMC05XXsyfSk/KSQvaSxcbiAgICAgICByZ2JhID0gL15yZ2JhP1xcKFxccyooWystXT9cXGQrKVxccyosXFxzKihbKy1dP1xcZCspXFxzKixcXHMqKFsrLV0/XFxkKylcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC9pLFxuICAgICAgIHBlciA9IC9ecmdiYT9cXChcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvaSxcbiAgICAgICBrZXl3b3JkID0gLyhcXHcrKS87XG5cbiAgIHZhciByZ2IgPSBbMCwgMCwgMF0sXG4gICAgICAgYSA9IDEsXG4gICAgICAgbWF0Y2ggPSBzdHJpbmcubWF0Y2goYWJiciksXG4gICAgICAgaGV4QWxwaGEgPSBcIlwiO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgICBtYXRjaCA9IG1hdGNoWzFdO1xuICAgICAgaGV4QWxwaGEgPSBtYXRjaFszXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpXSArIG1hdGNoW2ldLCAxNik7XG4gICAgICB9XG4gICAgICBpZiAoaGV4QWxwaGEpIHtcbiAgICAgICAgIGEgPSBNYXRoLnJvdW5kKChwYXJzZUludChoZXhBbHBoYSArIGhleEFscGhhLCAxNikgLyAyNTUpICogMTAwKSAvIDEwMDtcbiAgICAgIH1cbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGhleCkpIHtcbiAgICAgIGhleEFscGhhID0gbWF0Y2hbMl07XG4gICAgICBtYXRjaCA9IG1hdGNoWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNik7XG4gICAgICB9XG4gICAgICBpZiAoaGV4QWxwaGEpIHtcbiAgICAgICAgIGEgPSBNYXRoLnJvdW5kKChwYXJzZUludChoZXhBbHBoYSwgMTYpIC8gMjU1KSAqIDEwMCkgLyAxMDA7XG4gICAgICB9XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChyZ2JhKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2kgKyAxXSk7XG4gICAgICB9XG4gICAgICBhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChwZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KG1hdGNoW2kgKyAxXSkgKiAyLjU1KTtcbiAgICAgIH1cbiAgICAgIGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGtleXdvcmQpKSB7XG4gICAgICBpZiAobWF0Y2hbMV0gPT0gXCJ0cmFuc3BhcmVudFwiKSB7XG4gICAgICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgICAgfVxuICAgICAgcmdiID0gY29sb3JOYW1lW21hdGNoWzFdXTtcbiAgICAgIGlmICghcmdiKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICB9XG5cbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZ2JbaV0gPSBzY2FsZShyZ2JbaV0sIDAsIDI1NSk7XG4gICB9XG4gICBpZiAoIWEgJiYgYSAhPSAwKSB7XG4gICAgICBhID0gMTtcbiAgIH1cbiAgIGVsc2Uge1xuICAgICAgYSA9IHNjYWxlKGEsIDAsIDEpO1xuICAgfVxuICAgcmdiWzNdID0gYTtcbiAgIHJldHVybiByZ2I7XG59XG5cbmZ1bmN0aW9uIGdldEhzbGEoc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGhzbCA9IC9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChoc2wpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgICAgIHZhciBoID0gc2NhbGUocGFyc2VJbnQobWF0Y2hbMV0pLCAwLCAzNjApLFxuICAgICAgICAgIHMgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKSxcbiAgICAgICAgICBsID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCksXG4gICAgICAgICAgYSA9IHNjYWxlKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XG4gICAgICByZXR1cm4gW2gsIHMsIGwsIGFdO1xuICAgfVxufVxuXG5mdW5jdGlvbiBnZXRId2Ioc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGh3YiA9IC9eaHdiXFwoXFxzKihbKy1dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKS87XG4gICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHdiKTtcbiAgIGlmIChtYXRjaCkge1xuICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgdyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGIgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgdywgYiwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldFJnYihzdHJpbmcpIHtcbiAgIHZhciByZ2JhID0gZ2V0UmdiYShzdHJpbmcpO1xuICAgcmV0dXJuIHJnYmEgJiYgcmdiYS5zbGljZSgwLCAzKTtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsKHN0cmluZykge1xuICB2YXIgaHNsYSA9IGdldEhzbGEoc3RyaW5nKTtcbiAgcmV0dXJuIGhzbGEgJiYgaHNsYS5zbGljZSgwLCAzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxwaGEoc3RyaW5nKSB7XG4gICB2YXIgdmFscyA9IGdldFJnYmEoc3RyaW5nKTtcbiAgIGlmICh2YWxzKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHMgPSBnZXRIc2xhKHN0cmluZykpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxuICAgZWxzZSBpZiAodmFscyA9IGdldEh3YihzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbn1cblxuLy8gZ2VuZXJhdG9yc1xuZnVuY3Rpb24gaGV4U3RyaW5nKHJnYmEsIGEpIHtcbiAgIHZhciBhID0gKGEgIT09IHVuZGVmaW5lZCAmJiByZ2JhLmxlbmd0aCA9PT0gMykgPyBhIDogcmdiYVszXTtcbiAgIHJldHVybiBcIiNcIiArIGhleERvdWJsZShyZ2JhWzBdKSBcbiAgICAgICAgICAgICAgKyBoZXhEb3VibGUocmdiYVsxXSlcbiAgICAgICAgICAgICAgKyBoZXhEb3VibGUocmdiYVsyXSlcbiAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgIChhID49IDAgJiYgYSA8IDEpXG4gICAgICAgICAgICAgICAgID8gaGV4RG91YmxlKE1hdGgucm91bmQoYSAqIDI1NSkpXG4gICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICApO1xufVxuXG5mdW5jdGlvbiByZ2JTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKHJnYmFbM10gJiYgcmdiYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gcmdiYVN0cmluZyhyZ2JhLCBhbHBoYSk7XG4gICB9XG4gICByZXR1cm4gXCJyZ2IoXCIgKyByZ2JhWzBdICsgXCIsIFwiICsgcmdiYVsxXSArIFwiLCBcIiArIHJnYmFbMl0gKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gcmdiYVN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gKHJnYmFbM10gIT09IHVuZGVmaW5lZCA/IHJnYmFbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JhWzBdICsgXCIsIFwiICsgcmdiYVsxXSArIFwiLCBcIiArIHJnYmFbMl1cbiAgICAgICAgICAgKyBcIiwgXCIgKyBhbHBoYSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBwZXJjZW50U3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChyZ2JhWzNdICYmIHJnYmFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIHBlcmNlbnRhU3RyaW5nKHJnYmEsIGFscGhhKTtcbiAgIH1cbiAgIHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdLzI1NSAqIDEwMCksXG4gICAgICAgZyA9IE1hdGgucm91bmQocmdiYVsxXS8yNTUgKiAxMDApLFxuICAgICAgIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0vMjU1ICogMTAwKTtcblxuICAgcmV0dXJuIFwicmdiKFwiICsgciArIFwiJSwgXCIgKyBnICsgXCIlLCBcIiArIGIgKyBcIiUpXCI7XG59XG5cbmZ1bmN0aW9uIHBlcmNlbnRhU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICB2YXIgciA9IE1hdGgucm91bmQocmdiYVswXS8yNTUgKiAxMDApLFxuICAgICAgIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0vMjU1ICogMTAwKSxcbiAgICAgICBiID0gTWF0aC5yb3VuZChyZ2JhWzJdLzI1NSAqIDEwMCk7XG4gICByZXR1cm4gXCJyZ2JhKFwiICsgciArIFwiJSwgXCIgKyBnICsgXCIlLCBcIiArIGIgKyBcIiUsIFwiICsgKGFscGhhIHx8IHJnYmFbM10gfHwgMSkgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gaHNsU3RyaW5nKGhzbGEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChoc2xhWzNdICYmIGhzbGFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIGhzbGFTdHJpbmcoaHNsYSwgYWxwaGEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHNsKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSlcIjtcbn1cblxuZnVuY3Rpb24gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gKGhzbGFbM10gIT09IHVuZGVmaW5lZCA/IGhzbGFbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcImhzbGEoXCIgKyBoc2xhWzBdICsgXCIsIFwiICsgaHNsYVsxXSArIFwiJSwgXCIgKyBoc2xhWzJdICsgXCIlLCBcIlxuICAgICAgICAgICArIGFscGhhICsgXCIpXCI7XG59XG5cbi8vIGh3YiBpcyBhIGJpdCBkaWZmZXJlbnQgdGhhbiByZ2IoYSkgJiBoc2woYSkgc2luY2UgdGhlcmUgaXMgbm8gYWxwaGEgc3BlY2lmaWMgc3ludGF4XG4vLyAoaHdiIGhhdmUgYWxwaGEgb3B0aW9uYWwgJiAxIGlzIGRlZmF1bHQgdmFsdWUpXG5mdW5jdGlvbiBod2JTdHJpbmcoaHdiLCBhbHBoYSkge1xuICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFscGhhID0gKGh3YlszXSAhPT0gdW5kZWZpbmVkID8gaHdiWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJod2IoXCIgKyBod2JbMF0gKyBcIiwgXCIgKyBod2JbMV0gKyBcIiUsIFwiICsgaHdiWzJdICsgXCIlXCJcbiAgICAgICAgICAgKyAoYWxwaGEgIT09IHVuZGVmaW5lZCAmJiBhbHBoYSAhPT0gMSA/IFwiLCBcIiArIGFscGhhIDogXCJcIikgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24ga2V5d29yZChyZ2IpIHtcbiAgcmV0dXJuIHJldmVyc2VOYW1lc1tyZ2Iuc2xpY2UoMCwgMyldO1xufVxuXG4vLyBoZWxwZXJzXG5mdW5jdGlvbiBzY2FsZShudW0sIG1pbiwgbWF4KSB7XG4gICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBudW0pLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBoZXhEb3VibGUobnVtKSB7XG4gIHZhciBzdHIgPSBudW0udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiAoc3RyLmxlbmd0aCA8IDIpID8gXCIwXCIgKyBzdHIgOiBzdHI7XG59XG5cblxuLy9jcmVhdGUgYSBsaXN0IG9mIHJldmVyc2UgY29sb3IgbmFtZXNcbnZhciByZXZlcnNlTmFtZXMgPSB7fTtcbmZvciAodmFyIG5hbWUgaW4gY29sb3JOYW1lKSB7XG4gICByZXZlcnNlTmFtZXNbY29sb3JOYW1lW25hbWVdXSA9IG5hbWU7XG59XG5cbi8qIE1JVCBsaWNlbnNlICovXG5cblxuXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAob2JqKSB7XG5cdGlmIChvYmogaW5zdGFuY2VvZiBDb2xvcikge1xuXHRcdHJldHVybiBvYmo7XG5cdH1cblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbG9yKSkge1xuXHRcdHJldHVybiBuZXcgQ29sb3Iob2JqKTtcblx0fVxuXG5cdHRoaXMudmFsaWQgPSBmYWxzZTtcblx0dGhpcy52YWx1ZXMgPSB7XG5cdFx0cmdiOiBbMCwgMCwgMF0sXG5cdFx0aHNsOiBbMCwgMCwgMF0sXG5cdFx0aHN2OiBbMCwgMCwgMF0sXG5cdFx0aHdiOiBbMCwgMCwgMF0sXG5cdFx0Y215azogWzAsIDAsIDAsIDBdLFxuXHRcdGFscGhhOiAxXG5cdH07XG5cblx0Ly8gcGFyc2UgQ29sb3IoKSBhcmd1bWVudFxuXHR2YXIgdmFscztcblx0aWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG5cdFx0dmFscyA9IGNvbG9yU3RyaW5nLmdldFJnYmEob2JqKTtcblx0XHRpZiAodmFscykge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscyA9IGNvbG9yU3RyaW5nLmdldEhzbGEob2JqKSkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscyA9IGNvbG9yU3RyaW5nLmdldEh3YihvYmopKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgdmFscyk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG5cdFx0dmFscyA9IG9iajtcblx0XHRpZiAodmFscy5yICE9PSB1bmRlZmluZWQgfHwgdmFscy5yZWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy5sICE9PSB1bmRlZmluZWQgfHwgdmFscy5saWdodG5lc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy52ICE9PSB1bmRlZmluZWQgfHwgdmFscy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHN2JywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLncgIT09IHVuZGVmaW5lZCB8fCB2YWxzLndoaXRlbmVzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLmMgIT09IHVuZGVmaW5lZCB8fCB2YWxzLmN5YW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2NteWsnLCB2YWxzKTtcblx0XHR9XG5cdH1cbn07XG5cbkNvbG9yLnByb3RvdHlwZSA9IHtcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbGlkO1xuXHR9LFxuXHRyZ2I6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgncmdiJywgYXJndW1lbnRzKTtcblx0fSxcblx0aHNsOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2hzbCcsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGhzdjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdoc3YnLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRod2I6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHdiJywgYXJndW1lbnRzKTtcblx0fSxcblx0Y215azogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdjbXlrJywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRyZ2JBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5yZ2I7XG5cdH0sXG5cdGhzbEFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmhzbDtcblx0fSxcblx0aHN2QXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuaHN2O1xuXHR9LFxuXHRod2JBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0XHRpZiAodmFsdWVzLmFscGhhICE9PSAxKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWVzLmh3Yi5jb25jYXQoW3ZhbHVlcy5hbHBoYV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWVzLmh3Yjtcblx0fSxcblx0Y215a0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmNteWs7XG5cdH0sXG5cdHJnYmFBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0XHRyZXR1cm4gdmFsdWVzLnJnYi5jb25jYXQoW3ZhbHVlcy5hbHBoYV0pO1xuXHR9LFxuXHRoc2xhQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0cmV0dXJuIHZhbHVlcy5oc2wuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0fSxcblx0YWxwaGE6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR9XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2FscGhhJywgdmFsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZWQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdyZ2InLCAwLCB2YWwpO1xuXHR9LFxuXHRncmVlbjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDEsIHZhbCk7XG5cdH0sXG5cdGJsdWU6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdyZ2InLCAyLCB2YWwpO1xuXHR9LFxuXHRodWU6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRpZiAodmFsKSB7XG5cdFx0XHR2YWwgJT0gMzYwO1xuXHRcdFx0dmFsID0gdmFsIDwgMCA/IDM2MCArIHZhbCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMCwgdmFsKTtcblx0fSxcblx0c2F0dXJhdGlvbjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzbCcsIDEsIHZhbCk7XG5cdH0sXG5cdGxpZ2h0bmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzbCcsIDIsIHZhbCk7XG5cdH0sXG5cdHNhdHVyYXRpb252OiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHN2JywgMSwgdmFsKTtcblx0fSxcblx0d2hpdGVuZXNzOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHdiJywgMSwgdmFsKTtcblx0fSxcblx0YmxhY2tuZXNzOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHdiJywgMiwgdmFsKTtcblx0fSxcblx0dmFsdWU6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc3YnLCAyLCB2YWwpO1xuXHR9LFxuXHRjeWFuOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDAsIHZhbCk7XG5cdH0sXG5cdG1hZ2VudGE6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMSwgdmFsKTtcblx0fSxcblx0eWVsbG93OiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDIsIHZhbCk7XG5cdH0sXG5cdGJsYWNrOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDMsIHZhbCk7XG5cdH0sXG5cblx0aGV4U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmhleFN0cmluZyh0aGlzLnZhbHVlcy5yZ2IpO1xuXHR9LFxuXHRyZ2JTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcucmdiU3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRyZ2JhU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnJnYmFTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdHBlcmNlbnRTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcucGVyY2VudFN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0aHNsU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmhzbFN0cmluZyh0aGlzLnZhbHVlcy5oc2wsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0aHNsYVN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5oc2xhU3RyaW5nKHRoaXMudmFsdWVzLmhzbCwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRod2JTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaHdiU3RyaW5nKHRoaXMudmFsdWVzLmh3YiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRrZXl3b3JkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmtleXdvcmQodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cblx0cmdiTnVtYmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHRyZXR1cm4gKHJnYlswXSA8PCAxNikgfCAocmdiWzFdIDw8IDgpIHwgcmdiWzJdO1xuXHR9LFxuXG5cdGx1bWlub3NpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHR2YXIgbHVtID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBjaGFuID0gcmdiW2ldIC8gMjU1O1xuXHRcdFx0bHVtW2ldID0gKGNoYW4gPD0gMC4wMzkyOCkgPyBjaGFuIC8gMTIuOTIgOiBNYXRoLnBvdygoKGNoYW4gKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7XG5cdFx0fVxuXHRcdHJldHVybiAwLjIxMjYgKiBsdW1bMF0gKyAwLjcxNTIgKiBsdW1bMV0gKyAwLjA3MjIgKiBsdW1bMl07XG5cdH0sXG5cblx0Y29udHJhc3Q6IGZ1bmN0aW9uIChjb2xvcjIpIHtcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI2NvbnRyYXN0LXJhdGlvZGVmXG5cdFx0dmFyIGx1bTEgPSB0aGlzLmx1bWlub3NpdHkoKTtcblx0XHR2YXIgbHVtMiA9IGNvbG9yMi5sdW1pbm9zaXR5KCk7XG5cdFx0aWYgKGx1bTEgPiBsdW0yKSB7XG5cdFx0XHRyZXR1cm4gKGx1bTEgKyAwLjA1KSAvIChsdW0yICsgMC4wNSk7XG5cdFx0fVxuXHRcdHJldHVybiAobHVtMiArIDAuMDUpIC8gKGx1bTEgKyAwLjA1KTtcblx0fSxcblxuXHRsZXZlbDogZnVuY3Rpb24gKGNvbG9yMikge1xuXHRcdHZhciBjb250cmFzdFJhdGlvID0gdGhpcy5jb250cmFzdChjb2xvcjIpO1xuXHRcdGlmIChjb250cmFzdFJhdGlvID49IDcuMSkge1xuXHRcdFx0cmV0dXJuICdBQUEnO1xuXHRcdH1cblxuXHRcdHJldHVybiAoY29udHJhc3RSYXRpbyA+PSA0LjUpID8gJ0FBJyA6ICcnO1xuXHR9LFxuXG5cdGRhcms6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBZSVEgZXF1YXRpb24gZnJvbSBodHRwOi8vMjR3YXlzLm9yZy8yMDEwL2NhbGN1bGF0aW5nLWNvbG9yLWNvbnRyYXN0XG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHR2YXIgeWlxID0gKHJnYlswXSAqIDI5OSArIHJnYlsxXSAqIDU4NyArIHJnYlsyXSAqIDExNCkgLyAxMDAwO1xuXHRcdHJldHVybiB5aXEgPCAxMjg7XG5cdH0sXG5cblx0bGlnaHQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuZGFyaygpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0cmdiW2ldID0gMjU1IC0gdGhpcy52YWx1ZXMucmdiW2ldO1xuXHRcdH1cblx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgcmdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRsaWdodGVuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsyXSArPSBoc2xbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRkYXJrZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzJdIC09IGhzbFsyXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNhdHVyYXRlOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsxXSArPSBoc2xbMV0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRkZXNhdHVyYXRlOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsxXSAtPSBoc2xbMV0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3aGl0ZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBod2IgPSB0aGlzLnZhbHVlcy5od2I7XG5cdFx0aHdiWzFdICs9IGh3YlsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCBod2IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGJsYWNrZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBod2IgPSB0aGlzLnZhbHVlcy5od2I7XG5cdFx0aHdiWzJdICs9IGh3YlsyXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCBod2IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdyZXlzY2FsZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmF5c2NhbGUjQ29udmVydGluZ19jb2xvcl90b19ncmF5c2NhbGVcblx0XHR2YXIgdmFsID0gcmdiWzBdICogMC4zICsgcmdiWzFdICogMC41OSArIHJnYlsyXSAqIDAuMTE7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIFt2YWwsIHZhbCwgdmFsXSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xlYXJlcjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGFscGhhID0gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2FscGhhJywgYWxwaGEgLSAoYWxwaGEgKiByYXRpbykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdG9wYXF1ZXI6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBhbHBoYSA9IHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIGFscGhhICsgKGFscGhhICogcmF0aW8pKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uIChkZWdyZWVzKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHR2YXIgaHVlID0gKGhzbFswXSArIGRlZ3JlZXMpICUgMzYwO1xuXHRcdGhzbFswXSA9IGh1ZSA8IDAgPyAzNjAgKyBodWUgOiBodWU7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFBvcnRlZCBmcm9tIHNhc3MgaW1wbGVtZW50YXRpb24gaW4gQ1xuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vc2Fzcy9saWJzYXNzL2Jsb2IvMGU2YjRhMjg1MDA5MjM1NmFhM2VjZTA3YzZiMjQ5ZjAyMjFjYWNlZC9mdW5jdGlvbnMuY3BwI0wyMDlcblx0ICovXG5cdG1peDogZnVuY3Rpb24gKG1peGluQ29sb3IsIHdlaWdodCkge1xuXHRcdHZhciBjb2xvcjEgPSB0aGlzO1xuXHRcdHZhciBjb2xvcjIgPSBtaXhpbkNvbG9yO1xuXHRcdHZhciBwID0gd2VpZ2h0ID09PSB1bmRlZmluZWQgPyAwLjUgOiB3ZWlnaHQ7XG5cblx0XHR2YXIgdyA9IDIgKiBwIC0gMTtcblx0XHR2YXIgYSA9IGNvbG9yMS5hbHBoYSgpIC0gY29sb3IyLmFscGhhKCk7XG5cblx0XHR2YXIgdzEgPSAoKCh3ICogYSA9PT0gLTEpID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcblx0XHR2YXIgdzIgPSAxIC0gdzE7XG5cblx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0LnJnYihcblx0XHRcdFx0dzEgKiBjb2xvcjEucmVkKCkgKyB3MiAqIGNvbG9yMi5yZWQoKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuZ3JlZW4oKSArIHcyICogY29sb3IyLmdyZWVuKCksXG5cdFx0XHRcdHcxICogY29sb3IxLmJsdWUoKSArIHcyICogY29sb3IyLmJsdWUoKVxuXHRcdFx0KVxuXHRcdFx0LmFscGhhKGNvbG9yMS5hbHBoYSgpICogcCArIGNvbG9yMi5hbHBoYSgpICogKDEgLSBwKSk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmdiKCk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBOT1RFKFNCKTogdXNpbmcgbm9kZS1jbG9uZSBjcmVhdGVzIGEgZGVwZW5kZW5jeSB0byBCdWZmZXIgd2hlbiB1c2luZyBicm93c2VyaWZ5LFxuXHRcdC8vIG1ha2luZyB0aGUgZmluYWwgYnVpbGQgd2F5IHRvIGJpZyB0byBlbWJlZCBpbiBDaGFydC5qcy4gU28gbGV0J3MgZG8gaXQgbWFudWFsbHksXG5cdFx0Ly8gYXNzdW1pbmcgdGhhdCB2YWx1ZXMgdG8gY2xvbmUgYXJlIDEgZGltZW5zaW9uIGFycmF5cyBjb250YWluaW5nIG9ubHkgbnVtYmVycyxcblx0XHQvLyBleGNlcHQgJ2FscGhhJyB3aGljaCBpcyBhIG51bWJlci5cblx0XHR2YXIgcmVzdWx0ID0gbmV3IENvbG9yKCk7XG5cdFx0dmFyIHNvdXJjZSA9IHRoaXMudmFsdWVzO1xuXHRcdHZhciB0YXJnZXQgPSByZXN1bHQudmFsdWVzO1xuXHRcdHZhciB2YWx1ZSwgdHlwZTtcblxuXHRcdGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG5cdFx0XHRpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRcdHZhbHVlID0gc291cmNlW3Byb3BdO1xuXHRcdFx0XHR0eXBlID0gKHt9KS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblx0XHRcdFx0XHR0YXJnZXRbcHJvcF0gPSB2YWx1ZS5zbGljZSgwKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBOdW1iZXJdJykge1xuXHRcdFx0XHRcdHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ3VuZXhwZWN0ZWQgY29sb3IgdmFsdWU6JywgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxufTtcblxuQ29sb3IucHJvdG90eXBlLnNwYWNlcyA9IHtcblx0cmdiOiBbJ3JlZCcsICdncmVlbicsICdibHVlJ10sXG5cdGhzbDogWydodWUnLCAnc2F0dXJhdGlvbicsICdsaWdodG5lc3MnXSxcblx0aHN2OiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ3ZhbHVlJ10sXG5cdGh3YjogWydodWUnLCAnd2hpdGVuZXNzJywgJ2JsYWNrbmVzcyddLFxuXHRjbXlrOiBbJ2N5YW4nLCAnbWFnZW50YScsICd5ZWxsb3cnLCAnYmxhY2snXVxufTtcblxuQ29sb3IucHJvdG90eXBlLm1heGVzID0ge1xuXHRyZ2I6IFsyNTUsIDI1NSwgMjU1XSxcblx0aHNsOiBbMzYwLCAxMDAsIDEwMF0sXG5cdGhzdjogWzM2MCwgMTAwLCAxMDBdLFxuXHRod2I6IFszNjAsIDEwMCwgMTAwXSxcblx0Y215azogWzEwMCwgMTAwLCAxMDAsIDEwMF1cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoc3BhY2UpIHtcblx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHR2YXIgdmFscyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHR2YWxzW3NwYWNlLmNoYXJBdChpKV0gPSB2YWx1ZXNbc3BhY2VdW2ldO1xuXHR9XG5cblx0aWYgKHZhbHVlcy5hbHBoYSAhPT0gMSkge1xuXHRcdHZhbHMuYSA9IHZhbHVlcy5hbHBoYTtcblx0fVxuXG5cdC8vIHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhOiAwLjR9XG5cdHJldHVybiB2YWxzO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uIChzcGFjZSwgdmFscykge1xuXHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdHZhciBzcGFjZXMgPSB0aGlzLnNwYWNlcztcblx0dmFyIG1heGVzID0gdGhpcy5tYXhlcztcblx0dmFyIGFscGhhID0gMTtcblx0dmFyIGk7XG5cblx0dGhpcy52YWxpZCA9IHRydWU7XG5cblx0aWYgKHNwYWNlID09PSAnYWxwaGEnKSB7XG5cdFx0YWxwaGEgPSB2YWxzO1xuXHR9IGVsc2UgaWYgKHZhbHMubGVuZ3RoKSB7XG5cdFx0Ly8gWzEwLCAxMCwgMTBdXG5cdFx0dmFsdWVzW3NwYWNlXSA9IHZhbHMuc2xpY2UoMCwgc3BhY2UubGVuZ3RoKTtcblx0XHRhbHBoYSA9IHZhbHNbc3BhY2UubGVuZ3RoXTtcblx0fSBlbHNlIGlmICh2YWxzW3NwYWNlLmNoYXJBdCgwKV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIHtyOiAxMCwgZzogMTAsIGI6IDEwfVxuXHRcdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsdWVzW3NwYWNlXVtpXSA9IHZhbHNbc3BhY2UuY2hhckF0KGkpXTtcblx0XHR9XG5cblx0XHRhbHBoYSA9IHZhbHMuYTtcblx0fSBlbHNlIGlmICh2YWxzW3NwYWNlc1tzcGFjZV1bMF1dICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyB7cmVkOiAxMCwgZ3JlZW46IDEwLCBibHVlOiAxMH1cblx0XHR2YXIgY2hhbnMgPSBzcGFjZXNbc3BhY2VdO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YWx1ZXNbc3BhY2VdW2ldID0gdmFsc1tjaGFuc1tpXV07XG5cdFx0fVxuXG5cdFx0YWxwaGEgPSB2YWxzLmFscGhhO1xuXHR9XG5cblx0dmFsdWVzLmFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGFscGhhID09PSB1bmRlZmluZWQgPyB2YWx1ZXMuYWxwaGEgOiBhbHBoYSkpKTtcblxuXHRpZiAoc3BhY2UgPT09ICdhbHBoYScpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgY2FwcGVkO1xuXG5cdC8vIGNhcCB2YWx1ZXMgb2YgdGhlIHNwYWNlIHByaW9yIGNvbnZlcnRpbmcgYWxsIHZhbHVlc1xuXHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRjYXBwZWQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXhlc1tzcGFjZV1baV0sIHZhbHVlc1tzcGFjZV1baV0pKTtcblx0XHR2YWx1ZXNbc3BhY2VdW2ldID0gTWF0aC5yb3VuZChjYXBwZWQpO1xuXHR9XG5cblx0Ly8gY29udmVydCB0byBhbGwgdGhlIG90aGVyIGNvbG9yIHNwYWNlc1xuXHRmb3IgKHZhciBzbmFtZSBpbiBzcGFjZXMpIHtcblx0XHRpZiAoc25hbWUgIT09IHNwYWNlKSB7XG5cdFx0XHR2YWx1ZXNbc25hbWVdID0gY29sb3JDb252ZXJ0W3NwYWNlXVtzbmFtZV0odmFsdWVzW3NwYWNlXSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0U3BhY2UgPSBmdW5jdGlvbiAoc3BhY2UsIGFyZ3MpIHtcblx0dmFyIHZhbHMgPSBhcmdzWzBdO1xuXG5cdGlmICh2YWxzID09PSB1bmRlZmluZWQpIHtcblx0XHQvLyBjb2xvci5yZ2IoKVxuXHRcdHJldHVybiB0aGlzLmdldFZhbHVlcyhzcGFjZSk7XG5cdH1cblxuXHQvLyBjb2xvci5yZ2IoMTAsIDEwLCAxMClcblx0aWYgKHR5cGVvZiB2YWxzID09PSAnbnVtYmVyJykge1xuXHRcdHZhbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcblx0fVxuXG5cdHRoaXMuc2V0VmFsdWVzKHNwYWNlLCB2YWxzKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0Q2hhbm5lbCA9IGZ1bmN0aW9uIChzcGFjZSwgaW5kZXgsIHZhbCkge1xuXHR2YXIgc3ZhbHVlcyA9IHRoaXMudmFsdWVzW3NwYWNlXTtcblx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gY29sb3IucmVkKClcblx0XHRyZXR1cm4gc3ZhbHVlc1tpbmRleF07XG5cdH0gZWxzZSBpZiAodmFsID09PSBzdmFsdWVzW2luZGV4XSkge1xuXHRcdC8vIGNvbG9yLnJlZChjb2xvci5yZWQoKSlcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIGNvbG9yLnJlZCgxMDApXG5cdHN2YWx1ZXNbaW5kZXhdID0gdmFsO1xuXHR0aGlzLnNldFZhbHVlcyhzcGFjZSwgc3ZhbHVlcyk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0d2luZG93LkNvbG9yID0gQ29sb3I7XG59XG5cbnZhciBjaGFydGpzQ29sb3IgPSBDb2xvcjtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnNcbiAqL1xudmFyIGhlbHBlcnMgPSB7XG5cdC8qKlxuXHQgKiBBbiBlbXB0eSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgZm9yIG9wdGlvbmFsIGNhbGxiYWNrLlxuXHQgKi9cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHVuaXF1ZSBpZCwgc2VxdWVudGlhbGx5IGdlbmVyYXRlZCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdHVpZDogKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZCA9IDA7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGlkKys7XG5cdFx0fTtcblx0fSgpKSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgbmVpdGhlciBudWxsIG5vciB1bmRlZmluZWQsIGVsc2UgcmV0dXJucyBmYWxzZS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRpc051bGxPclVuZGVmOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSAoaW5jbHVkaW5nIHR5cGVkIGFycmF5cyksIGVsc2UgcmV0dXJucyBmYWxzZS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRpc0FycmF5OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXHRcdGlmICh0eXBlLnN1YnN0cigwLCA3KSA9PT0gJ1tvYmplY3QnICYmIHR5cGUuc3Vic3RyKC02KSA9PT0gJ0FycmF5XScpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCAoZXhjbHVkaW5nIG51bGwpLCBlbHNlIHJldHVybnMgZmFsc2UuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0aXNPYmplY3Q6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgcmV0dXJucyBmYWxzZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlICAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzRmluaXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUodmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGB2YWx1ZWAgaWYgZGVmaW5lZCwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuXHQgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0dmFsdWVPckRlZmF1bHQ6IGZ1bmN0aW9uKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHZhbHVlIGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIGFycmF5IGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cblx0ICogQHBhcmFtIHtBcnJheX0gdmFsdWUgLSBUaGUgYXJyYXkgdG8gbG9va3VwIGZvciB2YWx1ZSBhdCBgaW5kZXhgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggaW4gYHZhbHVlYCB0byBsb29rdXAgZm9yIHZhbHVlLlxuXHQgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlW2luZGV4XWAgaXMgdW5kZWZpbmVkLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdHZhbHVlQXRJbmRleE9yRGVmYXVsdDogZnVuY3Rpb24odmFsdWUsIGluZGV4LCBkZWZhdWx0VmFsdWUpIHtcblx0XHRyZXR1cm4gaGVscGVycy52YWx1ZU9yRGVmYXVsdChoZWxwZXJzLmlzQXJyYXkodmFsdWUpID8gdmFsdWVbaW5kZXhdIDogdmFsdWUsIGRlZmF1bHRWYWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGxzIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gYGFyZ3NgIGluIHRoZSBzY29wZSBkZWZpbmVkIGJ5IGB0aGlzQXJnYCBhbmQgcmV0dXJucyB0aGVcblx0ICogdmFsdWUgcmV0dXJuZWQgYnkgYGZuYC4gSWYgYGZuYCBpcyBub3QgYSBmdW5jdGlvbiwgdGhpcyBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG5cdCAqIEBwYXJhbSB7QXJyYXl8dW5kZWZpbmVkfG51bGx9IGFyZ3MgLSBUaGUgYXJndW1lbnRzIHdpdGggd2hpY2ggYGZuYCBzaG91bGQgYmUgY2FsbGVkLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHRjYWxsYmFjazogZnVuY3Rpb24oZm4sIGFyZ3MsIHRoaXNBcmcpIHtcblx0XHRpZiAoZm4gJiYgdHlwZW9mIGZuLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIE5vdGUoU0IpIGZvciBwZXJmb3JtYW5jZSBzYWtlLCB0aGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gbG9vcGFibGUgdHlwZVxuXHQgKiBpcyB1bmtub3duIG9yIGluIG5vbmUgaW50ZW5zaXZlIGNvZGUgKG5vdCBjYWxsZWQgb2Z0ZW4gYW5kIHNtYWxsIGxvb3BhYmxlKS4gRWxzZVxuXHQgKiBpdCdzIHByZWZlcmFibGUgdG8gdXNlIGEgcmVndWxhciBmb3IoKSBsb29wIGFuZCBzYXZlIGV4dHJhIGZ1bmN0aW9uIGNhbGxzLlxuXHQgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gbG9vcGFibGUgLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGJlIGl0ZXJhdGVkLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGl0ZW0uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSAtIElmIHRydWUsIGl0ZXJhdGVzIGJhY2t3YXJkIG9uIHRoZSBsb29wYWJsZS5cblx0ICovXG5cdGVhY2g6IGZ1bmN0aW9uKGxvb3BhYmxlLCBmbiwgdGhpc0FyZywgcmV2ZXJzZSkge1xuXHRcdHZhciBpLCBsZW4sIGtleXM7XG5cdFx0aWYgKGhlbHBlcnMuaXNBcnJheShsb29wYWJsZSkpIHtcblx0XHRcdGxlbiA9IGxvb3BhYmxlLmxlbmd0aDtcblx0XHRcdGlmIChyZXZlcnNlKSB7XG5cdFx0XHRcdGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChoZWxwZXJzLmlzT2JqZWN0KGxvb3BhYmxlKSkge1xuXHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKGxvb3BhYmxlKTtcblx0XHRcdGxlbiA9IGtleXMubGVuZ3RoO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVba2V5c1tpXV0sIGtleXNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBgYTBgIGFuZCBgYTFgIGFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnQsIGVsc2UgcmV0dXJucyBmYWxzZS5cblx0ICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTQ4NTM5NzRcblx0ICogQHBhcmFtIHtBcnJheX0gYTAgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhMSAtIFRoZSBhcnJheSB0byBjb21wYXJlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0YXJyYXlFcXVhbHM6IGZ1bmN0aW9uKGEwLCBhMSkge1xuXHRcdHZhciBpLCBpbGVuLCB2MCwgdjE7XG5cblx0XHRpZiAoIWEwIHx8ICFhMSB8fCBhMC5sZW5ndGggIT09IGExLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhMC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHYwID0gYTBbaV07XG5cdFx0XHR2MSA9IGExW2ldO1xuXG5cdFx0XHRpZiAodjAgaW5zdGFuY2VvZiBBcnJheSAmJiB2MSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdGlmICghaGVscGVycy5hcnJheUVxdWFscyh2MCwgdjEpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHYwICE9PSB2MSkge1xuXHRcdFx0XHQvLyBOT1RFOiB0d28gZGlmZmVyZW50IG9iamVjdCBpbnN0YW5jZXMgd2lsbCBuZXZlciBiZSBlcXVhbDoge3g6MjB9ICE9IHt4OjIwfVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBkZWVwIGNvcHkgb2YgYHNvdXJjZWAgd2l0aG91dCBrZWVwaW5nIHJlZmVyZW5jZXMgb24gb2JqZWN0cyBhbmQgYXJyYXlzLlxuXHQgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSB2YWx1ZSB0byBjbG9uZS5cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHRjbG9uZTogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0aWYgKGhlbHBlcnMuaXNBcnJheShzb3VyY2UpKSB7XG5cdFx0XHRyZXR1cm4gc291cmNlLm1hcChoZWxwZXJzLmNsb25lKTtcblx0XHR9XG5cblx0XHRpZiAoaGVscGVycy5pc09iamVjdChzb3VyY2UpKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID0ge307XG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cdFx0XHR2YXIga2xlbiA9IGtleXMubGVuZ3RoO1xuXHRcdFx0dmFyIGsgPSAwO1xuXG5cdFx0XHRmb3IgKDsgayA8IGtsZW47ICsraykge1xuXHRcdFx0XHR0YXJnZXRba2V5c1trXV0gPSBoZWxwZXJzLmNsb25lKHNvdXJjZVtrZXlzW2tdXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNvdXJjZTtcblx0fSxcblxuXHQvKipcblx0ICogVGhlIGRlZmF1bHQgbWVyZ2VyIHdoZW4gQ2hhcnQuaGVscGVycy5tZXJnZSBpcyBjYWxsZWQgd2l0aG91dCBtZXJnZXIgb3B0aW9uLlxuXHQgKiBOb3RlKFNCKTogYWxzbyB1c2VkIGJ5IG1lcmdlQ29uZmlnIGFuZCBtZXJnZVNjYWxlQ29uZmlnIGFzIGZhbGxiYWNrLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X21lcmdlcjogZnVuY3Rpb24oa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdHZhciB0dmFsID0gdGFyZ2V0W2tleV07XG5cdFx0dmFyIHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuXHRcdGlmIChoZWxwZXJzLmlzT2JqZWN0KHR2YWwpICYmIGhlbHBlcnMuaXNPYmplY3Qoc3ZhbCkpIHtcblx0XHRcdGhlbHBlcnMubWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldFtrZXldID0gaGVscGVycy5jbG9uZShzdmFsKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIE1lcmdlcyBzb3VyY2Vba2V5XSBpbiB0YXJnZXRba2V5XSBvbmx5IGlmIHRhcmdldFtrZXldIGlzIHVuZGVmaW5lZC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9tZXJnZXJJZjogZnVuY3Rpb24oa2V5LCB0YXJnZXQsIHNvdXJjZSkge1xuXHRcdHZhciB0dmFsID0gdGFyZ2V0W2tleV07XG5cdFx0dmFyIHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuXHRcdGlmIChoZWxwZXJzLmlzT2JqZWN0KHR2YWwpICYmIGhlbHBlcnMuaXNPYmplY3Qoc3ZhbCkpIHtcblx0XHRcdGhlbHBlcnMubWVyZ2VJZih0dmFsLCBzdmFsKTtcblx0XHR9IGVsc2UgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLmNsb25lKHN2YWwpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cblx0ICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuXHQgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gc291cmNlIC0gT2JqZWN0KHMpIHRvIG1lcmdlIGludG8gYHRhcmdldGAuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBNZXJnaW5nIG9wdGlvbnM6XG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLm1lcmdlcl0gLSBUaGUgbWVyZ2UgbWV0aG9kIChrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgYHRhcmdldGAgb2JqZWN0LlxuXHQgKi9cblx0bWVyZ2U6IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHNvdXJjZXMgPSBoZWxwZXJzLmlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xuXHRcdHZhciBpbGVuID0gc291cmNlcy5sZW5ndGg7XG5cdFx0dmFyIG1lcmdlLCBpLCBrZXlzLCBrbGVuLCBrO1xuXG5cdFx0aWYgKCFoZWxwZXJzLmlzT2JqZWN0KHRhcmdldCkpIHtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0bWVyZ2UgPSBvcHRpb25zLm1lcmdlciB8fCBoZWxwZXJzLl9tZXJnZXI7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRzb3VyY2UgPSBzb3VyY2VzW2ldO1xuXHRcdFx0aWYgKCFoZWxwZXJzLmlzT2JqZWN0KHNvdXJjZSkpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXHRcdFx0Zm9yIChrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG5cdFx0XHRcdG1lcmdlKGtleXNba10sIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgKm9ubHkqIGlmIG5vdCBkZWZpbmVkIGluIHRhcmdldC5cblx0ICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuXHQgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gc291cmNlIC0gT2JqZWN0KHMpIHRvIG1lcmdlIGludG8gYHRhcmdldGAuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXG5cdCAqL1xuXHRtZXJnZUlmOiBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuXHRcdHJldHVybiBoZWxwZXJzLm1lcmdlKHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBoZWxwZXJzLl9tZXJnZXJJZn0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBjb250ZW50cyBvZiB0d28gb3IgbW9yZSBvYmplY3RzIHRvZ2V0aGVyIGludG8gdGhlIGZpcnN0IG9iamVjdC5cblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBvYmplY3RzIGFyZSBtZXJnZWQgaW50by5cblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZzEgLSBPYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gbWVyZ2UgaW4gdGFyZ2V0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJnTiAtIEFkZGl0aW9uYWwgb2JqZWN0cyBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gbWVyZ2UgaW4gdGFyZ2V0LlxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgYHRhcmdldGAgb2JqZWN0LlxuXHQgKi9cblx0ZXh0ZW5kOiBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHR2YXIgc2V0Rm4gPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IHZhbHVlO1xuXHRcdH07XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGlsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRoZWxwZXJzLmVhY2goYXJndW1lbnRzW2ldLCBzZXRGbik7XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEJhc2ljIGphdmFzY3JpcHQgaW5oZXJpdGFuY2UgYmFzZWQgb24gdGhlIG1vZGVsIGNyZWF0ZWQgaW4gQmFja2JvbmUuanNcblx0ICovXG5cdGluaGVyaXRzOiBmdW5jdGlvbihleHRlbnNpb25zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgQ2hhcnRFbGVtZW50ID0gKGV4dGVuc2lvbnMgJiYgZXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkgPyBleHRlbnNpb25zLmNvbnN0cnVjdG9yIDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXG5cdFx0dmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5jb25zdHJ1Y3RvciA9IENoYXJ0RWxlbWVudDtcblx0XHR9O1xuXG5cdFx0U3Vycm9nYXRlLnByb3RvdHlwZSA9IG1lLnByb3RvdHlwZTtcblx0XHRDaGFydEVsZW1lbnQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZSgpO1xuXHRcdENoYXJ0RWxlbWVudC5leHRlbmQgPSBoZWxwZXJzLmluaGVyaXRzO1xuXG5cdFx0aWYgKGV4dGVuc2lvbnMpIHtcblx0XHRcdGhlbHBlcnMuZXh0ZW5kKENoYXJ0RWxlbWVudC5wcm90b3R5cGUsIGV4dGVuc2lvbnMpO1xuXHRcdH1cblxuXHRcdENoYXJ0RWxlbWVudC5fX3N1cGVyX18gPSBtZS5wcm90b3R5cGU7XG5cdFx0cmV0dXJuIENoYXJ0RWxlbWVudDtcblx0fVxufTtcblxudmFyIGhlbHBlcnNfY29yZSA9IGhlbHBlcnM7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYWxsYmFjayBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuY2FsbENhbGxiYWNrXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmNhbGxDYWxsYmFjayA9IGhlbHBlcnMuY2FsbGJhY2s7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiBpbnN0ZWFkLlxuICogQXJyYXkucHJvdG90eXBlLmluZGV4T2YgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSwgU2FmYXJpLCBGRjEuNSssIElFOStcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmluZGV4T2ZcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tSW5kZXgpIHtcblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYXJyYXksIGl0ZW0sIGZyb21JbmRleCk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy52YWx1ZU9yRGVmYXVsdCBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuZ2V0VmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQgaW5zdGVhZC5cbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcblxuLyoqXG4gKiBFYXNpbmcgZnVuY3Rpb25zIGFkYXB0ZWQgZnJvbSBSb2JlcnQgUGVubmVyJ3MgZWFzaW5nIGVxdWF0aW9ucy5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5lYXNpbmdFZmZlY3RzXG4gKiBAc2VlIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcvXG4gKi9cbnZhciBlZmZlY3RzID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdDtcblx0fSxcblxuXHRlYXNlSW5RdWFkOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRRdWFkOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIC10ICogKHQgLSAyKTtcblx0fSxcblxuXHRlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQ7XG5cdFx0fVxuXHRcdHJldHVybiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpO1xuXHR9LFxuXG5cdGVhc2VJbkN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQgKiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPSB0IC0gMSkgKiB0ICogdCArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdCAqIHQ7XG5cdFx0fVxuXHRcdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpO1xuXHR9LFxuXG5cdGVhc2VJblF1YXJ0OiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHQ7XG5cdH0sXG5cblx0ZWFzZU91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIC0oKHQgPSB0IC0gMSkgKiB0ICogdCAqIHQgLSAxKTtcblx0fSxcblxuXHRlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0fVxuXHRcdHJldHVybiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMik7XG5cdH0sXG5cblx0ZWFzZUluUXVpbnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG5cdH0sXG5cblx0ZWFzZU91dFF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID0gdCAtIDEpICogdCAqIHQgKiB0ICogdCArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdCAqIHQgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKTtcblx0fSxcblxuXHRlYXNlSW5TaW5lOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIC1NYXRoLmNvcyh0ICogKE1hdGguUEkgLyAyKSkgKyAxO1xuXHR9LFxuXG5cdGVhc2VPdXRTaW5lOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIE1hdGguc2luKHQgKiAoTWF0aC5QSSAvIDIpKTtcblx0fSxcblxuXHRlYXNlSW5PdXRTaW5lOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQpIC0gMSk7XG5cdH0sXG5cblx0ZWFzZUluRXhwbzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAodCA9PT0gMCkgPyAwIDogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcblx0fSxcblxuXHRlYXNlT3V0RXhwbzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRFeHBvOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRpZiAodCA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG5cdFx0fVxuXHRcdHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIC0tdCkgKyAyKTtcblx0fSxcblxuXHRlYXNlSW5DaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPj0gMSkge1xuXHRcdFx0cmV0dXJuIHQ7XG5cdFx0fVxuXHRcdHJldHVybiAtKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XG5cdH0sXG5cblx0ZWFzZU91dENpcmM6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAodCA9IHQgLSAxKSAqIHQpO1xuXHR9LFxuXG5cdGVhc2VJbk91dENpcmM6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XG5cdFx0fVxuXHRcdHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSk7XG5cdH0sXG5cblx0ZWFzZUluRWxhc3RpYzogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHR2YXIgcCA9IDA7XG5cdFx0dmFyIGEgPSAxO1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKHQgPT09IDEpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoIXApIHtcblx0XHRcdHAgPSAwLjM7XG5cdFx0fVxuXHRcdGlmIChhIDwgMSkge1xuXHRcdFx0YSA9IDE7XG5cdFx0XHRzID0gcCAvIDQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG5cdFx0fVxuXHRcdHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHR9LFxuXG5cdGVhc2VPdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHZhciBwID0gMDtcblx0XHR2YXIgYSA9IDE7XG5cdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRpZiAodCA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdGlmICghcCkge1xuXHRcdFx0cCA9IDAuMztcblx0XHR9XG5cdFx0aWYgKGEgPCAxKSB7XG5cdFx0XHRhID0gMTtcblx0XHRcdHMgPSBwIC8gNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEgLyBhKTtcblx0XHR9XG5cdFx0cmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHZhciBhID0gMTtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICgodCAvPSAwLjUpID09PSAyKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCFwKSB7XG5cdFx0XHRwID0gMC40NTtcblx0XHR9XG5cdFx0aWYgKGEgPCAxKSB7XG5cdFx0XHRhID0gMTtcblx0XHRcdHMgPSBwIC8gNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEgLyBhKTtcblx0XHR9XG5cdFx0aWYgKHQgPCAxKSB7XG5cdFx0XHRyZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcblx0XHR9XG5cdFx0cmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcblx0fSxcblx0ZWFzZUluQmFjazogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRyZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcblx0fSxcblxuXHRlYXNlT3V0QmFjazogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRyZXR1cm4gKHQgPSB0IC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dEJhY2s6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKTtcblx0fSxcblxuXHRlYXNlSW5Cb3VuY2U6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gMSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCk7XG5cdH0sXG5cblx0ZWFzZU91dEJvdW5jZTogZnVuY3Rpb24odCkge1xuXHRcdGlmICh0IDwgKDEgLyAyLjc1KSkge1xuXHRcdFx0cmV0dXJuIDcuNTYyNSAqIHQgKiB0O1xuXHRcdH1cblx0XHRpZiAodCA8ICgyIC8gMi43NSkpIHtcblx0XHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMS41IC8gMi43NSkpICogdCArIDAuNzU7XG5cdFx0fVxuXHRcdGlmICh0IDwgKDIuNSAvIDIuNzUpKSB7XG5cdFx0XHRyZXR1cm4gNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgMC45Mzc1O1xuXHRcdH1cblx0XHRyZXR1cm4gNy41NjI1ICogKHQgLT0gKDIuNjI1IC8gMi43NSkpICogdCArIDAuOTg0Mzc1O1xuXHR9LFxuXG5cdGVhc2VJbk91dEJvdW5jZTogZnVuY3Rpb24odCkge1xuXHRcdGlmICh0IDwgMC41KSB7XG5cdFx0XHRyZXR1cm4gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41O1xuXHRcdH1cblx0XHRyZXR1cm4gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKHQgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG5cdH1cbn07XG5cbnZhciBoZWxwZXJzX2Vhc2luZyA9IHtcblx0ZWZmZWN0czogZWZmZWN0c1xufTtcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmVhc2luZy5lZmZlY3RzIGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5lYXNpbmdFZmZlY3RzXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzX2NvcmUuZWFzaW5nRWZmZWN0cyA9IGVmZmVjdHM7XG5cbnZhciBQSSA9IE1hdGguUEk7XG52YXIgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcbnZhciBET1VCTEVfUEkgPSBQSSAqIDI7XG52YXIgSEFMRl9QSSA9IFBJIC8gMjtcbnZhciBRVUFSVEVSX1BJID0gUEkgLyA0O1xudmFyIFRXT19USElSRFNfUEkgPSBQSSAqIDIgLyAzO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5jYW52YXNcbiAqL1xudmFyIGV4cG9ydHMkMSA9IHtcblx0LyoqXG5cdCAqIENsZWFycyB0aGUgZW50aXJlIGNhbnZhcyBhc3NvY2lhdGVkIHRvIHRoZSBnaXZlbiBgY2hhcnRgLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBmb3Igd2hpY2ggdG8gY2xlYXIgdGhlIGNhbnZhcy5cblx0ICovXG5cdGNsZWFyOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdGNoYXJ0LmN0eC5jbGVhclJlY3QoMCwgMCwgY2hhcnQud2lkdGgsIGNoYXJ0LmhlaWdodCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBcInBhdGhcIiBmb3IgYSByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMgYXQgcG9zaXRpb24gKHgsIHkpIHdpdGggYVxuXHQgKiBnaXZlbiBzaXplICh3aWR0aCwgaGVpZ2h0KSBhbmQgdGhlIHNhbWUgYHJhZGl1c2AgZm9yIGFsbCBjb3JuZXJzLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gVGhlIGNhbnZhcyAyRCBDb250ZXh0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGF4aXMgb2YgdGhlIGNvb3JkaW5hdGUgZm9yIHRoZSByZWN0YW5nbGUgc3RhcnRpbmcgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBmb3IgdGhlIHJlY3RhbmdsZSBzdGFydGluZyBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHJlY3RhbmdsZSdzIHdpZHRoLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIHJlY3RhbmdsZSdzIGhlaWdodC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByb3VuZGVkIGFtb3VudCAoaW4gcGl4ZWxzKSBmb3IgdGhlIGZvdXIgY29ybmVycy5cblx0ICogQHRvZG8gaGFuZGxlIGByYWRpdXNgIGFzIHRvcC1sZWZ0LCB0b3AtcmlnaHQsIGJvdHRvbS1yaWdodCwgYm90dG9tLWxlZnQgYXJyYXkvb2JqZWN0P1xuXHQgKi9cblx0cm91bmRlZFJlY3Q6IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG5cdFx0aWYgKHJhZGl1cykge1xuXHRcdFx0dmFyIHIgPSBNYXRoLm1pbihyYWRpdXMsIGhlaWdodCAvIDIsIHdpZHRoIC8gMik7XG5cdFx0XHR2YXIgbGVmdCA9IHggKyByO1xuXHRcdFx0dmFyIHRvcCA9IHkgKyByO1xuXHRcdFx0dmFyIHJpZ2h0ID0geCArIHdpZHRoIC0gcjtcblx0XHRcdHZhciBib3R0b20gPSB5ICsgaGVpZ2h0IC0gcjtcblxuXHRcdFx0Y3R4Lm1vdmVUbyh4LCB0b3ApO1xuXHRcdFx0aWYgKGxlZnQgPCByaWdodCAmJiB0b3AgPCBib3R0b20pIHtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1QSSwgLUhBTEZfUEkpO1xuXHRcdFx0XHRjdHguYXJjKHJpZ2h0LCB0b3AsIHIsIC1IQUxGX1BJLCAwKTtcblx0XHRcdFx0Y3R4LmFyYyhyaWdodCwgYm90dG9tLCByLCAwLCBIQUxGX1BJKTtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIEhBTEZfUEksIFBJKTtcblx0XHRcdH0gZWxzZSBpZiAobGVmdCA8IHJpZ2h0KSB7XG5cdFx0XHRcdGN0eC5tb3ZlVG8obGVmdCwgeSk7XG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIEhBTEZfUEkpO1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgSEFMRl9QSSwgUEkgKyBIQUxGX1BJKTtcblx0XHRcdH0gZWxzZSBpZiAodG9wIDwgYm90dG9tKSB7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCAtUEksIDApO1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIGJvdHRvbSwgciwgMCwgUEkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1QSSwgUEkpO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4LCB5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXdQb2ludDogZnVuY3Rpb24oY3R4LCBzdHlsZSwgcmFkaXVzLCB4LCB5LCByb3RhdGlvbikge1xuXHRcdHZhciB0eXBlLCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBjb3JuZXJSYWRpdXM7XG5cdFx0dmFyIHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuXG5cdFx0aWYgKHN0eWxlICYmIHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xuXHRcdFx0aWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIHggLSBzdHlsZS53aWR0aCAvIDIsIHkgLSBzdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0c3dpdGNoIChzdHlsZSkge1xuXHRcdC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBET1VCTEVfUEkpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAndHJpYW5nbGUnOlxuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuXHRcdFx0cmFkICs9IFRXT19USElSRFNfUEk7XG5cdFx0XHRjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG5cdFx0XHRyYWQgKz0gVFdPX1RISVJEU19QSTtcblx0XHRcdGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3JlY3RSb3VuZGVkJzpcblx0XHRcdC8vIE5PVEU6IHRoZSByb3VuZGVkIHJlY3QgaW1wbGVtZW50YXRpb24gY2hhbmdlZCB0byB1c2UgYGFyY2AgaW5zdGVhZCBvZlxuXHRcdFx0Ly8gYHF1YWRyYXRpY0N1cnZlVG9gIHNpbmNlIGl0IGdlbmVyYXRlcyBiZXR0ZXIgcmVzdWx0cyB3aGVuIHJlY3QgaXNcblx0XHRcdC8vIGFsbW9zdCBhIGNpcmNsZS4gMC41MTYgKGluc3RlYWQgb2YgMC41KSBwcm9kdWNlcyByZXN1bHRzIHdpdGggdmlzdWFsbHlcblx0XHRcdC8vIGNsb3NlciBwcm9wb3J0aW9uIHRvIHRoZSBwcmV2aW91cyBpbXBsIGFuZCBpdCBpcyBpbnNjcmliZWQgaW4gdGhlXG5cdFx0XHQvLyBjaXJjbGUgd2l0aCBgcmFkaXVzYC4gRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBmb2xsb3dpbmcgUFJzOlxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU1OTdcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81ODU4XG5cdFx0XHRjb3JuZXJSYWRpdXMgPSByYWRpdXMgKiAwLjUxNjtcblx0XHRcdHNpemUgPSByYWRpdXMgLSBjb3JuZXJSYWRpdXM7XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcblx0XHRcdGN0eC5hcmMoeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIFBJLCByYWQgLSBIQUxGX1BJKTtcblx0XHRcdGN0eC5hcmMoeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG5cdFx0XHRjdHguYXJjKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xuXHRcdFx0Y3R4LmFyYyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkICsgSEFMRl9QSSwgcmFkICsgUEkpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAncmVjdCc6XG5cdFx0XHRpZiAoIXJvdGF0aW9uKSB7XG5cdFx0XHRcdHNpemUgPSBNYXRoLlNRUlQxXzIgKiByYWRpdXM7XG5cdFx0XHRcdGN0eC5yZWN0KHggLSBzaXplLCB5IC0gc2l6ZSwgMiAqIHNpemUsIDIgKiBzaXplKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyYWQgKz0gUVVBUlRFUl9QSTtcblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRjYXNlICdyZWN0Um90Jzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdjcm9zc1JvdCc6XG5cdFx0XHRyYWQgKz0gUVVBUlRFUl9QSTtcblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRjYXNlICdjcm9zcyc6XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnc3Rhcic6XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuXHRcdFx0cmFkICs9IFFVQVJURVJfUEk7XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbGluZSc6XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnZGFzaCc6XG5cdFx0XHRjdHgubW92ZVRvKHgsIHkpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqIHJhZGl1cywgeSArIE1hdGguc2luKHJhZCkgKiByYWRpdXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0Y3R4LmZpbGwoKTtcblx0XHRjdHguc3Ryb2tlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtvYmplY3R9IHBvaW50IC0gVGhlIHBvaW50IHRvIHRlc3Rcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZWEgLSBUaGUgcmVjdGFuZ2xlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2lzUG9pbnRJbkFyZWE6IGZ1bmN0aW9uKHBvaW50LCBhcmVhKSB7XG5cdFx0dmFyIGVwc2lsb24gPSAxZS02OyAvLyAxZS02IGlzIG1hcmdpbiBpbiBwaXhlbHMgZm9yIGFjY3VtdWxhdGVkIGVycm9yLlxuXG5cdFx0cmV0dXJuIHBvaW50LnggPiBhcmVhLmxlZnQgLSBlcHNpbG9uICYmIHBvaW50LnggPCBhcmVhLnJpZ2h0ICsgZXBzaWxvbiAmJlxuXHRcdFx0cG9pbnQueSA+IGFyZWEudG9wIC0gZXBzaWxvbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBlcHNpbG9uO1xuXHR9LFxuXG5cdGNsaXBBcmVhOiBmdW5jdGlvbihjdHgsIGFyZWEpIHtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucmVjdChhcmVhLmxlZnQsIGFyZWEudG9wLCBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LCBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcblx0XHRjdHguY2xpcCgpO1xuXHR9LFxuXG5cdHVuY2xpcEFyZWE6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH0sXG5cblx0bGluZVRvOiBmdW5jdGlvbihjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXApIHtcblx0XHR2YXIgc3RlcHBlZCA9IHRhcmdldC5zdGVwcGVkTGluZTtcblx0XHRpZiAoc3RlcHBlZCkge1xuXHRcdFx0aWYgKHN0ZXBwZWQgPT09ICdtaWRkbGUnKSB7XG5cdFx0XHRcdHZhciBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xuXHRcdFx0XHRjdHgubGluZVRvKG1pZHBvaW50LCBmbGlwID8gdGFyZ2V0LnkgOiBwcmV2aW91cy55KTtcblx0XHRcdFx0Y3R4LmxpbmVUbyhtaWRwb2ludCwgZmxpcCA/IHByZXZpb3VzLnkgOiB0YXJnZXQueSk7XG5cdFx0XHR9IGVsc2UgaWYgKChzdGVwcGVkID09PSAnYWZ0ZXInICYmICFmbGlwKSB8fCAoc3RlcHBlZCAhPT0gJ2FmdGVyJyAmJiBmbGlwKSkge1xuXHRcdFx0XHRjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGFyZ2V0LnRlbnNpb24pIHtcblx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguYmV6aWVyQ3VydmVUbyhcblx0XHRcdGZsaXAgPyBwcmV2aW91cy5jb250cm9sUG9pbnRQcmV2aW91c1ggOiBwcmV2aW91cy5jb250cm9sUG9pbnROZXh0WCxcblx0XHRcdGZsaXAgPyBwcmV2aW91cy5jb250cm9sUG9pbnRQcmV2aW91c1kgOiBwcmV2aW91cy5jb250cm9sUG9pbnROZXh0WSxcblx0XHRcdGZsaXAgPyB0YXJnZXQuY29udHJvbFBvaW50TmV4dFggOiB0YXJnZXQuY29udHJvbFBvaW50UHJldmlvdXNYLFxuXHRcdFx0ZmxpcCA/IHRhcmdldC5jb250cm9sUG9pbnROZXh0WSA6IHRhcmdldC5jb250cm9sUG9pbnRQcmV2aW91c1ksXG5cdFx0XHR0YXJnZXQueCxcblx0XHRcdHRhcmdldC55KTtcblx0fVxufTtcblxudmFyIGhlbHBlcnNfY2FudmFzID0gZXhwb3J0cyQxO1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzLmNsZWFyIGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuY2xlYXJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnNfY29yZS5jbGVhciA9IGV4cG9ydHMkMS5jbGVhcjtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzLnJvdW5kZWRSZWN0IGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZHJhd1JvdW5kZWRSZWN0YW5nbGVcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnNfY29yZS5kcmF3Um91bmRlZFJlY3RhbmdsZSA9IGZ1bmN0aW9uKGN0eCkge1xuXHRjdHguYmVnaW5QYXRoKCk7XG5cdGV4cG9ydHMkMS5yb3VuZGVkUmVjdC5hcHBseShleHBvcnRzJDEsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgZGVmYXVsdHMgPSB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3NldDogZnVuY3Rpb24oc2NvcGUsIHZhbHVlcykge1xuXHRcdHJldHVybiBoZWxwZXJzX2NvcmUubWVyZ2UodGhpc1tzY29wZV0gfHwgKHRoaXNbc2NvcGVdID0ge30pLCB2YWx1ZXMpO1xuXHR9XG59O1xuXG5kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGRlZmF1bHRDb2xvcjogJ3JnYmEoMCwwLDAsMC4xKScsXG5cdGRlZmF1bHRGb250Q29sb3I6ICcjNjY2Jyxcblx0ZGVmYXVsdEZvbnRGYW1pbHk6IFwiJ0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWZcIixcblx0ZGVmYXVsdEZvbnRTaXplOiAxMixcblx0ZGVmYXVsdEZvbnRTdHlsZTogJ25vcm1hbCcsXG5cdGRlZmF1bHRMaW5lSGVpZ2h0OiAxLjIsXG5cdHNob3dMaW5lczogdHJ1ZVxufSk7XG5cbnZhciBjb3JlX2RlZmF1bHRzID0gZGVmYXVsdHM7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnNfY29yZS52YWx1ZU9yRGVmYXVsdDtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZm9udCBvYmplY3QgaW50byBhIENTUyBmb250IHN0cmluZy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBmb250IC0gQSBmb250IG9iamVjdC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIENTUyBmb250IHN0cmluZy4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0b0ZvbnRTdHJpbmcoZm9udCkge1xuXHRpZiAoIWZvbnQgfHwgaGVscGVyc19jb3JlLmlzTnVsbE9yVW5kZWYoZm9udC5zaXplKSB8fCBoZWxwZXJzX2NvcmUuaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcblx0XHQrIChmb250LndlaWdodCA/IGZvbnQud2VpZ2h0ICsgJyAnIDogJycpXG5cdFx0KyBmb250LnNpemUgKyAncHggJ1xuXHRcdCsgZm9udC5mYW1pbHk7XG59XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMub3B0aW9uc1xuICogQG5hbWVzcGFjZVxuICovXG52YXIgaGVscGVyc19vcHRpb25zID0ge1xuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIGxpbmUgaGVpZ2h0IGB2YWx1ZWAgaW4gcGl4ZWxzIGZvciBhIHNwZWNpZmljIGZvbnQgYHNpemVgLlxuXHQgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlIC0gVGhlIGxpbmVIZWlnaHQgdG8gcGFyc2UgKGVnLiAxLjYsICcxNHB4JywgJzc1JScsICcxLjZlbScpLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIFRoZSBmb250IHNpemUgKGluIHBpeGVscykgdXNlZCB0byByZXNvbHZlIHJlbGF0aXZlIGB2YWx1ZWAuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgaW4gcGl4ZWxzIChzaXplICogMS4yIGlmIHZhbHVlIGlzIGludmFsaWQpLlxuXHQgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9saW5lLWhlaWdodFxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdHRvTGluZUhlaWdodDogZnVuY3Rpb24odmFsdWUsIHNpemUpIHtcblx0XHR2YXIgbWF0Y2hlcyA9ICgnJyArIHZhbHVlKS5tYXRjaCgvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLyk7XG5cdFx0aWYgKCFtYXRjaGVzIHx8IG1hdGNoZXNbMV0gPT09ICdub3JtYWwnKSB7XG5cdFx0XHRyZXR1cm4gc2l6ZSAqIDEuMjtcblx0XHR9XG5cblx0XHR2YWx1ZSA9ICttYXRjaGVzWzJdO1xuXG5cdFx0c3dpdGNoIChtYXRjaGVzWzNdKSB7XG5cdFx0Y2FzZSAncHgnOlxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdGNhc2UgJyUnOlxuXHRcdFx0dmFsdWUgLz0gMTAwO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdHJldHVybiBzaXplICogdmFsdWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgcGFkZGluZyBvYmplY3Qgd2l0aCBwcmUtY29tcHV0ZWQgd2lkdGgvaGVpZ2h0LlxuXHQgKiBAcGFyYW0ge251bWJlcnxvYmplY3R9IHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxuXHQgKiAgZWxzZSwgaWYgYW5kIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgcGFkZGluZyB2YWx1ZXMgKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodClcblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHR0b1BhZGRpbmc6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIHQsIHIsIGIsIGw7XG5cblx0XHRpZiAoaGVscGVyc19jb3JlLmlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdFx0dCA9ICt2YWx1ZS50b3AgfHwgMDtcblx0XHRcdHIgPSArdmFsdWUucmlnaHQgfHwgMDtcblx0XHRcdGIgPSArdmFsdWUuYm90dG9tIHx8IDA7XG5cdFx0XHRsID0gK3ZhbHVlLmxlZnQgfHwgMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dCA9IHIgPSBiID0gbCA9ICt2YWx1ZSB8fCAwO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHQsXG5cdFx0XHRyaWdodDogcixcblx0XHRcdGJvdHRvbTogYixcblx0XHRcdGxlZnQ6IGwsXG5cdFx0XHRoZWlnaHQ6IHQgKyBiLFxuXHRcdFx0d2lkdGg6IGwgKyByXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogUGFyc2VzIGZvbnQgb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgZm9udCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gQSBvYmplY3QgdGhhdCBjb250YWlucyBmb250IG9wdGlvbnMgdG8gYmUgcGFyc2VkLlxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBmb250IG9iamVjdC5cblx0ICogQHRvZG8gU3VwcG9ydCBmb250Liogb3B0aW9ucyBhbmQgcmVuYW1lZCB0byB0b0ZvbnQoKS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9wYXJzZUZvbnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcblx0XHR2YXIgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0dmFyIGZvbnQgPSB7XG5cdFx0XHRmYW1pbHk6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdFx0bGluZUhlaWdodDogaGVscGVyc19jb3JlLm9wdGlvbnMudG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdExpbmVIZWlnaHQpLCBzaXplKSxcblx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRzdHlsZTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdFx0d2VpZ2h0OiBudWxsLFxuXHRcdFx0c3RyaW5nOiAnJ1xuXHRcdH07XG5cblx0XHRmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcblx0XHRyZXR1cm4gZm9udDtcblx0fSxcblxuXHQvKipcblx0ICogRXZhbHVhdGVzIHRoZSBnaXZlbiBgaW5wdXRzYCBzZXF1ZW50aWFsbHkgYW5kIHJldHVybnMgdGhlIGZpcnN0IGRlZmluZWQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGlucHV0cyAtIEFuIGFycmF5IG9mIHZhbHVlcywgZmFsbGluZyBiYWNrIHRvIHRoZSBsYXN0IHZhbHVlLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gSWYgZGVmaW5lZCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYSBmdW5jdGlvbiwgdGhlIHZhbHVlXG5cdCAqIGlzIGNhbGxlZCB3aXRoIGBjb250ZXh0YCBhcyBmaXJzdCBhcmd1bWVudCBhbmQgdGhlIHJlc3VsdCBiZWNvbWVzIHRoZSBuZXcgaW5wdXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdIC0gSWYgZGVmaW5lZCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYW4gYXJyYXksIHRoZSB2YWx1ZVxuXHQgKiBhdCBgaW5kZXhgIGJlY29tZSB0aGUgbmV3IGlucHV0LlxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdHJlc29sdmU6IGZ1bmN0aW9uKGlucHV0cywgY29udGV4dCwgaW5kZXgpIHtcblx0XHR2YXIgaSwgaWxlbiwgdmFsdWU7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dHNbaV07XG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUoY29udGV4dCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBoZWxwZXJzX2NvcmUuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtpbmRleF07XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgaGVscGVycyQxID0gaGVscGVyc19jb3JlO1xudmFyIGVhc2luZyA9IGhlbHBlcnNfZWFzaW5nO1xudmFyIGNhbnZhcyA9IGhlbHBlcnNfY2FudmFzO1xudmFyIG9wdGlvbnMgPSBoZWxwZXJzX29wdGlvbnM7XG5oZWxwZXJzJDEuZWFzaW5nID0gZWFzaW5nO1xuaGVscGVycyQxLmNhbnZhcyA9IGNhbnZhcztcbmhlbHBlcnMkMS5vcHRpb25zID0gb3B0aW9ucztcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RhcnQsIHZpZXcsIG1vZGVsLCBlYXNlKSB7XG5cdHZhciBrZXlzID0gT2JqZWN0LmtleXMobW9kZWwpO1xuXHR2YXIgaSwgaWxlbiwga2V5LCBhY3R1YWwsIG9yaWdpbiwgdGFyZ2V0LCB0eXBlLCBjMCwgYzE7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0a2V5ID0ga2V5c1tpXTtcblxuXHRcdHRhcmdldCA9IG1vZGVsW2tleV07XG5cblx0XHQvLyBpZiBhIHZhbHVlIGlzIGFkZGVkIHRvIHRoZSBtb2RlbCBhZnRlciBwaXZvdCgpIGhhcyBiZWVuIGNhbGxlZCwgdGhlIHZpZXdcblx0XHQvLyBkb2Vzbid0IGNvbnRhaW4gaXQsIHNvIGxldCdzIGluaXRpYWxpemUgdGhlIHZpZXcgdG8gdGhlIHRhcmdldCB2YWx1ZS5cblx0XHRpZiAoIXZpZXcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0dmlld1trZXldID0gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdGFjdHVhbCA9IHZpZXdba2V5XTtcblxuXHRcdGlmIChhY3R1YWwgPT09IHRhcmdldCB8fCBrZXlbMF0gPT09ICdfJykge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKCFzdGFydC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRzdGFydFtrZXldID0gYWN0dWFsO1xuXHRcdH1cblxuXHRcdG9yaWdpbiA9IHN0YXJ0W2tleV07XG5cblx0XHR0eXBlID0gdHlwZW9mIHRhcmdldDtcblxuXHRcdGlmICh0eXBlID09PSB0eXBlb2Ygb3JpZ2luKSB7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0YzAgPSBjaGFydGpzQ29sb3Iob3JpZ2luKTtcblx0XHRcdFx0aWYgKGMwLnZhbGlkKSB7XG5cdFx0XHRcdFx0YzEgPSBjaGFydGpzQ29sb3IodGFyZ2V0KTtcblx0XHRcdFx0XHRpZiAoYzEudmFsaWQpIHtcblx0XHRcdFx0XHRcdHZpZXdba2V5XSA9IGMxLm1peChjMCwgZWFzZSkucmdiU3RyaW5nKCk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoaGVscGVycyQxLmlzRmluaXRlKG9yaWdpbikgJiYgaGVscGVycyQxLmlzRmluaXRlKHRhcmdldCkpIHtcblx0XHRcdFx0dmlld1trZXldID0gb3JpZ2luICsgKHRhcmdldCAtIG9yaWdpbikgKiBlYXNlO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2aWV3W2tleV0gPSB0YXJnZXQ7XG5cdH1cbn1cblxudmFyIEVsZW1lbnQgPSBmdW5jdGlvbihjb25maWd1cmF0aW9uKSB7XG5cdGhlbHBlcnMkMS5leHRlbmQodGhpcywgY29uZmlndXJhdGlvbik7XG5cdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuaGVscGVycyQxLmV4dGVuZChFbGVtZW50LnByb3RvdHlwZSwge1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGlkZGVuID0gZmFsc2U7XG5cdH0sXG5cblx0cGl2b3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKCFtZS5fdmlldykge1xuXHRcdFx0bWUuX3ZpZXcgPSBoZWxwZXJzJDEuY2xvbmUobWUuX21vZGVsKTtcblx0XHR9XG5cdFx0bWUuX3N0YXJ0ID0ge307XG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2UpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtb2RlbCA9IG1lLl9tb2RlbDtcblx0XHR2YXIgc3RhcnQgPSBtZS5fc3RhcnQ7XG5cdFx0dmFyIHZpZXcgPSBtZS5fdmlldztcblxuXHRcdC8vIE5vIGFuaW1hdGlvbiAtPiBObyBUcmFuc2l0aW9uXG5cdFx0aWYgKCFtb2RlbCB8fCBlYXNlID09PSAxKSB7XG5cdFx0XHRtZS5fdmlldyA9IG1vZGVsO1xuXHRcdFx0bWUuX3N0YXJ0ID0gbnVsbDtcblx0XHRcdHJldHVybiBtZTtcblx0XHR9XG5cblx0XHRpZiAoIXZpZXcpIHtcblx0XHRcdHZpZXcgPSBtZS5fdmlldyA9IHt9O1xuXHRcdH1cblxuXHRcdGlmICghc3RhcnQpIHtcblx0XHRcdHN0YXJ0ID0gbWUuX3N0YXJ0ID0ge307XG5cdFx0fVxuXG5cdFx0aW50ZXJwb2xhdGUoc3RhcnQsIHZpZXcsIG1vZGVsLCBlYXNlKTtcblxuXHRcdHJldHVybiBtZTtcblx0fSxcblxuXHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB0aGlzLl9tb2RlbC54LFxuXHRcdFx0eTogdGhpcy5fbW9kZWwueVxuXHRcdH07XG5cdH0sXG5cblx0aGFzVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBoZWxwZXJzJDEuaXNOdW1iZXIodGhpcy5fbW9kZWwueCkgJiYgaGVscGVycyQxLmlzTnVtYmVyKHRoaXMuX21vZGVsLnkpO1xuXHR9XG59KTtcblxuRWxlbWVudC5leHRlbmQgPSBoZWxwZXJzJDEuaW5oZXJpdHM7XG5cbnZhciBjb3JlX2VsZW1lbnQgPSBFbGVtZW50O1xuXG52YXIgZXhwb3J0cyQyID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGNoYXJ0OiBudWxsLCAvLyB0aGUgYW5pbWF0aW9uIGFzc29jaWF0ZWQgY2hhcnQgaW5zdGFuY2Vcblx0Y3VycmVudFN0ZXA6IDAsIC8vIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGVwXG5cdG51bVN0ZXBzOiA2MCwgLy8gZGVmYXVsdCBudW1iZXIgb2Ygc3RlcHNcblx0ZWFzaW5nOiAnJywgLy8gdGhlIGVhc2luZyB0byB1c2UgZm9yIHRoaXMgYW5pbWF0aW9uXG5cdHJlbmRlcjogbnVsbCwgLy8gcmVuZGVyIGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGFuaW1hdGlvbiBzZXJ2aWNlXG5cblx0b25BbmltYXRpb25Qcm9ncmVzczogbnVsbCwgLy8gdXNlciBzcGVjaWZpZWQgY2FsbGJhY2sgdG8gZmlyZSBvbiBlYWNoIHN0ZXAgb2YgdGhlIGFuaW1hdGlvblxuXHRvbkFuaW1hdGlvbkNvbXBsZXRlOiBudWxsLCAvLyB1c2VyIHNwZWNpZmllZCBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIGFuaW1hdGlvbiBmaW5pc2hlc1xufSk7XG5cbnZhciBjb3JlX2FuaW1hdGlvbiA9IGV4cG9ydHMkMjtcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5BbmltYXRpb24gaW5zdGVhZFxuICogQHByb3AgQ2hhcnQuQW5pbWF0aW9uI2FuaW1hdGlvbk9iamVjdFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyQyLnByb3RvdHlwZSwgJ2FuaW1hdGlvbk9iamVjdCcsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5BbmltYXRpb24jY2hhcnQgaW5zdGVhZFxuICogQHByb3AgQ2hhcnQuQW5pbWF0aW9uI2NoYXJ0SW5zdGFuY2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMkMi5wcm90b3R5cGUsICdjaGFydEluc3RhbmNlJywge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNoYXJ0O1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy5jaGFydCA9IHZhbHVlO1xuXHR9XG59KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGFuaW1hdGlvbjoge1xuXHRcdGR1cmF0aW9uOiAxMDAwLFxuXHRcdGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG5cdFx0b25Qcm9ncmVzczogaGVscGVycyQxLm5vb3AsXG5cdFx0b25Db21wbGV0ZTogaGVscGVycyQxLm5vb3Bcblx0fVxufSk7XG5cbnZhciBjb3JlX2FuaW1hdGlvbnMgPSB7XG5cdGFuaW1hdGlvbnM6IFtdLFxuXHRyZXF1ZXN0OiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCB0byBhbmltYXRlLlxuXHQgKiBAcGFyYW0ge0NoYXJ0LkFuaW1hdGlvbn0gYW5pbWF0aW9uIC0gVGhlIGFuaW1hdGlvbiB0aGF0IHdlIHdpbGwgYW5pbWF0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtcy5cblx0ICogQHBhcmFtIHtib29sZWFufSBsYXp5IC0gaWYgdHJ1ZSwgdGhlIGNoYXJ0IGlzIG5vdCBtYXJrZWQgYXMgYW5pbWF0aW5nIHRvIGVuYWJsZSBtb3JlIHJlc3BvbnNpdmUgaW50ZXJhY3Rpb25zXG5cdCAqL1xuXHRhZGRBbmltYXRpb246IGZ1bmN0aW9uKGNoYXJ0LCBhbmltYXRpb24sIGR1cmF0aW9uLCBsYXp5KSB7XG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnM7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRhbmltYXRpb24uY2hhcnQgPSBjaGFydDtcblx0XHRhbmltYXRpb24uc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRhbmltYXRpb24uZHVyYXRpb24gPSBkdXJhdGlvbjtcblxuXHRcdGlmICghbGF6eSkge1xuXHRcdFx0Y2hhcnQuYW5pbWF0aW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYW5pbWF0aW9ucy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmIChhbmltYXRpb25zW2ldLmNoYXJ0ID09PSBjaGFydCkge1xuXHRcdFx0XHRhbmltYXRpb25zW2ldID0gYW5pbWF0aW9uO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgbm8gYW5pbWF0aW9ucyBxdWV1ZWQsIG1hbnVhbGx5IGtpY2tzdGFydCBhIGRpZ2VzdCwgZm9yIGxhY2sgb2YgYSBiZXR0ZXIgd29yZFxuXHRcdGlmIChhbmltYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcblx0XHR9XG5cdH0sXG5cblx0Y2FuY2VsQW5pbWF0aW9uOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciBpbmRleCA9IGhlbHBlcnMkMS5maW5kSW5kZXgodGhpcy5hbmltYXRpb25zLCBmdW5jdGlvbihhbmltYXRpb24pIHtcblx0XHRcdHJldHVybiBhbmltYXRpb24uY2hhcnQgPT09IGNoYXJ0O1xuXHRcdH0pO1xuXG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0dGhpcy5hbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRjaGFydC5hbmltYXRpbmcgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmIChtZS5yZXF1ZXN0ID09PSBudWxsKSB7XG5cdFx0XHQvLyBTa2lwIGFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0cyB1bnRpbCB0aGUgYWN0aXZlIG9uZSBpcyBleGVjdXRlZC5cblx0XHRcdC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHByb2Nlc3NpbmcgbW91c2UgZXZlbnRzLCBlLmcuICdtb3VzZW1vdmUnXG5cdFx0XHQvLyBhbmQgJ21vdXNlb3V0JyBldmVudHMgd2lsbCB0cmlnZ2VyIG11bHRpcGxlIHJlbmRlcnMuXG5cdFx0XHRtZS5yZXF1ZXN0ID0gaGVscGVycyQxLnJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtZS5yZXF1ZXN0ID0gbnVsbDtcblx0XHRcdFx0bWUuc3RhcnREaWdlc3QoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHN0YXJ0RGlnZXN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0bWUuYWR2YW5jZSgpO1xuXG5cdFx0Ly8gRG8gd2UgaGF2ZSBtb3JlIHN0dWZmIHRvIGFuaW1hdGU/XG5cdFx0aWYgKG1lLmFuaW1hdGlvbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0bWUucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0YWR2YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnM7XG5cdFx0dmFyIGFuaW1hdGlvbiwgY2hhcnQsIG51bVN0ZXBzLCBuZXh0U3RlcDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHQvLyAxIGFuaW1hdGlvbiBwZXIgY2hhcnQsIHNvIHdlIGFyZSBsb29waW5nIGNoYXJ0cyBoZXJlXG5cdFx0d2hpbGUgKGkgPCBhbmltYXRpb25zLmxlbmd0aCkge1xuXHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uc1tpXTtcblx0XHRcdGNoYXJ0ID0gYW5pbWF0aW9uLmNoYXJ0O1xuXHRcdFx0bnVtU3RlcHMgPSBhbmltYXRpb24ubnVtU3RlcHM7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGN1cnJlbnRTdGVwIHN0YXJ0cyBhdCAxXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjEwNFxuXHRcdFx0bmV4dFN0ZXAgPSBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gYW5pbWF0aW9uLnN0YXJ0VGltZSkgLyBhbmltYXRpb24uZHVyYXRpb24gKiBudW1TdGVwcykgKyAxO1xuXHRcdFx0YW5pbWF0aW9uLmN1cnJlbnRTdGVwID0gTWF0aC5taW4obmV4dFN0ZXAsIG51bVN0ZXBzKTtcblxuXHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbi5yZW5kZXIsIFtjaGFydCwgYW5pbWF0aW9uXSwgY2hhcnQpO1xuXHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbi5vbkFuaW1hdGlvblByb2dyZXNzLCBbYW5pbWF0aW9uXSwgY2hhcnQpO1xuXG5cdFx0XHRpZiAoYW5pbWF0aW9uLmN1cnJlbnRTdGVwID49IG51bVN0ZXBzKSB7XG5cdFx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb24ub25BbmltYXRpb25Db21wbGV0ZSwgW2FuaW1hdGlvbl0sIGNoYXJ0KTtcblx0XHRcdFx0Y2hhcnQuYW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdGFuaW1hdGlvbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0KytpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxudmFyIHJlc29sdmUgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG52YXIgYXJyYXlFdmVudHMgPSBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICd1bnNoaWZ0J107XG5cbi8qKlxuICogSG9va3MgdGhlIGFycmF5IG1ldGhvZHMgdGhhdCBhZGQgb3IgcmVtb3ZlIHZhbHVlcyAoJ3B1c2gnLCBwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJyxcbiAqICd1bnNoaWZ0JykgYW5kIG5vdGlmeSB0aGUgbGlzdGVuZXIgQUZURVIgdGhlIGFycmF5IGhhcyBiZWVuIGFsdGVyZWQuIExpc3RlbmVycyBhcmVcbiAqIGNhbGxlZCBvbiB0aGUgJ29uRGF0YSonIGNhbGxiYWNrcyAoZS5nLiBvbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcblx0aWYgKGFycmF5Ll9jaGFydGpzKSB7XG5cdFx0YXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwgJ19jaGFydGpzJywge1xuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHR2YWx1ZToge1xuXHRcdFx0bGlzdGVuZXJzOiBbbGlzdGVuZXJdXG5cdFx0fVxuXHR9KTtcblxuXHRhcnJheUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdHZhciBtZXRob2QgPSAnb25EYXRhJyArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTtcblx0XHR2YXIgYmFzZSA9IGFycmF5W2tleV07XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdFx0dmFyIHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG5cblx0XHRcdFx0aGVscGVycyQxLmVhY2goYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLCBmdW5jdGlvbihvYmplY3QpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIG9iamVjdFttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRvYmplY3RbbWV0aG9kXS5hcHBseShvYmplY3QsIGFyZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZ2l2ZW4gYXJyYXkgZXZlbnQgbGlzdGVuZXIgYW5kIGNsZWFudXAgZXh0cmEgYXR0YWNoZWQgcHJvcGVydGllcyAoc3VjaCBhc1xuICogdGhlIF9jaGFydGpzIHN0dWIgYW5kIG92ZXJyaWRkZW4gbWV0aG9kcykgaWYgYXJyYXkgZG9lc24ndCBoYXZlIGFueSBtb3JlIGxpc3RlbmVycy5cbiAqL1xuZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcblx0dmFyIHN0dWIgPSBhcnJheS5fY2hhcnRqcztcblx0aWYgKCFzdHViKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIGxpc3RlbmVycyA9IHN0dWIubGlzdGVuZXJzO1xuXHR2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG5cdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0fVxuXG5cdGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGFycmF5RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0ZGVsZXRlIGFycmF5W2tleV07XG5cdH0pO1xuXG5cdGRlbGV0ZSBhcnJheS5fY2hhcnRqcztcbn1cblxuLy8gQmFzZSBjbGFzcyBmb3IgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgKGxpbmUsIGJhciwgZXRjKVxudmFyIERhdGFzZXRDb250cm9sbGVyID0gZnVuY3Rpb24oY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuXHR0aGlzLmluaXRpYWxpemUoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG59O1xuXG5oZWxwZXJzJDEuZXh0ZW5kKERhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuXG5cdC8qKlxuXHQgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YXNldCAoZS5nLiBDaGFydC5lbGVtZW50LkxpbmUpLlxuXHQgKiBAdHlwZSB7Q2hhcnQuY29yZS5lbGVtZW50fVxuXHQgKi9cblx0ZGF0YXNldEVsZW1lbnRUeXBlOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YSAoZS5nLiBDaGFydC5lbGVtZW50LlBvaW50KS5cblx0ICogQHR5cGUge0NoYXJ0LmNvcmUuZWxlbWVudH1cblx0ICovXG5cdGRhdGFFbGVtZW50VHlwZTogbnVsbCxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihjaGFydCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRtZS5jaGFydCA9IGNoYXJ0O1xuXHRcdG1lLmluZGV4ID0gZGF0YXNldEluZGV4O1xuXHRcdG1lLmxpbmtTY2FsZXMoKTtcblx0XHRtZS5hZGRFbGVtZW50cygpO1xuXHR9LFxuXG5cdHVwZGF0ZUluZGV4OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHR0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuXHR9LFxuXG5cdGxpbmtTY2FsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cblx0XHRpZiAobWV0YS54QXhpc0lEID09PSBudWxsIHx8ICEobWV0YS54QXhpc0lEIGluIG1lLmNoYXJ0LnNjYWxlcykpIHtcblx0XHRcdG1ldGEueEF4aXNJRCA9IGRhdGFzZXQueEF4aXNJRCB8fCBtZS5jaGFydC5vcHRpb25zLnNjYWxlcy54QXhlc1swXS5pZDtcblx0XHR9XG5cdFx0aWYgKG1ldGEueUF4aXNJRCA9PT0gbnVsbCB8fCAhKG1ldGEueUF4aXNJRCBpbiBtZS5jaGFydC5zY2FsZXMpKSB7XG5cdFx0XHRtZXRhLnlBeGlzSUQgPSBkYXRhc2V0LnlBeGlzSUQgfHwgbWUuY2hhcnQub3B0aW9ucy5zY2FsZXMueUF4ZXNbMF0uaWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGdldERhdGFzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG5cdH0sXG5cblx0Z2V0TWV0YTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG5cdH0sXG5cblx0Z2V0U2NhbGVGb3JJZDogZnVuY3Rpb24oc2NhbGVJRCkge1xuXHRcdHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRWYWx1ZVNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS55QXhpc0lEO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldEluZGV4U2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnhBeGlzSUQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0VmFsdWVTY2FsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2NhbGVGb3JJZCh0aGlzLl9nZXRWYWx1ZVNjYWxlSWQoKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0SW5kZXhTY2FsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2NhbGVGb3JJZCh0aGlzLl9nZXRJbmRleFNjYWxlSWQoKSk7XG5cdH0sXG5cblx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlKHRydWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHtcblx0XHRcdHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdGNyZWF0ZU1ldGFEYXRhc2V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0eXBlID0gbWUuZGF0YXNldEVsZW1lbnRUeXBlO1xuXHRcdHJldHVybiB0eXBlICYmIG5ldyB0eXBlKHtcblx0XHRcdF9jaGFydDogbWUuY2hhcnQsXG5cdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH0pO1xuXHR9LFxuXG5cdGNyZWF0ZU1ldGFEYXRhOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHR5cGUgPSBtZS5kYXRhRWxlbWVudFR5cGU7XG5cdFx0cmV0dXJuIHR5cGUgJiYgbmV3IHR5cGUoe1xuXHRcdFx0X2NoYXJ0OiBtZS5jaGFydCxcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxuXHRcdFx0X2luZGV4OiBpbmRleFxuXHRcdH0pO1xuXHR9LFxuXG5cdGFkZEVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGEgfHwgW107XG5cdFx0dmFyIG1ldGFEYXRhID0gbWV0YS5kYXRhO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZXRhRGF0YVtpXSA9IG1ldGFEYXRhW2ldIHx8IG1lLmNyZWF0ZU1ldGFEYXRhKGkpO1xuXHRcdH1cblxuXHRcdG1ldGEuZGF0YXNldCA9IG1ldGEuZGF0YXNldCB8fCBtZS5jcmVhdGVNZXRhRGF0YXNldCgpO1xuXHR9LFxuXG5cdGFkZEVsZW1lbnRBbmRSZXNldDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuY3JlYXRlTWV0YURhdGEoaW5kZXgpO1xuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEuc3BsaWNlKGluZGV4LCAwLCBlbGVtZW50KTtcblx0XHR0aGlzLnVwZGF0ZUVsZW1lbnQoZWxlbWVudCwgaW5kZXgsIHRydWUpO1xuXHR9LFxuXG5cdGJ1aWxkT3JVcGRhdGVFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgZGF0YSA9IGRhdGFzZXQuZGF0YSB8fCAoZGF0YXNldC5kYXRhID0gW10pO1xuXG5cdFx0Ly8gSW4gb3JkZXIgdG8gY29ycmVjdGx5IGhhbmRsZSBkYXRhIGFkZGl0aW9uL2RlbGV0aW9uIGFuaW1hdGlvbiAoYW4gdGh1cyBzaW11bGF0ZVxuXHRcdC8vIHJlYWwtdGltZSBjaGFydHMpLCB3ZSBuZWVkIHRvIG1vbml0b3IgdGhlc2UgZGF0YSBtb2RpZmljYXRpb25zIGFuZCBzeW5jaHJvbml6ZVxuXHRcdC8vIHRoZSBpbnRlcm5hbCBtZXRhIGRhdGEgYWNjb3JkaW5nbHkuXG5cdFx0aWYgKG1lLl9kYXRhICE9PSBkYXRhKSB7XG5cdFx0XHRpZiAobWUuX2RhdGEpIHtcblx0XHRcdFx0Ly8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgdXNlciByZXBsYWNlZCB0aGUgZGF0YSBhcnJheSBpbnN0YW5jZS5cblx0XHRcdFx0dW5saXN0ZW5BcnJheUV2ZW50cyhtZS5fZGF0YSwgbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0YSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGRhdGEpKSB7XG5cdFx0XHRcdGxpc3RlbkFycmF5RXZlbnRzKGRhdGEsIG1lKTtcblx0XHRcdH1cblx0XHRcdG1lLl9kYXRhID0gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBSZS1zeW5jIG1ldGEgZGF0YSBpbiBjYXNlIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IG9yIGlmIHdlIG1pc3NlZFxuXHRcdC8vIGFueSB1cGRhdGVzIGFuZCBzbyBtYWtlIHN1cmUgdGhhdCB3ZSBoYW5kbGUgbnVtYmVyIG9mIGRhdGFwb2ludHMgY2hhbmdpbmcuXG5cdFx0bWUucmVzeW5jRWxlbWVudHMoKTtcblx0fSxcblxuXHR1cGRhdGU6IGhlbHBlcnMkMS5ub29wLFxuXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcblx0XHR2YXIgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0dmFyIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7XG5cdFx0dmFyIGkgPSAwO1xuXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGVsZW1lbnRzW2ldLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHRcdH1cblxuXHRcdGlmIChtZXRhLmRhdGFzZXQpIHtcblx0XHRcdG1ldGEuZGF0YXNldC50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcblx0XHR2YXIgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0dmFyIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7XG5cdFx0dmFyIGkgPSAwO1xuXG5cdFx0aWYgKG1ldGEuZGF0YXNldCkge1xuXHRcdFx0bWV0YS5kYXRhc2V0LmRyYXcoKTtcblx0XHR9XG5cblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZWxlbWVudHNbaV0uZHJhdygpO1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVIb3ZlclN0eWxlOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0aGVscGVycyQxLm1lcmdlKGVsZW1lbnQuX21vZGVsLCBlbGVtZW50LiRwcmV2aW91c1N0eWxlIHx8IHt9KTtcblx0XHRkZWxldGUgZWxlbWVudC4kcHJldmlvdXNTdHlsZTtcblx0fSxcblxuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZWxlbWVudC5fZGF0YXNldEluZGV4XTtcblx0XHR2YXIgaW5kZXggPSBlbGVtZW50Ll9pbmRleDtcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XG5cdFx0dmFyIG1vZGVsID0gZWxlbWVudC5fbW9kZWw7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblxuXHRcdGVsZW1lbnQuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aFxuXHRcdH07XG5cblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSByZXNvbHZlKFtjdXN0b20uaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGRhdGFzZXQuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3IobW9kZWwuYmFja2dyb3VuZENvbG9yKV0sIHVuZGVmaW5lZCwgaW5kZXgpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gcmVzb2x2ZShbY3VzdG9tLmhvdmVyQm9yZGVyQ29sb3IsIGRhdGFzZXQuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihtb2RlbC5ib3JkZXJDb2xvcildLCB1bmRlZmluZWQsIGluZGV4KTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJvcmRlcldpZHRoLCBkYXRhc2V0LmhvdmVyQm9yZGVyV2lkdGgsIG1vZGVsLmJvcmRlcldpZHRoXSwgdW5kZWZpbmVkLCBpbmRleCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZXN5bmNFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhO1xuXHRcdHZhciBudW1NZXRhID0gbWV0YS5kYXRhLmxlbmd0aDtcblx0XHR2YXIgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuXG5cdFx0aWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG5cdFx0XHRtZXRhLmRhdGEuc3BsaWNlKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcblx0XHR9IGVsc2UgaWYgKG51bURhdGEgPiBudW1NZXRhKSB7XG5cdFx0XHRtZS5pbnNlcnRFbGVtZW50cyhudW1NZXRhLCBudW1EYXRhIC0gbnVtTWV0YSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5zZXJ0RWxlbWVudHM6IGZ1bmN0aW9uKHN0YXJ0LCBjb3VudCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHRcdFx0dGhpcy5hZGRFbGVtZW50QW5kUmVzZXQoc3RhcnQgKyBpKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFQdXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHModGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSBjb3VudCwgY291bnQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25EYXRhUG9wOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnBvcCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25EYXRhU2hpZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEuc2hpZnQoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVNwbGljZTogZnVuY3Rpb24oc3RhcnQsIGNvdW50KSB7XG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcblx0XHR0aGlzLmluc2VydEVsZW1lbnRzKHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoIC0gMik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFVbnNoaWZ0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmluc2VydEVsZW1lbnRzKDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuXHR9XG59KTtcblxuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kID0gaGVscGVycyQxLmluaGVyaXRzO1xuXG52YXIgY29yZV9kYXRhc2V0Q29udHJvbGxlciA9IERhdGFzZXRDb250cm9sbGVyO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHtcblx0XHRhcmM6IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6ICcjZmZmJyxcblx0XHRcdGJvcmRlcldpZHRoOiAyLFxuXHRcdFx0Ym9yZGVyQWxpZ246ICdjZW50ZXInXG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGVsZW1lbnRfYXJjID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGluTGFiZWxSYW5nZTogZnVuY3Rpb24obW91c2VYKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdGlmICh2bSkge1xuXHRcdFx0cmV0dXJuIChNYXRoLnBvdyhtb3VzZVggLSB2bS54LCAyKSA8IE1hdGgucG93KHZtLnJhZGl1cyArIHZtLmhvdmVyUmFkaXVzLCAyKSk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpblJhbmdlOiBmdW5jdGlvbihjaGFydFgsIGNoYXJ0WSkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cblx0XHRpZiAodm0pIHtcblx0XHRcdHZhciBwb2ludFJlbGF0aXZlUG9zaXRpb24gPSBoZWxwZXJzJDEuZ2V0QW5nbGVGcm9tUG9pbnQodm0sIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuXHRcdFx0dmFyXHRhbmdsZSA9IHBvaW50UmVsYXRpdmVQb3NpdGlvbi5hbmdsZTtcblx0XHRcdHZhciBkaXN0YW5jZSA9IHBvaW50UmVsYXRpdmVQb3NpdGlvbi5kaXN0YW5jZTtcblxuXHRcdFx0Ly8gU2FuaXRpc2UgYW5nbGUgcmFuZ2Vcblx0XHRcdHZhciBzdGFydEFuZ2xlID0gdm0uc3RhcnRBbmdsZTtcblx0XHRcdHZhciBlbmRBbmdsZSA9IHZtLmVuZEFuZ2xlO1xuXHRcdFx0d2hpbGUgKGVuZEFuZ2xlIDwgc3RhcnRBbmdsZSkge1xuXHRcdFx0XHRlbmRBbmdsZSArPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGFuZ2xlID4gZW5kQW5nbGUpIHtcblx0XHRcdFx0YW5nbGUgLT0gMi4wICogTWF0aC5QSTtcblx0XHRcdH1cblx0XHRcdHdoaWxlIChhbmdsZSA8IHN0YXJ0QW5nbGUpIHtcblx0XHRcdFx0YW5nbGUgKz0gMi4wICogTWF0aC5QSTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgaWYgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgb3Blbi9jbG9zZSBhbmdsZVxuXHRcdFx0dmFyIGJldHdlZW5BbmdsZXMgPSAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSk7XG5cdFx0XHR2YXIgd2l0aGluUmFkaXVzID0gKGRpc3RhbmNlID49IHZtLmlubmVyUmFkaXVzICYmIGRpc3RhbmNlIDw9IHZtLm91dGVyUmFkaXVzKTtcblxuXHRcdFx0cmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgaGFsZkFuZ2xlID0gKHZtLnN0YXJ0QW5nbGUgKyB2bS5lbmRBbmdsZSkgLyAyO1xuXHRcdHZhciBoYWxmUmFkaXVzID0gKHZtLmlubmVyUmFkaXVzICsgdm0ub3V0ZXJSYWRpdXMpIC8gMjtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxuXHRcdFx0eTogdm0ueSArIE1hdGguc2luKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzXG5cdFx0fTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiBNYXRoLlBJICogKCh2bS5lbmRBbmdsZSAtIHZtLnN0YXJ0QW5nbGUpIC8gKDIgKiBNYXRoLlBJKSkgKiAoTWF0aC5wb3codm0ub3V0ZXJSYWRpdXMsIDIpIC0gTWF0aC5wb3codm0uaW5uZXJSYWRpdXMsIDIpKTtcblx0fSxcblxuXHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIGNlbnRyZUFuZ2xlID0gdm0uc3RhcnRBbmdsZSArICgodm0uZW5kQW5nbGUgLSB2bS5zdGFydEFuZ2xlKSAvIDIpO1xuXHRcdHZhciByYW5nZUZyb21DZW50cmUgPSAodm0ub3V0ZXJSYWRpdXMgLSB2bS5pbm5lclJhZGl1cykgLyAyICsgdm0uaW5uZXJSYWRpdXM7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCArIChNYXRoLmNvcyhjZW50cmVBbmdsZSkgKiByYW5nZUZyb21DZW50cmUpLFxuXHRcdFx0eTogdm0ueSArIChNYXRoLnNpbihjZW50cmVBbmdsZSkgKiByYW5nZUZyb21DZW50cmUpXG5cdFx0fTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIHNBID0gdm0uc3RhcnRBbmdsZTtcblx0XHR2YXIgZUEgPSB2bS5lbmRBbmdsZTtcblx0XHR2YXIgcGl4ZWxNYXJnaW4gPSAodm0uYm9yZGVyQWxpZ24gPT09ICdpbm5lcicpID8gMC4zMyA6IDA7XG5cdFx0dmFyIGFuZ2xlTWFyZ2luO1xuXG5cdFx0Y3R4LnNhdmUoKTtcblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHZtLngsIHZtLnksIE1hdGgubWF4KHZtLm91dGVyUmFkaXVzIC0gcGl4ZWxNYXJnaW4sIDApLCBzQSwgZUEpO1xuXHRcdGN0eC5hcmModm0ueCwgdm0ueSwgdm0uaW5uZXJSYWRpdXMsIGVBLCBzQSwgdHJ1ZSk7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvcjtcblx0XHRjdHguZmlsbCgpO1xuXG5cdFx0aWYgKHZtLmJvcmRlcldpZHRoKSB7XG5cdFx0XHRpZiAodm0uYm9yZGVyQWxpZ24gPT09ICdpbm5lcicpIHtcblx0XHRcdFx0Ly8gRHJhdyBhbiBpbm5lciBib3JkZXIgYnkgY2xpcGluZyB0aGUgYXJjIGFuZCBkcmF3aW5nIGEgZG91YmxlLXdpZHRoIGJvcmRlclxuXHRcdFx0XHQvLyBFbmxhcmdlIHRoZSBjbGlwcGluZyBhcmMgYnkgMC4zMyBwaXhlbHMgdG8gZWxpbWluYXRlIGdsaXRjaGVzIGJldHdlZW4gYm9yZGVyc1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyB2bS5vdXRlclJhZGl1cztcblx0XHRcdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5vdXRlclJhZGl1cywgc0EgLSBhbmdsZU1hcmdpbiwgZUEgKyBhbmdsZU1hcmdpbik7XG5cdFx0XHRcdGlmICh2bS5pbm5lclJhZGl1cyA+IHBpeGVsTWFyZ2luKSB7XG5cdFx0XHRcdFx0YW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIHZtLmlubmVyUmFkaXVzO1xuXHRcdFx0XHRcdGN0eC5hcmModm0ueCwgdm0ueSwgdm0uaW5uZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgZUEgKyBhbmdsZU1hcmdpbiwgc0EgLSBhbmdsZU1hcmdpbiwgdHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3R4LmFyYyh2bS54LCB2bS55LCBwaXhlbE1hcmdpbiwgZUEgKyBNYXRoLlBJIC8gMiwgc0EgLSBNYXRoLlBJIC8gMik7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRjdHguY2xpcCgpO1xuXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5vdXRlclJhZGl1cywgc0EsIGVBKTtcblx0XHRcdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5pbm5lclJhZGl1cywgZUEsIHNBLCB0cnVlKTtcblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aCAqIDI7XG5cdFx0XHRcdGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGg7XG5cdFx0XHRcdGN0eC5saW5lSm9pbiA9ICdiZXZlbCc7XG5cdFx0XHR9XG5cblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblxuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH1cbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkMSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxudmFyIGRlZmF1bHRDb2xvciA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGVsZW1lbnRzOiB7XG5cdFx0bGluZToge1xuXHRcdFx0dGVuc2lvbjogMC40LFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBkZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogMyxcblx0XHRcdGJvcmRlckNvbG9yOiBkZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuXHRcdFx0Ym9yZGVyRGFzaDogW10sXG5cdFx0XHRib3JkZXJEYXNoT2Zmc2V0OiAwLjAsXG5cdFx0XHRib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXG5cdFx0XHRjYXBCZXppZXJQb2ludHM6IHRydWUsXG5cdFx0XHRmaWxsOiB0cnVlLCAvLyBkbyB3ZSBmaWxsIGluIHRoZSBhcmVhIGJldHdlZW4gdGhlIGxpbmUgYW5kIGl0cyBiYXNlIGF4aXNcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZWxlbWVudF9saW5lID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHZtID0gbWUuX3ZpZXc7XG5cdFx0dmFyIGN0eCA9IG1lLl9jaGFydC5jdHg7XG5cdFx0dmFyIHNwYW5HYXBzID0gdm0uc3BhbkdhcHM7XG5cdFx0dmFyIHBvaW50cyA9IG1lLl9jaGlsZHJlbi5zbGljZSgpOyAvLyBjbG9uZSBhcnJheVxuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMgPSBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciBsYXN0RHJhd25JbmRleCA9IC0xO1xuXHRcdHZhciBpbmRleCwgY3VycmVudCwgcHJldmlvdXMsIGN1cnJlbnRWTTtcblxuXHRcdC8vIElmIHdlIGFyZSBsb29waW5nLCBhZGRpbmcgdGhlIGZpcnN0IHBvaW50IGFnYWluXG5cdFx0aWYgKG1lLl9sb29wICYmIHBvaW50cy5sZW5ndGgpIHtcblx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1swXSk7XG5cdFx0fVxuXG5cdFx0Y3R4LnNhdmUoKTtcblxuXHRcdC8vIFN0cm9rZSBMaW5lIE9wdGlvbnNcblx0XHRjdHgubGluZUNhcCA9IHZtLmJvcmRlckNhcFN0eWxlIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJDYXBTdHlsZTtcblxuXHRcdC8vIElFIDkgYW5kIDEwIGRvIG5vdCBzdXBwb3J0IGxpbmUgZGFzaFxuXHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaCh2bS5ib3JkZXJEYXNoIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJEYXNoKTtcblx0XHR9XG5cblx0XHRjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdCQxKHZtLmJvcmRlckRhc2hPZmZzZXQsIGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJEYXNoT2Zmc2V0KTtcblx0XHRjdHgubGluZUpvaW4gPSB2bS5ib3JkZXJKb2luU3R5bGUgfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckpvaW5TdHlsZTtcblx0XHRjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkMSh2bS5ib3JkZXJXaWR0aCwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlcldpZHRoKTtcblx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvciB8fCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Q29sb3I7XG5cblx0XHQvLyBTdHJva2UgTGluZVxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRsYXN0RHJhd25JbmRleCA9IC0xO1xuXG5cdFx0Zm9yIChpbmRleCA9IDA7IGluZGV4IDwgcG9pbnRzLmxlbmd0aDsgKytpbmRleCkge1xuXHRcdFx0Y3VycmVudCA9IHBvaW50c1tpbmRleF07XG5cdFx0XHRwcmV2aW91cyA9IGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpbmRleCk7XG5cdFx0XHRjdXJyZW50Vk0gPSBjdXJyZW50Ll92aWV3O1xuXG5cdFx0XHQvLyBGaXJzdCBwb2ludCBtb3ZlcyB0byBpdCdzIHN0YXJ0aW5nIHBvc2l0aW9uIG5vIG1hdHRlciB3aGF0XG5cdFx0XHRpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdFx0aWYgKCFjdXJyZW50Vk0uc2tpcCkge1xuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oY3VycmVudFZNLngsIGN1cnJlbnRWTS55KTtcblx0XHRcdFx0XHRsYXN0RHJhd25JbmRleCA9IGluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwcmV2aW91cyA9IGxhc3REcmF3bkluZGV4ID09PSAtMSA/IHByZXZpb3VzIDogcG9pbnRzW2xhc3REcmF3bkluZGV4XTtcblxuXHRcdFx0XHRpZiAoIWN1cnJlbnRWTS5za2lwKSB7XG5cdFx0XHRcdFx0aWYgKChsYXN0RHJhd25JbmRleCAhPT0gKGluZGV4IC0gMSkgJiYgIXNwYW5HYXBzKSB8fCBsYXN0RHJhd25JbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdC8vIFRoZXJlIHdhcyBhIGdhcCBhbmQgdGhpcyBpcyB0aGUgZmlyc3QgcG9pbnQgYWZ0ZXIgdGhlIGdhcFxuXHRcdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJyZW50Vk0ueCwgY3VycmVudFZNLnkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBMaW5lIHRvIG5leHQgcG9pbnRcblx0XHRcdFx0XHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgcHJldmlvdXMuX3ZpZXcsIGN1cnJlbnQuX3ZpZXcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsYXN0RHJhd25JbmRleCA9IGluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH1cbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkMiA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxudmFyIGRlZmF1bHRDb2xvciQxID0gY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHtcblx0XHRwb2ludDoge1xuXHRcdFx0cmFkaXVzOiAzLFxuXHRcdFx0cG9pbnRTdHlsZTogJ2NpcmNsZScsXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRDb2xvciQxLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvciQxLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdFx0XHQvLyBIb3ZlclxuXHRcdFx0aGl0UmFkaXVzOiAxLFxuXHRcdFx0aG92ZXJSYWRpdXM6IDQsXG5cdFx0XHRob3ZlckJvcmRlcldpZHRoOiAxXG5cdFx0fVxuXHR9XG59KTtcblxuZnVuY3Rpb24geFJhbmdlKG1vdXNlWCkge1xuXHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRyZXR1cm4gdm0gPyAoTWF0aC5hYnMobW91c2VYIC0gdm0ueCkgPCB2bS5yYWRpdXMgKyB2bS5oaXRSYWRpdXMpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHlSYW5nZShtb3VzZVkpIHtcblx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0cmV0dXJuIHZtID8gKE1hdGguYWJzKG1vdXNlWSAtIHZtLnkpIDwgdm0ucmFkaXVzICsgdm0uaGl0UmFkaXVzKSA6IGZhbHNlO1xufVxuXG52YXIgZWxlbWVudF9wb2ludCA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRpblJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIHZtID8gKChNYXRoLnBvdyhtb3VzZVggLSB2bS54LCAyKSArIE1hdGgucG93KG1vdXNlWSAtIHZtLnksIDIpKSA8IE1hdGgucG93KHZtLmhpdFJhZGl1cyArIHZtLnJhZGl1cywgMikpIDogZmFsc2U7XG5cdH0sXG5cblx0aW5MYWJlbFJhbmdlOiB4UmFuZ2UsXG5cdGluWFJhbmdlOiB4UmFuZ2UsXG5cdGluWVJhbmdlOiB5UmFuZ2UsXG5cblx0Z2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHZtLngsXG5cdFx0XHR5OiB2bS55XG5cdFx0fTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTWF0aC5QSSAqIE1hdGgucG93KHRoaXMuX3ZpZXcucmFkaXVzLCAyKTtcblx0fSxcblxuXHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHZtLngsXG5cdFx0XHR5OiB2bS55LFxuXHRcdFx0cGFkZGluZzogdm0ucmFkaXVzICsgdm0uYm9yZGVyV2lkdGhcblx0XHR9O1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGNoYXJ0QXJlYSkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgcG9pbnRTdHlsZSA9IHZtLnBvaW50U3R5bGU7XG5cdFx0dmFyIHJvdGF0aW9uID0gdm0ucm90YXRpb247XG5cdFx0dmFyIHJhZGl1cyA9IHZtLnJhZGl1cztcblx0XHR2YXIgeCA9IHZtLng7XG5cdFx0dmFyIHkgPSB2bS55O1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBkZWZhdWx0Q29sb3IgPSBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Q29sb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2hhZG93XG5cblx0XHRpZiAodm0uc2tpcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENsaXBwaW5nIGZvciBQb2ludHMuXG5cdFx0aWYgKGNoYXJ0QXJlYSA9PT0gdW5kZWZpbmVkIHx8IGhlbHBlcnMkMS5jYW52YXMuX2lzUG9pbnRJbkFyZWEodm0sIGNoYXJ0QXJlYSkpIHtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yIHx8IGRlZmF1bHRDb2xvcjtcblx0XHRcdGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQyKHZtLmJvcmRlcldpZHRoLCBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5wb2ludC5ib3JkZXJXaWR0aCk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yIHx8IGRlZmF1bHRDb2xvcjtcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMuZHJhd1BvaW50KGN0eCwgcG9pbnRTdHlsZSwgcmFkaXVzLCB4LCB5LCByb3RhdGlvbik7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGRlZmF1bHRDb2xvciQyID0gY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHtcblx0XHRyZWN0YW5nbGU6IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yJDIsXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yJDIsXG5cdFx0XHRib3JkZXJTa2lwcGVkOiAnYm90dG9tJyxcblx0XHRcdGJvcmRlcldpZHRoOiAwXG5cdFx0fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gaXNWZXJ0aWNhbCh2bSkge1xuXHRyZXR1cm4gdm0gJiYgdm0ud2lkdGggIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIGJhciByZWdhcmRsZXNzIG9mIHRoZSBvcmllbnRhdGlvblxuICogQHBhcmFtIGJhciB7Q2hhcnQuRWxlbWVudC5SZWN0YW5nbGV9IHRoZSBiYXJcbiAqIEByZXR1cm4ge0JvdW5kc30gYm91bmRzIG9mIHRoZSBiYXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEJhckJvdW5kcyh2bSkge1xuXHR2YXIgeDEsIHgyLCB5MSwgeTIsIGhhbGY7XG5cblx0aWYgKGlzVmVydGljYWwodm0pKSB7XG5cdFx0aGFsZiA9IHZtLndpZHRoIC8gMjtcblx0XHR4MSA9IHZtLnggLSBoYWxmO1xuXHRcdHgyID0gdm0ueCArIGhhbGY7XG5cdFx0eTEgPSBNYXRoLm1pbih2bS55LCB2bS5iYXNlKTtcblx0XHR5MiA9IE1hdGgubWF4KHZtLnksIHZtLmJhc2UpO1xuXHR9IGVsc2Uge1xuXHRcdGhhbGYgPSB2bS5oZWlnaHQgLyAyO1xuXHRcdHgxID0gTWF0aC5taW4odm0ueCwgdm0uYmFzZSk7XG5cdFx0eDIgPSBNYXRoLm1heCh2bS54LCB2bS5iYXNlKTtcblx0XHR5MSA9IHZtLnkgLSBoYWxmO1xuXHRcdHkyID0gdm0ueSArIGhhbGY7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGxlZnQ6IHgxLFxuXHRcdHRvcDogeTEsXG5cdFx0cmlnaHQ6IHgyLFxuXHRcdGJvdHRvbTogeTJcblx0fTtcbn1cblxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcblx0cmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcbn1cblxuZnVuY3Rpb24gcGFyc2VCb3JkZXJTa2lwcGVkKHZtKSB7XG5cdHZhciBlZGdlID0gdm0uYm9yZGVyU2tpcHBlZDtcblx0dmFyIHJlcyA9IHt9O1xuXG5cdGlmICghZWRnZSkge1xuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHRpZiAodm0uaG9yaXpvbnRhbCkge1xuXHRcdGlmICh2bS5iYXNlID4gdm0ueCkge1xuXHRcdFx0ZWRnZSA9IHN3YXAoZWRnZSwgJ2xlZnQnLCAncmlnaHQnKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodm0uYmFzZSA8IHZtLnkpIHtcblx0XHRlZGdlID0gc3dhcChlZGdlLCAnYm90dG9tJywgJ3RvcCcpO1xuXHR9XG5cblx0cmVzW2VkZ2VdID0gdHJ1ZTtcblx0cmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcGFyc2VCb3JkZXJXaWR0aCh2bSwgbWF4VywgbWF4SCkge1xuXHR2YXIgdmFsdWUgPSB2bS5ib3JkZXJXaWR0aDtcblx0dmFyIHNraXAgPSBwYXJzZUJvcmRlclNraXBwZWQodm0pO1xuXHR2YXIgdCwgciwgYiwgbDtcblxuXHRpZiAoaGVscGVycyQxLmlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdHQgPSArdmFsdWUudG9wIHx8IDA7XG5cdFx0ciA9ICt2YWx1ZS5yaWdodCB8fCAwO1xuXHRcdGIgPSArdmFsdWUuYm90dG9tIHx8IDA7XG5cdFx0bCA9ICt2YWx1ZS5sZWZ0IHx8IDA7XG5cdH0gZWxzZSB7XG5cdFx0dCA9IHIgPSBiID0gbCA9ICt2YWx1ZSB8fCAwO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR0OiBza2lwLnRvcCB8fCAodCA8IDApID8gMCA6IHQgPiBtYXhIID8gbWF4SCA6IHQsXG5cdFx0cjogc2tpcC5yaWdodCB8fCAociA8IDApID8gMCA6IHIgPiBtYXhXID8gbWF4VyA6IHIsXG5cdFx0Yjogc2tpcC5ib3R0b20gfHwgKGIgPCAwKSA/IDAgOiBiID4gbWF4SCA/IG1heEggOiBiLFxuXHRcdGw6IHNraXAubGVmdCB8fCAobCA8IDApID8gMCA6IGwgPiBtYXhXID8gbWF4VyA6IGxcblx0fTtcbn1cblxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyh2bSkge1xuXHR2YXIgYm91bmRzID0gZ2V0QmFyQm91bmRzKHZtKTtcblx0dmFyIHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XG5cdHZhciBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcblx0dmFyIGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgodm0sIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cblx0cmV0dXJuIHtcblx0XHRvdXRlcjoge1xuXHRcdFx0eDogYm91bmRzLmxlZnQsXG5cdFx0XHR5OiBib3VuZHMudG9wLFxuXHRcdFx0dzogd2lkdGgsXG5cdFx0XHRoOiBoZWlnaHRcblx0XHR9LFxuXHRcdGlubmVyOiB7XG5cdFx0XHR4OiBib3VuZHMubGVmdCArIGJvcmRlci5sLFxuXHRcdFx0eTogYm91bmRzLnRvcCArIGJvcmRlci50LFxuXHRcdFx0dzogd2lkdGggLSBib3JkZXIubCAtIGJvcmRlci5yLFxuXHRcdFx0aDogaGVpZ2h0IC0gYm9yZGVyLnQgLSBib3JkZXIuYlxuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gaW5SYW5nZSh2bSwgeCwgeSkge1xuXHR2YXIgc2tpcFggPSB4ID09PSBudWxsO1xuXHR2YXIgc2tpcFkgPSB5ID09PSBudWxsO1xuXHR2YXIgYm91bmRzID0gIXZtIHx8IChza2lwWCAmJiBza2lwWSkgPyBmYWxzZSA6IGdldEJhckJvdW5kcyh2bSk7XG5cblx0cmV0dXJuIGJvdW5kc1xuXHRcdCYmIChza2lwWCB8fCB4ID49IGJvdW5kcy5sZWZ0ICYmIHggPD0gYm91bmRzLnJpZ2h0KVxuXHRcdCYmIChza2lwWSB8fCB5ID49IGJvdW5kcy50b3AgJiYgeSA8PSBib3VuZHMuYm90dG9tKTtcbn1cblxudmFyIGVsZW1lbnRfcmVjdGFuZ2xlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgcmVjdHMgPSBib3VuZGluZ1JlY3RzKHZtKTtcblx0XHR2YXIgb3V0ZXIgPSByZWN0cy5vdXRlcjtcblx0XHR2YXIgaW5uZXIgPSByZWN0cy5pbm5lcjtcblxuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0Y3R4LmZpbGxSZWN0KG91dGVyLngsIG91dGVyLnksIG91dGVyLncsIG91dGVyLmgpO1xuXG5cdFx0aWYgKG91dGVyLncgPT09IGlubmVyLncgJiYgb3V0ZXIuaCA9PT0gaW5uZXIuaCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5yZWN0KG91dGVyLngsIG91dGVyLnksIG91dGVyLncsIG91dGVyLmgpO1xuXHRcdGN0eC5jbGlwKCk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJvcmRlckNvbG9yO1xuXHRcdGN0eC5yZWN0KGlubmVyLngsIGlubmVyLnksIGlubmVyLncsIGlubmVyLmgpO1xuXHRcdGN0eC5maWxsKCdldmVub2RkJyk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fSxcblxuXHRoZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIHZtLmJhc2UgLSB2bS55O1xuXHR9LFxuXG5cdGluUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XG5cdFx0cmV0dXJuIGluUmFuZ2UodGhpcy5fdmlldywgbW91c2VYLCBtb3VzZVkpO1xuXHR9LFxuXG5cdGluTGFiZWxSYW5nZTogZnVuY3Rpb24obW91c2VYLCBtb3VzZVkpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiBpc1ZlcnRpY2FsKHZtKVxuXHRcdFx0PyBpblJhbmdlKHZtLCBtb3VzZVgsIG51bGwpXG5cdFx0XHQ6IGluUmFuZ2Uodm0sIG51bGwsIG1vdXNlWSk7XG5cdH0sXG5cblx0aW5YUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCkge1xuXHRcdHJldHVybiBpblJhbmdlKHRoaXMuX3ZpZXcsIG1vdXNlWCwgbnVsbCk7XG5cdH0sXG5cblx0aW5ZUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWSkge1xuXHRcdHJldHVybiBpblJhbmdlKHRoaXMuX3ZpZXcsIG51bGwsIG1vdXNlWSk7XG5cdH0sXG5cblx0Z2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIHgsIHk7XG5cdFx0aWYgKGlzVmVydGljYWwodm0pKSB7XG5cdFx0XHR4ID0gdm0ueDtcblx0XHRcdHkgPSAodm0ueSArIHZtLmJhc2UpIC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9ICh2bS54ICsgdm0uYmFzZSkgLyAyO1xuXHRcdFx0eSA9IHZtLnk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHt4OiB4LCB5OiB5fTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0cmV0dXJuIGlzVmVydGljYWwodm0pXG5cdFx0XHQ/IHZtLndpZHRoICogTWF0aC5hYnModm0ueSAtIHZtLmJhc2UpXG5cdFx0XHQ6IHZtLmhlaWdodCAqIE1hdGguYWJzKHZtLnggLSB2bS5iYXNlKTtcblx0fSxcblxuXHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHZtLngsXG5cdFx0XHR5OiB2bS55XG5cdFx0fTtcblx0fVxufSk7XG5cbnZhciBlbGVtZW50cyA9IHt9O1xudmFyIEFyYyA9IGVsZW1lbnRfYXJjO1xudmFyIExpbmUgPSBlbGVtZW50X2xpbmU7XG52YXIgUG9pbnQgPSBlbGVtZW50X3BvaW50O1xudmFyIFJlY3RhbmdsZSA9IGVsZW1lbnRfcmVjdGFuZ2xlO1xuZWxlbWVudHMuQXJjID0gQXJjO1xuZWxlbWVudHMuTGluZSA9IExpbmU7XG5lbGVtZW50cy5Qb2ludCA9IFBvaW50O1xuZWxlbWVudHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xuXG52YXIgcmVzb2x2ZSQxID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdiYXInLCB7XG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ2xhYmVsJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2NhdGVnb3J5Jyxcblx0XHRcdGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuXHRcdFx0YmFyUGVyY2VudGFnZTogMC45LFxuXHRcdFx0b2Zmc2V0OiB0cnVlLFxuXHRcdFx0Z3JpZExpbmVzOiB7XG5cdFx0XHRcdG9mZnNldEdyaWRMaW5lczogdHJ1ZVxuXHRcdFx0fVxuXHRcdH1dLFxuXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnbGluZWFyJ1xuXHRcdH1dXG5cdH1cbn0pO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBcIm9wdGltYWxcIiBzYW1wbGUgc2l6ZSB0byBtYWludGFpbiBiYXJzIGVxdWFsbHkgc2l6ZWQgd2hpbGUgcHJldmVudGluZyBvdmVybGFwLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZU1pblNhbXBsZVNpemUoc2NhbGUsIHBpeGVscykge1xuXHR2YXIgbWluID0gc2NhbGUuaXNIb3Jpem9udGFsKCkgPyBzY2FsZS53aWR0aCA6IHNjYWxlLmhlaWdodDtcblx0dmFyIHRpY2tzID0gc2NhbGUuZ2V0VGlja3MoKTtcblx0dmFyIHByZXYsIGN1cnIsIGksIGlsZW47XG5cblx0Zm9yIChpID0gMSwgaWxlbiA9IHBpeGVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKHBpeGVsc1tpXSAtIHBpeGVsc1tpIC0gMV0pKTtcblx0fVxuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGkpO1xuXHRcdG1pbiA9IGkgPiAwID8gTWF0aC5taW4obWluLCBjdXJyIC0gcHJldikgOiBtaW47XG5cdFx0cHJldiA9IGN1cnI7XG5cdH1cblxuXHRyZXR1cm4gbWluO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwiaWRlYWxcIiBjYXRlZ29yeSBiYXNlZCBvbiB0aGUgYWJzb2x1dGUgYmFyIHRoaWNrbmVzcyBvciwgaWYgdW5kZWZpbmVkIG9yIG51bGwsXG4gKiB1c2VzIHRoZSBzbWFsbGVzdCBpbnRlcnZhbCAoc2VlIGNvbXB1dGVNaW5TYW1wbGVTaXplKSB0aGF0IHByZXZlbnRzIGJhciBvdmVybGFwcGluZy4gVGhpc1xuICogbW9kZSBjdXJyZW50bHkgYWx3YXlzIGdlbmVyYXRlcyBiYXJzIGVxdWFsbHkgc2l6ZWQgKHVudGlsIHdlIGludHJvZHVjZSBzY3JpcHRhYmxlIG9wdGlvbnM/KS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMpIHtcblx0dmFyIHRoaWNrbmVzcyA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xuXHR2YXIgY291bnQgPSBydWxlci5zdGFja0NvdW50O1xuXHR2YXIgY3VyciA9IHJ1bGVyLnBpeGVsc1tpbmRleF07XG5cdHZhciBzaXplLCByYXRpbztcblxuXHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodGhpY2tuZXNzKSkge1xuXHRcdHNpemUgPSBydWxlci5taW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcblx0XHRyYXRpbyA9IG9wdGlvbnMuYmFyUGVyY2VudGFnZTtcblx0fSBlbHNlIHtcblx0XHQvLyBXaGVuIGJhciB0aGlja25lc3MgaXMgZW5mb3JjZWQsIGNhdGVnb3J5IGFuZCBiYXIgcGVyY2VudGFnZXMgYXJlIGlnbm9yZWQuXG5cdFx0Ly8gTm90ZShTQik6IHdlIGNvdWxkIGFkZCBzdXBwb3J0IGZvciByZWxhdGl2ZSBiYXIgdGhpY2tuZXNzIChlLmcuIGJhclRoaWNrbmVzczogJzUwJScpXG5cdFx0Ly8gYW5kIGRlcHJlY2F0ZSBiYXJQZXJjZW50YWdlIHNpbmNlIHRoaXMgdmFsdWUgaXMgaWdub3JlZCB3aGVuIHRoaWNrbmVzcyBpcyBhYnNvbHV0ZS5cblx0XHRzaXplID0gdGhpY2tuZXNzICogY291bnQ7XG5cdFx0cmF0aW8gPSAxO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRjaHVuazogc2l6ZSAvIGNvdW50LFxuXHRcdHJhdGlvOiByYXRpbyxcblx0XHRzdGFydDogY3VyciAtIChzaXplIC8gMilcblx0fTtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbiBcIm9wdGltYWxcIiBjYXRlZ29yeSB0aGF0IGdsb2JhbGx5IGFycmFuZ2VzIGJhcnMgc2lkZSBieSBzaWRlIChubyBnYXAgd2hlblxuICogcGVyY2VudGFnZSBvcHRpb25zIGFyZSAxKSwgYmFzZWQgb24gdGhlIHByZXZpb3VzIGFuZCBmb2xsb3dpbmcgY2F0ZWdvcmllcy4gVGhpcyBtb2RlXG4gKiBnZW5lcmF0ZXMgYmFycyB3aXRoIGRpZmZlcmVudCB3aWR0aHMgd2hlbiBkYXRhIGFyZSBub3QgZXZlbmx5IHNwYWNlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKSB7XG5cdHZhciBwaXhlbHMgPSBydWxlci5waXhlbHM7XG5cdHZhciBjdXJyID0gcGl4ZWxzW2luZGV4XTtcblx0dmFyIHByZXYgPSBpbmRleCA+IDAgPyBwaXhlbHNbaW5kZXggLSAxXSA6IG51bGw7XG5cdHZhciBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcblx0dmFyIHBlcmNlbnQgPSBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcblx0dmFyIHN0YXJ0LCBzaXplO1xuXG5cdGlmIChwcmV2ID09PSBudWxsKSB7XG5cdFx0Ly8gZmlyc3QgZGF0YTogaXRzIHNpemUgaXMgZG91YmxlIGJhc2VkIG9uIHRoZSBuZXh0IHBvaW50IG9yLFxuXHRcdC8vIGlmIGl0J3MgYWxzbyB0aGUgbGFzdCBkYXRhLCB3ZSB1c2UgdGhlIHNjYWxlIHNpemUuXG5cdFx0cHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuXHR9XG5cblx0aWYgKG5leHQgPT09IG51bGwpIHtcblx0XHQvLyBsYXN0IGRhdGE6IGl0cyBzaXplIGlzIGFsc28gZG91YmxlIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBwb2ludC5cblx0XHRuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xuXHR9XG5cblx0c3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcblx0c2l6ZSA9IE1hdGguYWJzKG5leHQgLSBwcmV2KSAvIDIgKiBwZXJjZW50O1xuXG5cdHJldHVybiB7XG5cdFx0Y2h1bms6IHNpemUgLyBydWxlci5zdGFja0NvdW50LFxuXHRcdHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG5cdFx0c3RhcnQ6IHN0YXJ0XG5cdH07XG59XG5cbnZhciBjb250cm9sbGVyX2JhciA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlJlY3RhbmdsZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhO1xuXG5cdFx0Y29yZV9kYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblxuXHRcdG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0bWV0YS5zdGFjayA9IG1lLmdldERhdGFzZXQoKS5zdGFjaztcblx0XHRtZXRhLmJhciA9IHRydWU7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHJlY3RzID0gbWUuZ2V0TWV0YSgpLmRhdGE7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRtZS5fcnVsZXIgPSBtZS5nZXRSdWxlcigpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHJlY3RzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChyZWN0c1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHJlY3RhbmdsZSwgaW5kZXgpO1xuXG5cdFx0cmVjdGFuZ2xlLl94U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XG5cdFx0cmVjdGFuZ2xlLl95U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0cmVjdGFuZ2xlLl9kYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHRyZWN0YW5nbGUuX2luZGV4ID0gaW5kZXg7XG5cdFx0cmVjdGFuZ2xlLl9tb2RlbCA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlclNraXBwZWQ6IG9wdGlvbnMuYm9yZGVyU2tpcHBlZCxcblx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0ZGF0YXNldExhYmVsOiBkYXRhc2V0LmxhYmVsLFxuXHRcdFx0bGFiZWw6IG1lLmNoYXJ0LmRhdGEubGFiZWxzW2luZGV4XVxuXHRcdH07XG5cblx0XHRtZS5fdXBkYXRlRWxlbWVudEdlb21ldHJ5KHJlY3RhbmdsZSwgaW5kZXgsIHJlc2V0KTtcblxuXHRcdHJlY3RhbmdsZS5waXZvdCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3VwZGF0ZUVsZW1lbnRHZW9tZXRyeTogZnVuY3Rpb24ocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtb2RlbCA9IHJlY3RhbmdsZS5fbW9kZWw7XG5cdFx0dmFyIHZzY2FsZSA9IG1lLl9nZXRWYWx1ZVNjYWxlKCk7XG5cdFx0dmFyIGJhc2UgPSB2c2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG5cdFx0dmFyIGhvcml6b250YWwgPSB2c2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIHJ1bGVyID0gbWUuX3J1bGVyIHx8IG1lLmdldFJ1bGVyKCk7XG5cdFx0dmFyIHZwaXhlbHMgPSBtZS5jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhtZS5pbmRleCwgaW5kZXgpO1xuXHRcdHZhciBpcGl4ZWxzID0gbWUuY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMobWUuaW5kZXgsIGluZGV4LCBydWxlcik7XG5cblx0XHRtb2RlbC5ob3Jpem9udGFsID0gaG9yaXpvbnRhbDtcblx0XHRtb2RlbC5iYXNlID0gcmVzZXQgPyBiYXNlIDogdnBpeGVscy5iYXNlO1xuXHRcdG1vZGVsLnggPSBob3Jpem9udGFsID8gcmVzZXQgPyBiYXNlIDogdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXI7XG5cdFx0bW9kZWwueSA9IGhvcml6b250YWwgPyBpcGl4ZWxzLmNlbnRlciA6IHJlc2V0ID8gYmFzZSA6IHZwaXhlbHMuaGVhZDtcblx0XHRtb2RlbC5oZWlnaHQgPSBob3Jpem9udGFsID8gaXBpeGVscy5zaXplIDogdW5kZWZpbmVkO1xuXHRcdG1vZGVsLndpZHRoID0gaG9yaXpvbnRhbCA/IHVuZGVmaW5lZCA6IGlwaXhlbHMuc2l6ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbGFzdF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBsaXN0IG9mIHN0YWNrIElEc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFN0YWNrczogZnVuY3Rpb24obGFzdCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldEluZGV4U2NhbGUoKTtcblx0XHR2YXIgc3RhY2tlZCA9IHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcblx0XHR2YXIgaWxlbiA9IGxhc3QgPT09IHVuZGVmaW5lZCA/IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoIDogbGFzdCArIDE7XG5cdFx0dmFyIHN0YWNrcyA9IFtdO1xuXHRcdHZhciBpLCBtZXRhO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0aWYgKG1ldGEuYmFyICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkgJiZcblx0XHRcdFx0KHN0YWNrZWQgPT09IGZhbHNlIHx8XG5cdFx0XHRcdChzdGFja2VkID09PSB0cnVlICYmIHN0YWNrcy5pbmRleE9mKG1ldGEuc3RhY2spID09PSAtMSkgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiAobWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkIHx8IHN0YWNrcy5pbmRleE9mKG1ldGEuc3RhY2spID09PSAtMSkpKSkge1xuXHRcdFx0XHRzdGFja3MucHVzaChtZXRhLnN0YWNrKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc3RhY2tzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBlZmZlY3RpdmUgbnVtYmVyIG9mIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0U3RhY2tDb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldFN0YWNrcygpLmxlbmd0aDtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc3RhY2sgaW5kZXggZm9yIHRoZSBnaXZlbiBkYXRhc2V0IGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YXNldEluZGV4XSAtIFRoZSBkYXRhc2V0IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUgc3RhY2sgbmFtZSB0byBmaW5kXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzdGFjayBpbmRleFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0U3RhY2tJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4LCBuYW1lKSB7XG5cdFx0dmFyIHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgpO1xuXHRcdHZhciBpbmRleCA9IChuYW1lICE9PSB1bmRlZmluZWQpXG5cdFx0XHQ/IHN0YWNrcy5pbmRleE9mKG5hbWUpXG5cdFx0XHQ6IC0xOyAvLyBpbmRleE9mIHJldHVybnMgLTEgaWYgZWxlbWVudCBpcyBub3QgcHJlc2VudFxuXG5cdFx0cmV0dXJuIChpbmRleCA9PT0gLTEpXG5cdFx0XHQ/IHN0YWNrcy5sZW5ndGggLSAxXG5cdFx0XHQ6IGluZGV4O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0UnVsZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldEluZGV4U2NhbGUoKTtcblx0XHR2YXIgc3RhY2tDb3VudCA9IG1lLmdldFN0YWNrQ291bnQoKTtcblx0XHR2YXIgZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBzdGFydCA9IGlzSG9yaXpvbnRhbCA/IHNjYWxlLmxlZnQgOiBzY2FsZS50b3A7XG5cdFx0dmFyIGVuZCA9IHN0YXJ0ICsgKGlzSG9yaXpvbnRhbCA/IHNjYWxlLndpZHRoIDogc2NhbGUuaGVpZ2h0KTtcblx0XHR2YXIgcGl4ZWxzID0gW107XG5cdFx0dmFyIGksIGlsZW4sIG1pbjtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBtZS5nZXRNZXRhKCkuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHBpeGVscy5wdXNoKHNjYWxlLmdldFBpeGVsRm9yVmFsdWUobnVsbCwgaSwgZGF0YXNldEluZGV4KSk7XG5cdFx0fVxuXG5cdFx0bWluID0gaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoc2NhbGUub3B0aW9ucy5iYXJUaGlja25lc3MpXG5cdFx0XHQ/IGNvbXB1dGVNaW5TYW1wbGVTaXplKHNjYWxlLCBwaXhlbHMpXG5cdFx0XHQ6IC0xO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG1pbjogbWluLFxuXHRcdFx0cGl4ZWxzOiBwaXhlbHMsXG5cdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRlbmQ6IGVuZCxcblx0XHRcdHN0YWNrQ291bnQ6IHN0YWNrQ291bnQsXG5cdFx0XHRzY2FsZTogc2NhbGVcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y2FsY3VsYXRlQmFyVmFsdWVQaXhlbHM6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRWYWx1ZVNjYWxlKCk7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIHZhbHVlID0gK3NjYWxlLmdldFJpZ2h0VmFsdWUoZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdFx0dmFyIG1pbkJhckxlbmd0aCA9IHNjYWxlLm9wdGlvbnMubWluQmFyTGVuZ3RoO1xuXHRcdHZhciBzdGFja2VkID0gc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuXHRcdHZhciBzdGFjayA9IG1ldGEuc3RhY2s7XG5cdFx0dmFyIHN0YXJ0ID0gMDtcblx0XHR2YXIgaSwgaW1ldGEsIGl2YWx1ZSwgYmFzZSwgaGVhZCwgc2l6ZTtcblxuXHRcdGlmIChzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgc3RhY2sgIT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7ICsraSkge1xuXHRcdFx0XHRpbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXG5cdFx0XHRcdGlmIChpbWV0YS5iYXIgJiZcblx0XHRcdFx0XHRpbWV0YS5zdGFjayA9PT0gc3RhY2sgJiZcblx0XHRcdFx0XHRpbWV0YS5jb250cm9sbGVyLl9nZXRWYWx1ZVNjYWxlSWQoKSA9PT0gc2NhbGUuaWQgJiZcblx0XHRcdFx0XHRjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cblx0XHRcdFx0XHRpdmFsdWUgPSArc2NhbGUuZ2V0UmlnaHRWYWx1ZShkYXRhc2V0c1tpXS5kYXRhW2luZGV4XSk7XG5cdFx0XHRcdFx0aWYgKCh2YWx1ZSA8IDAgJiYgaXZhbHVlIDwgMCkgfHwgKHZhbHVlID49IDAgJiYgaXZhbHVlID4gMCkpIHtcblx0XHRcdFx0XHRcdHN0YXJ0ICs9IGl2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRiYXNlID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCk7XG5cdFx0aGVhZCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnQgKyB2YWx1ZSk7XG5cdFx0c2l6ZSA9IGhlYWQgLSBiYXNlO1xuXG5cdFx0aWYgKG1pbkJhckxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG5cdFx0XHRzaXplID0gbWluQmFyTGVuZ3RoO1xuXHRcdFx0aWYgKHZhbHVlID49IDAgJiYgIWlzSG9yaXpvbnRhbCB8fCB2YWx1ZSA8IDAgJiYgaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdGhlYWQgPSBiYXNlIC0gbWluQmFyTGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVhZCA9IGJhc2UgKyBtaW5CYXJMZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRiYXNlOiBiYXNlLFxuXHRcdFx0aGVhZDogaGVhZCxcblx0XHRcdGNlbnRlcjogaGVhZCArIHNpemUgLyAyXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgsIGluZGV4LCBydWxlcikge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBydWxlci5zY2FsZS5vcHRpb25zO1xuXHRcdHZhciByYW5nZSA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzID09PSAnZmxleCdcblx0XHRcdD8gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMpXG5cdFx0XHQ6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMpO1xuXG5cdFx0dmFyIHN0YWNrSW5kZXggPSBtZS5nZXRTdGFja0luZGV4KGRhdGFzZXRJbmRleCwgbWUuZ2V0TWV0YSgpLnN0YWNrKTtcblx0XHR2YXIgY2VudGVyID0gcmFuZ2Uuc3RhcnQgKyAocmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4KSArIChyYW5nZS5jaHVuayAvIDIpO1xuXHRcdHZhciBzaXplID0gTWF0aC5taW4oXG5cdFx0XHRoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KSxcblx0XHRcdHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGJhc2U6IGNlbnRlciAtIHNpemUgLyAyLFxuXHRcdFx0aGVhZDogY2VudGVyICsgc2l6ZSAvIDIsXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcblx0XHRcdHNpemU6IHNpemVcblx0XHR9O1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcblx0XHR2YXIgcmVjdHMgPSBtZS5nZXRNZXRhKCkuZGF0YTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgaWxlbiA9IHJlY3RzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGNoYXJ0LmN0eCwgY2hhcnQuY2hhcnRBcmVhKTtcblxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAoIWlzTmFOKHNjYWxlLmdldFJpZ2h0VmFsdWUoZGF0YXNldC5kYXRhW2ldKSkpIHtcblx0XHRcdFx0cmVjdHNbaV0uZHJhdygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhlbHBlcnMkMS5jYW52YXMudW5jbGlwQXJlYShjaGFydC5jdHgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVFbGVtZW50T3B0aW9uczogZnVuY3Rpb24ocmVjdGFuZ2xlLCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgZGF0YXNldCA9IGRhdGFzZXRzW21lLmluZGV4XTtcblx0XHR2YXIgY3VzdG9tID0gcmVjdGFuZ2xlLmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucmVjdGFuZ2xlO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHQnYm9yZGVyU2tpcHBlZCcsXG5cdFx0XHQnYm9yZGVyV2lkdGgnXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQxKFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQzID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHJlc29sdmUkMiA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnYnViYmxlJywge1xuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdzaW5nbGUnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnbGluZWFyJywgLy8gYnViYmxlIHNob3VsZCBwcm9iYWJseSB1c2UgYSBsaW5lYXIgc2NhbGUgYnkgZGVmYXVsdFxuXHRcdFx0cG9zaXRpb246ICdib3R0b20nLFxuXHRcdFx0aWQ6ICd4LWF4aXMtMCcgLy8gbmVlZCBhbiBJRCBzbyBkYXRhc2V0cyBjYW4gcmVmZXJlbmNlIHRoZSBzY2FsZVxuXHRcdH1dLFxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRwb3NpdGlvbjogJ2xlZnQnLFxuXHRcdFx0aWQ6ICd5LWF4aXMtMCdcblx0XHR9XVxuXHR9LFxuXG5cdHRvb2x0aXBzOiB7XG5cdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFRpdGxlIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3Igc2NhdHRlciBzaW5jZSB3ZSBmb3JtYXQgdGhlIGRhdGEgYXMgYSBwb2ludFxuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKGl0ZW0sIGRhdGEpIHtcblx0XHRcdFx0dmFyIGRhdGFzZXRMYWJlbCA9IGRhdGEuZGF0YXNldHNbaXRlbS5kYXRhc2V0SW5kZXhdLmxhYmVsIHx8ICcnO1xuXHRcdFx0XHR2YXIgZGF0YVBvaW50ID0gZGF0YS5kYXRhc2V0c1tpdGVtLmRhdGFzZXRJbmRleF0uZGF0YVtpdGVtLmluZGV4XTtcblx0XHRcdFx0cmV0dXJuIGRhdGFzZXRMYWJlbCArICc6ICgnICsgaXRlbS54TGFiZWwgKyAnLCAnICsgaXRlbS55TGFiZWwgKyAnLCAnICsgZGF0YVBvaW50LnIgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGNvbnRyb2xsZXJfYnViYmxlID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YTtcblxuXHRcdC8vIFVwZGF0ZSBQb2ludHNcblx0XHRoZWxwZXJzJDEuZWFjaChwb2ludHMsIGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChwb2ludCwgaW5kZXgsIHJlc2V0KTtcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocG9pbnQsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgeFNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnhBeGlzSUQpO1xuXHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHBvaW50LCBpbmRleCk7XG5cdFx0dmFyIGRhdGEgPSBtZS5nZXREYXRhc2V0KCkuZGF0YVtpbmRleF07XG5cdFx0dmFyIGRzSW5kZXggPSBtZS5pbmRleDtcblxuXHRcdHZhciB4ID0gcmVzZXQgPyB4U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiB4U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhIDogTmFOLCBpbmRleCwgZHNJbmRleCk7XG5cdFx0dmFyIHkgPSByZXNldCA/IHlTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGRhdGEsIGluZGV4LCBkc0luZGV4KTtcblxuXHRcdHBvaW50Ll94U2NhbGUgPSB4U2NhbGU7XG5cdFx0cG9pbnQuX3lTY2FsZSA9IHlTY2FsZTtcblx0XHRwb2ludC5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0cG9pbnQuX2RhdGFzZXRJbmRleCA9IGRzSW5kZXg7XG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XG5cdFx0cG9pbnQuX21vZGVsID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRoaXRSYWRpdXM6IG9wdGlvbnMuaGl0UmFkaXVzLFxuXHRcdFx0cG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuXHRcdFx0cm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXG5cdFx0XHRyYWRpdXM6IHJlc2V0ID8gMCA6IG9wdGlvbnMucmFkaXVzLFxuXHRcdFx0c2tpcDogY3VzdG9tLnNraXAgfHwgaXNOYU4oeCkgfHwgaXNOYU4oeSksXG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeSxcblx0XHR9O1xuXG5cdFx0cG9pbnQucGl2b3QoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0cG9pbnQuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHRcdHJhZGl1czogbW9kZWwucmFkaXVzXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDMob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkMyhvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkMyhvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHRcdG1vZGVsLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5ob3ZlclJhZGl1cztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlRWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgZGF0YXNldCA9IGRhdGFzZXRzW21lLmluZGV4XTtcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHR2YXIgZGF0YSA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJXaWR0aCcsXG5cdFx0XHQnaG92ZXJCYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2hvdmVyQm9yZGVyQ29sb3InLFxuXHRcdFx0J2hvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdFx0J2hvdmVyUmFkaXVzJyxcblx0XHRcdCdoaXRSYWRpdXMnLFxuXHRcdFx0J3BvaW50U3R5bGUnLFxuXHRcdFx0J3JvdGF0aW9uJ1xuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkMihbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdC8vIEN1c3RvbSByYWRpdXMgcmVzb2x1dGlvblxuXHRcdHZhbHVlcy5yYWRpdXMgPSByZXNvbHZlJDIoW1xuXHRcdFx0Y3VzdG9tLnJhZGl1cyxcblx0XHRcdGRhdGEgPyBkYXRhLnIgOiB1bmRlZmluZWQsXG5cdFx0XHRkYXRhc2V0LnJhZGl1cyxcblx0XHRcdG9wdGlvbnMucmFkaXVzXG5cdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fVxufSk7XG5cbnZhciByZXNvbHZlJDMgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xudmFyIHZhbHVlT3JEZWZhdWx0JDQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZG91Z2hudXQnLCB7XG5cdGFuaW1hdGlvbjoge1xuXHRcdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHdlIGFuaW1hdGUgdGhlIHJvdGF0aW9uIG9mIHRoZSBEb3VnaG51dFxuXHRcdGFuaW1hdGVSb3RhdGU6IHRydWUsXG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSBzY2FsaW5nIHRoZSBEb3VnaG51dCBmcm9tIHRoZSBjZW50cmVcblx0XHRhbmltYXRlU2NhbGU6IGZhbHNlXG5cdH0sXG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ3NpbmdsZSdcblx0fSxcblx0bGVnZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIHRleHQgPSBbXTtcblx0XHR0ZXh0LnB1c2goJzx1bCBjbGFzcz1cIicgKyBjaGFydC5pZCArICctbGVnZW5kXCI+Jyk7XG5cblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XG5cblx0XHRpZiAoZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRzWzBdLmRhdGEubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dGV4dC5wdXNoKCc8bGk+PHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBkYXRhc2V0c1swXS5iYWNrZ3JvdW5kQ29sb3JbaV0gKyAnXCI+PC9zcGFuPicpO1xuXHRcdFx0XHRpZiAobGFiZWxzW2ldKSB7XG5cdFx0XHRcdFx0dGV4dC5wdXNoKGxhYmVsc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGV4dC5wdXNoKCc8L2xpPicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRleHQucHVzaCgnPC91bD4nKTtcblx0XHRyZXR1cm4gdGV4dC5qb2luKCcnKTtcblx0fSxcblx0bGVnZW5kOiB7XG5cdFx0bGFiZWxzOiB7XG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzLm1hcChmdW5jdGlvbihsYWJlbCwgaSkge1xuXHRcdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcblx0XHRcdFx0XHRcdHZhciBkcyA9IGRhdGEuZGF0YXNldHNbMF07XG5cdFx0XHRcdFx0XHR2YXIgYXJjID0gbWV0YS5kYXRhW2ldO1xuXHRcdFx0XHRcdFx0dmFyIGN1c3RvbSA9IGFyYyAmJiBhcmMuY3VzdG9tIHx8IHt9O1xuXHRcdFx0XHRcdFx0dmFyIGFyY09wdHMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYztcblx0XHRcdFx0XHRcdHZhciBmaWxsID0gcmVzb2x2ZSQzKFtjdXN0b20uYmFja2dyb3VuZENvbG9yLCBkcy5iYWNrZ3JvdW5kQ29sb3IsIGFyY09wdHMuYmFja2dyb3VuZENvbG9yXSwgdW5kZWZpbmVkLCBpKTtcblx0XHRcdFx0XHRcdHZhciBzdHJva2UgPSByZXNvbHZlJDMoW2N1c3RvbS5ib3JkZXJDb2xvciwgZHMuYm9yZGVyQ29sb3IsIGFyY09wdHMuYm9yZGVyQ29sb3JdLCB1bmRlZmluZWQsIGkpO1xuXHRcdFx0XHRcdFx0dmFyIGJ3ID0gcmVzb2x2ZSQzKFtjdXN0b20uYm9yZGVyV2lkdGgsIGRzLmJvcmRlcldpZHRoLCBhcmNPcHRzLmJvcmRlcldpZHRoXSwgdW5kZWZpbmVkLCBpKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dGV4dDogbGFiZWwsXG5cdFx0XHRcdFx0XHRcdGZpbGxTdHlsZTogZmlsbCxcblx0XHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IHN0cm9rZSxcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiBidyxcblx0XHRcdFx0XHRcdFx0aGlkZGVuOiBpc05hTihkcy5kYXRhW2ldKSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuLFxuXG5cdFx0XHRcdFx0XHRcdC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuXHRcdFx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUsIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdHZhciBpbmRleCA9IGxlZ2VuZEl0ZW0uaW5kZXg7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0dmFyIGksIGlsZW4sIG1ldGE7XG5cblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0Ly8gdG9nZ2xlIHZpc2liaWxpdHkgb2YgaW5kZXggaWYgZXhpc3RzXG5cdFx0XHRcdGlmIChtZXRhLmRhdGFbaW5kZXhdKSB7XG5cdFx0XHRcdFx0bWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gPSAhbWV0YS5kYXRhW2luZGV4XS5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y2hhcnQudXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFydCB0aGF0IHdlIGN1dCBvdXQgb2YgdGhlIG1pZGRsZS5cblx0Y3V0b3V0UGVyY2VudGFnZTogNTAsXG5cblx0Ly8gVGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydCwgd2hlcmUgdGhlIGZpcnN0IGRhdGEgYXJjIGJlZ2lucy5cblx0cm90YXRpb246IE1hdGguUEkgKiAtMC41LFxuXG5cdC8vIFRoZSB0b3RhbCBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjaGFydC5cblx0Y2lyY3VtZmVyZW5jZTogTWF0aC5QSSAqIDIuMCxcblxuXHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgZGF0YUxhYmVsID0gZGF0YS5sYWJlbHNbdG9vbHRpcEl0ZW0uaW5kZXhdO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSAnOiAnICsgZGF0YS5kYXRhc2V0c1t0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXhdLmRhdGFbdG9vbHRpcEl0ZW0uaW5kZXhdO1xuXG5cdFx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShkYXRhTGFiZWwpKSB7XG5cdFx0XHRcdFx0Ly8gc2hvdyB2YWx1ZSBvbiBmaXJzdCBsaW5lIG9mIG11bHRpbGluZSBsYWJlbFxuXHRcdFx0XHRcdC8vIG5lZWQgdG8gY2xvbmUgYmVjYXVzZSB3ZSBhcmUgY2hhbmdpbmcgdGhlIHZhbHVlXG5cdFx0XHRcdFx0ZGF0YUxhYmVsID0gZGF0YUxhYmVsLnNsaWNlKCk7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsWzBdICs9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFMYWJlbCArPSB2YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBkYXRhTGFiZWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGNvbnRyb2xsZXJfZG91Z2hudXQgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5BcmMsXG5cblx0bGlua1NjYWxlczogaGVscGVycyQxLm5vb3AsXG5cblx0Ly8gR2V0IGluZGV4IG9mIHRoZSBkYXRhc2V0IGluIHJlbGF0aW9uIHRvIHRoZSB2aXNpYmxlIGRhdGFzZXRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0Z2V0UmluZ0luZGV4OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgcmluZ0luZGV4ID0gMDtcblxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGF0YXNldEluZGV4OyArK2opIHtcblx0XHRcdGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaikpIHtcblx0XHRcdFx0KytyaW5nSW5kZXg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJpbmdJbmRleDtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgYXZhaWxhYmxlV2lkdGggPSBjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdDtcblx0XHR2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3A7XG5cdFx0dmFyIG1pblNpemUgPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCwgYXZhaWxhYmxlSGVpZ2h0KTtcblx0XHR2YXIgb2Zmc2V0ID0ge3g6IDAsIHk6IDB9O1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBhcmNzID0gbWV0YS5kYXRhO1xuXHRcdHZhciBjdXRvdXRQZXJjZW50YWdlID0gb3B0cy5jdXRvdXRQZXJjZW50YWdlO1xuXHRcdHZhciBjaXJjdW1mZXJlbmNlID0gb3B0cy5jaXJjdW1mZXJlbmNlO1xuXHRcdHZhciBjaGFydFdlaWdodCA9IG1lLl9nZXRSaW5nV2VpZ2h0KG1lLmluZGV4KTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdC8vIElmIHRoZSBjaGFydCdzIGNpcmN1bWZlcmVuY2UgaXNuJ3QgYSBmdWxsIGNpcmNsZSwgY2FsY3VsYXRlIG1pblNpemUgYXMgYSByYXRpbyBvZiB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBhcmNcblx0XHRpZiAoY2lyY3VtZmVyZW5jZSA8IE1hdGguUEkgKiAyLjApIHtcblx0XHRcdHZhciBzdGFydEFuZ2xlID0gb3B0cy5yb3RhdGlvbiAlIChNYXRoLlBJICogMi4wKTtcblx0XHRcdHN0YXJ0QW5nbGUgKz0gTWF0aC5QSSAqIDIuMCAqIChzdGFydEFuZ2xlID49IE1hdGguUEkgPyAtMSA6IHN0YXJ0QW5nbGUgPCAtTWF0aC5QSSA/IDEgOiAwKTtcblx0XHRcdHZhciBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlO1xuXHRcdFx0dmFyIHN0YXJ0ID0ge3g6IE1hdGguY29zKHN0YXJ0QW5nbGUpLCB5OiBNYXRoLnNpbihzdGFydEFuZ2xlKX07XG5cdFx0XHR2YXIgZW5kID0ge3g6IE1hdGguY29zKGVuZEFuZ2xlKSwgeTogTWF0aC5zaW4oZW5kQW5nbGUpfTtcblx0XHRcdHZhciBjb250YWluczAgPSAoc3RhcnRBbmdsZSA8PSAwICYmIGVuZEFuZ2xlID49IDApIHx8IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgKiAyLjAgJiYgTWF0aC5QSSAqIDIuMCA8PSBlbmRBbmdsZSk7XG5cdFx0XHR2YXIgY29udGFpbnM5MCA9IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgKiAwLjUgJiYgTWF0aC5QSSAqIDAuNSA8PSBlbmRBbmdsZSkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDIuNSAmJiBNYXRoLlBJICogMi41IDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciBjb250YWluczE4MCA9IChzdGFydEFuZ2xlIDw9IC1NYXRoLlBJICYmIC1NYXRoLlBJIDw9IGVuZEFuZ2xlKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICYmIE1hdGguUEkgPD0gZW5kQW5nbGUpO1xuXHRcdFx0dmFyIGNvbnRhaW5zMjcwID0gKHN0YXJ0QW5nbGUgPD0gLU1hdGguUEkgKiAwLjUgJiYgLU1hdGguUEkgKiAwLjUgPD0gZW5kQW5nbGUpIHx8IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgKiAxLjUgJiYgTWF0aC5QSSAqIDEuNSA8PSBlbmRBbmdsZSk7XG5cdFx0XHR2YXIgY3V0b3V0ID0gY3V0b3V0UGVyY2VudGFnZSAvIDEwMC4wO1xuXHRcdFx0dmFyIG1pbiA9IHt4OiBjb250YWluczE4MCA/IC0xIDogTWF0aC5taW4oc3RhcnQueCAqIChzdGFydC54IDwgMCA/IDEgOiBjdXRvdXQpLCBlbmQueCAqIChlbmQueCA8IDAgPyAxIDogY3V0b3V0KSksIHk6IGNvbnRhaW5zMjcwID8gLTEgOiBNYXRoLm1pbihzdGFydC55ICogKHN0YXJ0LnkgPCAwID8gMSA6IGN1dG91dCksIGVuZC55ICogKGVuZC55IDwgMCA/IDEgOiBjdXRvdXQpKX07XG5cdFx0XHR2YXIgbWF4ID0ge3g6IGNvbnRhaW5zMCA/IDEgOiBNYXRoLm1heChzdGFydC54ICogKHN0YXJ0LnggPiAwID8gMSA6IGN1dG91dCksIGVuZC54ICogKGVuZC54ID4gMCA/IDEgOiBjdXRvdXQpKSwgeTogY29udGFpbnM5MCA/IDEgOiBNYXRoLm1heChzdGFydC55ICogKHN0YXJ0LnkgPiAwID8gMSA6IGN1dG91dCksIGVuZC55ICogKGVuZC55ID4gMCA/IDEgOiBjdXRvdXQpKX07XG5cdFx0XHR2YXIgc2l6ZSA9IHt3aWR0aDogKG1heC54IC0gbWluLngpICogMC41LCBoZWlnaHQ6IChtYXgueSAtIG1pbi55KSAqIDAuNX07XG5cdFx0XHRtaW5TaXplID0gTWF0aC5taW4oYXZhaWxhYmxlV2lkdGggLyBzaXplLndpZHRoLCBhdmFpbGFibGVIZWlnaHQgLyBzaXplLmhlaWdodCk7XG5cdFx0XHRvZmZzZXQgPSB7eDogKG1heC54ICsgbWluLngpICogLTAuNSwgeTogKG1heC55ICsgbWluLnkpICogLTAuNX07XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRhcmNzW2ldLl9vcHRpb25zID0gbWUuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhhcmNzW2ldLCBpKTtcblx0XHR9XG5cblx0XHRjaGFydC5ib3JkZXJXaWR0aCA9IG1lLmdldE1heEJvcmRlcldpZHRoKCk7XG5cdFx0Y2hhcnQub3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgobWluU2l6ZSAtIGNoYXJ0LmJvcmRlcldpZHRoKSAvIDIsIDApO1xuXHRcdGNoYXJ0LmlubmVyUmFkaXVzID0gTWF0aC5tYXgoY3V0b3V0UGVyY2VudGFnZSA/IChjaGFydC5vdXRlclJhZGl1cyAvIDEwMCkgKiAoY3V0b3V0UGVyY2VudGFnZSkgOiAwLCAwKTtcblx0XHRjaGFydC5yYWRpdXNMZW5ndGggPSAoY2hhcnQub3V0ZXJSYWRpdXMgLSBjaGFydC5pbm5lclJhZGl1cykgLyAobWUuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB8fCAxKTtcblx0XHRjaGFydC5vZmZzZXRYID0gb2Zmc2V0LnggKiBjaGFydC5vdXRlclJhZGl1cztcblx0XHRjaGFydC5vZmZzZXRZID0gb2Zmc2V0LnkgKiBjaGFydC5vdXRlclJhZGl1cztcblxuXHRcdG1ldGEudG90YWwgPSBtZS5jYWxjdWxhdGVUb3RhbCgpO1xuXG5cdFx0bWUub3V0ZXJSYWRpdXMgPSBjaGFydC5vdXRlclJhZGl1cyAtIGNoYXJ0LnJhZGl1c0xlbmd0aCAqIG1lLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KG1lLmluZGV4KTtcblx0XHRtZS5pbm5lclJhZGl1cyA9IE1hdGgubWF4KG1lLm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoICogY2hhcnRXZWlnaHQsIDApO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KGFyY3NbaV0sIGksIHJlc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24oYXJjLCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIG9wdHMgPSBjaGFydC5vcHRpb25zO1xuXHRcdHZhciBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG5cdFx0dmFyIGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcblx0XHR2YXIgY2VudGVyWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuXHRcdHZhciBzdGFydEFuZ2xlID0gb3B0cy5yb3RhdGlvbjsgLy8gbm9uIHJlc2V0IGNhc2UgaGFuZGxlZCBsYXRlclxuXHRcdHZhciBlbmRBbmdsZSA9IG9wdHMucm90YXRpb247IC8vIG5vbiByZXNldCBjYXNlIGhhbmRsZWQgbGF0ZXJcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgY2lyY3VtZmVyZW5jZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSA/IDAgOiBhcmMuaGlkZGVuID8gMCA6IG1lLmNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UoZGF0YXNldC5kYXRhW2luZGV4XSkgKiAob3B0cy5jaXJjdW1mZXJlbmNlIC8gKDIuMCAqIE1hdGguUEkpKTtcblx0XHR2YXIgaW5uZXJSYWRpdXMgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSA/IDAgOiBtZS5pbm5lclJhZGl1cztcblx0XHR2YXIgb3V0ZXJSYWRpdXMgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSA/IDAgOiBtZS5vdXRlclJhZGl1cztcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucyB8fCB7fTtcblxuXHRcdGhlbHBlcnMkMS5leHRlbmQoYXJjLCB7XG5cdFx0XHQvLyBVdGlsaXR5XG5cdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdF9pbmRleDogaW5kZXgsXG5cblx0XHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXG5cdFx0XHRfbW9kZWw6IHtcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0XHRib3JkZXJBbGlnbjogb3B0aW9ucy5ib3JkZXJBbGlnbixcblx0XHRcdFx0eDogY2VudGVyWCArIGNoYXJ0Lm9mZnNldFgsXG5cdFx0XHRcdHk6IGNlbnRlclkgKyBjaGFydC5vZmZzZXRZLFxuXHRcdFx0XHRzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuXHRcdFx0XHRlbmRBbmdsZTogZW5kQW5nbGUsXG5cdFx0XHRcdGNpcmN1bWZlcmVuY2U6IGNpcmN1bWZlcmVuY2UsXG5cdFx0XHRcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcblx0XHRcdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuXHRcdFx0XHRsYWJlbDogaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmxhYmVsLCBpbmRleCwgY2hhcnQuZGF0YS5sYWJlbHNbaW5kZXhdKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcblxuXHRcdC8vIFNldCBjb3JyZWN0IGFuZ2xlcyBpZiBub3QgcmVzZXR0aW5nXG5cdFx0aWYgKCFyZXNldCB8fCAhYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG5cdFx0XHRpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdFx0bW9kZWwuc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb247XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtb2RlbC5zdGFydEFuZ2xlID0gbWUuZ2V0TWV0YSgpLmRhdGFbaW5kZXggLSAxXS5fbW9kZWwuZW5kQW5nbGU7XG5cdFx0XHR9XG5cblx0XHRcdG1vZGVsLmVuZEFuZ2xlID0gbW9kZWwuc3RhcnRBbmdsZSArIG1vZGVsLmNpcmN1bWZlcmVuY2U7XG5cdFx0fVxuXG5cdFx0YXJjLnBpdm90KCk7XG5cdH0sXG5cblx0Y2FsY3VsYXRlVG90YWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcblx0XHR2YXIgdG90YWwgPSAwO1xuXHRcdHZhciB2YWx1ZTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKG1ldGEuZGF0YSwgZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHRcdHZhbHVlID0gZGF0YXNldC5kYXRhW2luZGV4XTtcblx0XHRcdGlmICghaXNOYU4odmFsdWUpICYmICFlbGVtZW50LmhpZGRlbikge1xuXHRcdFx0XHR0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKiBpZiAodG90YWwgPT09IDApIHtcblx0XHRcdHRvdGFsID0gTmFOO1xuXHRcdH0qL1xuXG5cdFx0cmV0dXJuIHRvdGFsO1xuXHR9LFxuXG5cdGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIHRvdGFsID0gdGhpcy5nZXRNZXRhKCkudG90YWw7XG5cdFx0aWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gKE1hdGguUEkgKiAyLjApICogKE1hdGguYWJzKHZhbHVlKSAvIHRvdGFsKTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gZ2V0cyB0aGUgbWF4IGJvcmRlciBvciBob3ZlciB3aWR0aCB0byBwcm9wZXJseSBzY2FsZSBwaWUgY2hhcnRzXG5cdGdldE1heEJvcmRlcldpZHRoOiBmdW5jdGlvbihhcmNzKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWF4ID0gMDtcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgaSwgaWxlbiwgbWV0YSwgYXJjLCBjb250cm9sbGVyLCBvcHRpb25zLCBib3JkZXJXaWR0aCwgaG92ZXJXaWR0aDtcblxuXHRcdGlmICghYXJjcykge1xuXHRcdFx0Ly8gRmluZCB0aGUgb3V0bW9zdCB2aXNpYmxlIGRhdGFzZXRcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0XHRhcmNzID0gbWV0YS5kYXRhO1xuXHRcdFx0XHRcdGlmIChpICE9PSBtZS5pbmRleCkge1xuXHRcdFx0XHRcdFx0Y29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWFyY3MpIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0YXJjID0gYXJjc1tpXTtcblx0XHRcdG9wdGlvbnMgPSBjb250cm9sbGVyID8gY29udHJvbGxlci5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGFyYywgaSkgOiBhcmMuX29wdGlvbnM7XG5cdFx0XHRpZiAob3B0aW9ucy5ib3JkZXJBbGlnbiAhPT0gJ2lubmVyJykge1xuXHRcdFx0XHRib3JkZXJXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cdFx0XHRcdGhvdmVyV2lkdGggPSBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGg7XG5cblx0XHRcdFx0bWF4ID0gYm9yZGVyV2lkdGggPiBtYXggPyBib3JkZXJXaWR0aCA6IG1heDtcblx0XHRcdFx0bWF4ID0gaG92ZXJXaWR0aCA+IG1heCA/IGhvdmVyV2lkdGggOiBtYXg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKGFyYykge1xuXHRcdHZhciBtb2RlbCA9IGFyYy5fbW9kZWw7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblxuXHRcdGFyYy4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxuXHRcdH07XG5cblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ0KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDQob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDQob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlRWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKGFyYywgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBjdXN0b20gPSBhcmMuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmM7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJXaWR0aCcsXG5cdFx0XHQnYm9yZGVyQWxpZ24nLFxuXHRcdFx0J2hvdmVyQmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdob3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdCdob3ZlckJvcmRlcldpZHRoJyxcblx0XHRdO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDMoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgcmFkaXVzIGxlbmd0aCBvZmZzZXQgb2YgdGhlIGRhdGFzZXQgaW4gcmVsYXRpb24gdG8gdGhlIHZpc2libGUgZGF0YXNldHMgd2VpZ2h0cy4gVGhpcyBhbGxvd3MgZGV0ZXJtaW5pbmcgdGhlIGlubmVyIGFuZCBvdXRlciByYWRpdXMgY29ycmVjdGx5XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0UmluZ1dlaWdodE9mZnNldDogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIHJpbmdXZWlnaHRPZmZzZXQgPSAwO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7ICsraSkge1xuXHRcdFx0aWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRyaW5nV2VpZ2h0T2Zmc2V0ICs9IHRoaXMuX2dldFJpbmdXZWlnaHQoaSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0UmluZ1dlaWdodDogZnVuY3Rpb24oZGF0YVNldEluZGV4KSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0JDQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFTZXRJbmRleF0ud2VpZ2h0LCAxKSwgMCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHN1bSBvZiBhbGwgdmlzaWJpbGUgZGF0YSBzZXQgd2VpZ2h0cy4gIFRoaXMgdmFsdWUgY2FuIGJlIDAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCk7XG5cdH1cbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2hvcml6b250YWxCYXInLCB7XG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ2luZGV4Jyxcblx0XHRheGlzOiAneSdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0cG9zaXRpb246ICdib3R0b20nXG5cdFx0fV0sXG5cblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdjYXRlZ29yeScsXG5cdFx0XHRwb3NpdGlvbjogJ2xlZnQnLFxuXHRcdFx0Y2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG5cdFx0XHRiYXJQZXJjZW50YWdlOiAwLjksXG5cdFx0XHRvZmZzZXQ6IHRydWUsXG5cdFx0XHRncmlkTGluZXM6IHtcblx0XHRcdFx0b2Zmc2V0R3JpZExpbmVzOiB0cnVlXG5cdFx0XHR9XG5cdFx0fV1cblx0fSxcblxuXHRlbGVtZW50czoge1xuXHRcdHJlY3RhbmdsZToge1xuXHRcdFx0Ym9yZGVyU2tpcHBlZDogJ2xlZnQnXG5cdFx0fVxuXHR9LFxuXG5cdHRvb2x0aXBzOiB7XG5cdFx0bW9kZTogJ2luZGV4Jyxcblx0XHRheGlzOiAneSdcblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX2hvcml6b250YWxCYXIgPSBjb250cm9sbGVyX2Jhci5leHRlbmQoe1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRWYWx1ZVNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS54QXhpc0lEO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldEluZGV4U2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnlBeGlzSUQ7XG5cdH1cbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkNSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcbnZhciByZXNvbHZlJDQgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xudmFyIGlzUG9pbnRJbkFyZWEgPSBoZWxwZXJzJDEuY2FudmFzLl9pc1BvaW50SW5BcmVhO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2xpbmUnLCB7XG5cdHNob3dMaW5lczogdHJ1ZSxcblx0c3BhbkdhcHM6IGZhbHNlLFxuXG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ2xhYmVsJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2NhdGVnb3J5Jyxcblx0XHRcdGlkOiAneC1heGlzLTAnXG5cdFx0fV0sXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcblx0XHRcdGlkOiAneS1heGlzLTAnXG5cdFx0fV1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGxpbmVFbmFibGVkKGRhdGFzZXQsIG9wdGlvbnMpIHtcblx0cmV0dXJuIHZhbHVlT3JEZWZhdWx0JDUoZGF0YXNldC5zaG93TGluZSwgb3B0aW9ucy5zaG93TGluZXMpO1xufVxuXG52YXIgY29udHJvbGxlcl9saW5lID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogZWxlbWVudHMuTGluZSxcblxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlBvaW50LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBsaW5lID0gbWV0YS5kYXRhc2V0O1xuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0dmFyIHNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBzaG93TGluZSA9IGxpbmVFbmFibGVkKGRhdGFzZXQsIG1lLmNoYXJ0Lm9wdGlvbnMpO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0Ly8gVXBkYXRlIExpbmVcblx0XHRpZiAoc2hvd0xpbmUpIHtcblx0XHRcdC8vIENvbXBhdGliaWxpdHk6IElmIHRoZSBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIHdpdGggb25seSB0aGUgb2xkIG5hbWUsIHVzZSB0aG9zZSB2YWx1ZXNcblx0XHRcdGlmICgoZGF0YXNldC50ZW5zaW9uICE9PSB1bmRlZmluZWQpICYmIChkYXRhc2V0LmxpbmVUZW5zaW9uID09PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRcdGRhdGFzZXQubGluZVRlbnNpb24gPSBkYXRhc2V0LnRlbnNpb247XG5cdFx0XHR9XG5cblx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdGxpbmUuX3NjYWxlID0gc2NhbGU7XG5cdFx0XHRsaW5lLl9kYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHRcdC8vIERhdGFcblx0XHRcdGxpbmUuX2NoaWxkcmVuID0gcG9pbnRzO1xuXHRcdFx0Ly8gTW9kZWxcblx0XHRcdGxpbmUuX21vZGVsID0gbWUuX3Jlc29sdmVMaW5lT3B0aW9ucyhsaW5lKTtcblxuXHRcdFx0bGluZS5waXZvdCgpO1xuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSBQb2ludHNcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChwb2ludHNbaV0sIGksIHJlc2V0KTtcblx0XHR9XG5cblx0XHRpZiAoc2hvd0xpbmUgJiYgbGluZS5fbW9kZWwudGVuc2lvbiAhPT0gMCkge1xuXHRcdFx0bWUudXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cygpO1xuXHRcdH1cblxuXHRcdC8vIE5vdyBwaXZvdCB0aGUgcG9pbnQgZm9yIGFuaW1hdGlvblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRwb2ludHNbaV0ucGl2b3QoKTtcblx0XHR9XG5cdH0sXG5cblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocG9pbnQsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0dmFyIHZhbHVlID0gZGF0YXNldC5kYXRhW2luZGV4XTtcblx0XHR2YXIgeVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdHZhciB4U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XG5cdFx0dmFyIGxpbmVNb2RlbCA9IG1ldGEuZGF0YXNldC5fbW9kZWw7XG5cdFx0dmFyIHgsIHk7XG5cblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlUG9pbnRPcHRpb25zKHBvaW50LCBpbmRleCk7XG5cblx0XHR4ID0geFNjYWxlLmdldFBpeGVsRm9yVmFsdWUodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHZhbHVlIDogTmFOLCBpbmRleCwgZGF0YXNldEluZGV4KTtcblx0XHR5ID0gcmVzZXQgPyB5U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiBtZS5jYWxjdWxhdGVQb2ludFkodmFsdWUsIGluZGV4LCBkYXRhc2V0SW5kZXgpO1xuXG5cdFx0Ly8gVXRpbGl0eVxuXHRcdHBvaW50Ll94U2NhbGUgPSB4U2NhbGU7XG5cdFx0cG9pbnQuX3lTY2FsZSA9IHlTY2FsZTtcblx0XHRwb2ludC5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0cG9pbnQuX2RhdGFzZXRJbmRleCA9IGRhdGFzZXRJbmRleDtcblx0XHRwb2ludC5faW5kZXggPSBpbmRleDtcblxuXHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXG5cdFx0cG9pbnQuX21vZGVsID0ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHksXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcblx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdHJhZGl1czogb3B0aW9ucy5yYWRpdXMsXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcblx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0dGVuc2lvbjogdmFsdWVPckRlZmF1bHQkNShjdXN0b20udGVuc2lvbiwgbGluZU1vZGVsID8gbGluZU1vZGVsLnRlbnNpb24gOiAwKSxcblx0XHRcdHN0ZXBwZWRMaW5lOiBsaW5lTW9kZWwgPyBsaW5lTW9kZWwuc3RlcHBlZExpbmUgOiBmYWxzZSxcblx0XHRcdC8vIFRvb2x0aXBcblx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXNcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVQb2ludE9wdGlvbnM6IGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQ7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHR2YXIgRUxFTUVOVF9PUFRJT05TID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiAncG9pbnRCYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0Ym9yZGVyQ29sb3I6ICdwb2ludEJvcmRlckNvbG9yJyxcblx0XHRcdGJvcmRlcldpZHRoOiAncG9pbnRCb3JkZXJXaWR0aCcsXG5cdFx0XHRoaXRSYWRpdXM6ICdwb2ludEhpdFJhZGl1cycsXG5cdFx0XHRob3ZlckJhY2tncm91bmRDb2xvcjogJ3BvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0aG92ZXJCb3JkZXJDb2xvcjogJ3BvaW50SG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0XHRob3ZlckJvcmRlcldpZHRoOiAncG9pbnRIb3ZlckJvcmRlcldpZHRoJyxcblx0XHRcdGhvdmVyUmFkaXVzOiAncG9pbnRIb3ZlclJhZGl1cycsXG5cdFx0XHRwb2ludFN0eWxlOiAncG9pbnRTdHlsZScsXG5cdFx0XHRyYWRpdXM6ICdwb2ludFJhZGl1cycsXG5cdFx0XHRyb3RhdGlvbjogJ3BvaW50Um90YXRpb24nXG5cdFx0fTtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKEVMRU1FTlRfT1BUSU9OUyk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkNChbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W0VMRU1FTlRfT1BUSU9OU1trZXldXSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVMaW5lT3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBjaGFydC5kYXRhLmRhdGFzZXRzW21lLmluZGV4XTtcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zO1xuXHRcdHZhciBlbGVtZW50T3B0aW9ucyA9IG9wdGlvbnMuZWxlbWVudHMubGluZTtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJDYXBTdHlsZScsXG5cdFx0XHQnYm9yZGVyRGFzaCcsXG5cdFx0XHQnYm9yZGVyRGFzaE9mZnNldCcsXG5cdFx0XHQnYm9yZGVySm9pblN0eWxlJyxcblx0XHRcdCdmaWxsJyxcblx0XHRcdCdjdWJpY0ludGVycG9sYXRpb25Nb2RlJ1xuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkNChbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdGVsZW1lbnRPcHRpb25zW2tleV1cblx0XHRcdF0pO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGxpbmVzIGlzIHRvIGJyZWFrIGF0IG51bGwgdmFsdWVzLCBhY2NvcmRpbmdcblx0XHQvLyB0byBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjQzNSNpc3N1ZWNvbW1lbnQtMjE2NzE4MTU4XG5cdFx0Ly8gVGhpcyBvcHRpb24gZ2l2ZXMgbGluZXMgdGhlIGFiaWxpdHkgdG8gc3BhbiBnYXBzXG5cdFx0dmFsdWVzLnNwYW5HYXBzID0gdmFsdWVPckRlZmF1bHQkNShkYXRhc2V0LnNwYW5HYXBzLCBvcHRpb25zLnNwYW5HYXBzKTtcblx0XHR2YWx1ZXMudGVuc2lvbiA9IHZhbHVlT3JEZWZhdWx0JDUoZGF0YXNldC5saW5lVGVuc2lvbiwgZWxlbWVudE9wdGlvbnMudGVuc2lvbik7XG5cdFx0dmFsdWVzLnN0ZXBwZWRMaW5lID0gcmVzb2x2ZSQ0KFtjdXN0b20uc3RlcHBlZExpbmUsIGRhdGFzZXQuc3RlcHBlZExpbmUsIGVsZW1lbnRPcHRpb25zLnN0ZXBwZWRdKTtcblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0Y2FsY3VsYXRlUG9pbnRZOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHR2YXIgc3VtUG9zID0gMDtcblx0XHR2YXIgc3VtTmVnID0gMDtcblx0XHR2YXIgaSwgZHMsIGRzTWV0YTtcblxuXHRcdGlmICh5U2NhbGUub3B0aW9ucy5zdGFja2VkKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyBpKyspIHtcblx0XHRcdFx0ZHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzW2ldO1xuXHRcdFx0XHRkc01ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0aWYgKGRzTWV0YS50eXBlID09PSAnbGluZScgJiYgZHNNZXRhLnlBeGlzSUQgPT09IHlTY2FsZS5pZCAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdFx0dmFyIHN0YWNrZWRSaWdodFZhbHVlID0gTnVtYmVyKHlTY2FsZS5nZXRSaWdodFZhbHVlKGRzLmRhdGFbaW5kZXhdKSk7XG5cdFx0XHRcdFx0aWYgKHN0YWNrZWRSaWdodFZhbHVlIDwgMCkge1xuXHRcdFx0XHRcdFx0c3VtTmVnICs9IHN0YWNrZWRSaWdodFZhbHVlIHx8IDA7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN1bVBvcyArPSBzdGFja2VkUmlnaHRWYWx1ZSB8fCAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmlnaHRWYWx1ZSA9IE51bWJlcih5U2NhbGUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSkpO1xuXHRcdFx0aWYgKHJpZ2h0VmFsdWUgPCAwKSB7XG5cdFx0XHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdW1OZWcgKyByaWdodFZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdW1Qb3MgKyByaWdodFZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4geVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpO1xuXHR9LFxuXG5cdHVwZGF0ZUJlemllckNvbnRyb2xQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGxpbmVNb2RlbCA9IG1ldGEuZGF0YXNldC5fbW9kZWw7XG5cdFx0dmFyIGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaSwgaWxlbiwgbW9kZWwsIGNvbnRyb2xQb2ludHM7XG5cblx0XHQvLyBPbmx5IGNvbnNpZGVyIHBvaW50cyB0aGF0IGFyZSBkcmF3biBpbiBjYXNlIHRoZSBzcGFuR2FwcyBvcHRpb24gaXMgdXNlZFxuXHRcdGlmIChsaW5lTW9kZWwuc3BhbkdhcHMpIHtcblx0XHRcdHBvaW50cyA9IHBvaW50cy5maWx0ZXIoZnVuY3Rpb24ocHQpIHtcblx0XHRcdFx0cmV0dXJuICFwdC5fbW9kZWwuc2tpcDtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdCwgbWluLCBtYXgpIHtcblx0XHRcdHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcblx0XHR9XG5cblx0XHRpZiAobGluZU1vZGVsLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcblx0XHRcdGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1vZGVsID0gcG9pbnRzW2ldLl9tb2RlbDtcblx0XHRcdFx0Y29udHJvbFBvaW50cyA9IGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZShcblx0XHRcdFx0XHRoZWxwZXJzJDEucHJldmlvdXNJdGVtKHBvaW50cywgaSkuX21vZGVsLFxuXHRcdFx0XHRcdG1vZGVsLFxuXHRcdFx0XHRcdGhlbHBlcnMkMS5uZXh0SXRlbShwb2ludHMsIGkpLl9tb2RlbCxcblx0XHRcdFx0XHRsaW5lTW9kZWwudGVuc2lvblxuXHRcdFx0XHQpO1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLng7XG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBjb250cm9sUG9pbnRzLm5leHQueDtcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY2hhcnQub3B0aW9ucy5lbGVtZW50cy5saW5lLmNhcEJlemllclBvaW50cykge1xuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bW9kZWwgPSBwb2ludHNbaV0uX21vZGVsO1xuXHRcdFx0XHRpZiAoaXNQb2ludEluQXJlYShtb2RlbCwgYXJlYSkpIHtcblx0XHRcdFx0XHRpZiAoaSA+IDAgJiYgaXNQb2ludEluQXJlYShwb2ludHNbaSAtIDFdLl9tb2RlbCwgYXJlYSkpIHtcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1gsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZLCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaSA8IHBvaW50cy5sZW5ndGggLSAxICYmIGlzUG9pbnRJbkFyZWEocG9pbnRzW2kgKyAxXS5fbW9kZWwsIGFyZWEpKSB7XG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnROZXh0WCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludE5leHRZLCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0dmFyIGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIGlsZW4gPSBwb2ludHMubGVuZ3RoO1xuXHRcdHZhciBoYWxmQm9yZGVyV2lkdGg7XG5cdFx0dmFyIGkgPSAwO1xuXG5cdFx0aWYgKGxpbmVFbmFibGVkKG1lLmdldERhdGFzZXQoKSwgY2hhcnQub3B0aW9ucykpIHtcblx0XHRcdGhhbGZCb3JkZXJXaWR0aCA9IChtZXRhLmRhdGFzZXQuX21vZGVsLmJvcmRlcldpZHRoIHx8IDApIC8gMjtcblxuXHRcdFx0aGVscGVycyQxLmNhbnZhcy5jbGlwQXJlYShjaGFydC5jdHgsIHtcblx0XHRcdFx0bGVmdDogYXJlYS5sZWZ0LFxuXHRcdFx0XHRyaWdodDogYXJlYS5yaWdodCxcblx0XHRcdFx0dG9wOiBhcmVhLnRvcCAtIGhhbGZCb3JkZXJXaWR0aCxcblx0XHRcdFx0Ym90dG9tOiBhcmVhLmJvdHRvbSArIGhhbGZCb3JkZXJXaWR0aFxuXHRcdFx0fSk7XG5cblx0XHRcdG1ldGEuZGF0YXNldC5kcmF3KCk7XG5cblx0XHRcdGhlbHBlcnMkMS5jYW52YXMudW5jbGlwQXJlYShjaGFydC5jdHgpO1xuXHRcdH1cblxuXHRcdC8vIERyYXcgdGhlIHBvaW50c1xuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRwb2ludHNbaV0uZHJhdyhhcmVhKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gcG9pbnQuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblxuXHRcdHBvaW50LiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0XHRyYWRpdXM6IG1vZGVsLnJhZGl1c1xuXHRcdH07XG5cblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ1KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDUob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDUob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcblx0XHRtb2RlbC5yYWRpdXMgPSB2YWx1ZU9yRGVmYXVsdCQ1KG9wdGlvbnMuaG92ZXJSYWRpdXMsIG9wdGlvbnMucmFkaXVzKTtcblx0fSxcbn0pO1xuXG52YXIgcmVzb2x2ZSQ1ID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdwb2xhckFyZWEnLCB7XG5cdHNjYWxlOiB7XG5cdFx0dHlwZTogJ3JhZGlhbExpbmVhcicsXG5cdFx0YW5nbGVMaW5lczoge1xuXHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHR9LFxuXHRcdGdyaWRMaW5lczoge1xuXHRcdFx0Y2lyY3VsYXI6IHRydWVcblx0XHR9LFxuXHRcdHBvaW50TGFiZWxzOiB7XG5cdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdH0sXG5cdFx0dGlja3M6IHtcblx0XHRcdGJlZ2luQXRaZXJvOiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgdGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydFxuXHRhbmltYXRpb246IHtcblx0XHRhbmltYXRlUm90YXRlOiB0cnVlLFxuXHRcdGFuaW1hdGVTY2FsZTogdHJ1ZVxuXHR9LFxuXG5cdHN0YXJ0QW5nbGU6IC0wLjUgKiBNYXRoLlBJLFxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgdGV4dCA9IFtdO1xuXHRcdHRleHQucHVzaCgnPHVsIGNsYXNzPVwiJyArIGNoYXJ0LmlkICsgJy1sZWdlbmRcIj4nKTtcblxuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBsYWJlbHMgPSBkYXRhLmxhYmVscztcblxuXHRcdGlmIChkYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXNldHNbMF0uZGF0YS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0ZXh0LnB1c2goJzxsaT48c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGRhdGFzZXRzWzBdLmJhY2tncm91bmRDb2xvcltpXSArICdcIj48L3NwYW4+Jyk7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0pIHtcblx0XHRcdFx0XHR0ZXh0LnB1c2gobGFiZWxzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXh0LnB1c2goJzwvbGk+Jyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGV4dC5wdXNoKCc8L3VsPicpO1xuXHRcdHJldHVybiB0ZXh0LmpvaW4oJycpO1xuXHR9LFxuXHRsZWdlbmQ6IHtcblx0XHRsYWJlbHM6IHtcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHRcdGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5sYWJlbHMubWFwKGZ1bmN0aW9uKGxhYmVsLCBpKSB7XG5cdFx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuXHRcdFx0XHRcdFx0dmFyIGRzID0gZGF0YS5kYXRhc2V0c1swXTtcblx0XHRcdFx0XHRcdHZhciBhcmMgPSBtZXRhLmRhdGFbaV07XG5cdFx0XHRcdFx0XHR2YXIgY3VzdG9tID0gYXJjLmN1c3RvbSB8fCB7fTtcblx0XHRcdFx0XHRcdHZhciBhcmNPcHRzID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmM7XG5cdFx0XHRcdFx0XHR2YXIgZmlsbCA9IHJlc29sdmUkNShbY3VzdG9tLmJhY2tncm91bmRDb2xvciwgZHMuYmFja2dyb3VuZENvbG9yLCBhcmNPcHRzLmJhY2tncm91bmRDb2xvcl0sIHVuZGVmaW5lZCwgaSk7XG5cdFx0XHRcdFx0XHR2YXIgc3Ryb2tlID0gcmVzb2x2ZSQ1KFtjdXN0b20uYm9yZGVyQ29sb3IsIGRzLmJvcmRlckNvbG9yLCBhcmNPcHRzLmJvcmRlckNvbG9yXSwgdW5kZWZpbmVkLCBpKTtcblx0XHRcdFx0XHRcdHZhciBidyA9IHJlc29sdmUkNShbY3VzdG9tLmJvcmRlcldpZHRoLCBkcy5ib3JkZXJXaWR0aCwgYXJjT3B0cy5ib3JkZXJXaWR0aF0sIHVuZGVmaW5lZCwgaSk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHRleHQ6IGxhYmVsLFxuXHRcdFx0XHRcdFx0XHRmaWxsU3R5bGU6IGZpbGwsXG5cdFx0XHRcdFx0XHRcdHN0cm9rZVN0eWxlOiBzdHJva2UsXG5cdFx0XHRcdFx0XHRcdGxpbmVXaWR0aDogYncsXG5cdFx0XHRcdFx0XHRcdGhpZGRlbjogaXNOYU4oZHMuZGF0YVtpXSkgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbixcblxuXHRcdFx0XHRcdFx0XHQvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cblx0XHRcdFx0XHRcdFx0aW5kZXg6IGlcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmluZGV4O1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblx0XHRcdHZhciBpLCBpbGVuLCBtZXRhO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuID0gIW1ldGEuZGF0YVtpbmRleF0uaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGFydC51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTmVlZCB0byBvdmVycmlkZSB0aGVzZSB0byBnaXZlIGEgbmljZSBkZWZhdWx0XG5cdHRvb2x0aXBzOiB7XG5cdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSwgZGF0YSkge1xuXHRcdFx0XHRyZXR1cm4gZGF0YS5sYWJlbHNbaXRlbS5pbmRleF0gKyAnOiAnICsgaXRlbS55TGFiZWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGNvbnRyb2xsZXJfcG9sYXJBcmVhID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuQXJjLFxuXG5cdGxpbmtTY2FsZXM6IGhlbHBlcnMkMS5ub29wLFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBzdGFydCA9IG1lLmNoYXJ0Lm9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwO1xuXHRcdHZhciBzdGFydHMgPSBtZS5fc3RhcnRzID0gW107XG5cdFx0dmFyIGFuZ2xlcyA9IG1lLl9hbmdsZXMgPSBbXTtcblx0XHR2YXIgYXJjcyA9IG1ldGEuZGF0YTtcblx0XHR2YXIgaSwgaWxlbiwgYW5nbGU7XG5cblx0XHRtZS5fdXBkYXRlUmFkaXVzKCk7XG5cblx0XHRtZXRhLmNvdW50ID0gbWUuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0LmRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG5cdFx0XHRzdGFydHNbaV0gPSBzdGFydDtcblx0XHRcdGFuZ2xlID0gbWUuX2NvbXB1dGVBbmdsZShpKTtcblx0XHRcdGFuZ2xlc1tpXSA9IGFuZ2xlO1xuXHRcdFx0c3RhcnQgKz0gYW5nbGU7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRhcmNzW2ldLl9vcHRpb25zID0gbWUuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhhcmNzW2ldLCBpKTtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQoYXJjc1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF91cGRhdGVSYWRpdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuXG5cdFx0Y2hhcnQub3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG5cdFx0Y2hhcnQuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAoY2hhcnQub3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcblx0XHRjaGFydC5yYWRpdXNMZW5ndGggPSAoY2hhcnQub3V0ZXJSYWRpdXMgLSBjaGFydC5pbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG5cblx0XHRtZS5vdXRlclJhZGl1cyA9IGNoYXJ0Lm91dGVyUmFkaXVzIC0gKGNoYXJ0LnJhZGl1c0xlbmd0aCAqIG1lLmluZGV4KTtcblx0XHRtZS5pbm5lclJhZGl1cyA9IG1lLm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoO1xuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGFyYywgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcblx0XHR2YXIgc2NhbGUgPSBjaGFydC5zY2FsZTtcblx0XHR2YXIgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHM7XG5cblx0XHR2YXIgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XG5cdFx0dmFyIGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuXG5cdFx0Ly8gdmFyIG5lZ0hhbGZQSSA9IC0wLjUgKiBNYXRoLlBJO1xuXHRcdHZhciBkYXRhc2V0U3RhcnRBbmdsZSA9IG9wdHMuc3RhcnRBbmdsZTtcblx0XHR2YXIgZGlzdGFuY2UgPSBhcmMuaGlkZGVuID8gMCA6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXHRcdHZhciBzdGFydEFuZ2xlID0gbWUuX3N0YXJ0c1tpbmRleF07XG5cdFx0dmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChhcmMuaGlkZGVuID8gMCA6IG1lLl9hbmdsZXNbaW5kZXhdKTtcblxuXHRcdHZhciByZXNldFJhZGl1cyA9IGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zIHx8IHt9O1xuXG5cdFx0aGVscGVycyQxLmV4dGVuZChhcmMsIHtcblx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxuXHRcdFx0X2luZGV4OiBpbmRleCxcblx0XHRcdF9zY2FsZTogc2NhbGUsXG5cblx0XHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXG5cdFx0XHRfbW9kZWw6IHtcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0XHRib3JkZXJBbGlnbjogb3B0aW9ucy5ib3JkZXJBbGlnbixcblx0XHRcdFx0eDogY2VudGVyWCxcblx0XHRcdFx0eTogY2VudGVyWSxcblx0XHRcdFx0aW5uZXJSYWRpdXM6IDAsXG5cdFx0XHRcdG91dGVyUmFkaXVzOiByZXNldCA/IHJlc2V0UmFkaXVzIDogZGlzdGFuY2UsXG5cdFx0XHRcdHN0YXJ0QW5nbGU6IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSA/IGRhdGFzZXRTdGFydEFuZ2xlIDogc3RhcnRBbmdsZSxcblx0XHRcdFx0ZW5kQW5nbGU6IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSA/IGRhdGFzZXRTdGFydEFuZ2xlIDogZW5kQW5nbGUsXG5cdFx0XHRcdGxhYmVsOiBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0KGxhYmVscywgaW5kZXgsIGxhYmVsc1tpbmRleF0pXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhcmMucGl2b3QoKTtcblx0fSxcblxuXHRjb3VudFZpc2libGVFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciBjb3VudCA9IDA7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChtZXRhLmRhdGEsIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cdFx0XHRpZiAoIWlzTmFOKGRhdGFzZXQuZGF0YVtpbmRleF0pICYmICFlbGVtZW50LmhpZGRlbikge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNvdW50O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihhcmMpIHtcblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cdFx0dmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG5cdFx0YXJjLiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVFbGVtZW50T3B0aW9uczogZnVuY3Rpb24oYXJjLCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGN1c3RvbSA9IGFyYy5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYztcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdCdib3JkZXJBbGlnbicsXG5cdFx0XHQnaG92ZXJCYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2hvdmVyQm9yZGVyQ29sb3InLFxuXHRcdFx0J2hvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkNShbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY29tcHV0ZUFuZ2xlOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNvdW50ID0gdGhpcy5nZXRNZXRhKCkuY291bnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cblx0XHRpZiAoaXNOYU4oZGF0YXNldC5kYXRhW2luZGV4XSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IG1lLmNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHJldHVybiByZXNvbHZlJDUoW1xuXHRcdFx0bWUuY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmMuYW5nbGUsXG5cdFx0XHQoMiAqIE1hdGguUEkpIC8gY291bnRcblx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdH1cbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3BpZScsIGhlbHBlcnMkMS5jbG9uZShjb3JlX2RlZmF1bHRzLmRvdWdobnV0KSk7XG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3BpZScsIHtcblx0Y3V0b3V0UGVyY2VudGFnZTogMFxufSk7XG5cbi8vIFBpZSBjaGFydHMgYXJlIERvdWdobnV0IGNoYXJ0IHdpdGggZGlmZmVyZW50IGRlZmF1bHRzXG52YXIgY29udHJvbGxlcl9waWUgPSBjb250cm9sbGVyX2RvdWdobnV0O1xuXG52YXIgdmFsdWVPckRlZmF1bHQkNiA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcbnZhciByZXNvbHZlJDYgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3JhZGFyJywge1xuXHRzY2FsZToge1xuXHRcdHR5cGU6ICdyYWRpYWxMaW5lYXInXG5cdH0sXG5cdGVsZW1lbnRzOiB7XG5cdFx0bGluZToge1xuXHRcdFx0dGVuc2lvbjogMCAvLyBubyBiZXppZXIgaW4gcmFkYXJcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9yYWRhciA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRkYXRhc2V0RWxlbWVudFR5cGU6IGVsZW1lbnRzLkxpbmUsXG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcblxuXHRsaW5rU2NhbGVzOiBoZWxwZXJzJDEubm9vcCxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgbGluZSA9IG1ldGEuZGF0YXNldDtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBzY2FsZSA9IG1lLmNoYXJ0LnNjYWxlO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0Ly8gQ29tcGF0aWJpbGl0eTogSWYgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgd2l0aCBvbmx5IHRoZSBvbGQgbmFtZSwgdXNlIHRob3NlIHZhbHVlc1xuXHRcdGlmICgoZGF0YXNldC50ZW5zaW9uICE9PSB1bmRlZmluZWQpICYmIChkYXRhc2V0LmxpbmVUZW5zaW9uID09PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRkYXRhc2V0LmxpbmVUZW5zaW9uID0gZGF0YXNldC50ZW5zaW9uO1xuXHRcdH1cblxuXHRcdC8vIFV0aWxpdHlcblx0XHRsaW5lLl9zY2FsZSA9IHNjYWxlO1xuXHRcdGxpbmUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdC8vIERhdGFcblx0XHRsaW5lLl9jaGlsZHJlbiA9IHBvaW50cztcblx0XHRsaW5lLl9sb29wID0gdHJ1ZTtcblx0XHQvLyBNb2RlbFxuXHRcdGxpbmUuX21vZGVsID0gbWUuX3Jlc29sdmVMaW5lT3B0aW9ucyhsaW5lKTtcblxuXHRcdGxpbmUucGl2b3QoKTtcblxuXHRcdC8vIFVwZGF0ZSBQb2ludHNcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChwb2ludHNbaV0sIGksIHJlc2V0KTtcblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgYmV6aWVyIGNvbnRyb2wgcG9pbnRzXG5cdFx0bWUudXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cygpO1xuXG5cdFx0Ly8gTm93IHBpdm90IHRoZSBwb2ludCBmb3IgYW5pbWF0aW9uXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHBvaW50c1tpXS5waXZvdCgpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBzY2FsZSA9IG1lLmNoYXJ0LnNjYWxlO1xuXHRcdHZhciBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCBkYXRhc2V0LmRhdGFbaW5kZXhdKTtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlUG9pbnRPcHRpb25zKHBvaW50LCBpbmRleCk7XG5cdFx0dmFyIGxpbmVNb2RlbCA9IG1lLmdldE1ldGEoKS5kYXRhc2V0Ll9tb2RlbDtcblx0XHR2YXIgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcblx0XHR2YXIgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcblxuXHRcdC8vIFV0aWxpdHlcblx0XHRwb2ludC5fc2NhbGUgPSBzY2FsZTtcblx0XHRwb2ludC5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0cG9pbnQuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdHBvaW50Ll9pbmRleCA9IGluZGV4O1xuXG5cdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHR4OiB4LCAvLyB2YWx1ZSBub3QgdXNlZCBpbiBkYXRhc2V0IHNjYWxlLCBidXQgd2Ugd2FudCBhIGNvbnNpc3RlbnQgQVBJIGJldHdlZW4gc2NhbGVzXG5cdFx0XHR5OiB5LFxuXHRcdFx0c2tpcDogY3VzdG9tLnNraXAgfHwgaXNOYU4oeCkgfHwgaXNOYU4oeSksXG5cdFx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0XHRyYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxuXHRcdFx0cG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuXHRcdFx0cm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdHRlbnNpb246IHZhbHVlT3JEZWZhdWx0JDYoY3VzdG9tLnRlbnNpb24sIGxpbmVNb2RlbCA/IGxpbmVNb2RlbC50ZW5zaW9uIDogMCksXG5cblx0XHRcdC8vIFRvb2x0aXBcblx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXNcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVQb2ludE9wdGlvbnM6IGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQ7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHR2YXIgRUxFTUVOVF9PUFRJT05TID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiAncG9pbnRCYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0Ym9yZGVyQ29sb3I6ICdwb2ludEJvcmRlckNvbG9yJyxcblx0XHRcdGJvcmRlcldpZHRoOiAncG9pbnRCb3JkZXJXaWR0aCcsXG5cdFx0XHRoaXRSYWRpdXM6ICdwb2ludEhpdFJhZGl1cycsXG5cdFx0XHRob3ZlckJhY2tncm91bmRDb2xvcjogJ3BvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0aG92ZXJCb3JkZXJDb2xvcjogJ3BvaW50SG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0XHRob3ZlckJvcmRlcldpZHRoOiAncG9pbnRIb3ZlckJvcmRlcldpZHRoJyxcblx0XHRcdGhvdmVyUmFkaXVzOiAncG9pbnRIb3ZlclJhZGl1cycsXG5cdFx0XHRwb2ludFN0eWxlOiAncG9pbnRTdHlsZScsXG5cdFx0XHRyYWRpdXM6ICdwb2ludFJhZGl1cycsXG5cdFx0XHRyb3RhdGlvbjogJ3BvaW50Um90YXRpb24nXG5cdFx0fTtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKEVMRU1FTlRfT1BUSU9OUyk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkNihbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W0VMRU1FTlRfT1BUSU9OU1trZXldXSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVMaW5lT3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBjaGFydC5kYXRhLmRhdGFzZXRzW21lLmluZGV4XTtcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmxpbmU7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ2FwU3R5bGUnLFxuXHRcdFx0J2JvcmRlckRhc2gnLFxuXHRcdFx0J2JvcmRlckRhc2hPZmZzZXQnLFxuXHRcdFx0J2JvcmRlckpvaW5TdHlsZScsXG5cdFx0XHQnZmlsbCdcblx0XHRdO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDYoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdF0pO1xuXHRcdH1cblxuXHRcdHZhbHVlcy50ZW5zaW9uID0gdmFsdWVPckRlZmF1bHQkNihkYXRhc2V0LmxpbmVUZW5zaW9uLCBvcHRpb25zLnRlbnNpb24pO1xuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHR1cGRhdGVCZXppZXJDb250cm9sUG9pbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBhcmVhID0gbWUuY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0dmFyIGksIGlsZW4sIG1vZGVsLCBjb250cm9sUG9pbnRzO1xuXG5cdFx0ZnVuY3Rpb24gY2FwQ29udHJvbFBvaW50KHB0LCBtaW4sIG1heCkge1xuXHRcdFx0cmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtb2RlbCA9IHBvaW50c1tpXS5fbW9kZWw7XG5cdFx0XHRjb250cm9sUG9pbnRzID0gaGVscGVycyQxLnNwbGluZUN1cnZlKFxuXHRcdFx0XHRoZWxwZXJzJDEucHJldmlvdXNJdGVtKHBvaW50cywgaSwgdHJ1ZSkuX21vZGVsLFxuXHRcdFx0XHRtb2RlbCxcblx0XHRcdFx0aGVscGVycyQxLm5leHRJdGVtKHBvaW50cywgaSwgdHJ1ZSkuX21vZGVsLFxuXHRcdFx0XHRtb2RlbC50ZW5zaW9uXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRoZSBiZXppZXIgZ29pbmcgb3V0c2lkZSBvZiB0aGUgYm91bmRzIG9mIHRoZSBncmFwaFxuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMucHJldmlvdXMueCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcblx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IGNhcENvbnRyb2xQb2ludChjb250cm9sUG9pbnRzLnByZXZpb3VzLnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNhcENvbnRyb2xQb2ludChjb250cm9sUG9pbnRzLm5leHQueCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcblx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMubmV4dC55LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuXHRcdH1cblx0fSxcblxuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0bW9kZWwucmFkaXVzID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyUmFkaXVzLCBvcHRpb25zLnJhZGl1cyk7XG5cdH1cbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3NjYXR0ZXInLCB7XG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ3NpbmdsZSdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdGlkOiAneC1heGlzLTEnLCAgICAvLyBuZWVkIGFuIElEIHNvIGRhdGFzZXRzIGNhbiByZWZlcmVuY2UgdGhlIHNjYWxlXG5cdFx0XHR0eXBlOiAnbGluZWFyJywgICAgLy8gc2NhdHRlciBzaG91bGQgbm90IHVzZSBhIGNhdGVnb3J5IGF4aXNcblx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJ1xuXHRcdH1dLFxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0aWQ6ICd5LWF4aXMtMScsXG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCdcblx0XHR9XVxuXHR9LFxuXG5cdHNob3dMaW5lczogZmFsc2UsXG5cblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnOyAgICAgLy8gZG9lc24ndCBtYWtlIHNlbnNlIGZvciBzY2F0dGVyIHNpbmNlIGRhdGEgYXJlIGZvcm1hdHRlZCBhcyBhIHBvaW50XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0cmV0dXJuICcoJyArIGl0ZW0ueExhYmVsICsgJywgJyArIGl0ZW0ueUxhYmVsICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIFNjYXR0ZXIgY2hhcnRzIHVzZSBsaW5lIGNvbnRyb2xsZXJzXG52YXIgY29udHJvbGxlcl9zY2F0dGVyID0gY29udHJvbGxlcl9saW5lO1xuXG4vLyBOT1RFIGV4cG9ydCBhIG1hcCBpbiB3aGljaCB0aGUga2V5IHJlcHJlc2VudHMgdGhlIGNvbnRyb2xsZXIgdHlwZSwgbm90XG4vLyB0aGUgY2xhc3MsIGFuZCBzbyBtdXN0IGJlIENhbWVsQ2FzZSBpbiBvcmRlciB0byBiZSBjb3JyZWN0bHkgcmV0cmlldmVkXG4vLyBieSB0aGUgY29udHJvbGxlciBpbiBjb3JlLmNvbnRyb2xsZXIuanMgKGBjb250cm9sbGVyc1ttZXRhLnR5cGVdYCkuXG5cbnZhciBjb250cm9sbGVycyA9IHtcblx0YmFyOiBjb250cm9sbGVyX2Jhcixcblx0YnViYmxlOiBjb250cm9sbGVyX2J1YmJsZSxcblx0ZG91Z2hudXQ6IGNvbnRyb2xsZXJfZG91Z2hudXQsXG5cdGhvcml6b250YWxCYXI6IGNvbnRyb2xsZXJfaG9yaXpvbnRhbEJhcixcblx0bGluZTogY29udHJvbGxlcl9saW5lLFxuXHRwb2xhckFyZWE6IGNvbnRyb2xsZXJfcG9sYXJBcmVhLFxuXHRwaWU6IGNvbnRyb2xsZXJfcGllLFxuXHRyYWRhcjogY29udHJvbGxlcl9yYWRhcixcblx0c2NhdHRlcjogY29udHJvbGxlcl9zY2F0dGVyXG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgcmVsYXRpdmUgcG9zaXRpb24gZm9yIGFuIGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50fElFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBwb3NpdGlvbiBmb3JcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0XG4gKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgZXZlbnQgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCkge1xuXHRpZiAoZS5uYXRpdmUpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogZS54LFxuXHRcdFx0eTogZS55XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBoZWxwZXJzJDEuZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHRyYXZlcnNlIGFsbCBvZiB0aGUgdmlzaWJsZSBlbGVtZW50cyBpbiB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgZm9yIGVhY2ggdmlzaWJsZSBpdGVtXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBoYW5kbGVyKSB7XG5cdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG5cdHZhciBtZXRhLCBpLCBqLCBpbGVuLCBqbGVuO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpZiAoIWNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRmb3IgKGogPSAwLCBqbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBtZXRhLmRhdGFbal07XG5cdFx0XHRpZiAoIWVsZW1lbnQuX3ZpZXcuc2tpcCkge1xuXHRcdFx0XHRoYW5kbGVyKGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBldmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtDaGFydEVsZW1lbnRbXX0gaXRlbXMgLSBlbGVtZW50cyB0byBmaWx0ZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvXG4gKiBAcmV0dXJuIHtDaGFydEVsZW1lbnRbXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKSB7XG5cdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0ZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBjb25zaWRlcmluZyBhbGwgdmlzaWJsZSBpdGVtcyBpbiB0ZWggY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtvYmplY3R9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW50ZXJzZWN0IC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpc3RhbmNlTWV0cmljIC0gZnVuY3Rpb24gdG8gcHJvdmlkZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHNcbiAqIEByZXR1cm4ge0NoYXJ0RWxlbWVudFtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBpbnRlcnNlY3QsIGRpc3RhbmNlTWV0cmljKSB7XG5cdHZhciBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0dmFyIG5lYXJlc3RJdGVtcyA9IFtdO1xuXG5cdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0aWYgKGludGVyc2VjdCAmJiAhZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQoKTtcblx0XHR2YXIgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcblx0XHRpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0bmVhcmVzdEl0ZW1zID0gW2VsZW1lbnRdO1xuXHRcdFx0bWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHR9IGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuXHRcdFx0Ly8gQ2FuIGhhdmUgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIHNhbWUgZGlzdGFuY2UgaW4gd2hpY2ggY2FzZSB3ZSBzb3J0IGJ5IHNpemVcblx0XHRcdG5lYXJlc3RJdGVtcy5wdXNoKGVsZW1lbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIG5lYXJlc3RJdGVtcztcbn1cblxuLyoqXG4gKiBHZXQgYSBkaXN0YW5jZSBtZXRyaWMgZnVuY3Rpb24gZm9yIHR3byBwb2ludHMgYmFzZWQgb24gdGhlXG4gKiBheGlzIG1vZGUgc2V0dGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHlcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcblx0dmFyIHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG5cdHZhciB1c2VZID0gYXhpcy5pbmRleE9mKCd5JykgIT09IC0xO1xuXG5cdHJldHVybiBmdW5jdGlvbihwdDEsIHB0Mikge1xuXHRcdHZhciBkZWx0YVggPSB1c2VYID8gTWF0aC5hYnMocHQxLnggLSBwdDIueCkgOiAwO1xuXHRcdHZhciBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xuXHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBpbmRleE1vZGUoY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdC8vIERlZmF1bHQgYXhpcyBmb3IgaW5kZXggbW9kZSBpcyAneCcgdG8gbWF0Y2ggb2xkIGJlaGF2aW91clxuXHRvcHRpb25zLmF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xuXHR2YXIgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMob3B0aW9ucy5heGlzKTtcblx0dmFyIGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3QgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgZmFsc2UsIGRpc3RhbmNlTWV0cmljKTtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0aWYgKCFpdGVtcy5sZW5ndGgpIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSkge1xuXHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBtZXRhLmRhdGFbaXRlbXNbMF0uX2luZGV4XTtcblxuXHRcdFx0Ly8gZG9uJ3QgY291bnQgaXRlbXMgdGhhdCBhcmUgc2tpcHBlZCAobnVsbCBkYXRhKVxuXHRcdFx0aWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuX3ZpZXcuc2tpcCkge1xuXHRcdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgSUludGVyYWN0aW9uT3B0aW9uc1xuICovXG4vKipcbiAqIElmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvaW50XG4gKiBAbmFtZSBJSW50ZXJmYWNlT3B0aW9ucyNib29sZWFuXG4gKiBAdHlwZSBCb29sZWFuXG4gKi9cblxuLyoqXG4gKiBDb250YWlucyBpbnRlcmFjdGlvbiByZWxhdGVkIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5JbnRlcmFjdGlvblxuICovXG52YXIgY29yZV9pbnRlcmFjdGlvbiA9IHtcblx0Ly8gSGVscGVyIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgbW9kZXNcblx0bW9kZXM6IHtcblx0XHRzaW5nbGU6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0ZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudHM7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gZWxlbWVudHMuc2xpY2UoMCwgMSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5sYWJlbFxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjBcblx0XHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRsYWJlbDogaW5kZXhNb2RlLFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IG1vZGUgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleCBhcyB0aGF0IGl0ZW1cblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW5kZXhcblx0XHQgKiBAc2luY2UgdjIuNC4wXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZSBkdXJpbmcgaW50ZXJhY3Rpb25cblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0aW5kZXg6IGluZGV4TW9kZSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgaW4gdGhlIHNhbWUgZGF0YXNldC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgaW4gdGhhdCBkYXRhc2V0XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXRcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlIGR1cmluZyBpbnRlcmFjdGlvblxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRkYXRhc2V0OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHRvcHRpb25zLmF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5Jztcblx0XHRcdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xuXHRcdFx0dmFyIGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3QgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgZmFsc2UsIGRpc3RhbmNlTWV0cmljKTtcblxuXHRcdFx0aWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0aXRlbXMgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5fZGF0YXNldEluZGV4KS5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54LWF4aXNcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNC4wLiBVc2UgaW5kZXggbW9kZSBhbmQgaW50ZXJzZWN0ID09IHRydWVcblx0XHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHQneC1heGlzJzogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHRcdHJldHVybiBpbmRleE1vZGUoY2hhcnQsIGUsIHtpbnRlcnNlY3Q6IGZhbHNlfSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBvaW50IG1vZGUgcmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBoaXQgdGVzdCBiYXNlZCBvbiB0aGUgZXZlbnQgcG9zaXRpb25cblx0XHQgKiBvZiB0aGUgZXZlbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0cG9pbnQ6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdHJldHVybiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBuZWFyZXN0IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudCBjbG9zZXN0IHRvIHRoZSBwb2ludFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdG5lYXJlc3Q6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdG9wdGlvbnMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuXHRcdFx0dmFyIGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKG9wdGlvbnMuYXhpcyk7XG5cdFx0XHRyZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgb3B0aW9ucy5pbnRlcnNlY3QsIGRpc3RhbmNlTWV0cmljKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogeCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeCBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnhcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdHg6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdFx0dmFyIGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG5cblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdGlmIChlbGVtZW50LmluWFJhbmdlKHBvc2l0aW9uLngpKSB7XG5cdFx0XHRcdFx0aXRlbXMucHVzaChlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRpbnRlcnNlY3RzSXRlbSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xuXHRcdFx0Ly8gdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uLCByZXR1cm4gbm90aGluZ1xuXHRcdFx0aWYgKG9wdGlvbnMuaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuXHRcdFx0XHRpdGVtcyA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiB5IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB5IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueVxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0eTogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0XHR2YXIgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcblxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5ZUmFuZ2UocG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGludGVyc2VjdHNJdGVtID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG5cdFx0XHQvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG5cdFx0XHRpZiAob3B0aW9ucy5pbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG5cdFx0XHRcdGl0ZW1zID0gW107XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fVxuXHR9XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xuXHRyZXR1cm4gaGVscGVycyQxLndoZXJlKGFycmF5LCBmdW5jdGlvbih2KSB7XG5cdFx0cmV0dXJuIHYucG9zaXRpb24gPT09IHBvc2l0aW9uO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gc29ydEJ5V2VpZ2h0KGFycmF5LCByZXZlcnNlKSB7XG5cdGFycmF5LmZvckVhY2goZnVuY3Rpb24odiwgaSkge1xuXHRcdHYuX3RtcEluZGV4XyA9IGk7XG5cdFx0cmV0dXJuIHY7XG5cdH0pO1xuXHRhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHR2YXIgdjAgPSByZXZlcnNlID8gYiA6IGE7XG5cdFx0dmFyIHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuXHRcdHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG5cdFx0XHR2MC5fdG1wSW5kZXhfIC0gdjEuX3RtcEluZGV4XyA6XG5cdFx0XHR2MC53ZWlnaHQgLSB2MS53ZWlnaHQ7XG5cdH0pO1xuXHRhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcblx0XHRkZWxldGUgdi5fdG1wSW5kZXhfO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZmluZE1heFBhZGRpbmcoYm94ZXMpIHtcblx0dmFyIHRvcCA9IDA7XG5cdHZhciBsZWZ0ID0gMDtcblx0dmFyIGJvdHRvbSA9IDA7XG5cdHZhciByaWdodCA9IDA7XG5cdGhlbHBlcnMkMS5lYWNoKGJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRpZiAoYm94LmdldFBhZGRpbmcpIHtcblx0XHRcdHZhciBib3hQYWRkaW5nID0gYm94LmdldFBhZGRpbmcoKTtcblx0XHRcdHRvcCA9IE1hdGgubWF4KHRvcCwgYm94UGFkZGluZy50b3ApO1xuXHRcdFx0bGVmdCA9IE1hdGgubWF4KGxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG5cdFx0XHRib3R0b20gPSBNYXRoLm1heChib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcblx0XHRcdHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIGJveFBhZGRpbmcucmlnaHQpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiB7XG5cdFx0dG9wOiB0b3AsXG5cdFx0bGVmdDogbGVmdCxcblx0XHRib3R0b206IGJvdHRvbSxcblx0XHRyaWdodDogcmlnaHRcblx0fTtcbn1cblxuZnVuY3Rpb24gYWRkU2l6ZUJ5UG9zaXRpb24oYm94ZXMsIHNpemUpIHtcblx0aGVscGVycyQxLmVhY2goYm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdHNpemVbYm94LnBvc2l0aW9uXSArPSBib3guaXNIb3Jpem9udGFsKCkgPyBib3guaGVpZ2h0IDogYm94LndpZHRoO1xuXHR9KTtcbn1cblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGxheW91dDoge1xuXHRcdHBhZGRpbmc6IHtcblx0XHRcdHRvcDogMCxcblx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0Ym90dG9tOiAwLFxuXHRcdFx0bGVmdDogMFxuXHRcdH1cblx0fVxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBJTGF5b3V0SXRlbVxuICogQHByb3Age3N0cmluZ30gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNoYXJ0IGxheW91dC4gUG9zc2libGUgdmFsdWVzIGFyZVxuICogJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsIGFuZCAnY2hhcnRBcmVhJ1xuICogQHByb3Age251bWJlcn0gd2VpZ2h0IC0gVGhlIHdlaWdodCB1c2VkIHRvIHNvcnQgdGhlIGl0ZW0uIEhpZ2hlciB3ZWlnaHRzIGFyZSBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuICogQHByb3Age2Jvb2xlYW59IGZ1bGxXaWR0aCAtIGlmIHRydWUsIGFuZCB0aGUgaXRlbSBpcyBob3Jpem9udGFsLCB0aGVuIHB1c2ggdmVydGljYWwgYm94ZXMgZG93blxuICogQHByb3Age2Z1bmN0aW9ufSBpc0hvcml6b250YWwgLSByZXR1cm5zIHRydWUgaWYgdGhlIGxheW91dCBpdGVtIGlzIGhvcml6b250YWwgKGllLiB0b3Agb3IgYm90dG9tKVxuICogQHByb3Age2Z1bmN0aW9ufSB1cGRhdGUgLSBUYWtlcyB0d28gcGFyYW1ldGVyczogd2lkdGggYW5kIGhlaWdodC4gUmV0dXJucyBzaXplIG9mIGl0ZW1cbiAqIEBwcm9wIHtmdW5jdGlvbn0gZ2V0UGFkZGluZyAtICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHBhZGRpbmcgb24gdGhlIGVkZ2VzXG4gKiBAcHJvcCB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXG4gKiBAcHJvcCB7bnVtYmVyfSBsZWZ0IC0gTGVmdCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSB0b3AgLSBUb3AgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gcmlnaHQgLSBSaWdodCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSBib3R0b20gLSBCb3R0b20gZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICovXG5cbi8vIFRoZSBsYXlvdXQgc2VydmljZSBpcyB2ZXJ5IHNlbGYgZXhwbGFuYXRvcnkuICBJdCdzIHJlc3BvbnNpYmxlIGZvciB0aGUgbGF5b3V0IHdpdGhpbiBhIGNoYXJ0LlxuLy8gU2NhbGVzLCBMZWdlbmRzIGFuZCBQbHVnaW5zIGFsbCByZWx5IG9uIHRoZSBsYXlvdXQgc2VydmljZSBhbmQgY2FuIGVhc2lseSByZWdpc3RlciB0byBiZSBwbGFjZWQgYW55d2hlcmUgdGhleSBuZWVkXG4vLyBJdCBpcyB0aGlzIHNlcnZpY2UncyByZXNwb25zaWJpbGl0eSBvZiBjYXJyeWluZyBvdXQgdGhhdCBsYXlvdXQuXG52YXIgY29yZV9sYXlvdXRzID0ge1xuXHRkZWZhdWx0czoge30sXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGEgYm94IHRvIGEgY2hhcnQuXG5cdCAqIEEgYm94IGlzIHNpbXBseSBhIHJlZmVyZW5jZSB0byBhbiBvYmplY3QgdGhhdCByZXF1aXJlcyBsYXlvdXQuIGVnLiBTY2FsZXMsIExlZ2VuZCwgVGl0bGUuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHVzZVxuXHQgKiBAcGFyYW0ge0lMYXlvdXRJdGVtfSBpdGVtIC0gdGhlIGl0ZW0gdG8gYWRkIHRvIGJlIGxheWVkIG91dFxuXHQgKi9cblx0YWRkQm94OiBmdW5jdGlvbihjaGFydCwgaXRlbSkge1xuXHRcdGlmICghY2hhcnQuYm94ZXMpIHtcblx0XHRcdGNoYXJ0LmJveGVzID0gW107XG5cdFx0fVxuXG5cdFx0Ly8gaW5pdGlhbGl6ZSBpdGVtIHdpdGggZGVmYXVsdCB2YWx1ZXNcblx0XHRpdGVtLmZ1bGxXaWR0aCA9IGl0ZW0uZnVsbFdpZHRoIHx8IGZhbHNlO1xuXHRcdGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuXHRcdGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcblxuXHRcdGNoYXJ0LmJveGVzLnB1c2goaXRlbSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIGxheW91dEl0ZW0gZnJvbSBhIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHJlbW92ZSB0aGUgYm94IGZyb21cblx0ICogQHBhcmFtIHtJTGF5b3V0SXRlbX0gbGF5b3V0SXRlbSAtIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXRcblx0ICovXG5cdHJlbW92ZUJveDogZnVuY3Rpb24oY2hhcnQsIGxheW91dEl0ZW0pIHtcblx0XHR2YXIgaW5kZXggPSBjaGFydC5ib3hlcyA/IGNoYXJ0LmJveGVzLmluZGV4T2YobGF5b3V0SXRlbSkgOiAtMTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRjaGFydC5ib3hlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0cyAob3IgdXBkYXRlcykgb3B0aW9ucyBvbiB0aGUgZ2l2ZW4gYGl0ZW1gLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCBpbiB3aGljaCB0aGUgaXRlbSBsaXZlcyAob3Igd2lsbCBiZSBhZGRlZCB0bylcblx0ICogQHBhcmFtIHtJTGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGNvbmZpZ3VyZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIG5ldyBpdGVtIG9wdGlvbnMuXG5cdCAqL1xuXHRjb25maWd1cmU6IGZ1bmN0aW9uKGNoYXJ0LCBpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIHByb3BzID0gWydmdWxsV2lkdGgnLCAncG9zaXRpb24nLCAnd2VpZ2h0J107XG5cdFx0dmFyIGlsZW4gPSBwcm9wcy5sZW5ndGg7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciBwcm9wO1xuXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHByb3AgPSBwcm9wc1tpXTtcblx0XHRcdGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRcdGl0ZW1bcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogRml0cyBib3hlcyBvZiB0aGUgZ2l2ZW4gY2hhcnQgaW50byB0aGUgZ2l2ZW4gc2l6ZSBieSBoYXZpbmcgZWFjaCBib3ggbWVhc3VyZSBpdHNlbGZcblx0ICogdGhlbiBydW5uaW5nIGEgZml0dGluZyBhbGdvcml0aG1cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIHRvIGZpdCBpbnRvXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IHRvIGZpdCBpbnRvXG5cdCAqL1xuXHR1cGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0aWYgKCFjaGFydCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBsYXlvdXRPcHRpb25zID0gY2hhcnQub3B0aW9ucy5sYXlvdXQgfHwge307XG5cdFx0dmFyIHBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcobGF5b3V0T3B0aW9ucy5wYWRkaW5nKTtcblx0XHR2YXIgbGVmdFBhZGRpbmcgPSBwYWRkaW5nLmxlZnQ7XG5cdFx0dmFyIHJpZ2h0UGFkZGluZyA9IHBhZGRpbmcucmlnaHQ7XG5cdFx0dmFyIHRvcFBhZGRpbmcgPSBwYWRkaW5nLnRvcDtcblx0XHR2YXIgYm90dG9tUGFkZGluZyA9IHBhZGRpbmcuYm90dG9tO1xuXG5cdFx0dmFyIGxlZnRCb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICdsZWZ0Jyk7XG5cdFx0dmFyIHJpZ2h0Qm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAncmlnaHQnKTtcblx0XHR2YXIgdG9wQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAndG9wJyk7XG5cdFx0dmFyIGJvdHRvbUJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ2JvdHRvbScpO1xuXHRcdHZhciBjaGFydEFyZWFCb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICdjaGFydEFyZWEnKTtcblxuXHRcdC8vIFNvcnQgYm94ZXMgYnkgd2VpZ2h0LiBBIGhpZ2hlciB3ZWlnaHQgaXMgZnVydGhlciBhd2F5IGZyb20gdGhlIGNoYXJ0IGFyZWFcblx0XHRzb3J0QnlXZWlnaHQobGVmdEJveGVzLCB0cnVlKTtcblx0XHRzb3J0QnlXZWlnaHQocmlnaHRCb3hlcywgZmFsc2UpO1xuXHRcdHNvcnRCeVdlaWdodCh0b3BCb3hlcywgdHJ1ZSk7XG5cdFx0c29ydEJ5V2VpZ2h0KGJvdHRvbUJveGVzLCBmYWxzZSk7XG5cblx0XHR2YXIgdmVydGljYWxCb3hlcyA9IGxlZnRCb3hlcy5jb25jYXQocmlnaHRCb3hlcyk7XG5cdFx0dmFyIGhvcml6b250YWxCb3hlcyA9IHRvcEJveGVzLmNvbmNhdChib3R0b21Cb3hlcyk7XG5cdFx0dmFyIG91dGVyQm94ZXMgPSB2ZXJ0aWNhbEJveGVzLmNvbmNhdChob3Jpem9udGFsQm94ZXMpO1xuXG5cdFx0Ly8gRXNzZW50aWFsbHkgd2Ugbm93IGhhdmUgYW55IG51bWJlciBvZiBib3hlcyBvbiBlYWNoIG9mIHRoZSA0IHNpZGVzLlxuXHRcdC8vIE91ciBjYW52YXMgbG9va3MgbGlrZSB0aGUgZm9sbG93aW5nLlxuXHRcdC8vIFRoZSBhcmVhcyBMMSBhbmQgTDIgYXJlIHRoZSBsZWZ0IGF4ZXMuIFIxIGlzIHRoZSByaWdodCBheGlzLCBUMSBpcyB0aGUgdG9wIGF4aXMgYW5kXG5cdFx0Ly8gQjEgaXMgdGhlIGJvdHRvbSBheGlzXG5cdFx0Ly8gVGhlcmUgYXJlIGFsc28gNCBxdWFkcmFudC1saWtlIGxvY2F0aW9ucyAobGVmdCB0byByaWdodCBpbnN0ZWFkIG9mIGNsb2Nrd2lzZSkgcmVzZXJ2ZWQgZm9yIGNoYXJ0IG92ZXJsYXlzXG5cdFx0Ly8gVGhlc2UgbG9jYXRpb25zIGFyZSBzaW5nbGUtYm94IGxvY2F0aW9ucyBvbmx5LCB3aGVuIHRyeWluZyB0byByZWdpc3RlciBhIGNoYXJ0QXJlYSBsb2NhdGlvbiB0aGF0IGlzIGFscmVhZHkgdGFrZW4sXG5cdFx0Ly8gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG5cdFx0Ly9cblx0XHQvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcblx0XHQvLyB8ICAgICAgICAgICAgICAgICAgVDEgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcblx0XHQvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcblx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgVDIgICAgICAgICAgICAgICAgICB8ICAgIHxcblx0XHQvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcblx0XHQvLyB8ICAgIHwgICAgfCBDMSB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDMiB8ICAgIHxcblx0XHQvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcblx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcblx0XHQvLyB8IEwxIHwgTDIgfCAgICAgICAgICAgQ2hhcnRBcmVhIChDMCkgICAgICAgICAgICB8IFIxIHxcblx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcblx0XHQvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcblx0XHQvLyB8ICAgIHwgICAgfCBDMyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDNCB8ICAgIHxcblx0XHQvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcblx0XHQvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgQjEgICAgICAgICAgICAgICAgICB8ICAgIHxcblx0XHQvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcblx0XHQvLyB8ICAgICAgICAgICAgICAgICAgQjIgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcblx0XHQvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcblx0XHQvL1xuXHRcdC8vIFdoYXQgd2UgZG8gdG8gZmluZCB0aGUgYmVzdCBzaXppbmcsIHdlIGRvIHRoZSBmb2xsb3dpbmdcblx0XHQvLyAxLiBEZXRlcm1pbmUgdGhlIG1pbmltdW0gc2l6ZSBvZiB0aGUgY2hhcnQgYXJlYS5cblx0XHQvLyAyLiBTcGxpdCB0aGUgcmVtYWluaW5nIHdpZHRoIGVxdWFsbHkgYmV0d2VlbiBlYWNoIHZlcnRpY2FsIGF4aXNcblx0XHQvLyAzLiBTcGxpdCB0aGUgcmVtYWluaW5nIGhlaWdodCBlcXVhbGx5IGJldHdlZW4gZWFjaCBob3Jpem9udGFsIGF4aXNcblx0XHQvLyA0LiBHaXZlIGVhY2ggbGF5b3V0IHRoZSBtYXhpbXVtIHNpemUgaXQgY2FuIGJlLiBUaGUgbGF5b3V0IHdpbGwgcmV0dXJuIGl0J3MgbWluaW11bSBzaXplXG5cdFx0Ly8gNS4gQWRqdXN0IHRoZSBzaXplcyBvZiBlYWNoIGF4aXMgYmFzZWQgb24gaXQncyBtaW5pbXVtIHJlcG9ydGVkIHNpemUuXG5cdFx0Ly8gNi4gUmVmaXQgZWFjaCBheGlzXG5cdFx0Ly8gNy4gUG9zaXRpb24gZWFjaCBheGlzIGluIHRoZSBmaW5hbCBsb2NhdGlvblxuXHRcdC8vIDguIFRlbGwgdGhlIGNoYXJ0IHRoZSBmaW5hbCBsb2NhdGlvbiBvZiB0aGUgY2hhcnQgYXJlYVxuXHRcdC8vIDkuIFRlbGwgYW55IGF4ZXMgdGhhdCBvdmVybGF5IHRoZSBjaGFydCBhcmVhIHRoZSBwb3NpdGlvbnMgb2YgdGhlIGNoYXJ0IGFyZWFcblxuXHRcdC8vIFN0ZXAgMVxuXHRcdHZhciBjaGFydFdpZHRoID0gd2lkdGggLSBsZWZ0UGFkZGluZyAtIHJpZ2h0UGFkZGluZztcblx0XHR2YXIgY2hhcnRIZWlnaHQgPSBoZWlnaHQgLSB0b3BQYWRkaW5nIC0gYm90dG9tUGFkZGluZztcblx0XHR2YXIgY2hhcnRBcmVhV2lkdGggPSBjaGFydFdpZHRoIC8gMjsgLy8gbWluIDUwJVxuXG5cdFx0Ly8gU3RlcCAyXG5cdFx0dmFyIHZlcnRpY2FsQm94V2lkdGggPSAod2lkdGggLSBjaGFydEFyZWFXaWR0aCkgLyB2ZXJ0aWNhbEJveGVzLmxlbmd0aDtcblxuXHRcdC8vIFN0ZXAgM1xuXHRcdC8vIFRPRE8gcmUtbGltaXQgaG9yaXpvbnRhbCBheGlzIGhlaWdodCAodGhpcyBsaW1pdCBoYXMgYWZmZWN0ZWQgb25seSBwYWRkaW5nIGNhbGN1bGF0aW9uIHNpbmNlIFBSIDE4MzcpXG5cdFx0Ly8gdmFyIGhvcml6b250YWxCb3hIZWlnaHQgPSAoaGVpZ2h0IC0gY2hhcnRBcmVhSGVpZ2h0KSAvIGhvcml6b250YWxCb3hlcy5sZW5ndGg7XG5cblx0XHQvLyBTdGVwIDRcblx0XHR2YXIgbWF4Q2hhcnRBcmVhV2lkdGggPSBjaGFydFdpZHRoO1xuXHRcdHZhciBtYXhDaGFydEFyZWFIZWlnaHQgPSBjaGFydEhlaWdodDtcblx0XHR2YXIgb3V0ZXJCb3hTaXplcyA9IHt0b3A6IHRvcFBhZGRpbmcsIGxlZnQ6IGxlZnRQYWRkaW5nLCBib3R0b206IGJvdHRvbVBhZGRpbmcsIHJpZ2h0OiByaWdodFBhZGRpbmd9O1xuXHRcdHZhciBtaW5Cb3hTaXplcyA9IFtdO1xuXHRcdHZhciBtYXhQYWRkaW5nO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0TWluaW11bUJveFNpemUoYm94KSB7XG5cdFx0XHR2YXIgbWluU2l6ZTtcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBib3guaXNIb3Jpem9udGFsKCk7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0bWluU2l6ZSA9IGJveC51cGRhdGUoYm94LmZ1bGxXaWR0aCA/IGNoYXJ0V2lkdGggOiBtYXhDaGFydEFyZWFXaWR0aCwgY2hhcnRIZWlnaHQgLyAyKTtcblx0XHRcdFx0bWF4Q2hhcnRBcmVhSGVpZ2h0IC09IG1pblNpemUuaGVpZ2h0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWluU2l6ZSA9IGJveC51cGRhdGUodmVydGljYWxCb3hXaWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0KTtcblx0XHRcdFx0bWF4Q2hhcnRBcmVhV2lkdGggLT0gbWluU2l6ZS53aWR0aDtcblx0XHRcdH1cblxuXHRcdFx0bWluQm94U2l6ZXMucHVzaCh7XG5cdFx0XHRcdGhvcml6b250YWw6IGlzSG9yaXpvbnRhbCxcblx0XHRcdFx0d2lkdGg6IG1pblNpemUud2lkdGgsXG5cdFx0XHRcdGJveDogYm94LFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aGVscGVycyQxLmVhY2gob3V0ZXJCb3hlcywgZ2V0TWluaW11bUJveFNpemUpO1xuXG5cdFx0Ly8gSWYgYSBob3Jpem9udGFsIGJveCBoYXMgcGFkZGluZywgd2UgbW92ZSB0aGUgbGVmdCBib3hlcyBvdmVyIHRvIGF2b2lkIHVnbHkgY2hhcnRzIChzZWUgaXNzdWUgIzI0NzgpXG5cdFx0bWF4UGFkZGluZyA9IGZpbmRNYXhQYWRkaW5nKG91dGVyQm94ZXMpO1xuXG5cdFx0Ly8gQXQgdGhpcyBwb2ludCwgbWF4Q2hhcnRBcmVhSGVpZ2h0IGFuZCBtYXhDaGFydEFyZWFXaWR0aCBhcmUgdGhlIHNpemUgdGhlIGNoYXJ0IGFyZWEgY291bGRcblx0XHQvLyBiZSBpZiB0aGUgYXhlcyBhcmUgZHJhd24gYXQgdGhlaXIgbWluaW11bSBzaXplcy5cblx0XHQvLyBTdGVwcyA1ICYgNlxuXG5cdFx0Ly8gRnVuY3Rpb24gdG8gZml0IGEgYm94XG5cdFx0ZnVuY3Rpb24gZml0Qm94KGJveCkge1xuXHRcdFx0dmFyIG1pbkJveFNpemUgPSBoZWxwZXJzJDEuZmluZE5leHRXaGVyZShtaW5Cb3hTaXplcywgZnVuY3Rpb24obWluQm94KSB7XG5cdFx0XHRcdHJldHVybiBtaW5Cb3guYm94ID09PSBib3g7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKG1pbkJveFNpemUpIHtcblx0XHRcdFx0aWYgKG1pbkJveFNpemUuaG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdHZhciBzY2FsZU1hcmdpbiA9IHtcblx0XHRcdFx0XHRcdGxlZnQ6IE1hdGgubWF4KG91dGVyQm94U2l6ZXMubGVmdCwgbWF4UGFkZGluZy5sZWZ0KSxcblx0XHRcdFx0XHRcdHJpZ2h0OiBNYXRoLm1heChvdXRlckJveFNpemVzLnJpZ2h0LCBtYXhQYWRkaW5nLnJpZ2h0KSxcblx0XHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRcdGJvdHRvbTogMFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvLyBEb24ndCB1c2UgbWluIHNpemUgaGVyZSBiZWNhdXNlIG9mIGxhYmVsIHJvdGF0aW9uLiBXaGVuIHRoZSBsYWJlbHMgYXJlIHJvdGF0ZWQsIHRoZWlyIHJvdGF0aW9uIGhpZ2hseSBkZXBlbmRzXG5cdFx0XHRcdFx0Ly8gb24gdGhlIG1hcmdpbi4gU29tZXRpbWVzIHRoZXkgbmVlZCB0byBpbmNyZWFzZSBpbiBzaXplIHNsaWdodGx5XG5cdFx0XHRcdFx0Ym94LnVwZGF0ZShib3guZnVsbFdpZHRoID8gY2hhcnRXaWR0aCA6IG1heENoYXJ0QXJlYVdpZHRoLCBjaGFydEhlaWdodCAvIDIsIHNjYWxlTWFyZ2luKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRib3gudXBkYXRlKG1pbkJveFNpemUud2lkdGgsIG1heENoYXJ0QXJlYUhlaWdodCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBVcGRhdGUsIGFuZCBjYWxjdWxhdGUgdGhlIGxlZnQgYW5kIHJpZ2h0IG1hcmdpbnMgZm9yIHRoZSBob3Jpem9udGFsIGJveGVzXG5cdFx0aGVscGVycyQxLmVhY2godmVydGljYWxCb3hlcywgZml0Qm94KTtcblx0XHRhZGRTaXplQnlQb3NpdGlvbih2ZXJ0aWNhbEJveGVzLCBvdXRlckJveFNpemVzKTtcblxuXHRcdC8vIFNldCB0aGUgTGVmdCBhbmQgUmlnaHQgbWFyZ2lucyBmb3IgdGhlIGhvcml6b250YWwgYm94ZXNcblx0XHRoZWxwZXJzJDEuZWFjaChob3Jpem9udGFsQm94ZXMsIGZpdEJveCk7XG5cdFx0YWRkU2l6ZUJ5UG9zaXRpb24oaG9yaXpvbnRhbEJveGVzLCBvdXRlckJveFNpemVzKTtcblxuXHRcdGZ1bmN0aW9uIGZpbmFsRml0VmVydGljYWxCb3goYm94KSB7XG5cdFx0XHR2YXIgbWluQm94U2l6ZSA9IGhlbHBlcnMkMS5maW5kTmV4dFdoZXJlKG1pbkJveFNpemVzLCBmdW5jdGlvbihtaW5TaXplKSB7XG5cdFx0XHRcdHJldHVybiBtaW5TaXplLmJveCA9PT0gYm94O1xuXHRcdFx0fSk7XG5cblx0XHRcdHZhciBzY2FsZU1hcmdpbiA9IHtcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdHRvcDogb3V0ZXJCb3hTaXplcy50b3AsXG5cdFx0XHRcdGJvdHRvbTogb3V0ZXJCb3hTaXplcy5ib3R0b21cblx0XHRcdH07XG5cblx0XHRcdGlmIChtaW5Cb3hTaXplKSB7XG5cdFx0XHRcdGJveC51cGRhdGUobWluQm94U2l6ZS53aWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0LCBzY2FsZU1hcmdpbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTGV0IHRoZSBsZWZ0IGxheW91dCBrbm93IHRoZSBmaW5hbCBtYXJnaW5cblx0XHRoZWxwZXJzJDEuZWFjaCh2ZXJ0aWNhbEJveGVzLCBmaW5hbEZpdFZlcnRpY2FsQm94KTtcblxuXHRcdC8vIFJlY2FsY3VsYXRlIGJlY2F1c2UgdGhlIHNpemUgb2YgZWFjaCBsYXlvdXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNsaWdodGx5IGR1ZSB0byB0aGUgbWFyZ2lucyAobGFiZWwgcm90YXRpb24gZm9yIGluc3RhbmNlKVxuXHRcdG91dGVyQm94U2l6ZXMgPSB7dG9wOiB0b3BQYWRkaW5nLCBsZWZ0OiBsZWZ0UGFkZGluZywgYm90dG9tOiBib3R0b21QYWRkaW5nLCByaWdodDogcmlnaHRQYWRkaW5nfTtcblx0XHRhZGRTaXplQnlQb3NpdGlvbihvdXRlckJveGVzLCBvdXRlckJveFNpemVzKTtcblxuXHRcdC8vIFdlIG1heSBiZSBhZGRpbmcgc29tZSBwYWRkaW5nIHRvIGFjY291bnQgZm9yIHJvdGF0ZWQgeCBheGlzIGxhYmVsc1xuXHRcdHZhciBsZWZ0UGFkZGluZ0FkZGl0aW9uID0gTWF0aC5tYXgobWF4UGFkZGluZy5sZWZ0IC0gb3V0ZXJCb3hTaXplcy5sZWZ0LCAwKTtcblx0XHRvdXRlckJveFNpemVzLmxlZnQgKz0gbGVmdFBhZGRpbmdBZGRpdGlvbjtcblx0XHRvdXRlckJveFNpemVzLnJpZ2h0ICs9IE1hdGgubWF4KG1heFBhZGRpbmcucmlnaHQgLSBvdXRlckJveFNpemVzLnJpZ2h0LCAwKTtcblxuXHRcdHZhciB0b3BQYWRkaW5nQWRkaXRpb24gPSBNYXRoLm1heChtYXhQYWRkaW5nLnRvcCAtIG91dGVyQm94U2l6ZXMudG9wLCAwKTtcblx0XHRvdXRlckJveFNpemVzLnRvcCArPSB0b3BQYWRkaW5nQWRkaXRpb247XG5cdFx0b3V0ZXJCb3hTaXplcy5ib3R0b20gKz0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20gLSBvdXRlckJveFNpemVzLmJvdHRvbSwgMCk7XG5cblx0XHQvLyBGaWd1cmUgb3V0IGlmIG91ciBjaGFydCBhcmVhIGNoYW5nZWQuIFRoaXMgd291bGQgb2NjdXIgaWYgdGhlIGRhdGFzZXQgbGF5b3V0IGxhYmVsIHJvdGF0aW9uXG5cdFx0Ly8gY2hhbmdlZCBkdWUgdG8gdGhlIGFwcGxpY2F0aW9uIG9mIHRoZSBtYXJnaW5zIGluIHN0ZXAgNi4gU2luY2Ugd2UgY2FuIG9ubHkgZ2V0IGJpZ2dlciwgdGhpcyBpcyBzYWZlIHRvIGRvXG5cdFx0Ly8gd2l0aG91dCBjYWxsaW5nIGBmaXRgIGFnYWluXG5cdFx0dmFyIG5ld01heENoYXJ0QXJlYUhlaWdodCA9IGhlaWdodCAtIG91dGVyQm94U2l6ZXMudG9wIC0gb3V0ZXJCb3hTaXplcy5ib3R0b207XG5cdFx0dmFyIG5ld01heENoYXJ0QXJlYVdpZHRoID0gd2lkdGggLSBvdXRlckJveFNpemVzLmxlZnQgLSBvdXRlckJveFNpemVzLnJpZ2h0O1xuXG5cdFx0aWYgKG5ld01heENoYXJ0QXJlYVdpZHRoICE9PSBtYXhDaGFydEFyZWFXaWR0aCB8fCBuZXdNYXhDaGFydEFyZWFIZWlnaHQgIT09IG1heENoYXJ0QXJlYUhlaWdodCkge1xuXHRcdFx0aGVscGVycyQxLmVhY2godmVydGljYWxCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdGJveC5oZWlnaHQgPSBuZXdNYXhDaGFydEFyZWFIZWlnaHQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2goaG9yaXpvbnRhbEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0aWYgKCFib3guZnVsbFdpZHRoKSB7XG5cdFx0XHRcdFx0Ym94LndpZHRoID0gbmV3TWF4Q2hhcnRBcmVhV2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRtYXhDaGFydEFyZWFIZWlnaHQgPSBuZXdNYXhDaGFydEFyZWFIZWlnaHQ7XG5cdFx0XHRtYXhDaGFydEFyZWFXaWR0aCA9IG5ld01heENoYXJ0QXJlYVdpZHRoO1xuXHRcdH1cblxuXHRcdC8vIFN0ZXAgNyAtIFBvc2l0aW9uIHRoZSBib3hlc1xuXHRcdHZhciBsZWZ0ID0gbGVmdFBhZGRpbmcgKyBsZWZ0UGFkZGluZ0FkZGl0aW9uO1xuXHRcdHZhciB0b3AgPSB0b3BQYWRkaW5nICsgdG9wUGFkZGluZ0FkZGl0aW9uO1xuXG5cdFx0ZnVuY3Rpb24gcGxhY2VCb3goYm94KSB7XG5cdFx0XHRpZiAoYm94LmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdGJveC5sZWZ0ID0gYm94LmZ1bGxXaWR0aCA/IGxlZnRQYWRkaW5nIDogb3V0ZXJCb3hTaXplcy5sZWZ0O1xuXHRcdFx0XHRib3gucmlnaHQgPSBib3guZnVsbFdpZHRoID8gd2lkdGggLSByaWdodFBhZGRpbmcgOiBvdXRlckJveFNpemVzLmxlZnQgKyBtYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdFx0Ym94LnRvcCA9IHRvcDtcblx0XHRcdFx0Ym94LmJvdHRvbSA9IHRvcCArIGJveC5oZWlnaHQ7XG5cblx0XHRcdFx0Ly8gTW92ZSB0byBuZXh0IHBvaW50XG5cdFx0XHRcdHRvcCA9IGJveC5ib3R0b207XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ym94LmxlZnQgPSBsZWZ0O1xuXHRcdFx0XHRib3gucmlnaHQgPSBsZWZ0ICsgYm94LndpZHRoO1xuXHRcdFx0XHRib3gudG9wID0gb3V0ZXJCb3hTaXplcy50b3A7XG5cdFx0XHRcdGJveC5ib3R0b20gPSBvdXRlckJveFNpemVzLnRvcCArIG1heENoYXJ0QXJlYUhlaWdodDtcblxuXHRcdFx0XHQvLyBNb3ZlIHRvIG5leHQgcG9pbnRcblx0XHRcdFx0bGVmdCA9IGJveC5yaWdodDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoZWxwZXJzJDEuZWFjaChsZWZ0Qm94ZXMuY29uY2F0KHRvcEJveGVzKSwgcGxhY2VCb3gpO1xuXG5cdFx0Ly8gQWNjb3VudCBmb3IgY2hhcnQgd2lkdGggYW5kIGhlaWdodFxuXHRcdGxlZnQgKz0gbWF4Q2hhcnRBcmVhV2lkdGg7XG5cdFx0dG9wICs9IG1heENoYXJ0QXJlYUhlaWdodDtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHJpZ2h0Qm94ZXMsIHBsYWNlQm94KTtcblx0XHRoZWxwZXJzJDEuZWFjaChib3R0b21Cb3hlcywgcGxhY2VCb3gpO1xuXG5cdFx0Ly8gU3RlcCA4XG5cdFx0Y2hhcnQuY2hhcnRBcmVhID0ge1xuXHRcdFx0bGVmdDogb3V0ZXJCb3hTaXplcy5sZWZ0LFxuXHRcdFx0dG9wOiBvdXRlckJveFNpemVzLnRvcCxcblx0XHRcdHJpZ2h0OiBvdXRlckJveFNpemVzLmxlZnQgKyBtYXhDaGFydEFyZWFXaWR0aCxcblx0XHRcdGJvdHRvbTogb3V0ZXJCb3hTaXplcy50b3AgKyBtYXhDaGFydEFyZWFIZWlnaHRcblx0XHR9O1xuXG5cdFx0Ly8gU3RlcCA5XG5cdFx0aGVscGVycyQxLmVhY2goY2hhcnRBcmVhQm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0Ym94LmxlZnQgPSBjaGFydC5jaGFydEFyZWEubGVmdDtcblx0XHRcdGJveC50b3AgPSBjaGFydC5jaGFydEFyZWEudG9wO1xuXHRcdFx0Ym94LnJpZ2h0ID0gY2hhcnQuY2hhcnRBcmVhLnJpZ2h0O1xuXHRcdFx0Ym94LmJvdHRvbSA9IGNoYXJ0LmNoYXJ0QXJlYS5ib3R0b207XG5cblx0XHRcdGJveC51cGRhdGUobWF4Q2hhcnRBcmVhV2lkdGgsIG1heENoYXJ0QXJlYUhlaWdodCk7XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8qKlxuICogUGxhdGZvcm0gZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gKG1pbmltYWwpLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1OTEjaXNzdWVjb21tZW50LTMxOTU3NTkzOVxuICovXG5cbnZhciBwbGF0Zm9ybV9iYXNpYyA9IHtcblx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG5cdFx0XHRpdGVtID0gaXRlbS5jYW52YXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XG5cdH1cbn07XG5cbnZhciBwbGF0Zm9ybV9kb20gPSBcIi8qXFxuICogRE9NIGVsZW1lbnQgcmVuZGVyaW5nIGRldGVjdGlvblxcbiAqIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL2RldGVjdC1ub2RlLWluc2VydGlvblxcbiAqL1xcbkBrZXlmcmFtZXMgY2hhcnRqcy1yZW5kZXItYW5pbWF0aW9uIHtcXG5cXHRmcm9tIHsgb3BhY2l0eTogMC45OTsgfVxcblxcdHRvIHsgb3BhY2l0eTogMTsgfVxcbn1cXG5cXG4uY2hhcnRqcy1yZW5kZXItbW9uaXRvciB7XFxuXFx0YW5pbWF0aW9uOiBjaGFydGpzLXJlbmRlci1hbmltYXRpb24gMC4wMDFzO1xcbn1cXG5cXG4vKlxcbiAqIERPTSBlbGVtZW50IHJlc2l6aW5nIGRldGVjdGlvblxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjai9jc3MtZWxlbWVudC1xdWVyaWVzXFxuICovXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLFxcbi5jaGFydGpzLXNpemUtbW9uaXRvci1leHBhbmQsXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLXNocmluayB7XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdGRpcmVjdGlvbjogbHRyO1xcblxcdGxlZnQ6IDA7XFxuXFx0dG9wOiAwO1xcblxcdHJpZ2h0OiAwO1xcblxcdGJvdHRvbTogMDtcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcblxcdHZpc2liaWxpdHk6IGhpZGRlbjtcXG5cXHR6LWluZGV4OiAtMTtcXG59XFxuXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLWV4cGFuZCA+IGRpdiB7XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdHdpZHRoOiAxMDAwMDAwcHg7XFxuXFx0aGVpZ2h0OiAxMDAwMDAwcHg7XFxuXFx0bGVmdDogMDtcXG5cXHR0b3A6IDA7XFxufVxcblxcbi5jaGFydGpzLXNpemUtbW9uaXRvci1zaHJpbmsgPiBkaXYge1xcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHR3aWR0aDogMjAwJTtcXG5cXHRoZWlnaHQ6IDIwMCU7XFxuXFx0bGVmdDogMDtcXG5cXHR0b3A6IDA7XFxufVxcblwiO1xuXG52YXIgcGxhdGZvcm1fZG9tJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5kZWZhdWx0OiBwbGF0Zm9ybV9kb21cbn0pO1xuXG5mdW5jdGlvbiBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlIChuKSB7XG5cdHJldHVybiBuICYmIG4uZGVmYXVsdCB8fCBuO1xufVxuXG52YXIgc3R5bGVzaGVldCA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UocGxhdGZvcm1fZG9tJDEpO1xuXG52YXIgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xudmFyIENTU19QUkVGSVggPSAnY2hhcnRqcy0nO1xudmFyIENTU19TSVpFX01PTklUT1IgPSBDU1NfUFJFRklYICsgJ3NpemUtbW9uaXRvcic7XG52YXIgQ1NTX1JFTkRFUl9NT05JVE9SID0gQ1NTX1BSRUZJWCArICdyZW5kZXItbW9uaXRvcic7XG52YXIgQ1NTX1JFTkRFUl9BTklNQVRJT04gPSBDU1NfUFJFRklYICsgJ3JlbmRlci1hbmltYXRpb24nO1xudmFyIEFOSU1BVElPTl9TVEFSVF9FVkVOVFMgPSBbJ2FuaW1hdGlvbnN0YXJ0JywgJ3dlYmtpdEFuaW1hdGlvblN0YXJ0J107XG5cbi8qKlxuICogRE9NIGV2ZW50IHR5cGVzIC0+IENoYXJ0LmpzIGV2ZW50IHR5cGVzLlxuICogTm90ZTogb25seSBldmVudHMgd2l0aCBkaWZmZXJlbnQgdHlwZXMgYXJlIG1hcHBlZC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzXG4gKi9cbnZhciBFVkVOVF9UWVBFUyA9IHtcblx0dG91Y2hzdGFydDogJ21vdXNlZG93bicsXG5cdHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG5cdHRvdWNoZW5kOiAnbW91c2V1cCcsXG5cdHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuXHRwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG5cdHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcblx0cG9pbnRlcnVwOiAnbW91c2V1cCcsXG5cdHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0Jyxcblx0cG9pbnRlcm91dDogJ21vdXNlb3V0J1xufTtcblxuLyoqXG4gKiBUaGUgXCJ1c2VkXCIgc2l6ZSBpcyB0aGUgZmluYWwgdmFsdWUgb2YgYSBkaW1lbnNpb24gcHJvcGVydHkgYWZ0ZXIgYWxsIGNhbGN1bGF0aW9ucyBoYXZlXG4gKiBiZWVuIHBlcmZvcm1lZC4gVGhpcyBtZXRob2QgdXNlcyB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgYGVsZW1lbnRgIGJ1dCByZXR1cm5zIHVuZGVmaW5lZFxuICogaWYgdGhlIGNvbXB1dGVkIHN0eWxlIGlzIG5vdCBleHByZXNzZWQgaW4gcGl4ZWxzLiBUaGF0IGNhbiBoYXBwZW4gaW4gc29tZSBjYXNlcyB3aGVyZVxuICogYGVsZW1lbnRgIGhhcyBhIHNpemUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBhbmQgdGhpcyBsYXN0IG9uZSBpcyBub3QgeWV0IGRpc3BsYXllZCxcbiAqIGZvciBleGFtcGxlIGJlY2F1c2Ugb2YgYGRpc3BsYXk6IG5vbmVgIG9uIGEgcGFyZW50IG5vZGUuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy91c2VkX3ZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaXplIGluIHBpeGVscyBvciB1bmRlZmluZWQgaWYgdW5rbm93bi5cbiAqL1xuZnVuY3Rpb24gcmVhZFVzZWRTaXplKGVsZW1lbnQsIHByb3BlcnR5KSB7XG5cdHZhciB2YWx1ZSA9IGhlbHBlcnMkMS5nZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XG5cdHZhciBtYXRjaGVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL14oXFxkKykoXFwuXFxkKyk/cHgkLyk7XG5cdHJldHVybiBtYXRjaGVzID8gTnVtYmVyKG1hdGNoZXNbMV0pIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBjYW52YXMgc3R5bGUgYW5kIHJlbmRlciBzaXplIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBjYW52YXMgZGlzcGxheSBzaXplLFxuICogc2luY2UgcmVzcG9uc2l2ZW5lc3MgaXMgaGFuZGxlZCBieSB0aGUgY29udHJvbGxlci5yZXNpemUoKSBtZXRob2QuIFRoZSBjb25maWcgaXMgdXNlZFxuICogdG8gZGV0ZXJtaW5lIHRoZSBhc3BlY3QgcmF0aW8gdG8gYXBwbHkgaW4gY2FzZSBubyBleHBsaWNpdCBoZWlnaHQgaGFzIGJlZW4gc3BlY2lmaWVkLlxuICovXG5mdW5jdGlvbiBpbml0Q2FudmFzKGNhbnZhcywgY29uZmlnKSB7XG5cdHZhciBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcblxuXHQvLyBOT1RFKFNCKSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpICE9PSBjYW52YXMud2lkdGg6IGluIHRoZSBmaXJzdCBjYXNlIGl0XG5cdC8vIHJldHVybnMgbnVsbCBvciAnJyBpZiBubyBleHBsaWNpdCB2YWx1ZSBoYXMgYmVlbiBzZXQgdG8gdGhlIGNhbnZhcyBhdHRyaWJ1dGUuXG5cdHZhciByZW5kZXJIZWlnaHQgPSBjYW52YXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcblx0dmFyIHJlbmRlcldpZHRoID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcblxuXHQvLyBDaGFydC5qcyBtb2RpZmllcyBzb21lIGNhbnZhcyB2YWx1ZXMgdGhhdCB3ZSB3YW50IHRvIHJlc3RvcmUgb24gZGVzdHJveVxuXHRjYW52YXNbRVhQQU5ET19LRVldID0ge1xuXHRcdGluaXRpYWw6IHtcblx0XHRcdGhlaWdodDogcmVuZGVySGVpZ2h0LFxuXHRcdFx0d2lkdGg6IHJlbmRlcldpZHRoLFxuXHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0ZGlzcGxheTogc3R5bGUuZGlzcGxheSxcblx0XHRcdFx0aGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG5cdFx0XHRcdHdpZHRoOiBzdHlsZS53aWR0aFxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyBGb3JjZSBjYW52YXMgdG8gZGlzcGxheSBhcyBibG9jayB0byBhdm9pZCBleHRyYSBzcGFjZSBjYXVzZWQgYnkgaW5saW5lXG5cdC8vIGVsZW1lbnRzLCB3aGljaCB3b3VsZCBpbnRlcmZlcmUgd2l0aCB0aGUgcmVzcG9uc2l2ZSByZXNpemUgcHJvY2Vzcy5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI1Mzhcblx0c3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcblxuXHRpZiAocmVuZGVyV2lkdGggPT09IG51bGwgfHwgcmVuZGVyV2lkdGggPT09ICcnKSB7XG5cdFx0dmFyIGRpc3BsYXlXaWR0aCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICd3aWR0aCcpO1xuXHRcdGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2FudmFzLndpZHRoID0gZGlzcGxheVdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdGlmIChyZW5kZXJIZWlnaHQgPT09IG51bGwgfHwgcmVuZGVySGVpZ2h0ID09PSAnJykge1xuXHRcdGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuXHRcdFx0Ly8gSWYgbm8gZXhwbGljaXQgcmVuZGVyIGhlaWdodCBhbmQgc3R5bGUgaGVpZ2h0LCBsZXQncyBhcHBseSB0aGUgYXNwZWN0IHJhdGlvLFxuXHRcdFx0Ly8gd2hpY2ggb25lIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgYnV0IGFsc28gYnkgY2hhcnRzIGFzIGRlZmF1bHQgb3B0aW9uXG5cdFx0XHQvLyAoaS5lLiBvcHRpb25zLmFzcGVjdFJhdGlvKS4gSWYgbm90IHNwZWNpZmllZCwgdXNlIGNhbnZhcyBhc3BlY3QgcmF0aW8gb2YgMi5cblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoY29uZmlnLm9wdGlvbnMuYXNwZWN0UmF0aW8gfHwgMik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkaXNwbGF5SGVpZ2h0ID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ2hlaWdodCcpO1xuXHRcdFx0aWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjYW52YXM7XG59XG5cbi8qKlxuICogRGV0ZWN0cyBzdXBwb3J0IGZvciBvcHRpb25zIG9iamVjdCBhcmd1bWVudCBpbiBhZGRFdmVudExpc3RlbmVyLlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuICogQHByaXZhdGVcbiAqL1xudmFyIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBzdXBwb3J0cyA9IGZhbHNlO1xuXHR0cnkge1xuXHRcdHZhciBvcHRpb25zID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnZXR0ZXItcmV0dXJuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzdXBwb3J0cyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2UnLCBudWxsLCBvcHRpb25zKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3Jcblx0fVxuXHRyZXR1cm4gc3VwcG9ydHM7XG59KCkpO1xuXG4vLyBEZWZhdWx0IHBhc3NpdmUgdG8gdHJ1ZSBhcyBleHBlY3RlZCBieSBDaHJvbWUgZm9yICd0b3VjaHN0YXJ0JyBhbmQgJ3RvdWNoZW5kJyBldmVudHMuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDI4N1xudmFyIGV2ZW50TGlzdGVuZXJPcHRpb25zID0gc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlO1xuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuXHRub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcblx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50KHR5cGUsIGNoYXJ0LCB4LCB5LCBuYXRpdmVFdmVudCkge1xuXHRyZXR1cm4ge1xuXHRcdHR5cGU6IHR5cGUsXG5cdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdG5hdGl2ZTogbmF0aXZlRXZlbnQgfHwgbnVsbCxcblx0XHR4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcblx0XHR5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcblx0fTtcbn1cblxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuXHR2YXIgdHlwZSA9IEVWRU5UX1RZUEVTW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XG5cdHZhciBwb3MgPSBoZWxwZXJzJDEuZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuXHRyZXR1cm4gY3JlYXRlRXZlbnQodHlwZSwgY2hhcnQsIHBvcy54LCBwb3MueSwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiB0aHJvdHRsZWQoZm4sIHRoaXNBcmcpIHtcblx0dmFyIHRpY2tpbmcgPSBmYWxzZTtcblx0dmFyIGFyZ3MgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0dGhpc0FyZyA9IHRoaXNBcmcgfHwgdGhpcztcblxuXHRcdGlmICghdGlja2luZykge1xuXHRcdFx0dGlja2luZyA9IHRydWU7XG5cdFx0XHRoZWxwZXJzJDEucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRpY2tpbmcgPSBmYWxzZTtcblx0XHRcdFx0Zm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURpdihjbHMpIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdGVsLmNsYXNzTmFtZSA9IGNscyB8fCAnJztcblx0cmV0dXJuIGVsO1xufVxuXG4vLyBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbWFyY2ovY3NzLWVsZW1lbnQtcXVlcmllc1xuZnVuY3Rpb24gY3JlYXRlUmVzaXplcihoYW5kbGVyKSB7XG5cdHZhciBtYXhTaXplID0gMTAwMDAwMDtcblxuXHQvLyBOT1RFKFNCKSBEb24ndCB1c2UgaW5uZXJIVE1MIGJlY2F1c2UgaXQgY291bGQgYmUgY29uc2lkZXJlZCB1bnNhZmUuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81OTAyXG5cdHZhciByZXNpemVyID0gY3JlYXRlRGl2KENTU19TSVpFX01PTklUT1IpO1xuXHR2YXIgZXhwYW5kID0gY3JlYXRlRGl2KENTU19TSVpFX01PTklUT1IgKyAnLWV4cGFuZCcpO1xuXHR2YXIgc2hyaW5rID0gY3JlYXRlRGl2KENTU19TSVpFX01PTklUT1IgKyAnLXNocmluaycpO1xuXG5cdGV4cGFuZC5hcHBlbmRDaGlsZChjcmVhdGVEaXYoKSk7XG5cdHNocmluay5hcHBlbmRDaGlsZChjcmVhdGVEaXYoKSk7XG5cblx0cmVzaXplci5hcHBlbmRDaGlsZChleHBhbmQpO1xuXHRyZXNpemVyLmFwcGVuZENoaWxkKHNocmluayk7XG5cdHJlc2l6ZXIuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0ZXhwYW5kLnNjcm9sbExlZnQgPSBtYXhTaXplO1xuXHRcdGV4cGFuZC5zY3JvbGxUb3AgPSBtYXhTaXplO1xuXHRcdHNocmluay5zY3JvbGxMZWZ0ID0gbWF4U2l6ZTtcblx0XHRzaHJpbmsuc2Nyb2xsVG9wID0gbWF4U2l6ZTtcblx0fTtcblxuXHR2YXIgb25TY3JvbGwgPSBmdW5jdGlvbigpIHtcblx0XHRyZXNpemVyLl9yZXNldCgpO1xuXHRcdGhhbmRsZXIoKTtcblx0fTtcblxuXHRhZGRMaXN0ZW5lcihleHBhbmQsICdzY3JvbGwnLCBvblNjcm9sbC5iaW5kKGV4cGFuZCwgJ2V4cGFuZCcpKTtcblx0YWRkTGlzdGVuZXIoc2hyaW5rLCAnc2Nyb2xsJywgb25TY3JvbGwuYmluZChzaHJpbmssICdzaHJpbmsnKSk7XG5cblx0cmV0dXJuIHJlc2l6ZXI7XG59XG5cbi8vIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL2RldGVjdC1ub2RlLWluc2VydGlvblxuZnVuY3Rpb24gd2F0Y2hGb3JSZW5kZXIobm9kZSwgaGFuZGxlcikge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IChub2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcblx0dmFyIHByb3h5ID0gZXhwYW5kby5yZW5kZXJQcm94eSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5hbmltYXRpb25OYW1lID09PSBDU1NfUkVOREVSX0FOSU1BVElPTikge1xuXHRcdFx0aGFuZGxlcigpO1xuXHRcdH1cblx0fTtcblxuXHRoZWxwZXJzJDEuZWFjaChBTklNQVRJT05fU1RBUlRfRVZFTlRTLCBmdW5jdGlvbih0eXBlKSB7XG5cdFx0YWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgcHJveHkpO1xuXHR9KTtcblxuXHQvLyAjNDczNzogQ2hyb21lIG1pZ2h0IHNraXAgdGhlIENTUyBhbmltYXRpb24gd2hlbiB0aGUgQ1NTX1JFTkRFUl9NT05JVE9SIGNsYXNzXG5cdC8vIGlzIHJlbW92ZWQgdGhlbiBhZGRlZCBiYWNrIGltbWVkaWF0ZWx5IChzYW1lIGFuaW1hdGlvbiBmcmFtZT8pLiBBY2Nlc3NpbmcgdGhlXG5cdC8vIGBvZmZzZXRQYXJlbnRgIHByb3BlcnR5IHdpbGwgZm9yY2UgYSByZWZsb3cgYW5kIHJlLWV2YWx1YXRlIHRoZSBDU1MgYW5pbWF0aW9uLlxuXHQvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvNWQ1MmZiMDgxYjM1NzBjODFlM2EjYm94LW1ldHJpY3Ncblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQ3Mzdcblx0ZXhwYW5kby5yZWZsb3cgPSAhIW5vZGUub2Zmc2V0UGFyZW50O1xuXG5cdG5vZGUuY2xhc3NMaXN0LmFkZChDU1NfUkVOREVSX01PTklUT1IpO1xufVxuXG5mdW5jdGlvbiB1bndhdGNoRm9yUmVuZGVyKG5vZGUpIHtcblx0dmFyIGV4cGFuZG8gPSBub2RlW0VYUEFORE9fS0VZXSB8fCB7fTtcblx0dmFyIHByb3h5ID0gZXhwYW5kby5yZW5kZXJQcm94eTtcblxuXHRpZiAocHJveHkpIHtcblx0XHRoZWxwZXJzJDEuZWFjaChBTklNQVRJT05fU1RBUlRfRVZFTlRTLCBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRyZW1vdmVMaXN0ZW5lcihub2RlLCB0eXBlLCBwcm94eSk7XG5cdFx0fSk7XG5cblx0XHRkZWxldGUgZXhwYW5kby5yZW5kZXJQcm94eTtcblx0fVxuXG5cdG5vZGUuY2xhc3NMaXN0LnJlbW92ZShDU1NfUkVOREVSX01PTklUT1IpO1xufVxuXG5mdW5jdGlvbiBhZGRSZXNpemVMaXN0ZW5lcihub2RlLCBsaXN0ZW5lciwgY2hhcnQpIHtcblx0dmFyIGV4cGFuZG8gPSBub2RlW0VYUEFORE9fS0VZXSB8fCAobm9kZVtFWFBBTkRPX0tFWV0gPSB7fSk7XG5cblx0Ly8gTGV0J3Mga2VlcCB0cmFjayBvZiB0aGlzIGFkZGVkIHJlc2l6ZXIgYW5kIHRodXMgYXZvaWQgRE9NIHF1ZXJ5IHdoZW4gcmVtb3ZpbmcgaXQuXG5cdHZhciByZXNpemVyID0gZXhwYW5kby5yZXNpemVyID0gY3JlYXRlUmVzaXplcih0aHJvdHRsZWQoZnVuY3Rpb24oKSB7XG5cdFx0aWYgKGV4cGFuZG8ucmVzaXplcikge1xuXHRcdFx0dmFyIGNvbnRhaW5lciA9IGNoYXJ0Lm9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBub2RlLnBhcmVudE5vZGU7XG5cdFx0XHR2YXIgdyA9IGNvbnRhaW5lciA/IGNvbnRhaW5lci5jbGllbnRXaWR0aCA6IDA7XG5cdFx0XHRsaXN0ZW5lcihjcmVhdGVFdmVudCgncmVzaXplJywgY2hhcnQpKTtcblx0XHRcdGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLmNsaWVudFdpZHRoIDwgdyAmJiBjaGFydC5jYW52YXMpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIGNvbnRhaW5lciBzaXplIHNocmFuayBkdXJpbmcgY2hhcnQgcmVzaXplLCBsZXQncyBhc3N1bWVcblx0XHRcdFx0Ly8gc2Nyb2xsYmFyIGFwcGVhcmVkLiBTbyB3ZSByZXNpemUgYWdhaW4gd2l0aCB0aGUgc2Nyb2xsYmFyIHZpc2libGUgLVxuXHRcdFx0XHQvLyBlZmZlY3RpdmVseSBtYWtpbmcgY2hhcnQgc21hbGxlciBhbmQgdGhlIHNjcm9sbGJhciBoaWRkZW4gYWdhaW4uXG5cdFx0XHRcdC8vIEJlY2F1c2Ugd2UgYXJlIGluc2lkZSBgdGhyb3R0bGVkYCwgYW5kIGN1cnJlbnRseSBgdGlja2luZ2AsIHNjcm9sbFxuXHRcdFx0XHQvLyBldmVudHMgYXJlIGlnbm9yZWQgZHVyaW5nIHRoaXMgd2hvbGUgMiByZXNpemUgcHJvY2Vzcy5cblx0XHRcdFx0Ly8gSWYgd2UgYXNzdW1lZCB3cm9uZyBhbmQgc29tZXRoaW5nIGVsc2UgaGFwcGVuZWQsIHdlIGFyZSByZXNpemluZ1xuXHRcdFx0XHQvLyB0d2ljZSBpbiBhIGZyYW1lIChwb3RlbnRpYWwgcGVyZm9ybWFuY2UgaXNzdWUpXG5cdFx0XHRcdGxpc3RlbmVyKGNyZWF0ZUV2ZW50KCdyZXNpemUnLCBjaGFydCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSkpO1xuXG5cdC8vIFRoZSByZXNpemVyIG5lZWRzIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBub2RlIHBhcmVudCwgc28gd2UgZmlyc3QgbmVlZCB0byBiZVxuXHQvLyBzdXJlIHRoYXQgYG5vZGVgIGlzIGF0dGFjaGVkIHRvIHRoZSBET00gYmVmb3JlIGluamVjdGluZyB0aGUgcmVzaXplciBlbGVtZW50LlxuXHR3YXRjaEZvclJlbmRlcihub2RlLCBmdW5jdGlvbigpIHtcblx0XHRpZiAoZXhwYW5kby5yZXNpemVyKSB7XG5cdFx0XHR2YXIgY29udGFpbmVyID0gbm9kZS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIgIT09IHJlc2l6ZXIucGFyZW50Tm9kZSkge1xuXHRcdFx0XHRjb250YWluZXIuaW5zZXJ0QmVmb3JlKHJlc2l6ZXIsIGNvbnRhaW5lci5maXJzdENoaWxkKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGNvbnRhaW5lciBzaXplIG1pZ2h0IGhhdmUgY2hhbmdlZCwgbGV0J3MgcmVzZXQgdGhlIHJlc2l6ZXIgc3RhdGUuXG5cdFx0XHRyZXNpemVyLl9yZXNldCgpO1xuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVJlc2l6ZUxpc3RlbmVyKG5vZGUpIHtcblx0dmFyIGV4cGFuZG8gPSBub2RlW0VYUEFORE9fS0VZXSB8fCB7fTtcblx0dmFyIHJlc2l6ZXIgPSBleHBhbmRvLnJlc2l6ZXI7XG5cblx0ZGVsZXRlIGV4cGFuZG8ucmVzaXplcjtcblx0dW53YXRjaEZvclJlbmRlcihub2RlKTtcblxuXHRpZiAocmVzaXplciAmJiByZXNpemVyLnBhcmVudE5vZGUpIHtcblx0XHRyZXNpemVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVzaXplcik7XG5cdH1cbn1cblxuZnVuY3Rpb24gaW5qZWN0Q1NTKHBsYXRmb3JtLCBjc3MpIHtcblx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM5MjIxMzlcblx0dmFyIHN0eWxlID0gcGxhdGZvcm0uX3N0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdGlmICghcGxhdGZvcm0uX3N0eWxlKSB7XG5cdFx0cGxhdGZvcm0uX3N0eWxlID0gc3R5bGU7XG5cdFx0Y3NzID0gJy8qIENoYXJ0LmpzICovXFxuJyArIGNzcztcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcblx0XHRkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fVxuXG5cdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xufVxuXG52YXIgcGxhdGZvcm1fZG9tJDIgPSB7XG5cdC8qKlxuXHQgKiBXaGVuIGB0cnVlYCwgcHJldmVudHMgdGhlIGF1dG9tYXRpYyBpbmplY3Rpb24gb2YgdGhlIHN0eWxlc2hlZXQgcmVxdWlyZWQgdG9cblx0ICogY29ycmVjdGx5IGRldGVjdCB3aGVuIHRoZSBjaGFydCBpcyBhZGRlZCB0byB0aGUgRE9NIGFuZCB0aGVuIHJlc2l6ZWQuIFRoaXNcblx0ICogc3dpdGNoIGhhcyBiZWVuIGFkZGVkIHRvIGFsbG93IGV4dGVybmFsIHN0eWxlc2hlZXQgKGBkaXN0L0NoYXJ0KC5taW4pPy5qc2ApXG5cdCAqIHRvIGJlIG1hbnVhbGx5IGltcG9ydGVkIHRvIG1ha2UgdGhpcyBsaWJyYXJ5IGNvbXBhdGlibGUgd2l0aCBhbnkgQ1NQLlxuXHQgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzUyMDhcblx0ICovXG5cdGRpc2FibGVDU1NJbmplY3Rpb246IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBUaGlzIHByb3BlcnR5IGhvbGRzIHdoZXRoZXIgdGhpcyBwbGF0Zm9ybSBpcyBlbmFibGVkIGZvciB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cblx0ICogQ3VycmVudGx5IHVzZWQgYnkgcGxhdGZvcm0uanMgdG8gc2VsZWN0IHRoZSBwcm9wZXIgaW1wbGVtZW50YXRpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZW5hYmxlZDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbnN1cmVMb2FkZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzUyMDhcblx0XHRpZiAoIXRoaXMuZGlzYWJsZUNTU0luamVjdGlvbikge1xuXHRcdFx0aW5qZWN0Q1NTKHRoaXMsIHN0eWxlc2hlZXQpO1xuXHRcdH1cblx0fSxcblxuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdFx0aWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuXHRcdFx0aXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pO1xuXHRcdH0gZWxzZSBpZiAoaXRlbS5sZW5ndGgpIHtcblx0XHRcdC8vIFN1cHBvcnQgZm9yIGFycmF5IGJhc2VkIHF1ZXJpZXMgKHN1Y2ggYXMgalF1ZXJ5KVxuXHRcdFx0aXRlbSA9IGl0ZW1bMF07XG5cdFx0fVxuXG5cdFx0aWYgKGl0ZW0gJiYgaXRlbS5jYW52YXMpIHtcblx0XHRcdC8vIFN1cHBvcnQgZm9yIGFueSBvYmplY3QgYXNzb2NpYXRlZCB0byBhIGNhbnZhcyAoaW5jbHVkaW5nIGEgY29udGV4dDJkKVxuXHRcdFx0aXRlbSA9IGl0ZW0uY2FudmFzO1xuXHRcdH1cblxuXHRcdC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcblx0XHQvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG5cdFx0dmFyIGNvbnRleHQgPSBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJyk7XG5cblx0XHQvLyBMb2FkIHBsYXRmb3JtIHJlc291cmNlcyBvbiBmaXJzdCBjaGFydCBjcmVhdGlvbiwgdG8gbWFrZSBwb3NzaWJsZSB0byBjaGFuZ2Vcblx0XHQvLyBwbGF0Zm9ybSBvcHRpb25zIGFmdGVyIGltcG9ydGluZyB0aGUgbGlicmFyeSAoZS5nLiBgZGlzYWJsZUNTU0luamVjdGlvbmApLlxuXHRcdHRoaXMuX2Vuc3VyZUxvYWRlZCgpO1xuXG5cdFx0Ly8gYGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEYCBmYWlscyB3aGVuIHRoZSBpdGVtIGlzXG5cdFx0Ly8gaW5zaWRlIGFuIGlmcmFtZSBvciB3aGVuIHJ1bm5pbmcgaW4gYSBwcm90ZWN0ZWQgZW52aXJvbm1lbnQuIFdlIGNvdWxkIGd1ZXNzIHRoZVxuXHRcdC8vIHR5cGVzIGZyb20gdGhlaXIgdG9TdHJpbmcoKSB2YWx1ZSBidXQgbGV0J3Mga2VlcCB0aGluZ3MgZmxleGlibGUgYW5kIGFzc3VtZSBpdCdzXG5cdFx0Ly8gYSBzdWZmaWNpZW50IGNvbmRpdGlvbiBpZiB0aGUgaXRlbSBoYXMgYSBjb250ZXh0MkQgd2hpY2ggaGFzIGl0ZW0gYXMgYGNhbnZhc2AuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM4ODdcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDEwMlxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTUyXG5cdFx0aWYgKGNvbnRleHQgJiYgY29udGV4dC5jYW52YXMgPT09IGl0ZW0pIHtcblx0XHRcdGluaXRDYW52YXMoaXRlbSwgY29uZmlnKTtcblx0XHRcdHJldHVybiBjb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdHJlbGVhc2VDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0dmFyIGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuXHRcdGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbml0aWFsID0gY2FudmFzW0VYUEFORE9fS0VZXS5pbml0aWFsO1xuXHRcdFsnaGVpZ2h0JywgJ3dpZHRoJ10uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBpbml0aWFsW3Byb3BdO1xuXHRcdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHZhbHVlKSkge1xuXHRcdFx0XHRjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FudmFzLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChpbml0aWFsLnN0eWxlIHx8IHt9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRjYW52YXMuc3R5bGVba2V5XSA9IHZhbHVlO1xuXHRcdH0pO1xuXG5cdFx0Ly8gVGhlIGNhbnZhcyByZW5kZXIgc2l6ZSBtaWdodCBoYXZlIGJlZW4gY2hhbmdlZCAoYW5kIHRodXMgdGhlIHN0YXRlIHN0YWNrIGRpc2NhcmRlZCksXG5cdFx0Ly8gd2UgY2FuJ3QgdXNlIHNhdmUoKSBhbmQgcmVzdG9yZSgpIHRvIHJlc3RvcmUgdGhlIGluaXRpYWwgc3RhdGUuIFNvIG1ha2Ugc3VyZSB0aGF0IGF0XG5cdFx0Ly8gbGVhc3QgdGhlIGNhbnZhcyBjb250ZXh0IGlzIHJlc2V0IHRvIHRoZSBkZWZhdWx0IHN0YXRlIGJ5IHNldHRpbmcgdGhlIGNhbnZhcyB3aWR0aC5cblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAxMS9XRC1odG1sNS0yMDExMDUyNS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbFxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcblxuXHRcdGRlbGV0ZSBjYW52YXNbRVhQQU5ET19LRVldO1xuXHR9LFxuXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0aWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG5cdFx0XHQvLyBOb3RlOiB0aGUgcmVzaXplIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gYWxsIGJyb3dzZXJzLlxuXHRcdFx0YWRkUmVzaXplTGlzdGVuZXIoY2FudmFzLCBsaXN0ZW5lciwgY2hhcnQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBleHBhbmRvID0gbGlzdGVuZXJbRVhQQU5ET19LRVldIHx8IChsaXN0ZW5lcltFWFBBTkRPX0tFWV0gPSB7fSk7XG5cdFx0dmFyIHByb3hpZXMgPSBleHBhbmRvLnByb3hpZXMgfHwgKGV4cGFuZG8ucHJveGllcyA9IHt9KTtcblx0XHR2YXIgcHJveHkgPSBwcm94aWVzW2NoYXJ0LmlkICsgJ18nICsgdHlwZV0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0bGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuXHRcdH07XG5cblx0XHRhZGRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcblx0fSxcblxuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXHRcdGlmICh0eXBlID09PSAncmVzaXplJykge1xuXHRcdFx0Ly8gTm90ZTogdGhlIHJlc2l6ZSBldmVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIGFsbCBicm93c2Vycy5cblx0XHRcdHJlbW92ZVJlc2l6ZUxpc3RlbmVyKGNhbnZhcyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGV4cGFuZG8gPSBsaXN0ZW5lcltFWFBBTkRPX0tFWV0gfHwge307XG5cdFx0dmFyIHByb3hpZXMgPSBleHBhbmRvLnByb3hpZXMgfHwge307XG5cdFx0dmFyIHByb3h5ID0gcHJveGllc1tjaGFydC5pZCArICdfJyArIHR5cGVdO1xuXHRcdGlmICghcHJveHkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZW1vdmVMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcblx0fVxufTtcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyIGluc3RlYWQuXG4gKiBFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyIGNvbXBhdGliaWxpdHk6IENocm9tZSwgT3BlcmEgNywgU2FmYXJpLCBGRjEuNSssIElFOStcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmFkZEV2ZW50XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzJDEuYWRkRXZlbnQgPSBhZGRMaXN0ZW5lcjtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgaW5zdGVhZC5cbiAqIEV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSA3LCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMucmVtb3ZlRXZlbnRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5yZW1vdmVFdmVudCA9IHJlbW92ZUxpc3RlbmVyO1xuXG4vLyBAVE9ETyBNYWtlIHBvc3NpYmxlIHRvIHNlbGVjdCBhbm90aGVyIHBsYXRmb3JtIGF0IGJ1aWxkIHRpbWUuXG52YXIgaW1wbGVtZW50YXRpb24gPSBwbGF0Zm9ybV9kb20kMi5fZW5hYmxlZCA/IHBsYXRmb3JtX2RvbSQyIDogcGxhdGZvcm1fYmFzaWM7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5wbGF0Zm9ybVxuICogQHNlZSBodHRwczovL2NoYXJ0anMuZ2l0Ym9va3MuaW8vcHJvcG9zYWxzL2NvbnRlbnQvUGxhdGZvcm0uaHRtbFxuICogQHNpbmNlIDIuNC4wXG4gKi9cbnZhciBwbGF0Zm9ybSA9IGhlbHBlcnMkMS5leHRlbmQoe1xuXHQvKipcblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgY29uc3RydWN0aW9uIHRpbWUsIHJldHVybnMgYSBjb250ZXh0MmQgaW5zdGFuY2UgaW1wbGVtZW50aW5nXG5cdCAqIHRoZSBbVzNDIENhbnZhcyAyRCBDb250ZXh0IEFQSSBzdGFuZGFyZF17QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC99LlxuXHQgKiBAcGFyYW0geyp9IGl0ZW0gLSBUaGUgbmF0aXZlIGl0ZW0gZnJvbSB3aGljaCB0byBhY3F1aXJlIGNvbnRleHQgKHBsYXRmb3JtIHNwZWNpZmljKVxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFRoZSBjaGFydCBvcHRpb25zXG5cdCAqIEByZXR1cm5zIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQyZCBpbnN0YW5jZVxuXHQgKi9cblx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBkZXN0cnVjdGlvbiB0aW1lLCByZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFzc29jaWF0ZWQgdG8gdGhlIGNvbnRleHRcblx0ICogcHJldmlvdXNseSByZXR1cm5lZCBieSB0aGUgYWNxdWlyZUNvbnRleHQoKSBtZXRob2QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIGNvbnRleHQyZCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgbWV0aG9kIHN1Y2NlZWRlZCwgZWxzZSBmYWxzZVxuXHQgKi9cblx0cmVsZWFzZUNvbnRleHQ6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIG9uIHRoZSBnaXZlbiBjaGFydC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIGxpc3RlbiBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBJRXZlbnR9KSB0eXBlIHRvIGxpc3RlbiBmb3Jcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBSZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiAoYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50c1xuXHQgKiB0aGUge0BsaW5rIElFdmVudH0gaW50ZXJmYWNlKSB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG5cdCAqL1xuXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBJRXZlbnR9KSB0eXBlIHRvIHJlbW92ZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0LlxuXHQgKi9cblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7fVxuXG59LCBpbXBsZW1lbnRhdGlvbik7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRwbHVnaW5zOiB7fVxufSk7XG5cbi8qKlxuICogVGhlIHBsdWdpbiBzZXJ2aWNlIHNpbmdsZXRvblxuICogQG5hbWVzcGFjZSBDaGFydC5wbHVnaW5zXG4gKiBAc2luY2UgMi4xLjBcbiAqL1xudmFyIGNvcmVfcGx1Z2lucyA9IHtcblx0LyoqXG5cdCAqIEdsb2JhbGx5IHJlZ2lzdGVyZWQgcGx1Z2lucy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9wbHVnaW5zOiBbXSxcblxuXHQvKipcblx0ICogVGhpcyBpZGVudGlmaWVyIGlzIHVzZWQgdG8gaW52YWxpZGF0ZSB0aGUgZGVzY3JpcHRvcnMgY2FjaGUgYXR0YWNoZWQgdG8gZWFjaCBjaGFydFxuXHQgKiB3aGVuIGEgZ2xvYmFsIHBsdWdpbiBpcyByZWdpc3RlcmVkIG9yIHVucmVnaXN0ZXJlZC4gSW4gdGhpcyBjYXNlLCB0aGUgY2FjaGUgSUQgaXNcblx0ICogaW5jcmVtZW50ZWQgYW5kIGRlc2NyaXB0b3JzIGFyZSByZWdlbmVyYXRlZCBkdXJpbmcgZm9sbG93aW5nIEFQSSBjYWxscy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jYWNoZUlkOiAwLFxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgdGhlIGdpdmVuIHBsdWdpbihzKSBpZiBub3QgYWxyZWFkeSByZWdpc3RlcmVkLlxuXHQgKiBAcGFyYW0ge0lQbHVnaW5bXXxJUGx1Z2lufSBwbHVnaW5zIHBsdWdpbiBpbnN0YW5jZShzKS5cblx0ICovXG5cdHJlZ2lzdGVyOiBmdW5jdGlvbihwbHVnaW5zKSB7XG5cdFx0dmFyIHAgPSB0aGlzLl9wbHVnaW5zO1xuXHRcdChbXSkuY29uY2F0KHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHRpZiAocC5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG5cdFx0XHRcdHAucHVzaChwbHVnaW4pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fY2FjaGVJZCsrO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVbnJlZ2lzdGVycyB0aGUgZ2l2ZW4gcGx1Z2luKHMpIG9ubHkgaWYgcmVnaXN0ZXJlZC5cblx0ICogQHBhcmFtIHtJUGx1Z2luW118SVBsdWdpbn0gcGx1Z2lucyBwbHVnaW4gaW5zdGFuY2UocykuXG5cdCAqL1xuXHR1bnJlZ2lzdGVyOiBmdW5jdGlvbihwbHVnaW5zKSB7XG5cdFx0dmFyIHAgPSB0aGlzLl9wbHVnaW5zO1xuXHRcdChbXSkuY29uY2F0KHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHR2YXIgaWR4ID0gcC5pbmRleE9mKHBsdWdpbik7XG5cdFx0XHRpZiAoaWR4ICE9PSAtMSkge1xuXHRcdFx0XHRwLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fY2FjaGVJZCsrO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgcGx1Z2lucy5cblx0ICogQHNpbmNlIDIuMS41XG5cdCAqL1xuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcGx1Z2lucyA9IFtdO1xuXHRcdHRoaXMuX2NhY2hlSWQrKztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJlZ2lzdGVyZWQgcGx1Z2lucz9cblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICogQHNpbmNlIDIuMS41XG5cdCAqL1xuXHRjb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BsdWdpbnMubGVuZ3RoO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIHBsdWdpbiBpbnN0YW5jZXMuXG5cdCAqIEByZXR1cm5zIHtJUGx1Z2luW119IGFycmF5IG9mIHBsdWdpbiBvYmplY3RzLlxuXHQgKiBAc2luY2UgMi4xLjVcblx0ICovXG5cdGdldEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BsdWdpbnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGxzIGVuYWJsZWQgcGx1Z2lucyBmb3IgYGNoYXJ0YCBvbiB0aGUgc3BlY2lmaWVkIGhvb2sgYW5kIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG5cdCAqIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWx5IHJldHVybnMgYXMgc29vbiBhcyBhIHBsdWdpbiBleHBsaWNpdGx5IHJldHVybnMgZmFsc2UuIFRoZVxuXHQgKiByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdXNlZCwgZm9yIGluc3RhbmNlLCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgYWN0aW9uLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZSBmb3Igd2hpY2ggcGx1Z2lucyBzaG91bGQgYmUgY2FsbGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaG9vayAtIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gbWV0aG9kIHRvIGNhbGwgKGUuZy4gJ2JlZm9yZVVwZGF0ZScpLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cblx0bm90aWZ5OiBmdW5jdGlvbihjaGFydCwgaG9vaywgYXJncykge1xuXHRcdHZhciBkZXNjcmlwdG9ycyA9IHRoaXMuZGVzY3JpcHRvcnMoY2hhcnQpO1xuXHRcdHZhciBpbGVuID0gZGVzY3JpcHRvcnMubGVuZ3RoO1xuXHRcdHZhciBpLCBkZXNjcmlwdG9yLCBwbHVnaW4sIHBhcmFtcywgbWV0aG9kO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JzW2ldO1xuXHRcdFx0cGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG5cdFx0XHRtZXRob2QgPSBwbHVnaW5baG9va107XG5cdFx0XHRpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRwYXJhbXMgPSBbY2hhcnRdLmNvbmNhdChhcmdzIHx8IFtdKTtcblx0XHRcdFx0cGFyYW1zLnB1c2goZGVzY3JpcHRvci5vcHRpb25zKTtcblx0XHRcdFx0aWYgKG1ldGhvZC5hcHBseShwbHVnaW4sIHBhcmFtcykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgZGVzY3JpcHRvcnMgb2YgZW5hYmxlZCBwbHVnaW5zIGZvciB0aGUgZ2l2ZW4gY2hhcnQuXG5cdCAqIEByZXR1cm5zIHtvYmplY3RbXX0gW3sgcGx1Z2luLCBvcHRpb25zIH1dXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkZXNjcmlwdG9yczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgY2FjaGUgPSBjaGFydC4kcGx1Z2lucyB8fCAoY2hhcnQuJHBsdWdpbnMgPSB7fSk7XG5cdFx0aWYgKGNhY2hlLmlkID09PSB0aGlzLl9jYWNoZUlkKSB7XG5cdFx0XHRyZXR1cm4gY2FjaGUuZGVzY3JpcHRvcnM7XG5cdFx0fVxuXG5cdFx0dmFyIHBsdWdpbnMgPSBbXTtcblx0XHR2YXIgZGVzY3JpcHRvcnMgPSBbXTtcblx0XHR2YXIgY29uZmlnID0gKGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZykgfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSAoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucykgfHwge307XG5cblx0XHR0aGlzLl9wbHVnaW5zLmNvbmNhdChjb25maWcucGx1Z2lucyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdHZhciBpZHggPSBwbHVnaW5zLmluZGV4T2YocGx1Z2luKTtcblx0XHRcdGlmIChpZHggIT09IC0xKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGlkID0gcGx1Z2luLmlkO1xuXHRcdFx0dmFyIG9wdHMgPSBvcHRpb25zW2lkXTtcblx0XHRcdGlmIChvcHRzID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRzID09PSB0cnVlKSB7XG5cdFx0XHRcdG9wdHMgPSBoZWxwZXJzJDEuY2xvbmUoY29yZV9kZWZhdWx0cy5nbG9iYWwucGx1Z2luc1tpZF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRwbHVnaW5zLnB1c2gocGx1Z2luKTtcblx0XHRcdGRlc2NyaXB0b3JzLnB1c2goe1xuXHRcdFx0XHRwbHVnaW46IHBsdWdpbixcblx0XHRcdFx0b3B0aW9uczogb3B0cyB8fCB7fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRjYWNoZS5kZXNjcmlwdG9ycyA9IGRlc2NyaXB0b3JzO1xuXHRcdGNhY2hlLmlkID0gdGhpcy5fY2FjaGVJZDtcblx0XHRyZXR1cm4gZGVzY3JpcHRvcnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEludmFsaWRhdGVzIGNhY2hlIGZvciB0aGUgZ2l2ZW4gY2hhcnQ6IGRlc2NyaXB0b3JzIGhvbGQgYSByZWZlcmVuY2Ugb24gcGx1Z2luIG9wdGlvbixcblx0ICogYnV0IGluIHNvbWUgY2FzZXMsIHRoaXMgcmVmZXJlbmNlIGNhbiBiZSBjaGFuZ2VkIGJ5IHRoZSB1c2VyIHdoZW4gdXBkYXRpbmcgb3B0aW9ucy5cblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzUxMTEjaXNzdWVjb21tZW50LTM1NTkzNDE2N1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2ludmFsaWRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0ZGVsZXRlIGNoYXJ0LiRwbHVnaW5zO1xuXHR9XG59O1xuXG52YXIgY29yZV9zY2FsZVNlcnZpY2UgPSB7XG5cdC8vIFNjYWxlIHJlZ2lzdHJhdGlvbiBvYmplY3QuIEV4dGVuc2lvbnMgY2FuIHJlZ2lzdGVyIG5ldyBzY2FsZSB0eXBlcyAoc3VjaCBhcyBsb2cgb3IgREIgc2NhbGVzKSBhbmQgdGhlblxuXHQvLyB1c2UgdGhlIG5ldyBjaGFydCBvcHRpb25zIHRvIGdyYWIgdGhlIGNvcnJlY3Qgc2NhbGVcblx0Y29uc3RydWN0b3JzOiB7fSxcblx0Ly8gVXNlIGEgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIHNvIHRoYXQgd2UgY2FuIG1vdmUgdG8gYW4gRVM2IG1hcCB3aGVuIHdlIG5vIGxvbmdlciBuZWVkIHRvIHN1cHBvcnRcblx0Ly8gb2xkIGJyb3dzZXJzXG5cblx0Ly8gU2NhbGUgY29uZmlnIGRlZmF1bHRzXG5cdGRlZmF1bHRzOiB7fSxcblx0cmVnaXN0ZXJTY2FsZVR5cGU6IGZ1bmN0aW9uKHR5cGUsIHNjYWxlQ29uc3RydWN0b3IsIHNjYWxlRGVmYXVsdHMpIHtcblx0XHR0aGlzLmNvbnN0cnVjdG9yc1t0eXBlXSA9IHNjYWxlQ29uc3RydWN0b3I7XG5cdFx0dGhpcy5kZWZhdWx0c1t0eXBlXSA9IGhlbHBlcnMkMS5jbG9uZShzY2FsZURlZmF1bHRzKTtcblx0fSxcblx0Z2V0U2NhbGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24odHlwZSkge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9ycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSA/IHRoaXMuY29uc3RydWN0b3JzW3R5cGVdIDogdW5kZWZpbmVkO1xuXHR9LFxuXHRnZXRTY2FsZURlZmF1bHRzOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0Ly8gUmV0dXJuIHRoZSBzY2FsZSBkZWZhdWx0cyBtZXJnZWQgd2l0aCB0aGUgZ2xvYmFsIHNldHRpbmdzIHNvIHRoYXQgd2UgYWx3YXlzIHVzZSB0aGUgbGF0ZXN0IG9uZXNcblx0XHRyZXR1cm4gdGhpcy5kZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSA/IGhlbHBlcnMkMS5tZXJnZSh7fSwgW2NvcmVfZGVmYXVsdHMuc2NhbGUsIHRoaXMuZGVmYXVsdHNbdHlwZV1dKSA6IHt9O1xuXHR9LFxuXHR1cGRhdGVTY2FsZURlZmF1bHRzOiBmdW5jdGlvbih0eXBlLCBhZGRpdGlvbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmIChtZS5kZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuXHRcdFx0bWUuZGVmYXVsdHNbdHlwZV0gPSBoZWxwZXJzJDEuZXh0ZW5kKG1lLmRlZmF1bHRzW3R5cGVdLCBhZGRpdGlvbnMpO1xuXHRcdH1cblx0fSxcblx0YWRkU2NhbGVzVG9MYXlvdXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0Ly8gQWRkcyBlYWNoIHNjYWxlIHRvIHRoZSBjaGFydC5ib3hlcyBhcnJheSB0byBiZSBzaXplZCBhY2NvcmRpbmdseVxuXHRcdGhlbHBlcnMkMS5lYWNoKGNoYXJ0LnNjYWxlcywgZnVuY3Rpb24oc2NhbGUpIHtcblx0XHRcdC8vIFNldCBJTGF5b3V0SXRlbSBwYXJhbWV0ZXJzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0c2NhbGUuZnVsbFdpZHRoID0gc2NhbGUub3B0aW9ucy5mdWxsV2lkdGg7XG5cdFx0XHRzY2FsZS5wb3NpdGlvbiA9IHNjYWxlLm9wdGlvbnMucG9zaXRpb247XG5cdFx0XHRzY2FsZS53ZWlnaHQgPSBzY2FsZS5vcHRpb25zLndlaWdodDtcblx0XHRcdGNvcmVfbGF5b3V0cy5hZGRCb3goY2hhcnQsIHNjYWxlKTtcblx0XHR9KTtcblx0fVxufTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDcgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHR0b29sdGlwczoge1xuXHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0Y3VzdG9tOiBudWxsLFxuXHRcdG1vZGU6ICduZWFyZXN0Jyxcblx0XHRwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuXHRcdGludGVyc2VjdDogdHJ1ZSxcblx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuXHRcdHRpdGxlRm9udFN0eWxlOiAnYm9sZCcsXG5cdFx0dGl0bGVTcGFjaW5nOiAyLFxuXHRcdHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuXHRcdHRpdGxlRm9udENvbG9yOiAnI2ZmZicsXG5cdFx0dGl0bGVBbGlnbjogJ2xlZnQnLFxuXHRcdGJvZHlTcGFjaW5nOiAyLFxuXHRcdGJvZHlGb250Q29sb3I6ICcjZmZmJyxcblx0XHRib2R5QWxpZ246ICdsZWZ0Jyxcblx0XHRmb290ZXJGb250U3R5bGU6ICdib2xkJyxcblx0XHRmb290ZXJTcGFjaW5nOiAyLFxuXHRcdGZvb3Rlck1hcmdpblRvcDogNixcblx0XHRmb290ZXJGb250Q29sb3I6ICcjZmZmJyxcblx0XHRmb290ZXJBbGlnbjogJ2xlZnQnLFxuXHRcdHlQYWRkaW5nOiA2LFxuXHRcdHhQYWRkaW5nOiA2LFxuXHRcdGNhcmV0UGFkZGluZzogMixcblx0XHRjYXJldFNpemU6IDUsXG5cdFx0Y29ybmVyUmFkaXVzOiA2LFxuXHRcdG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuXHRcdGRpc3BsYXlDb2xvcnM6IHRydWUsXG5cdFx0Ym9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcblx0XHRib3JkZXJXaWR0aDogMCxcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuXHRcdFx0YmVmb3JlVGl0bGU6IGhlbHBlcnMkMS5ub29wLFxuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtcywgZGF0YSkge1xuXHRcdFx0XHR2YXIgdGl0bGUgPSAnJztcblx0XHRcdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xuXHRcdFx0XHR2YXIgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xuXG5cdFx0XHRcdGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHZhciBpdGVtID0gdG9vbHRpcEl0ZW1zWzBdO1xuXHRcdFx0XHRcdGlmIChpdGVtLmxhYmVsKSB7XG5cdFx0XHRcdFx0XHR0aXRsZSA9IGl0ZW0ubGFiZWw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpdGVtLnhMYWJlbCkge1xuXHRcdFx0XHRcdFx0dGl0bGUgPSBpdGVtLnhMYWJlbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uaW5kZXggPCBsYWJlbENvdW50KSB7XG5cdFx0XHRcdFx0XHR0aXRsZSA9IGxhYmVsc1tpdGVtLmluZGV4XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGl0bGU7XG5cdFx0XHR9LFxuXHRcdFx0YWZ0ZXJUaXRsZTogaGVscGVycyQxLm5vb3AsXG5cblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuXHRcdFx0YmVmb3JlQm9keTogaGVscGVycyQxLm5vb3AsXG5cblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdFx0XHRiZWZvcmVMYWJlbDogaGVscGVycyQxLm5vb3AsXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGRhdGEpIHtcblx0XHRcdFx0dmFyIGxhYmVsID0gZGF0YS5kYXRhc2V0c1t0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXhdLmxhYmVsIHx8ICcnO1xuXG5cdFx0XHRcdGlmIChsYWJlbCkge1xuXHRcdFx0XHRcdGxhYmVsICs9ICc6ICc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0b29sdGlwSXRlbS52YWx1ZSkpIHtcblx0XHRcdFx0XHRsYWJlbCArPSB0b29sdGlwSXRlbS52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsYWJlbCArPSB0b29sdGlwSXRlbS55TGFiZWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGxhYmVsO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsQ29sb3I6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBjaGFydCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdHZhciBhY3RpdmVFbGVtZW50ID0gbWV0YS5kYXRhW3Rvb2x0aXBJdGVtLmluZGV4XTtcblx0XHRcdFx0dmFyIHZpZXcgPSBhY3RpdmVFbGVtZW50Ll92aWV3O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGJvcmRlckNvbG9yOiB2aWV3LmJvcmRlckNvbG9yLFxuXHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogdmlldy5iYWNrZ3JvdW5kQ29sb3Jcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRsYWJlbFRleHRDb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9vcHRpb25zLmJvZHlGb250Q29sb3I7XG5cdFx0XHR9LFxuXHRcdFx0YWZ0ZXJMYWJlbDogaGVscGVycyQxLm5vb3AsXG5cblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuXHRcdFx0YWZ0ZXJCb2R5OiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVGb290ZXI6IGhlbHBlcnMkMS5ub29wLFxuXHRcdFx0Zm9vdGVyOiBoZWxwZXJzJDEubm9vcCxcblx0XHRcdGFmdGVyRm9vdGVyOiBoZWxwZXJzJDEubm9vcFxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBwb3NpdGlvbmVycyA9IHtcblx0LyoqXG5cdCAqIEF2ZXJhZ2UgbW9kZSBwbGFjZXMgdGhlIHRvb2x0aXAgYXQgdGhlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRzIHNob3duXG5cdCAqIEBmdW5jdGlvbiBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzLmF2ZXJhZ2Vcblx0ICogQHBhcmFtIGVsZW1lbnRzIHtDaGFydEVsZW1lbnRbXX0gdGhlIGVsZW1lbnRzIGJlaW5nIGRpc3BsYXllZCBpbiB0aGUgdG9vbHRpcFxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSB0b29sdGlwIHBvc2l0aW9uXG5cdCAqL1xuXHRhdmVyYWdlOiBmdW5jdGlvbihlbGVtZW50cykge1xuXHRcdGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIGksIGxlbjtcblx0XHR2YXIgeCA9IDA7XG5cdFx0dmFyIHkgPSAwO1xuXHRcdHZhciBjb3VudCA9IDA7XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0dmFyIGVsID0gZWxlbWVudHNbaV07XG5cdFx0XHRpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuXHRcdFx0XHR2YXIgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XG5cdFx0XHRcdHggKz0gcG9zLng7XG5cdFx0XHRcdHkgKz0gcG9zLnk7XG5cdFx0XHRcdCsrY291bnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHggLyBjb3VudCxcblx0XHRcdHk6IHkgLyBjb3VudFxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHRvb2x0aXAgcG9zaXRpb24gbmVhcmVzdCBvZiB0aGUgaXRlbSBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvblxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVycy5uZWFyZXN0XG5cdCAqIEBwYXJhbSBlbGVtZW50cyB7Q2hhcnQuRWxlbWVudFtdfSB0aGUgdG9vbHRpcCBlbGVtZW50c1xuXHQgKiBAcGFyYW0gZXZlbnRQb3NpdGlvbiB7b2JqZWN0fSB0aGUgcG9zaXRpb24gb2YgdGhlIGV2ZW50IGluIGNhbnZhcyBjb29yZGluYXRlc1xuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgdG9vbHRpcCBwb3NpdGlvblxuXHQgKi9cblx0bmVhcmVzdDogZnVuY3Rpb24oZWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcblx0XHR2YXIgeCA9IGV2ZW50UG9zaXRpb24ueDtcblx0XHR2YXIgeSA9IGV2ZW50UG9zaXRpb24ueTtcblx0XHR2YXIgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdFx0dmFyIGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0dmFyIGVsID0gZWxlbWVudHNbaV07XG5cdFx0XHRpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuXHRcdFx0XHR2YXIgY2VudGVyID0gZWwuZ2V0Q2VudGVyUG9pbnQoKTtcblx0XHRcdFx0dmFyIGQgPSBoZWxwZXJzJDEuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XG5cblx0XHRcdFx0aWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gZDtcblx0XHRcdFx0XHRuZWFyZXN0RWxlbWVudCA9IGVsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5lYXJlc3RFbGVtZW50KSB7XG5cdFx0XHR2YXIgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcblx0XHRcdHggPSB0cC54O1xuXHRcdFx0eSA9IHRwLnk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiB5XG5cdFx0fTtcblx0fVxufTtcblxuLy8gSGVscGVyIHRvIHB1c2ggb3IgY29uY2F0IGJhc2VkIG9uIGlmIHRoZSAybmQgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIG5vdFxuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuXHRpZiAodG9QdXNoKSB7XG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRvUHVzaCkpIHtcblx0XHRcdC8vIGJhc2UgPSBiYXNlLmNvbmNhdCh0b1B1c2gpO1xuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYmFzZSwgdG9QdXNoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YmFzZS5wdXNoKHRvUHVzaCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGJhc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhcnJheSBvZiBzdHJpbmdzIHNwbGl0IGJ5IG5ld2xpbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzcGxpdCBieSBuZXdsaW5lLlxuICogQHJldHVybnMge3N0cmluZ1tdfSB2YWx1ZSBpZiBuZXdsaW5lIHByZXNlbnQgLSBSZXR1cm5lZCBmcm9tIFN0cmluZyBzcGxpdCgpIG1ldGhvZFxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHNwbGl0TmV3bGluZXMoc3RyKSB7XG5cdGlmICgodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nKSAmJiBzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuXHRcdHJldHVybiBzdHIuc3BsaXQoJ1xcbicpO1xuXHR9XG5cdHJldHVybiBzdHI7XG59XG5cblxuLyoqXG4gKiBQcml2YXRlIGhlbHBlciB0byBjcmVhdGUgYSB0b29sdGlwIGl0ZW0gbW9kZWxcbiAqIEBwYXJhbSBlbGVtZW50IC0gdGhlIGNoYXJ0IGVsZW1lbnQgKHBvaW50LCBhcmMsIGJhcikgdG8gY3JlYXRlIHRoZSB0b29sdGlwIGl0ZW0gZm9yXG4gKiBAcmV0dXJuIG5ldyB0b29sdGlwIGl0ZW1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcEl0ZW0oZWxlbWVudCkge1xuXHR2YXIgeFNjYWxlID0gZWxlbWVudC5feFNjYWxlO1xuXHR2YXIgeVNjYWxlID0gZWxlbWVudC5feVNjYWxlIHx8IGVsZW1lbnQuX3NjYWxlOyAvLyBoYW5kbGUgcmFkYXIgfHwgcG9sYXJBcmVhIGNoYXJ0c1xuXHR2YXIgaW5kZXggPSBlbGVtZW50Ll9pbmRleDtcblx0dmFyIGRhdGFzZXRJbmRleCA9IGVsZW1lbnQuX2RhdGFzZXRJbmRleDtcblx0dmFyIGNvbnRyb2xsZXIgPSBlbGVtZW50Ll9jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG5cdHZhciBpbmRleFNjYWxlID0gY29udHJvbGxlci5fZ2V0SW5kZXhTY2FsZSgpO1xuXHR2YXIgdmFsdWVTY2FsZSA9IGNvbnRyb2xsZXIuX2dldFZhbHVlU2NhbGUoKTtcblxuXHRyZXR1cm4ge1xuXHRcdHhMYWJlbDogeFNjYWxlID8geFNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcblx0XHR5TGFiZWw6IHlTY2FsZSA/IHlTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0bGFiZWw6IGluZGV4U2NhbGUgPyAnJyArIGluZGV4U2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdHZhbHVlOiB2YWx1ZVNjYWxlID8gJycgKyB2YWx1ZVNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcblx0XHRpbmRleDogaW5kZXgsXG5cdFx0ZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXgsXG5cdFx0eDogZWxlbWVudC5fbW9kZWwueCxcblx0XHR5OiBlbGVtZW50Ll9tb2RlbC55XG5cdH07XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGdldCB0aGUgcmVzZXQgbW9kZWwgZm9yIHRoZSB0b29sdGlwXG4gKiBAcGFyYW0gdG9vbHRpcE9wdHMge29iamVjdH0gdGhlIHRvb2x0aXAgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRCYXNlTW9kZWwodG9vbHRpcE9wdHMpIHtcblx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cblx0cmV0dXJuIHtcblx0XHQvLyBQb3NpdGlvbmluZ1xuXHRcdHhQYWRkaW5nOiB0b29sdGlwT3B0cy54UGFkZGluZyxcblx0XHR5UGFkZGluZzogdG9vbHRpcE9wdHMueVBhZGRpbmcsXG5cdFx0eEFsaWduOiB0b29sdGlwT3B0cy54QWxpZ24sXG5cdFx0eUFsaWduOiB0b29sdGlwT3B0cy55QWxpZ24sXG5cblx0XHQvLyBCb2R5XG5cdFx0Ym9keUZvbnRDb2xvcjogdG9vbHRpcE9wdHMuYm9keUZvbnRDb2xvcixcblx0XHRfYm9keUZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuYm9keUZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRfYm9keUZvbnRTdHlsZTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5ib2R5Rm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRfYm9keUFsaWduOiB0b29sdGlwT3B0cy5ib2R5QWxpZ24sXG5cdFx0Ym9keUZvbnRTaXplOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLmJvZHlGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcblx0XHRib2R5U3BhY2luZzogdG9vbHRpcE9wdHMuYm9keVNwYWNpbmcsXG5cblx0XHQvLyBUaXRsZVxuXHRcdHRpdGxlRm9udENvbG9yOiB0b29sdGlwT3B0cy50aXRsZUZvbnRDb2xvcixcblx0XHRfdGl0bGVGb250RmFtaWx5OiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLnRpdGxlRm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdF90aXRsZUZvbnRTdHlsZTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy50aXRsZUZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXG5cdFx0dGl0bGVGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy50aXRsZUZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpLFxuXHRcdF90aXRsZUFsaWduOiB0b29sdGlwT3B0cy50aXRsZUFsaWduLFxuXHRcdHRpdGxlU3BhY2luZzogdG9vbHRpcE9wdHMudGl0bGVTcGFjaW5nLFxuXHRcdHRpdGxlTWFyZ2luQm90dG9tOiB0b29sdGlwT3B0cy50aXRsZU1hcmdpbkJvdHRvbSxcblxuXHRcdC8vIEZvb3RlclxuXHRcdGZvb3RlckZvbnRDb2xvcjogdG9vbHRpcE9wdHMuZm9vdGVyRm9udENvbG9yLFxuXHRcdF9mb290ZXJGb250RmFtaWx5OiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLmZvb3RlckZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRfZm9vdGVyRm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLmZvb3RlckZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXG5cdFx0Zm9vdGVyRm9udFNpemU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuZm9vdGVyRm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0X2Zvb3RlckFsaWduOiB0b29sdGlwT3B0cy5mb290ZXJBbGlnbixcblx0XHRmb290ZXJTcGFjaW5nOiB0b29sdGlwT3B0cy5mb290ZXJTcGFjaW5nLFxuXHRcdGZvb3Rlck1hcmdpblRvcDogdG9vbHRpcE9wdHMuZm9vdGVyTWFyZ2luVG9wLFxuXG5cdFx0Ly8gQXBwZWFyYW5jZVxuXHRcdGNhcmV0U2l6ZTogdG9vbHRpcE9wdHMuY2FyZXRTaXplLFxuXHRcdGNvcm5lclJhZGl1czogdG9vbHRpcE9wdHMuY29ybmVyUmFkaXVzLFxuXHRcdGJhY2tncm91bmRDb2xvcjogdG9vbHRpcE9wdHMuYmFja2dyb3VuZENvbG9yLFxuXHRcdG9wYWNpdHk6IDAsXG5cdFx0bGVnZW5kQ29sb3JCYWNrZ3JvdW5kOiB0b29sdGlwT3B0cy5tdWx0aUtleUJhY2tncm91bmQsXG5cdFx0ZGlzcGxheUNvbG9yczogdG9vbHRpcE9wdHMuZGlzcGxheUNvbG9ycyxcblx0XHRib3JkZXJDb2xvcjogdG9vbHRpcE9wdHMuYm9yZGVyQ29sb3IsXG5cdFx0Ym9yZGVyV2lkdGg6IHRvb2x0aXBPcHRzLmJvcmRlcldpZHRoXG5cdH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSB0b29sdGlwXG4gKi9cbmZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG1vZGVsKSB7XG5cdHZhciBjdHggPSB0b29sdGlwLl9jaGFydC5jdHg7XG5cblx0dmFyIGhlaWdodCA9IG1vZGVsLnlQYWRkaW5nICogMjsgLy8gVG9vbHRpcCBQYWRkaW5nXG5cdHZhciB3aWR0aCA9IDA7XG5cblx0Ly8gQ291bnQgb2YgYWxsIGxpbmVzIGluIHRoZSBib2R5XG5cdHZhciBib2R5ID0gbW9kZWwuYm9keTtcblx0dmFyIGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKGZ1bmN0aW9uKGNvdW50LCBib2R5SXRlbSkge1xuXHRcdHJldHVybiBjb3VudCArIGJvZHlJdGVtLmJlZm9yZS5sZW5ndGggKyBib2R5SXRlbS5saW5lcy5sZW5ndGggKyBib2R5SXRlbS5hZnRlci5sZW5ndGg7XG5cdH0sIDApO1xuXHRjb21iaW5lZEJvZHlMZW5ndGggKz0gbW9kZWwuYmVmb3JlQm9keS5sZW5ndGggKyBtb2RlbC5hZnRlckJvZHkubGVuZ3RoO1xuXG5cdHZhciB0aXRsZUxpbmVDb3VudCA9IG1vZGVsLnRpdGxlLmxlbmd0aDtcblx0dmFyIGZvb3RlckxpbmVDb3VudCA9IG1vZGVsLmZvb3Rlci5sZW5ndGg7XG5cdHZhciB0aXRsZUZvbnRTaXplID0gbW9kZWwudGl0bGVGb250U2l6ZTtcblx0dmFyIGJvZHlGb250U2l6ZSA9IG1vZGVsLmJvZHlGb250U2l6ZTtcblx0dmFyIGZvb3RlckZvbnRTaXplID0gbW9kZWwuZm9vdGVyRm9udFNpemU7XG5cblx0aGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250U2l6ZTsgLy8gVGl0bGUgTGluZXNcblx0aGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ID8gKHRpdGxlTGluZUNvdW50IC0gMSkgKiBtb2RlbC50aXRsZVNwYWNpbmcgOiAwOyAvLyBUaXRsZSBMaW5lIFNwYWNpbmdcblx0aGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ID8gbW9kZWwudGl0bGVNYXJnaW5Cb3R0b20gOiAwOyAvLyBUaXRsZSdzIGJvdHRvbSBNYXJnaW5cblx0aGVpZ2h0ICs9IGNvbWJpbmVkQm9keUxlbmd0aCAqIGJvZHlGb250U2l6ZTsgLy8gQm9keSBMaW5lc1xuXHRoZWlnaHQgKz0gY29tYmluZWRCb2R5TGVuZ3RoID8gKGNvbWJpbmVkQm9keUxlbmd0aCAtIDEpICogbW9kZWwuYm9keVNwYWNpbmcgOiAwOyAvLyBCb2R5IExpbmUgU3BhY2luZ1xuXHRoZWlnaHQgKz0gZm9vdGVyTGluZUNvdW50ID8gbW9kZWwuZm9vdGVyTWFyZ2luVG9wIDogMDsgLy8gRm9vdGVyIE1hcmdpblxuXHRoZWlnaHQgKz0gZm9vdGVyTGluZUNvdW50ICogKGZvb3RlckZvbnRTaXplKTsgLy8gRm9vdGVyIExpbmVzXG5cdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgPyAoZm9vdGVyTGluZUNvdW50IC0gMSkgKiBtb2RlbC5mb290ZXJTcGFjaW5nIDogMDsgLy8gRm9vdGVyIExpbmUgU3BhY2luZ1xuXG5cdC8vIFRpdGxlIHdpZHRoXG5cdHZhciB3aWR0aFBhZGRpbmcgPSAwO1xuXHR2YXIgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xuXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XG5cdH07XG5cblx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyh0aXRsZUZvbnRTaXplLCBtb2RlbC5fdGl0bGVGb250U3R5bGUsIG1vZGVsLl90aXRsZUZvbnRGYW1pbHkpO1xuXHRoZWxwZXJzJDEuZWFjaChtb2RlbC50aXRsZSwgbWF4TGluZVdpZHRoKTtcblxuXHQvLyBCb2R5IHdpZHRoXG5cdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcoYm9keUZvbnRTaXplLCBtb2RlbC5fYm9keUZvbnRTdHlsZSwgbW9kZWwuX2JvZHlGb250RmFtaWx5KTtcblx0aGVscGVycyQxLmVhY2gobW9kZWwuYmVmb3JlQm9keS5jb25jYXQobW9kZWwuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcblxuXHQvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgd2lkdGggZHVlIHRvIHRoZSBjb2xvciBib3hcblx0d2lkdGhQYWRkaW5nID0gbW9kZWwuZGlzcGxheUNvbG9ycyA/IChib2R5Rm9udFNpemUgKyAyKSA6IDA7XG5cdGhlbHBlcnMkMS5lYWNoKGJvZHksIGZ1bmN0aW9uKGJvZHlJdGVtKSB7XG5cdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmFmdGVyLCBtYXhMaW5lV2lkdGgpO1xuXHR9KTtcblxuXHQvLyBSZXNldCBiYWNrIHRvIDBcblx0d2lkdGhQYWRkaW5nID0gMDtcblxuXHQvLyBGb290ZXIgd2lkdGhcblx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyhmb290ZXJGb250U2l6ZSwgbW9kZWwuX2Zvb3RlckZvbnRTdHlsZSwgbW9kZWwuX2Zvb3RlckZvbnRGYW1pbHkpO1xuXHRoZWxwZXJzJDEuZWFjaChtb2RlbC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG5cblx0Ly8gQWRkIHBhZGRpbmdcblx0d2lkdGggKz0gMiAqIG1vZGVsLnhQYWRkaW5nO1xuXG5cdHJldHVybiB7XG5cdFx0d2lkdGg6IHdpZHRoLFxuXHRcdGhlaWdodDogaGVpZ2h0XG5cdH07XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGdldCB0aGUgYWxpZ25tZW50IG9mIGEgdG9vbHRpcCBnaXZlbiB0aGUgc2l6ZVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVBbGlnbm1lbnQodG9vbHRpcCwgc2l6ZSkge1xuXHR2YXIgbW9kZWwgPSB0b29sdGlwLl9tb2RlbDtcblx0dmFyIGNoYXJ0ID0gdG9vbHRpcC5fY2hhcnQ7XG5cdHZhciBjaGFydEFyZWEgPSB0b29sdGlwLl9jaGFydC5jaGFydEFyZWE7XG5cdHZhciB4QWxpZ24gPSAnY2VudGVyJztcblx0dmFyIHlBbGlnbiA9ICdjZW50ZXInO1xuXG5cdGlmIChtb2RlbC55IDwgc2l6ZS5oZWlnaHQpIHtcblx0XHR5QWxpZ24gPSAndG9wJztcblx0fSBlbHNlIGlmIChtb2RlbC55ID4gKGNoYXJ0LmhlaWdodCAtIHNpemUuaGVpZ2h0KSkge1xuXHRcdHlBbGlnbiA9ICdib3R0b20nO1xuXHR9XG5cblx0dmFyIGxmLCByZjsgLy8gZnVuY3Rpb25zIHRvIGRldGVybWluZSBsZWZ0LCByaWdodCBhbGlnbm1lbnRcblx0dmFyIG9sZiwgb3JmOyAvLyBmdW5jdGlvbnMgdG8gZGV0ZXJtaW5lIGlmIGxlZnQvcmlnaHQgYWxpZ25tZW50IGNhdXNlcyB0b29sdGlwIHRvIGdvIG91dHNpZGUgY2hhcnRcblx0dmFyIHlmOyAvLyBmdW5jdGlvbiB0byBnZXQgdGhlIHkgYWxpZ25tZW50IGlmIHRoZSB0b29sdGlwIGdvZXMgb3V0c2lkZSBvZiB0aGUgbGVmdCBvciByaWdodCBlZGdlc1xuXHR2YXIgbWlkWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuXHR2YXIgbWlkWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuXG5cdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0bGYgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4geCA8PSBtaWRYO1xuXHRcdH07XG5cdFx0cmYgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4geCA+IG1pZFg7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRsZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4IDw9IChzaXplLndpZHRoIC8gMik7XG5cdFx0fTtcblx0XHRyZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4ID49IChjaGFydC53aWR0aCAtIChzaXplLndpZHRoIC8gMikpO1xuXHRcdH07XG5cdH1cblxuXHRvbGYgPSBmdW5jdGlvbih4KSB7XG5cdFx0cmV0dXJuIHggKyBzaXplLndpZHRoICsgbW9kZWwuY2FyZXRTaXplICsgbW9kZWwuY2FyZXRQYWRkaW5nID4gY2hhcnQud2lkdGg7XG5cdH07XG5cdG9yZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRyZXR1cm4geCAtIHNpemUud2lkdGggLSBtb2RlbC5jYXJldFNpemUgLSBtb2RlbC5jYXJldFBhZGRpbmcgPCAwO1xuXHR9O1xuXHR5ZiA9IGZ1bmN0aW9uKHkpIHtcblx0XHRyZXR1cm4geSA8PSBtaWRZID8gJ3RvcCcgOiAnYm90dG9tJztcblx0fTtcblxuXHRpZiAobGYobW9kZWwueCkpIHtcblx0XHR4QWxpZ24gPSAnbGVmdCc7XG5cblx0XHQvLyBJcyB0b29sdGlwIHRvbyB3aWRlIGFuZCBnb2VzIG92ZXIgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGNoYXJ0Lj9cblx0XHRpZiAob2xmKG1vZGVsLngpKSB7XG5cdFx0XHR4QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdHlBbGlnbiA9IHlmKG1vZGVsLnkpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChyZihtb2RlbC54KSkge1xuXHRcdHhBbGlnbiA9ICdyaWdodCc7XG5cblx0XHQvLyBJcyB0b29sdGlwIHRvbyB3aWRlIGFuZCBnb2VzIG91dHNpZGUgbGVmdCBlZGdlIG9mIGNhbnZhcz9cblx0XHRpZiAob3JmKG1vZGVsLngpKSB7XG5cdFx0XHR4QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdHlBbGlnbiA9IHlmKG1vZGVsLnkpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBvcHRzID0gdG9vbHRpcC5fb3B0aW9ucztcblx0cmV0dXJuIHtcblx0XHR4QWxpZ246IG9wdHMueEFsaWduID8gb3B0cy54QWxpZ24gOiB4QWxpZ24sXG5cdFx0eUFsaWduOiBvcHRzLnlBbGlnbiA/IG9wdHMueUFsaWduIDogeUFsaWduXG5cdH07XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGdldCB0aGUgbG9jYXRpb24gYSB0b29sdGlwIG5lZWRzIHRvIGJlIHBsYWNlZCBhdCBnaXZlbiB0aGUgaW5pdGlhbCBwb3NpdGlvbiAodmlhIHRoZSB2bSkgYW5kIHRoZSBzaXplIGFuZCBhbGlnbm1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KHZtLCBzaXplLCBhbGlnbm1lbnQsIGNoYXJ0KSB7XG5cdC8vIEJhY2tncm91bmQgUG9zaXRpb25cblx0dmFyIHggPSB2bS54O1xuXHR2YXIgeSA9IHZtLnk7XG5cblx0dmFyIGNhcmV0U2l6ZSA9IHZtLmNhcmV0U2l6ZTtcblx0dmFyIGNhcmV0UGFkZGluZyA9IHZtLmNhcmV0UGFkZGluZztcblx0dmFyIGNvcm5lclJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcblx0dmFyIHhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG5cdHZhciB5QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuXHR2YXIgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XG5cdHZhciByYWRpdXNBbmRQYWRkaW5nID0gY29ybmVyUmFkaXVzICsgY2FyZXRQYWRkaW5nO1xuXG5cdGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHR4IC09IHNpemUud2lkdGg7XG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAnY2VudGVyJykge1xuXHRcdHggLT0gKHNpemUud2lkdGggLyAyKTtcblx0XHRpZiAoeCArIHNpemUud2lkdGggPiBjaGFydC53aWR0aCkge1xuXHRcdFx0eCA9IGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aDtcblx0XHR9XG5cdFx0aWYgKHggPCAwKSB7XG5cdFx0XHR4ID0gMDtcblx0XHR9XG5cdH1cblxuXHRpZiAoeUFsaWduID09PSAndG9wJykge1xuXHRcdHkgKz0gcGFkZGluZ0FuZFNpemU7XG5cdH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuXHRcdHkgLT0gc2l6ZS5oZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcblx0fSBlbHNlIHtcblx0XHR5IC09IChzaXplLmhlaWdodCAvIDIpO1xuXHR9XG5cblx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdHggKz0gcGFkZGluZ0FuZFNpemU7XG5cdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdHggLT0gcGFkZGluZ0FuZFNpemU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0eCAtPSByYWRpdXNBbmRQYWRkaW5nO1xuXHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdHggKz0gcmFkaXVzQW5kUGFkZGluZztcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0eDogeCxcblx0XHR5OiB5XG5cdH07XG59XG5cbmZ1bmN0aW9uIGdldEFsaWduZWRYKHZtLCBhbGlnbikge1xuXHRyZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXG5cdFx0PyB2bS54ICsgdm0ud2lkdGggLyAyXG5cdFx0OiBhbGlnbiA9PT0gJ3JpZ2h0J1xuXHRcdFx0PyB2bS54ICsgdm0ud2lkdGggLSB2bS54UGFkZGluZ1xuXHRcdFx0OiB2bS54ICsgdm0ueFBhZGRpbmc7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGJ1aWxkIGJlZm9yZSBhbmQgYWZ0ZXIgYm9keSBsaW5lc1xuICovXG5mdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuXHRyZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XG59XG5cbnZhciBleHBvcnRzJDMgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbW9kZWwgPSBnZXRCYXNlTW9kZWwodGhpcy5fb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGFzdEFjdGl2ZSA9IFtdO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgdGl0bGVcblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0VGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5fb3B0aW9ucztcblx0XHR2YXIgY2FsbGJhY2tzID0gb3B0cy5jYWxsYmFja3M7XG5cblx0XHR2YXIgYmVmb3JlVGl0bGUgPSBjYWxsYmFja3MuYmVmb3JlVGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIHRpdGxlID0gY2FsbGJhY2tzLnRpdGxlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdHZhciBhZnRlclRpdGxlID0gY2FsbGJhY2tzLmFmdGVyVGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cblx0XHR2YXIgbGluZXMgPSBbXTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJUaXRsZSkpO1xuXG5cdFx0cmV0dXJuIGxpbmVzO1xuXHR9LFxuXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdGdldEJlZm9yZUJvZHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyh0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5iZWZvcmVCb2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdGdldEJvZHk6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtcywgZGF0YSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNhbGxiYWNrcyA9IG1lLl9vcHRpb25zLmNhbGxiYWNrcztcblx0XHR2YXIgYm9keUl0ZW1zID0gW107XG5cblx0XHRoZWxwZXJzJDEuZWFjaCh0b29sdGlwSXRlbXMsIGZ1bmN0aW9uKHRvb2x0aXBJdGVtKSB7XG5cdFx0XHR2YXIgYm9keUl0ZW0gPSB7XG5cdFx0XHRcdGJlZm9yZTogW10sXG5cdFx0XHRcdGxpbmVzOiBbXSxcblx0XHRcdFx0YWZ0ZXI6IFtdXG5cdFx0XHR9O1xuXHRcdFx0cHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhjYWxsYmFja3MuYmVmb3JlTGFiZWwuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIGRhdGEpKSk7XG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIGNhbGxiYWNrcy5sYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpO1xuXHRcdFx0cHVzaE9yQ29uY2F0KGJvZHlJdGVtLmFmdGVyLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrcy5hZnRlckxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSkpO1xuXG5cdFx0XHRib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gYm9keUl0ZW1zO1xuXHR9LFxuXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdGdldEFmdGVyQm9keTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLmFmdGVyQm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIGZvb3RlciBhbmQgYmVmb3JlRm9vdGVyIGFuZCBhZnRlckZvb3RlciBsaW5lc1xuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRnZXRGb290ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNhbGxiYWNrcyA9IG1lLl9vcHRpb25zLmNhbGxiYWNrcztcblxuXHRcdHZhciBiZWZvcmVGb290ZXIgPSBjYWxsYmFja3MuYmVmb3JlRm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdHZhciBmb290ZXIgPSBjYWxsYmFja3MuZm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdHZhciBhZnRlckZvb3RlciA9IGNhbGxiYWNrcy5hZnRlckZvb3Rlci5hcHBseShtZSwgYXJndW1lbnRzKTtcblxuXHRcdHZhciBsaW5lcyA9IFtdO1xuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZUZvb3RlcikpO1xuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGZvb3RlcikpO1xuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyRm9vdGVyKSk7XG5cblx0XHRyZXR1cm4gbGluZXM7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihjaGFuZ2VkKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLl9vcHRpb25zO1xuXG5cdFx0Ly8gTmVlZCB0byByZWdlbmVyYXRlIHRoZSBtb2RlbCBiZWNhdXNlIGl0cyBmYXN0ZXIgdGhhbiB1c2luZyBleHRlbmQgYW5kIGl0IGlzIG5lY2Vzc2FyeSBkdWUgdG8gdGhlIG9wdGltaXphdGlvbiBpbiBDaGFydC5FbGVtZW50LnRyYW5zaXRpb25cblx0XHQvLyB0aGF0IGRvZXMgX3ZpZXcgPSBfbW9kZWwgaWYgZWFzZSA9PT0gMS4gVGhpcyBjYXVzZXMgdGhlIDJuZCB0b29sdGlwIHVwZGF0ZSB0byBzZXQgcHJvcGVydGllcyBpbiBib3RoIHRoZSB2aWV3IGFuZCBtb2RlbCBhdCB0aGUgc2FtZSB0aW1lXG5cdFx0Ly8gd2hpY2ggYnJlYWtzIGFueSBhbmltYXRpb25zLlxuXHRcdHZhciBleGlzdGluZ01vZGVsID0gbWUuX21vZGVsO1xuXHRcdHZhciBtb2RlbCA9IG1lLl9tb2RlbCA9IGdldEJhc2VNb2RlbChvcHRzKTtcblx0XHR2YXIgYWN0aXZlID0gbWUuX2FjdGl2ZTtcblxuXHRcdHZhciBkYXRhID0gbWUuX2RhdGE7XG5cblx0XHQvLyBJbiB0aGUgY2FzZSB3aGVyZSBhY3RpdmUubGVuZ3RoID09PSAwIHdlIG5lZWQgdG8ga2VlcCB0aGVzZSBhdCBleGlzdGluZyB2YWx1ZXMgZm9yIGdvb2QgYW5pbWF0aW9uc1xuXHRcdHZhciBhbGlnbm1lbnQgPSB7XG5cdFx0XHR4QWxpZ246IGV4aXN0aW5nTW9kZWwueEFsaWduLFxuXHRcdFx0eUFsaWduOiBleGlzdGluZ01vZGVsLnlBbGlnblxuXHRcdH07XG5cdFx0dmFyIGJhY2tncm91bmRQb2ludCA9IHtcblx0XHRcdHg6IGV4aXN0aW5nTW9kZWwueCxcblx0XHRcdHk6IGV4aXN0aW5nTW9kZWwueVxuXHRcdH07XG5cdFx0dmFyIHRvb2x0aXBTaXplID0ge1xuXHRcdFx0d2lkdGg6IGV4aXN0aW5nTW9kZWwud2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGV4aXN0aW5nTW9kZWwuaGVpZ2h0XG5cdFx0fTtcblx0XHR2YXIgdG9vbHRpcFBvc2l0aW9uID0ge1xuXHRcdFx0eDogZXhpc3RpbmdNb2RlbC5jYXJldFgsXG5cdFx0XHR5OiBleGlzdGluZ01vZGVsLmNhcmV0WVxuXHRcdH07XG5cblx0XHR2YXIgaSwgbGVuO1xuXG5cdFx0aWYgKGFjdGl2ZS5sZW5ndGgpIHtcblx0XHRcdG1vZGVsLm9wYWNpdHkgPSAxO1xuXG5cdFx0XHR2YXIgbGFiZWxDb2xvcnMgPSBbXTtcblx0XHRcdHZhciBsYWJlbFRleHRDb2xvcnMgPSBbXTtcblx0XHRcdHRvb2x0aXBQb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdHMucG9zaXRpb25dLmNhbGwobWUsIGFjdGl2ZSwgbWUuX2V2ZW50UG9zaXRpb24pO1xuXG5cdFx0XHR2YXIgdG9vbHRpcEl0ZW1zID0gW107XG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBhY3RpdmUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdFx0dG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0oYWN0aXZlW2ldKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSB1c2VyIHByb3ZpZGVkIGEgZmlsdGVyIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXG5cdFx0XHRpZiAob3B0cy5maWx0ZXIpIHtcblx0XHRcdFx0dG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcihmdW5jdGlvbihhKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wdHMuZmlsdGVyKGEsIGRhdGEpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBzb3J0aW5nIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXG5cdFx0XHRpZiAob3B0cy5pdGVtU29ydCkge1xuXHRcdFx0XHR0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wdHMuaXRlbVNvcnQoYSwgYiwgZGF0YSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXRlcm1pbmUgY29sb3JzIGZvciBib3hlc1xuXHRcdFx0aGVscGVycyQxLmVhY2godG9vbHRpcEl0ZW1zLCBmdW5jdGlvbih0b29sdGlwSXRlbSkge1xuXHRcdFx0XHRsYWJlbENvbG9ycy5wdXNoKG9wdHMuY2FsbGJhY2tzLmxhYmVsQ29sb3IuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIG1lLl9jaGFydCkpO1xuXHRcdFx0XHRsYWJlbFRleHRDb2xvcnMucHVzaChvcHRzLmNhbGxiYWNrcy5sYWJlbFRleHRDb2xvci5jYWxsKG1lLCB0b29sdGlwSXRlbSwgbWUuX2NoYXJ0KSk7XG5cdFx0XHR9KTtcblxuXG5cdFx0XHQvLyBCdWlsZCB0aGUgVGV4dCBMaW5lc1xuXHRcdFx0bW9kZWwudGl0bGUgPSBtZS5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuYmVmb3JlQm9keSA9IG1lLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdG1vZGVsLmJvZHkgPSBtZS5nZXRCb2R5KHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRtb2RlbC5hZnRlckJvZHkgPSBtZS5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdG1vZGVsLmZvb3RlciA9IG1lLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIGRhdGEpO1xuXG5cdFx0XHQvLyBJbml0aWFsIHBvc2l0aW9uaW5nIGFuZCBjb2xvcnNcblx0XHRcdG1vZGVsLnggPSB0b29sdGlwUG9zaXRpb24ueDtcblx0XHRcdG1vZGVsLnkgPSB0b29sdGlwUG9zaXRpb24ueTtcblx0XHRcdG1vZGVsLmNhcmV0UGFkZGluZyA9IG9wdHMuY2FyZXRQYWRkaW5nO1xuXHRcdFx0bW9kZWwubGFiZWxDb2xvcnMgPSBsYWJlbENvbG9ycztcblx0XHRcdG1vZGVsLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcblxuXHRcdFx0Ly8gZGF0YSBwb2ludHNcblx0XHRcdG1vZGVsLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG5cblx0XHRcdC8vIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIGFsaWdubWVudCBvZiB0aGUgdG9vbHRpcFxuXHRcdFx0dG9vbHRpcFNpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBtb2RlbCk7XG5cdFx0XHRhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQodGhpcywgdG9vbHRpcFNpemUpO1xuXHRcdFx0Ly8gRmluYWwgU2l6ZSBhbmQgUG9zaXRpb25cblx0XHRcdGJhY2tncm91bmRQb2ludCA9IGdldEJhY2tncm91bmRQb2ludChtb2RlbCwgdG9vbHRpcFNpemUsIGFsaWdubWVudCwgbWUuX2NoYXJ0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bW9kZWwub3BhY2l0eSA9IDA7XG5cdFx0fVxuXG5cdFx0bW9kZWwueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcblx0XHRtb2RlbC55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuXHRcdG1vZGVsLnggPSBiYWNrZ3JvdW5kUG9pbnQueDtcblx0XHRtb2RlbC55ID0gYmFja2dyb3VuZFBvaW50Lnk7XG5cdFx0bW9kZWwud2lkdGggPSB0b29sdGlwU2l6ZS53aWR0aDtcblx0XHRtb2RlbC5oZWlnaHQgPSB0b29sdGlwU2l6ZS5oZWlnaHQ7XG5cblx0XHQvLyBQb2ludCB3aGVyZSB0aGUgY2FyZXQgb24gdGhlIHRvb2x0aXAgcG9pbnRzIHRvXG5cdFx0bW9kZWwuY2FyZXRYID0gdG9vbHRpcFBvc2l0aW9uLng7XG5cdFx0bW9kZWwuY2FyZXRZID0gdG9vbHRpcFBvc2l0aW9uLnk7XG5cblx0XHRtZS5fbW9kZWwgPSBtb2RlbDtcblxuXHRcdGlmIChjaGFuZ2VkICYmIG9wdHMuY3VzdG9tKSB7XG5cdFx0XHRvcHRzLmN1c3RvbS5jYWxsKG1lLCBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdGRyYXdDYXJldDogZnVuY3Rpb24odG9vbHRpcFBvaW50LCBzaXplKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgdm0pO1xuXG5cdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngxLCBjYXJldFBvc2l0aW9uLnkxKTtcblx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDIsIGNhcmV0UG9zaXRpb24ueTIpO1xuXHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MywgY2FyZXRQb3NpdGlvbi55Myk7XG5cdH0sXG5cdGdldENhcmV0UG9zaXRpb246IGZ1bmN0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgdm0pIHtcblx0XHR2YXIgeDEsIHgyLCB4MywgeTEsIHkyLCB5Mztcblx0XHR2YXIgY2FyZXRTaXplID0gdm0uY2FyZXRTaXplO1xuXHRcdHZhciBjb3JuZXJSYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XG5cdFx0dmFyIHhBbGlnbiA9IHZtLnhBbGlnbjtcblx0XHR2YXIgeUFsaWduID0gdm0ueUFsaWduO1xuXHRcdHZhciBwdFggPSB0b29sdGlwUG9pbnQueDtcblx0XHR2YXIgcHRZID0gdG9vbHRpcFBvaW50Lnk7XG5cdFx0dmFyIHdpZHRoID0gc2l6ZS53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuXHRcdFx0eTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG5cblx0XHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0XHR4MSA9IHB0WDtcblx0XHRcdFx0eDIgPSB4MSAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDMgPSB4MTtcblxuXHRcdFx0XHR5MSA9IHkyICsgY2FyZXRTaXplO1xuXHRcdFx0XHR5MyA9IHkyIC0gY2FyZXRTaXplO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eDEgPSBwdFggKyB3aWR0aDtcblx0XHRcdFx0eDIgPSB4MSArIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDMgPSB4MTtcblxuXHRcdFx0XHR5MSA9IHkyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR5MyA9IHkyICsgY2FyZXRTaXplO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdFx0eDIgPSBwdFggKyBjb3JuZXJSYWRpdXMgKyAoY2FyZXRTaXplKTtcblx0XHRcdFx0eDEgPSB4MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcblx0XHRcdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHRcdHgyID0gcHRYICsgd2lkdGggLSBjb3JuZXJSYWRpdXMgLSBjYXJldFNpemU7XG5cdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XG5cdFx0XHRcdHgzID0geDIgKyBjYXJldFNpemU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4MiA9IHZtLmNhcmV0WDtcblx0XHRcdFx0eDEgPSB4MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcblx0XHRcdH1cblx0XHRcdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0XHRcdHkxID0gcHRZO1xuXHRcdFx0XHR5MiA9IHkxIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR5MyA9IHkxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eTEgPSBwdFkgKyBoZWlnaHQ7XG5cdFx0XHRcdHkyID0geTEgKyBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTE7XG5cdFx0XHRcdC8vIGludmVydCBkcmF3aW5nIG9yZGVyXG5cdFx0XHRcdHZhciB0bXAgPSB4Mztcblx0XHRcdFx0eDMgPSB4MTtcblx0XHRcdFx0eDEgPSB0bXA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7eDE6IHgxLCB4MjogeDIsIHgzOiB4MywgeTE6IHkxLCB5MjogeTIsIHkzOiB5M307XG5cdH0sXG5cblx0ZHJhd1RpdGxlOiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xuXHRcdHZhciB0aXRsZSA9IHZtLnRpdGxlO1xuXG5cdFx0aWYgKHRpdGxlLmxlbmd0aCkge1xuXHRcdFx0cHQueCA9IGdldEFsaWduZWRYKHZtLCB2bS5fdGl0bGVBbGlnbik7XG5cblx0XHRcdGN0eC50ZXh0QWxpZ24gPSB2bS5fdGl0bGVBbGlnbjtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuXHRcdFx0dmFyIHRpdGxlRm9udFNpemUgPSB2bS50aXRsZUZvbnRTaXplO1xuXHRcdFx0dmFyIHRpdGxlU3BhY2luZyA9IHZtLnRpdGxlU3BhY2luZztcblxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLnRpdGxlRm9udENvbG9yO1xuXHRcdFx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyh0aXRsZUZvbnRTaXplLCB2bS5fdGl0bGVGb250U3R5bGUsIHZtLl90aXRsZUZvbnRGYW1pbHkpO1xuXG5cdFx0XHR2YXIgaSwgbGVuO1xuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gdGl0bGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBwdC54LCBwdC55KTtcblx0XHRcdFx0cHQueSArPSB0aXRsZUZvbnRTaXplICsgdGl0bGVTcGFjaW5nOyAvLyBMaW5lIEhlaWdodCBhbmQgc3BhY2luZ1xuXG5cdFx0XHRcdGlmIChpICsgMSA9PT0gdGl0bGUubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cHQueSArPSB2bS50aXRsZU1hcmdpbkJvdHRvbSAtIHRpdGxlU3BhY2luZzsgLy8gSWYgTGFzdCwgYWRkIG1hcmdpbiwgcmVtb3ZlIHNwYWNpbmdcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRkcmF3Qm9keTogZnVuY3Rpb24ocHQsIHZtLCBjdHgpIHtcblx0XHR2YXIgYm9keUZvbnRTaXplID0gdm0uYm9keUZvbnRTaXplO1xuXHRcdHZhciBib2R5U3BhY2luZyA9IHZtLmJvZHlTcGFjaW5nO1xuXHRcdHZhciBib2R5QWxpZ24gPSB2bS5fYm9keUFsaWduO1xuXHRcdHZhciBib2R5ID0gdm0uYm9keTtcblx0XHR2YXIgZHJhd0NvbG9yQm94ZXMgPSB2bS5kaXNwbGF5Q29sb3JzO1xuXHRcdHZhciBsYWJlbENvbG9ycyA9IHZtLmxhYmVsQ29sb3JzO1xuXHRcdHZhciB4TGluZVBhZGRpbmcgPSAwO1xuXHRcdHZhciBjb2xvclggPSBkcmF3Q29sb3JCb3hlcyA/IGdldEFsaWduZWRYKHZtLCAnbGVmdCcpIDogMDtcblx0XHR2YXIgdGV4dENvbG9yO1xuXG5cdFx0Y3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcblx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cdFx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyhib2R5Rm9udFNpemUsIHZtLl9ib2R5Rm9udFN0eWxlLCB2bS5fYm9keUZvbnRGYW1pbHkpO1xuXG5cdFx0cHQueCA9IGdldEFsaWduZWRYKHZtLCBib2R5QWxpZ24pO1xuXG5cdFx0Ly8gQmVmb3JlIEJvZHlcblx0XHR2YXIgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG5cdFx0XHRjdHguZmlsbFRleHQobGluZSwgcHQueCArIHhMaW5lUGFkZGluZywgcHQueSk7XG5cdFx0XHRwdC55ICs9IGJvZHlGb250U2l6ZSArIGJvZHlTcGFjaW5nO1xuXHRcdH07XG5cblx0XHQvLyBCZWZvcmUgYm9keSBsaW5lc1xuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5ib2R5Rm9udENvbG9yO1xuXHRcdGhlbHBlcnMkMS5lYWNoKHZtLmJlZm9yZUJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblxuXHRcdHhMaW5lUGFkZGluZyA9IGRyYXdDb2xvckJveGVzICYmIGJvZHlBbGlnbiAhPT0gJ3JpZ2h0J1xuXHRcdFx0PyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJvZHlGb250U2l6ZSAvIDIgKyAxKSA6IChib2R5Rm9udFNpemUgKyAyKVxuXHRcdFx0OiAwO1xuXG5cdFx0Ly8gRHJhdyBib2R5IGxpbmVzIG5vd1xuXHRcdGhlbHBlcnMkMS5lYWNoKGJvZHksIGZ1bmN0aW9uKGJvZHlJdGVtLCBpKSB7XG5cdFx0XHR0ZXh0Q29sb3IgPSB2bS5sYWJlbFRleHRDb2xvcnNbaV07XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuXHRcdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmxpbmVzLCBmdW5jdGlvbihsaW5lKSB7XG5cdFx0XHRcdC8vIERyYXcgTGVnZW5kLWxpa2UgYm94ZXMgaWYgbmVlZGVkXG5cdFx0XHRcdGlmIChkcmF3Q29sb3JCb3hlcykge1xuXHRcdFx0XHRcdC8vIEZpbGwgYSB3aGl0ZSByZWN0IHNvIHRoYXQgY29sb3VycyBtZXJnZSBuaWNlbHkgaWYgdGhlIG9wYWNpdHkgaXMgPCAxXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmxlZ2VuZENvbG9yQmFja2dyb3VuZDtcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoY29sb3JYLCBwdC55LCBib2R5Rm9udFNpemUsIGJvZHlGb250U2l6ZSk7XG5cblx0XHRcdFx0XHQvLyBCb3JkZXJcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gMTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9yc1tpXS5ib3JkZXJDb2xvcjtcblx0XHRcdFx0XHRjdHguc3Ryb2tlUmVjdChjb2xvclgsIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcblxuXHRcdFx0XHRcdC8vIElubmVyIHNxdWFyZVxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yc1tpXS5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KGNvbG9yWCArIDEsIHB0LnkgKyAxLCBib2R5Rm9udFNpemUgLSAyLCBib2R5Rm9udFNpemUgLSAyKTtcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmlsbExpbmVPZlRleHQobGluZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcblx0XHR9KTtcblxuXHRcdC8vIFJlc2V0IGJhY2sgdG8gMCBmb3IgYWZ0ZXIgYm9keVxuXHRcdHhMaW5lUGFkZGluZyA9IDA7XG5cblx0XHQvLyBBZnRlciBib2R5IGxpbmVzXG5cdFx0aGVscGVycyQxLmVhY2godm0uYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG5cdFx0cHQueSAtPSBib2R5U3BhY2luZzsgLy8gUmVtb3ZlIGxhc3QgYm9keSBzcGFjaW5nXG5cdH0sXG5cblx0ZHJhd0Zvb3RlcjogZnVuY3Rpb24ocHQsIHZtLCBjdHgpIHtcblx0XHR2YXIgZm9vdGVyID0gdm0uZm9vdGVyO1xuXG5cdFx0aWYgKGZvb3Rlci5sZW5ndGgpIHtcblx0XHRcdHB0LnggPSBnZXRBbGlnbmVkWCh2bSwgdm0uX2Zvb3RlckFsaWduKTtcblx0XHRcdHB0LnkgKz0gdm0uZm9vdGVyTWFyZ2luVG9wO1xuXG5cdFx0XHRjdHgudGV4dEFsaWduID0gdm0uX2Zvb3RlckFsaWduO1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdm0uZm9vdGVyRm9udENvbG9yO1xuXHRcdFx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyh2bS5mb290ZXJGb250U2l6ZSwgdm0uX2Zvb3RlckZvbnRTdHlsZSwgdm0uX2Zvb3RlckZvbnRGYW1pbHkpO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChmb290ZXIsIGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxpbmUsIHB0LngsIHB0LnkpO1xuXHRcdFx0XHRwdC55ICs9IHZtLmZvb3RlckZvbnRTaXplICsgdm0uZm9vdGVyU3BhY2luZztcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRkcmF3QmFja2dyb3VuZDogZnVuY3Rpb24ocHQsIHZtLCBjdHgsIHRvb2x0aXBTaXplKSB7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvcjtcblx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvcjtcblx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGg7XG5cdFx0dmFyIHhBbGlnbiA9IHZtLnhBbGlnbjtcblx0XHR2YXIgeUFsaWduID0gdm0ueUFsaWduO1xuXHRcdHZhciB4ID0gcHQueDtcblx0XHR2YXIgeSA9IHB0Lnk7XG5cdFx0dmFyIHdpZHRoID0gdG9vbHRpcFNpemUud2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IHRvb2x0aXBTaXplLmhlaWdodDtcblx0XHR2YXIgcmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG5cdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xuXHRcdH1cblx0XHRjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuXHRcdGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG5cdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xuXHRcdH1cblx0XHRjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xuXHRcdH1cblx0XHRjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuXHRcdGN0eC5jbG9zZVBhdGgoKTtcblxuXHRcdGN0eC5maWxsKCk7XG5cblx0XHRpZiAodm0uYm9yZGVyV2lkdGggPiAwKSB7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdGlmICh2bS5vcGFjaXR5ID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRvb2x0aXBTaXplID0ge1xuXHRcdFx0d2lkdGg6IHZtLndpZHRoLFxuXHRcdFx0aGVpZ2h0OiB2bS5oZWlnaHRcblx0XHR9O1xuXHRcdHZhciBwdCA9IHtcblx0XHRcdHg6IHZtLngsXG5cdFx0XHR5OiB2bS55XG5cdFx0fTtcblxuXHRcdC8vIElFMTEvRWRnZSBkb2VzIG5vdCBsaWtlIHZlcnkgc21hbGwgb3BhY2l0aWVzLCBzbyBzbmFwIHRvIDBcblx0XHR2YXIgb3BhY2l0eSA9IE1hdGguYWJzKHZtLm9wYWNpdHkgPCAxZS0zKSA/IDAgOiB2bS5vcGFjaXR5O1xuXG5cdFx0Ly8gVHJ1dGh5L2ZhbHNleSB2YWx1ZSBmb3IgZW1wdHkgdG9vbHRpcFxuXHRcdHZhciBoYXNUb29sdGlwQ29udGVudCA9IHZtLnRpdGxlLmxlbmd0aCB8fCB2bS5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB2bS5ib2R5Lmxlbmd0aCB8fCB2bS5hZnRlckJvZHkubGVuZ3RoIHx8IHZtLmZvb3Rlci5sZW5ndGg7XG5cblx0XHRpZiAodGhpcy5fb3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcblxuXHRcdFx0Ly8gRHJhdyBCYWNrZ3JvdW5kXG5cdFx0XHR0aGlzLmRyYXdCYWNrZ3JvdW5kKHB0LCB2bSwgY3R4LCB0b29sdGlwU2l6ZSk7XG5cblx0XHRcdC8vIERyYXcgVGl0bGUsIEJvZHksIGFuZCBGb290ZXJcblx0XHRcdHB0LnkgKz0gdm0ueVBhZGRpbmc7XG5cblx0XHRcdC8vIFRpdGxlc1xuXHRcdFx0dGhpcy5kcmF3VGl0bGUocHQsIHZtLCBjdHgpO1xuXG5cdFx0XHQvLyBCb2R5XG5cdFx0XHR0aGlzLmRyYXdCb2R5KHB0LCB2bSwgY3R4KTtcblxuXHRcdFx0Ly8gRm9vdGVyXG5cdFx0XHR0aGlzLmRyYXdGb290ZXIocHQsIHZtLCBjdHgpO1xuXG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRvb2x0aXAgY2hhbmdlZFxuXHQgKi9cblx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUuX29wdGlvbnM7XG5cdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdG1lLl9sYXN0QWN0aXZlID0gbWUuX2xhc3RBY3RpdmUgfHwgW107XG5cblx0XHQvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgdG9vbHRpcHNcblx0XHRpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG5cdFx0XHRtZS5fYWN0aXZlID0gW107XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLl9hY3RpdmUgPSBtZS5fY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIExhc3QgQWN0aXZlc1xuXHRcdGNoYW5nZWQgPSAhaGVscGVycyQxLmFycmF5RXF1YWxzKG1lLl9hY3RpdmUsIG1lLl9sYXN0QWN0aXZlKTtcblxuXHRcdC8vIE9ubHkgaGFuZGxlIHRhcmdldCBldmVudCBvbiB0b29sdGlwIGNoYW5nZVxuXHRcdGlmIChjaGFuZ2VkKSB7XG5cdFx0XHRtZS5fbGFzdEFjdGl2ZSA9IG1lLl9hY3RpdmU7XG5cblx0XHRcdGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5jdXN0b20pIHtcblx0XHRcdFx0bWUuX2V2ZW50UG9zaXRpb24gPSB7XG5cdFx0XHRcdFx0eDogZS54LFxuXHRcdFx0XHRcdHk6IGUueVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdG1lLnVwZGF0ZSh0cnVlKTtcblx0XHRcdFx0bWUucGl2b3QoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2hhbmdlZDtcblx0fVxufSk7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzXG4gKi9cbnZhciBwb3NpdGlvbmVyc18xID0gcG9zaXRpb25lcnM7XG5cbnZhciBjb3JlX3Rvb2x0aXAgPSBleHBvcnRzJDM7XG5jb3JlX3Rvb2x0aXAucG9zaXRpb25lcnMgPSBwb3NpdGlvbmVyc18xO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkOCA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGVsZW1lbnRzOiB7fSxcblx0ZXZlbnRzOiBbXG5cdFx0J21vdXNlbW92ZScsXG5cdFx0J21vdXNlb3V0Jyxcblx0XHQnY2xpY2snLFxuXHRcdCd0b3VjaHN0YXJ0Jyxcblx0XHQndG91Y2htb3ZlJ1xuXHRdLFxuXHRob3Zlcjoge1xuXHRcdG9uSG92ZXI6IG51bGwsXG5cdFx0bW9kZTogJ25lYXJlc3QnLFxuXHRcdGludGVyc2VjdDogdHJ1ZSxcblx0XHRhbmltYXRpb25EdXJhdGlvbjogNDAwXG5cdH0sXG5cdG9uQ2xpY2s6IG51bGwsXG5cdG1haW50YWluQXNwZWN0UmF0aW86IHRydWUsXG5cdHJlc3BvbnNpdmU6IHRydWUsXG5cdHJlc3BvbnNpdmVBbmltYXRpb25EdXJhdGlvbjogMFxufSk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbWVyZ2UgdGhlIGdpdmVuIGNvbmZpZyBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgYHNjYWxlc2Agb3B0aW9uXG4gKiBieSBpbmNvcnBvcmF0aW5nIHNjYWxlIGRlZmF1bHRzIGluIGB4QXhlc2AgYW5kIGB5QXhlc2AgYXJyYXkgaXRlbXMsIHRoZW5cbiAqIHJldHVybnMgYSBkZWVwIGNvcHkgb2YgdGhlIHJlc3VsdCwgdGh1cyBkb2Vzbid0IGFsdGVyIGlucHV0cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZygvKiBjb25maWcgb2JqZWN0cyAuLi4gKi8pIHtcblx0cmV0dXJuIGhlbHBlcnMkMS5tZXJnZSh7fSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCB7XG5cdFx0bWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0XHRpZiAoa2V5ID09PSAneEF4ZXMnIHx8IGtleSA9PT0gJ3lBeGVzJykge1xuXHRcdFx0XHR2YXIgc2xlbiA9IHNvdXJjZVtrZXldLmxlbmd0aDtcblx0XHRcdFx0dmFyIGksIHR5cGUsIHNjYWxlO1xuXG5cdFx0XHRcdGlmICghdGFyZ2V0W2tleV0pIHtcblx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHNsZW47ICsraSkge1xuXHRcdFx0XHRcdHNjYWxlID0gc291cmNlW2tleV1baV07XG5cdFx0XHRcdFx0dHlwZSA9IHZhbHVlT3JEZWZhdWx0JDgoc2NhbGUudHlwZSwga2V5ID09PSAneEF4ZXMnID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInKTtcblxuXHRcdFx0XHRcdGlmIChpID49IHRhcmdldFtrZXldLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W2tleV0ucHVzaCh7fSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCF0YXJnZXRba2V5XVtpXS50eXBlIHx8IChzY2FsZS50eXBlICYmIHNjYWxlLnR5cGUgIT09IHRhcmdldFtrZXldW2ldLnR5cGUpKSB7XG5cdFx0XHRcdFx0XHQvLyBuZXcvdW50eXBlZCBzY2FsZSBvciB0eXBlIGNoYW5nZWQ6IGxldCdzIGFwcGx5IHRoZSBuZXcgZGVmYXVsdHNcblx0XHRcdFx0XHRcdC8vIHRoZW4gbWVyZ2Ugc291cmNlIHNjYWxlIHRvIGNvcnJlY3RseSBvdmVyd3JpdGUgdGhlIGRlZmF1bHRzLlxuXHRcdFx0XHRcdFx0aGVscGVycyQxLm1lcmdlKHRhcmdldFtrZXldW2ldLCBbY29yZV9zY2FsZVNlcnZpY2UuZ2V0U2NhbGVEZWZhdWx0cyh0eXBlKSwgc2NhbGVdKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gc2NhbGVzIHR5cGUgYXJlIHRoZSBzYW1lXG5cdFx0XHRcdFx0XHRoZWxwZXJzJDEubWVyZ2UodGFyZ2V0W2tleV1baV0sIHNjYWxlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhlbHBlcnMkMS5fbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbWVyZ2UgdGhlIGdpdmVuIGNvbmZpZyBvYmplY3RzIGFzIHRoZSByb290IG9wdGlvbnMgYnkgaGFuZGxpbmdcbiAqIGRlZmF1bHQgc2NhbGUgb3B0aW9ucyBmb3IgdGhlIGBzY2FsZXNgIGFuZCBgc2NhbGVgIHByb3BlcnRpZXMsIHRoZW4gcmV0dXJuc1xuICogYSBkZWVwIGNvcHkgb2YgdGhlIHJlc3VsdCwgdGh1cyBkb2Vzbid0IGFsdGVyIGlucHV0cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VDb25maWcoLyogY29uZmlnIG9iamVjdHMgLi4uICovKSB7XG5cdHJldHVybiBoZWxwZXJzJDEubWVyZ2Uoe30sIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwge1xuXHRcdG1lcmdlcjogZnVuY3Rpb24oa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XSB8fCB7fTtcblx0XHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XG5cblx0XHRcdGlmIChrZXkgPT09ICdzY2FsZXMnKSB7XG5cdFx0XHRcdC8vIHNjYWxlIGNvbmZpZyBtZXJnaW5nIGlzIGNvbXBsZXguIEFkZCBvdXIgb3duIGZ1bmN0aW9uIGhlcmUgZm9yIHRoYXRcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBtZXJnZVNjYWxlQ29uZmlnKHR2YWwsIHN2YWwpO1xuXHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzY2FsZScpIHtcblx0XHRcdFx0Ly8gdXNlZCBpbiBwb2xhciBhcmVhICYgcmFkYXIgY2hhcnRzIHNpbmNlIHRoZXJlIGlzIG9ubHkgb25lIHNjYWxlXG5cdFx0XHRcdHRhcmdldFtrZXldID0gaGVscGVycyQxLm1lcmdlKHR2YWwsIFtjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZURlZmF1bHRzKHN2YWwudHlwZSksIHN2YWxdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhlbHBlcnMkMS5fbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIGluaXRDb25maWcoY29uZmlnKSB7XG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBEbyBOT1QgdXNlIG1lcmdlQ29uZmlnIGZvciB0aGUgZGF0YSBvYmplY3QgYmVjYXVzZSB0aGlzIG1ldGhvZCBtZXJnZXMgYXJyYXlzXG5cdC8vIGFuZCBzbyB3b3VsZCBjaGFuZ2UgcmVmZXJlbmNlcyB0byBsYWJlbHMgYW5kIGRhdGFzZXRzLCBwcmV2ZW50aW5nIGRhdGEgdXBkYXRlcy5cblx0dmFyIGRhdGEgPSBjb25maWcuZGF0YSA9IGNvbmZpZy5kYXRhIHx8IHt9O1xuXHRkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcblx0ZGF0YS5sYWJlbHMgPSBkYXRhLmxhYmVscyB8fCBbXTtcblxuXHRjb25maWcub3B0aW9ucyA9IG1lcmdlQ29uZmlnKFxuXHRcdGNvcmVfZGVmYXVsdHMuZ2xvYmFsLFxuXHRcdGNvcmVfZGVmYXVsdHNbY29uZmlnLnR5cGVdLFxuXHRcdGNvbmZpZy5vcHRpb25zIHx8IHt9KTtcblxuXHRyZXR1cm4gY29uZmlnO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb25maWcoY2hhcnQpIHtcblx0dmFyIG5ld09wdGlvbnMgPSBjaGFydC5vcHRpb25zO1xuXG5cdGhlbHBlcnMkMS5lYWNoKGNoYXJ0LnNjYWxlcywgZnVuY3Rpb24oc2NhbGUpIHtcblx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBzY2FsZSk7XG5cdH0pO1xuXG5cdG5ld09wdGlvbnMgPSBtZXJnZUNvbmZpZyhcblx0XHRjb3JlX2RlZmF1bHRzLmdsb2JhbCxcblx0XHRjb3JlX2RlZmF1bHRzW2NoYXJ0LmNvbmZpZy50eXBlXSxcblx0XHRuZXdPcHRpb25zKTtcblxuXHRjaGFydC5vcHRpb25zID0gY2hhcnQuY29uZmlnLm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuXHRjaGFydC5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG5cdGNoYXJ0LmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcblxuXHQvLyBUb29sdGlwXG5cdGNoYXJ0LnRvb2x0aXAuX29wdGlvbnMgPSBuZXdPcHRpb25zLnRvb2x0aXBzO1xuXHRjaGFydC50b29sdGlwLmluaXRpYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24pIHtcblx0cmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG59XG5cbnZhciBDaGFydCA9IGZ1bmN0aW9uKGl0ZW0sIGNvbmZpZykge1xuXHR0aGlzLmNvbnN0cnVjdChpdGVtLCBjb25maWcpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbmhlbHBlcnMkMS5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCAvKiogQGxlbmRzIENoYXJ0ICovIHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjb25zdHJ1Y3Q6IGZ1bmN0aW9uKGl0ZW0sIGNvbmZpZykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRjb25maWcgPSBpbml0Q29uZmlnKGNvbmZpZyk7XG5cblx0XHR2YXIgY29udGV4dCA9IHBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGl0ZW0sIGNvbmZpZyk7XG5cdFx0dmFyIGNhbnZhcyA9IGNvbnRleHQgJiYgY29udGV4dC5jYW52YXM7XG5cdFx0dmFyIGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xuXHRcdHZhciB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG5cblx0XHRtZS5pZCA9IGhlbHBlcnMkMS51aWQoKTtcblx0XHRtZS5jdHggPSBjb250ZXh0O1xuXHRcdG1lLmNhbnZhcyA9IGNhbnZhcztcblx0XHRtZS5jb25maWcgPSBjb25maWc7XG5cdFx0bWUud2lkdGggPSB3aWR0aDtcblx0XHRtZS5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0bWUuYXNwZWN0UmF0aW8gPSBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XG5cdFx0bWUub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuXHRcdG1lLl9idWZmZXJlZFJlbmRlciA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIENoYXJ0IGFuZCBDaGFydC5Db250cm9sbGVyIGhhdmUgYmVlbiBtZXJnZWQsXG5cdFx0ICogdGhlIFwiaW5zdGFuY2VcIiBzdGlsbCBuZWVkIHRvIGJlIGRlZmluZWQgc2luY2UgaXQgbWlnaHQgYmUgY2FsbGVkIGZyb20gcGx1Z2lucy5cblx0XHQgKiBAcHJvcCBDaGFydCNjaGFydFxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcblx0XHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRtZS5jaGFydCA9IG1lO1xuXHRcdG1lLmNvbnRyb2xsZXIgPSBtZTsgLy8gY2hhcnQuY2hhcnQuY29udHJvbGxlciAjaW5jZXB0aW9uXG5cblx0XHQvLyBBZGQgdGhlIGNoYXJ0IGluc3RhbmNlIHRvIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG5cdFx0Q2hhcnQuaW5zdGFuY2VzW21lLmlkXSA9IG1lO1xuXG5cdFx0Ly8gRGVmaW5lIGFsaWFzIHRvIHRoZSBjb25maWcgZGF0YTogYGNoYXJ0LmRhdGEgPT09IGNoYXJ0LmNvbmZpZy5kYXRhYFxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ2RhdGEnLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbWUuY29uZmlnLmRhdGE7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRtZS5jb25maWcuZGF0YSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcblx0XHRcdC8vIFRoZSBnaXZlbiBpdGVtIGlzIG5vdCBhIGNvbXBhdGlibGUgY29udGV4dDJkIGVsZW1lbnQsIGxldCdzIHJldHVybiBiZWZvcmUgZmluYWxpemluZ1xuXHRcdFx0Ly8gdGhlIGNoYXJ0IGluaXRpYWxpemF0aW9uIGJ1dCBhZnRlciBzZXR0aW5nIGJhc2ljIGNoYXJ0IC8gY29udHJvbGxlciBwcm9wZXJ0aWVzIHRoYXRcblx0XHRcdC8vIGNhbiBoZWxwIHRvIGZpZ3VyZSBvdXQgdGhhdCB0aGUgY2hhcnQgaXMgbm90IHZhbGlkIChlLmcgY2hhcnQuY2FudmFzICE9PSBudWxsKTtcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bWUuaW5pdGlhbGl6ZSgpO1xuXHRcdG1lLnVwZGF0ZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIEJlZm9yZSBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlSW5pdCcpO1xuXG5cdFx0aGVscGVycyQxLnJldGluYVNjYWxlKG1lLCBtZS5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuXG5cdFx0bWUuYmluZEV2ZW50cygpO1xuXG5cdFx0aWYgKG1lLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuXHRcdFx0Ly8gSW5pdGlhbCByZXNpemUgYmVmb3JlIGNoYXJ0IGRyYXdzIChtdXN0IGJlIHNpbGVudCB0byBwcmVzZXJ2ZSBpbml0aWFsIGFuaW1hdGlvbnMpLlxuXHRcdFx0bWUucmVzaXplKHRydWUpO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSBzY2FsZXMgaGF2ZSBJRHMgYW5kIGFyZSBidWlsdCBiZWZvcmUgd2UgYnVpbGQgYW55IGNvbnRyb2xsZXJzLlxuXHRcdG1lLmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcblx0XHRtZS5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG5cdFx0bWUuaW5pdFRvb2xUaXAoKTtcblxuXHRcdC8vIEFmdGVyIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckluaXQnKTtcblxuXHRcdHJldHVybiBtZTtcblx0fSxcblxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbnZhcy5jbGVhcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHQvLyBTdG9wcyBhbnkgY3VycmVudCBhbmltYXRpb24gbG9vcCBvY2N1cnJpbmdcblx0XHRjb3JlX2FuaW1hdGlvbnMuY2FuY2VsQW5pbWF0aW9uKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlc2l6ZTogZnVuY3Rpb24oc2lsZW50KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGNhbnZhcyA9IG1lLmNhbnZhcztcblx0XHR2YXIgYXNwZWN0UmF0aW8gPSAob3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIG1lLmFzcGVjdFJhdGlvKSB8fCBudWxsO1xuXG5cdFx0Ly8gdGhlIGNhbnZhcyByZW5kZXIgd2lkdGggYW5kIGhlaWdodCB3aWxsIGJlIGNhc3RlZCB0byBpbnRlZ2VycyBzbyBtYWtlIHN1cmUgdGhhdFxuXHRcdC8vIHRoZSBjYW52YXMgZGlzcGxheSBzdHlsZSB1c2VzIHRoZSBzYW1lIGludGVnZXIgdmFsdWVzIHRvIGF2b2lkIGJsdXJyaW5nIGVmZmVjdC5cblxuXHRcdC8vIFNldCB0byAwIGluc3RlYWQgb2YgY2FudmFzLnNpemUgYmVjYXVzZSB0aGUgc2l6ZSBkZWZhdWx0cyB0byAzMDB4MTUwIGlmIHRoZSBlbGVtZW50IGlzIGNvbGxhcHNlZFxuXHRcdHZhciBuZXdXaWR0aCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoaGVscGVycyQxLmdldE1heGltdW1XaWR0aChjYW52YXMpKSk7XG5cdFx0dmFyIG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IoYXNwZWN0UmF0aW8gPyBuZXdXaWR0aCAvIGFzcGVjdFJhdGlvIDogaGVscGVycyQxLmdldE1heGltdW1IZWlnaHQoY2FudmFzKSkpO1xuXG5cdFx0aWYgKG1lLndpZHRoID09PSBuZXdXaWR0aCAmJiBtZS5oZWlnaHQgPT09IG5ld0hlaWdodCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNhbnZhcy53aWR0aCA9IG1lLndpZHRoID0gbmV3V2lkdGg7XG5cdFx0Y2FudmFzLmhlaWdodCA9IG1lLmhlaWdodCA9IG5ld0hlaWdodDtcblx0XHRjYW52YXMuc3R5bGUud2lkdGggPSBuZXdXaWR0aCArICdweCc7XG5cdFx0Y2FudmFzLnN0eWxlLmhlaWdodCA9IG5ld0hlaWdodCArICdweCc7XG5cblx0XHRoZWxwZXJzJDEucmV0aW5hU2NhbGUobWUsIG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG5cblx0XHRpZiAoIXNpbGVudCkge1xuXHRcdFx0Ly8gTm90aWZ5IGFueSBwbHVnaW5zIGFib3V0IHRoZSByZXNpemVcblx0XHRcdHZhciBuZXdTaXplID0ge3dpZHRoOiBuZXdXaWR0aCwgaGVpZ2h0OiBuZXdIZWlnaHR9O1xuXHRcdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ3Jlc2l6ZScsIFtuZXdTaXplXSk7XG5cblx0XHRcdC8vIE5vdGlmeSBvZiByZXNpemVcblx0XHRcdGlmIChvcHRpb25zLm9uUmVzaXplKSB7XG5cdFx0XHRcdG9wdGlvbnMub25SZXNpemUobWUsIG5ld1NpemUpO1xuXHRcdFx0fVxuXG5cdFx0XHRtZS5zdG9wKCk7XG5cdFx0XHRtZS51cGRhdGUoe1xuXHRcdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5yZXNwb25zaXZlQW5pbWF0aW9uRHVyYXRpb25cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRlbnN1cmVTY2FsZXNIYXZlSURzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHR2YXIgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuXHRcdHZhciBzY2FsZU9wdGlvbnMgPSBvcHRpb25zLnNjYWxlO1xuXG5cdFx0aGVscGVycyQxLmVhY2goc2NhbGVzT3B0aW9ucy54QXhlcywgZnVuY3Rpb24oeEF4aXNPcHRpb25zLCBpbmRleCkge1xuXHRcdFx0eEF4aXNPcHRpb25zLmlkID0geEF4aXNPcHRpb25zLmlkIHx8ICgneC1heGlzLScgKyBpbmRleCk7XG5cdFx0fSk7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChzY2FsZXNPcHRpb25zLnlBeGVzLCBmdW5jdGlvbih5QXhpc09wdGlvbnMsIGluZGV4KSB7XG5cdFx0XHR5QXhpc09wdGlvbnMuaWQgPSB5QXhpc09wdGlvbnMuaWQgfHwgKCd5LWF4aXMtJyArIGluZGV4KTtcblx0XHR9KTtcblxuXHRcdGlmIChzY2FsZU9wdGlvbnMpIHtcblx0XHRcdHNjYWxlT3B0aW9ucy5pZCA9IHNjYWxlT3B0aW9ucy5pZCB8fCAnc2NhbGUnO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQnVpbGRzIGEgbWFwIG9mIHNjYWxlIElEIHRvIHNjYWxlIG9iamVjdCBmb3IgZnV0dXJlIGxvb2t1cC5cblx0ICovXG5cdGJ1aWxkT3JVcGRhdGVTY2FsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBzY2FsZXMgPSBtZS5zY2FsZXMgfHwge307XG5cdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0dmFyIHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhzY2FsZXMpLnJlZHVjZShmdW5jdGlvbihvYmosIGlkKSB7XG5cdFx0XHRvYmpbaWRdID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sIHt9KTtcblxuXHRcdGlmIChvcHRpb25zLnNjYWxlcykge1xuXHRcdFx0aXRlbXMgPSBpdGVtcy5jb25jYXQoXG5cdFx0XHRcdChvcHRpb25zLnNjYWxlcy54QXhlcyB8fCBbXSkubWFwKGZ1bmN0aW9uKHhBeGlzT3B0aW9ucykge1xuXHRcdFx0XHRcdHJldHVybiB7b3B0aW9uczogeEF4aXNPcHRpb25zLCBkdHlwZTogJ2NhdGVnb3J5JywgZHBvc2l0aW9uOiAnYm90dG9tJ307XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHQob3B0aW9ucy5zY2FsZXMueUF4ZXMgfHwgW10pLm1hcChmdW5jdGlvbih5QXhpc09wdGlvbnMpIHtcblx0XHRcdFx0XHRyZXR1cm4ge29wdGlvbnM6IHlBeGlzT3B0aW9ucywgZHR5cGU6ICdsaW5lYXInLCBkcG9zaXRpb246ICdsZWZ0J307XG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnNjYWxlKSB7XG5cdFx0XHRpdGVtcy5wdXNoKHtcblx0XHRcdFx0b3B0aW9uczogb3B0aW9ucy5zY2FsZSxcblx0XHRcdFx0ZHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuXHRcdFx0XHRpc0RlZmF1bHQ6IHRydWUsXG5cdFx0XHRcdGRwb3NpdGlvbjogJ2NoYXJ0QXJlYSdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGhlbHBlcnMkMS5lYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuXHRcdFx0dmFyIGlkID0gc2NhbGVPcHRpb25zLmlkO1xuXHRcdFx0dmFyIHNjYWxlVHlwZSA9IHZhbHVlT3JEZWZhdWx0JDgoc2NhbGVPcHRpb25zLnR5cGUsIGl0ZW0uZHR5cGUpO1xuXG5cdFx0XHRpZiAocG9zaXRpb25Jc0hvcml6b250YWwoc2NhbGVPcHRpb25zLnBvc2l0aW9uKSAhPT0gcG9zaXRpb25Jc0hvcml6b250YWwoaXRlbS5kcG9zaXRpb24pKSB7XG5cdFx0XHRcdHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9IGl0ZW0uZHBvc2l0aW9uO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGVkW2lkXSA9IHRydWU7XG5cdFx0XHR2YXIgc2NhbGUgPSBudWxsO1xuXHRcdFx0aWYgKGlkIGluIHNjYWxlcyAmJiBzY2FsZXNbaWRdLnR5cGUgPT09IHNjYWxlVHlwZSkge1xuXHRcdFx0XHRzY2FsZSA9IHNjYWxlc1tpZF07XG5cdFx0XHRcdHNjYWxlLm9wdGlvbnMgPSBzY2FsZU9wdGlvbnM7XG5cdFx0XHRcdHNjYWxlLmN0eCA9IG1lLmN0eDtcblx0XHRcdFx0c2NhbGUuY2hhcnQgPSBtZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBzY2FsZUNsYXNzID0gY29yZV9zY2FsZVNlcnZpY2UuZ2V0U2NhbGVDb25zdHJ1Y3RvcihzY2FsZVR5cGUpO1xuXHRcdFx0XHRpZiAoIXNjYWxlQ2xhc3MpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0c2NhbGUgPSBuZXcgc2NhbGVDbGFzcyh7XG5cdFx0XHRcdFx0aWQ6IGlkLFxuXHRcdFx0XHRcdHR5cGU6IHNjYWxlVHlwZSxcblx0XHRcdFx0XHRvcHRpb25zOiBzY2FsZU9wdGlvbnMsXG5cdFx0XHRcdFx0Y3R4OiBtZS5jdHgsXG5cdFx0XHRcdFx0Y2hhcnQ6IG1lXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG5cdFx0XHR9XG5cblx0XHRcdHNjYWxlLm1lcmdlVGlja3NPcHRpb25zKCk7XG5cblx0XHRcdC8vIFRPRE8oU0IpOiBJIHRoaW5rIHdlIHNob3VsZCBiZSBhYmxlIHRvIHJlbW92ZSB0aGlzIGN1c3RvbSBjYXNlIChvcHRpb25zLnNjYWxlKVxuXHRcdFx0Ly8gYW5kIGNvbnNpZGVyIGl0IGFzIGEgcmVndWxhciBzY2FsZSBwYXJ0IG9mIHRoZSBcInNjYWxlc1wiXCIgbWFwIG9ubHkhIFRoaXMgd291bGRcblx0XHRcdC8vIG1ha2UgdGhlIGxvZ2ljIGVhc2llciBhbmQgcmVtb3ZlIHNvbWUgdXNlbGVzcz8gY3VzdG9tIGNvZGUuXG5cdFx0XHRpZiAoaXRlbS5pc0RlZmF1bHQpIHtcblx0XHRcdFx0bWUuc2NhbGUgPSBzY2FsZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHQvLyBjbGVhciB1cCBkaXNjYXJkZWQgc2NhbGVzXG5cdFx0aGVscGVycyQxLmVhY2godXBkYXRlZCwgZnVuY3Rpb24oaGFzVXBkYXRlZCwgaWQpIHtcblx0XHRcdGlmICghaGFzVXBkYXRlZCkge1xuXHRcdFx0XHRkZWxldGUgc2NhbGVzW2lkXTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdG1lLnNjYWxlcyA9IHNjYWxlcztcblxuXHRcdGNvcmVfc2NhbGVTZXJ2aWNlLmFkZFNjYWxlc1RvTGF5b3V0KHRoaXMpO1xuXHR9LFxuXG5cdGJ1aWxkT3JVcGRhdGVDb250cm9sbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbmV3Q29udHJvbGxlcnMgPSBbXTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0dmFyIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0dmFyIHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgbWUuY29uZmlnLnR5cGU7XG5cblx0XHRcdGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG5cdFx0XHRcdG1lLmRlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdH1cblx0XHRcdG1ldGEudHlwZSA9IHR5cGU7XG5cblx0XHRcdGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcblx0XHRcdFx0bWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgQ29udHJvbGxlckNsYXNzID0gY29udHJvbGxlcnNbbWV0YS50eXBlXTtcblx0XHRcdFx0aWYgKENvbnRyb2xsZXJDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdcIicgKyBtZXRhLnR5cGUgKyAnXCIgaXMgbm90IGEgY2hhcnQgdHlwZS4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1ldGEuY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyQ2xhc3MobWUsIGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdG5ld0NvbnRyb2xsZXJzLnB1c2gobWV0YS5jb250cm9sbGVyKTtcblx0XHRcdH1cblx0XHR9LCBtZSk7XG5cblx0XHRyZXR1cm4gbmV3Q29udHJvbGxlcnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlc2V0IHRoZSBlbGVtZW50cyBvZiBhbGwgZGF0YXNldHNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlc2V0RWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aGVscGVycyQxLmVhY2gobWUuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcblx0XHR9LCBtZSk7XG5cdH0sXG5cblx0LyoqXG5cdCogUmVzZXRzIHRoZSBjaGFydCBiYWNrIHRvIGl0J3Mgc3RhdGUgYmVmb3JlIHRoZSBpbml0aWFsIGFuaW1hdGlvblxuXHQqL1xuXHRyZXNldDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZXNldEVsZW1lbnRzKCk7XG5cdFx0dGhpcy50b29sdGlwLmluaXRpYWxpemUoKTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRpZiAoIWNvbmZpZyB8fCB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdGNvbmZpZyA9IHtcblx0XHRcdFx0ZHVyYXRpb246IGNvbmZpZyxcblx0XHRcdFx0bGF6eTogYXJndW1lbnRzWzFdXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHVwZGF0ZUNvbmZpZyhtZSk7XG5cblx0XHQvLyBwbHVnaW5zIG9wdGlvbnMgcmVmZXJlbmNlcyBtaWdodCBoYXZlIGNoYW5nZSwgbGV0J3MgaW52YWxpZGF0ZSB0aGUgY2FjaGVcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTExMSNpc3N1ZWNvbW1lbnQtMzU1OTM0MTY3XG5cdFx0Y29yZV9wbHVnaW5zLl9pbnZhbGlkYXRlKG1lKTtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlVXBkYXRlJykgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSW4gY2FzZSB0aGUgZW50aXJlIGRhdGEgb2JqZWN0IGNoYW5nZWRcblx0XHRtZS50b29sdGlwLl9kYXRhID0gbWUuZGF0YTtcblxuXHRcdC8vIE1ha2Ugc3VyZSBkYXRhc2V0IGNvbnRyb2xsZXJzIGFyZSB1cGRhdGVkIGFuZCBuZXcgY29udHJvbGxlcnMgYXJlIHJlc2V0XG5cdFx0dmFyIG5ld0NvbnRyb2xsZXJzID0gbWUuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG5cblx0XHQvLyBNYWtlIHN1cmUgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgaGF2ZSBjb3JyZWN0IG1ldGEgZGF0YSBjb3VudHNcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMoKTtcblx0XHR9LCBtZSk7XG5cblx0XHRtZS51cGRhdGVMYXlvdXQoKTtcblxuXHRcdC8vIENhbiBvbmx5IHJlc2V0IHRoZSBuZXcgY29udHJvbGxlcnMgYWZ0ZXIgdGhlIHNjYWxlcyBoYXZlIGJlZW4gdXBkYXRlZFxuXHRcdGlmIChtZS5vcHRpb25zLmFuaW1hdGlvbiAmJiBtZS5vcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbikge1xuXHRcdFx0aGVscGVycyQxLmVhY2gobmV3Q29udHJvbGxlcnMsIGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcblx0XHRcdFx0Y29udHJvbGxlci5yZXNldCgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0bWUudXBkYXRlRGF0YXNldHMoKTtcblxuXHRcdC8vIE5lZWQgdG8gcmVzZXQgdG9vbHRpcCBpbiBjYXNlIGl0IGlzIGRpc3BsYXllZCB3aXRoIGVsZW1lbnRzIHRoYXQgYXJlIHJlbW92ZWRcblx0XHQvLyBhZnRlciB1cGRhdGUuXG5cdFx0bWUudG9vbHRpcC5pbml0aWFsaXplKCk7XG5cblx0XHQvLyBMYXN0IGFjdGl2ZSBjb250YWlucyBpdGVtcyB0aGF0IHdlcmUgcHJldmlvdXNseSBpbiB0aGUgdG9vbHRpcC5cblx0XHQvLyBXaGVuIHdlIHJlc2V0IHRoZSB0b29sdGlwLCB3ZSBuZWVkIHRvIGNsZWFyIGl0XG5cdFx0bWUubGFzdEFjdGl2ZSA9IFtdO1xuXG5cdFx0Ly8gRG8gdGhpcyBiZWZvcmUgcmVuZGVyIHNvIHRoYXQgYW55IHBsdWdpbnMgdGhhdCBuZWVkIGZpbmFsIHNjYWxlIHVwZGF0ZXMgY2FuIHVzZSBpdFxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclVwZGF0ZScpO1xuXG5cdFx0aWYgKG1lLl9idWZmZXJlZFJlbmRlcikge1xuXHRcdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IHtcblx0XHRcdFx0ZHVyYXRpb246IGNvbmZpZy5kdXJhdGlvbixcblx0XHRcdFx0ZWFzaW5nOiBjb25maWcuZWFzaW5nLFxuXHRcdFx0XHRsYXp5OiBjb25maWcubGF6eVxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUucmVuZGVyKGNvbmZpZyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjaGFydCBsYXlvdXQgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZUxheW91dGBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyTGF5b3V0YC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZUxheW91dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlTGF5b3V0JykgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29yZV9sYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cblx0XHQvKipcblx0XHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIGBhZnRlckxheW91dGAgaW5zdGVhZC5cblx0XHQgKiBAbWV0aG9kIElQbHVnaW4jYWZ0ZXJTY2FsZVVwZGF0ZVxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LjBcblx0XHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJTY2FsZVVwZGF0ZScpO1xuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckxheW91dCcpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzVXBkYXRlYC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZURhdGFzZXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0c1VwZGF0ZScpID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gbWUuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLnVwZGF0ZURhdGFzZXQoaSk7XG5cdFx0fVxuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldHNVcGRhdGUnKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlcyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0VXBkYXRlYFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0VXBkYXRlYC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZURhdGFzZXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGluZGV4KTtcblx0XHR2YXIgYXJncyA9IHtcblx0XHRcdG1ldGE6IG1ldGEsXG5cdFx0XHRpbmRleDogaW5kZXhcblx0XHR9O1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0VXBkYXRlJywgW2FyZ3NdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRtZXRhLmNvbnRyb2xsZXIudXBkYXRlKCk7XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgW2FyZ3NdKTtcblx0fSxcblxuXHRyZW5kZXI6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRpZiAoIWNvbmZpZyB8fCB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdGNvbmZpZyA9IHtcblx0XHRcdFx0ZHVyYXRpb246IGNvbmZpZyxcblx0XHRcdFx0bGF6eTogYXJndW1lbnRzWzFdXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHZhciBhbmltYXRpb25PcHRpb25zID0gbWUub3B0aW9ucy5hbmltYXRpb247XG5cdFx0dmFyIGR1cmF0aW9uID0gdmFsdWVPckRlZmF1bHQkOChjb25maWcuZHVyYXRpb24sIGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5kdXJhdGlvbik7XG5cdFx0dmFyIGxhenkgPSBjb25maWcubGF6eTtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlUmVuZGVyJykgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9uQ29tcGxldGUgPSBmdW5jdGlvbihhbmltYXRpb24pIHtcblx0XHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclJlbmRlcicpO1xuXHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbYW5pbWF0aW9uXSwgbWUpO1xuXHRcdH07XG5cblx0XHRpZiAoYW5pbWF0aW9uT3B0aW9ucyAmJiBkdXJhdGlvbikge1xuXHRcdFx0dmFyIGFuaW1hdGlvbiA9IG5ldyBjb3JlX2FuaW1hdGlvbih7XG5cdFx0XHRcdG51bVN0ZXBzOiBkdXJhdGlvbiAvIDE2LjY2LCAvLyA2MCBmcHNcblx0XHRcdFx0ZWFzaW5nOiBjb25maWcuZWFzaW5nIHx8IGFuaW1hdGlvbk9wdGlvbnMuZWFzaW5nLFxuXG5cdFx0XHRcdHJlbmRlcjogZnVuY3Rpb24oY2hhcnQsIGFuaW1hdGlvbk9iamVjdCkge1xuXHRcdFx0XHRcdHZhciBlYXNpbmdGdW5jdGlvbiA9IGhlbHBlcnMkMS5lYXNpbmcuZWZmZWN0c1thbmltYXRpb25PYmplY3QuZWFzaW5nXTtcblx0XHRcdFx0XHR2YXIgY3VycmVudFN0ZXAgPSBhbmltYXRpb25PYmplY3QuY3VycmVudFN0ZXA7XG5cdFx0XHRcdFx0dmFyIHN0ZXBEZWNpbWFsID0gY3VycmVudFN0ZXAgLyBhbmltYXRpb25PYmplY3QubnVtU3RlcHM7XG5cblx0XHRcdFx0XHRjaGFydC5kcmF3KGVhc2luZ0Z1bmN0aW9uKHN0ZXBEZWNpbWFsKSwgc3RlcERlY2ltYWwsIGN1cnJlbnRTdGVwKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHRvbkFuaW1hdGlvblByb2dyZXNzOiBhbmltYXRpb25PcHRpb25zLm9uUHJvZ3Jlc3MsXG5cdFx0XHRcdG9uQW5pbWF0aW9uQ29tcGxldGU6IG9uQ29tcGxldGVcblx0XHRcdH0pO1xuXG5cdFx0XHRjb3JlX2FuaW1hdGlvbnMuYWRkQW5pbWF0aW9uKG1lLCBhbmltYXRpb24sIGR1cmF0aW9uLCBsYXp5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuZHJhdygpO1xuXG5cdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM3ODFcblx0XHRcdG9uQ29tcGxldGUobmV3IGNvcmVfYW5pbWF0aW9uKHtudW1TdGVwczogMCwgY2hhcnQ6IG1lfSkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRtZS5jbGVhcigpO1xuXG5cdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKGVhc2luZ1ZhbHVlKSkge1xuXHRcdFx0ZWFzaW5nVmFsdWUgPSAxO1xuXHRcdH1cblxuXHRcdG1lLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXG5cdFx0aWYgKG1lLndpZHRoIDw9IDAgfHwgbWUuaGVpZ2h0IDw9IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEcmF3IGFsbCB0aGUgc2NhbGVzXG5cdFx0aGVscGVycyQxLmVhY2gobWUuYm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0Ym94LmRyYXcobWUuY2hhcnRBcmVhKTtcblx0XHR9LCBtZSk7XG5cblx0XHRtZS5kcmF3RGF0YXNldHMoZWFzaW5nVmFsdWUpO1xuXHRcdG1lLl9kcmF3VG9vbHRpcChlYXNpbmdWYWx1ZSk7XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEcmF3JywgW2Vhc2luZ1ZhbHVlXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR0cmFuc2l0aW9uOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IChtZS5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmIChtZS5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUudG9vbHRpcC50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0ICogRHJhd3MgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c0RyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzRHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkcmF3RGF0YXNldHM6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldHNEcmF3JywgW2Vhc2luZ1ZhbHVlXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRHJhdyBkYXRhc2V0cyByZXZlcnNlZCB0byBzdXBwb3J0IHByb3BlciBsaW5lIHN0YWNraW5nXG5cdFx0Zm9yICh2YXIgaSA9IChtZS5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHRcdFx0aWYgKG1lLmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0bWUuZHJhd0RhdGFzZXQoaSwgZWFzaW5nVmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRzRHJhdycsIFtlYXNpbmdWYWx1ZV0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3cyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0RHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldERyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZHJhd0RhdGFzZXQ6IGZ1bmN0aW9uKGluZGV4LCBlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0dmFyIGFyZ3MgPSB7XG5cdFx0XHRtZXRhOiBtZXRhLFxuXHRcdFx0aW5kZXg6IGluZGV4LFxuXHRcdFx0ZWFzaW5nVmFsdWU6IGVhc2luZ1ZhbHVlXG5cdFx0fTtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldERyYXcnLCBbYXJnc10pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG1ldGEuY29udHJvbGxlci5kcmF3KGVhc2luZ1ZhbHVlKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXREcmF3JywgW2FyZ3NdKTtcblx0fSxcblxuXHQvKipcblx0ICogRHJhd3MgdG9vbHRpcCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlVG9vbHRpcERyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlclRvb2x0aXBEcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9kcmF3VG9vbHRpcDogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0b29sdGlwID0gbWUudG9vbHRpcDtcblx0XHR2YXIgYXJncyA9IHtcblx0XHRcdHRvb2x0aXA6IHRvb2x0aXAsXG5cdFx0XHRlYXNpbmdWYWx1ZTogZWFzaW5nVmFsdWVcblx0XHR9O1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVUb29sdGlwRHJhdycsIFthcmdzXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dG9vbHRpcC5kcmF3KCk7XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJUb29sdGlwRHJhdycsIFthcmdzXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgc2luZ2xlIGVsZW1lbnQgdGhhdCB3YXMgY2xpY2tlZCBvblxuXHQgKiBAcmV0dXJuIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhc2V0IGluZGV4IGFuZCBlbGVtZW50IGluZGV4IG9mIHRoZSBtYXRjaGluZyBlbGVtZW50LiBBbHNvIGNvbnRhaW5zIHRoZSByZWN0YW5nbGUgdGhhdCB3YXMgZHJhd1xuXHQgKi9cblx0Z2V0RWxlbWVudEF0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gY29yZV9pbnRlcmFjdGlvbi5tb2Rlcy5zaW5nbGUodGhpcywgZSk7XG5cdH0sXG5cblx0Z2V0RWxlbWVudHNBdEV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXMubGFiZWwodGhpcywgZSwge2ludGVyc2VjdDogdHJ1ZX0pO1xuXHR9LFxuXG5cdGdldEVsZW1lbnRzQXRYQXhpczogZnVuY3Rpb24oZSkge1xuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzWyd4LWF4aXMnXSh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdH0sXG5cblx0Z2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZTogZnVuY3Rpb24oZSwgbW9kZSwgb3B0aW9ucykge1xuXHRcdHZhciBtZXRob2QgPSBjb3JlX2ludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuXHRcdGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBbXTtcblx0fSxcblxuXHRnZXREYXRhc2V0QXRFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXQodGhpcywgZSwge2ludGVyc2VjdDogdHJ1ZX0pO1xuXHR9LFxuXG5cdGdldERhdGFzZXRNZXRhOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuXHRcdGlmICghZGF0YXNldC5fbWV0YSkge1xuXHRcdFx0ZGF0YXNldC5fbWV0YSA9IHt9O1xuXHRcdH1cblxuXHRcdHZhciBtZXRhID0gZGF0YXNldC5fbWV0YVttZS5pZF07XG5cdFx0aWYgKCFtZXRhKSB7XG5cdFx0XHRtZXRhID0gZGF0YXNldC5fbWV0YVttZS5pZF0gPSB7XG5cdFx0XHRcdHR5cGU6IG51bGwsXG5cdFx0XHRcdGRhdGE6IFtdLFxuXHRcdFx0XHRkYXRhc2V0OiBudWxsLFxuXHRcdFx0XHRjb250cm9sbGVyOiBudWxsLFxuXHRcdFx0XHRoaWRkZW46IG51bGwsXHRcdFx0Ly8gU2VlIGlzRGF0YXNldFZpc2libGUoKSBjb21tZW50XG5cdFx0XHRcdHhBeGlzSUQ6IG51bGwsXG5cdFx0XHRcdHlBeGlzSUQ6IG51bGxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1ldGE7XG5cdH0sXG5cblx0Z2V0VmlzaWJsZURhdGFzZXRDb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvdW50ID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmICh0aGlzLmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNvdW50O1xuXHR9LFxuXG5cdGlzRGF0YXNldFZpc2libGU6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG5cdFx0Ly8gbWV0YS5oaWRkZW4gaXMgYSBwZXIgY2hhcnQgZGF0YXNldCBoaWRkZW4gZmxhZyBvdmVycmlkZSB3aXRoIDMgc3RhdGVzOiBpZiB0cnVlIG9yIGZhbHNlLFxuXHRcdC8vIHRoZSBkYXRhc2V0LmhpZGRlbiB2YWx1ZSBpcyBpZ25vcmVkLCBlbHNlIGlmIG51bGwsIHRoZSBkYXRhc2V0IGhpZGRlbiBzdGF0ZSBpcyByZXR1cm5lZC5cblx0XHRyZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uaGlkZGVuO1xuXHR9LFxuXG5cdGdlbmVyYXRlTGVnZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmxlZ2VuZENhbGxiYWNrKHRoaXMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZGVzdHJveURhdGFzZXRNZXRhOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgaWQgPSB0aGlzLmlkO1xuXHRcdHZhciBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG5cdFx0dmFyIG1ldGEgPSBkYXRhc2V0Ll9tZXRhICYmIGRhdGFzZXQuX21ldGFbaWRdO1xuXG5cdFx0aWYgKG1ldGEpIHtcblx0XHRcdG1ldGEuY29udHJvbGxlci5kZXN0cm95KCk7XG5cdFx0XHRkZWxldGUgZGF0YXNldC5fbWV0YVtpZF07XG5cdFx0fVxuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNhbnZhcyA9IG1lLmNhbnZhcztcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdG1lLnN0b3AoKTtcblxuXHRcdC8vIGRhdGFzZXQgY29udHJvbGxlcnMgbmVlZCB0byBjbGVhbnVwIGFzc29jaWF0ZWQgZGF0YVxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBtZS5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUuZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuXHRcdH1cblxuXHRcdGlmIChjYW52YXMpIHtcblx0XHRcdG1lLnVuYmluZEV2ZW50cygpO1xuXHRcdFx0aGVscGVycyQxLmNhbnZhcy5jbGVhcihtZSk7XG5cdFx0XHRwbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChtZS5jdHgpO1xuXHRcdFx0bWUuY2FudmFzID0gbnVsbDtcblx0XHRcdG1lLmN0eCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2Rlc3Ryb3knKTtcblxuXHRcdGRlbGV0ZSBDaGFydC5pbnN0YW5jZXNbbWUuaWRdO1xuXHR9LFxuXG5cdHRvQmFzZTY0SW1hZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwuYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0aW5pdFRvb2xUaXA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0bWUudG9vbHRpcCA9IG5ldyBjb3JlX3Rvb2x0aXAoe1xuXHRcdFx0X2NoYXJ0OiBtZSxcblx0XHRcdF9jaGFydEluc3RhbmNlOiBtZSwgLy8gZGVwcmVjYXRlZCwgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXHRcdFx0X2RhdGE6IG1lLmRhdGEsXG5cdFx0XHRfb3B0aW9uczogbWUub3B0aW9ucy50b29sdGlwc1xuXHRcdH0sIG1lKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGJpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGxpc3RlbmVycyA9IG1lLl9saXN0ZW5lcnMgPSB7fTtcblx0XHR2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdG1lLmV2ZW50SGFuZGxlci5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR9O1xuXG5cdFx0aGVscGVycyQxLmVhY2gobWUub3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIobWUsIHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRWxlbWVudHMgdXNlZCB0byBkZXRlY3Qgc2l6ZSBjaGFuZ2Ugc2hvdWxkIG5vdCBiZSBpbmplY3RlZCBmb3Igbm9uIHJlc3BvbnNpdmUgY2hhcnRzLlxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjIxMFxuXHRcdGlmIChtZS5vcHRpb25zLnJlc3BvbnNpdmUpIHtcblx0XHRcdGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG1lLnJlc2l6ZSgpO1xuXHRcdFx0fTtcblxuXHRcdFx0cGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcblx0XHRcdGxpc3RlbmVycy5yZXNpemUgPSBsaXN0ZW5lcjtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1bmJpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGxpc3RlbmVycyA9IG1lLl9saXN0ZW5lcnM7XG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkZWxldGUgbWUuX2xpc3RlbmVycztcblx0XHRoZWxwZXJzJDEuZWFjaChsaXN0ZW5lcnMsIGZ1bmN0aW9uKGxpc3RlbmVyLCB0eXBlKSB7XG5cdFx0XHRwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKG1lLCB0eXBlLCBsaXN0ZW5lcik7XG5cdFx0fSk7XG5cdH0sXG5cblx0dXBkYXRlSG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudHMsIG1vZGUsIGVuYWJsZWQpIHtcblx0XHR2YXIgbWV0aG9kID0gZW5hYmxlZCA/ICdzZXRIb3ZlclN0eWxlJyA6ICdyZW1vdmVIb3ZlclN0eWxlJztcblx0XHR2YXIgZWxlbWVudCwgaSwgaWxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcblx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdHRoaXMuZ2V0RGF0YXNldE1ldGEoZWxlbWVudC5fZGF0YXNldEluZGV4KS5jb250cm9sbGVyW21ldGhvZF0oZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZXZlbnRIYW5kbGVyOiBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdG9vbHRpcCA9IG1lLnRvb2x0aXA7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZUV2ZW50JywgW2VdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBCdWZmZXIgYW55IHVwZGF0ZSBjYWxscyBzbyB0aGF0IHJlbmRlcnMgZG8gbm90IG9jY3VyXG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gdHJ1ZTtcblx0XHRtZS5fYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuXHRcdHZhciBjaGFuZ2VkID0gbWUuaGFuZGxlRXZlbnQoZSk7XG5cdFx0Ly8gZm9yIHNtb290aCB0b29sdGlwIGFuaW1hdGlvbnMgaXNzdWUgIzQ5ODlcblx0XHQvLyB0aGUgdG9vbHRpcCBzaG91bGQgYmUgdGhlIHNvdXJjZSBvZiBjaGFuZ2Vcblx0XHQvLyBBbmltYXRpb24gY2hlY2sgd29ya2Fyb3VuZDpcblx0XHQvLyB0b29sdGlwLl9zdGFydCB3aWxsIGJlIG51bGwgd2hlbiB0b29sdGlwIGlzbid0IGFuaW1hdGluZ1xuXHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHRjaGFuZ2VkID0gdG9vbHRpcC5fc3RhcnRcblx0XHRcdFx0PyB0b29sdGlwLmhhbmRsZUV2ZW50KGUpXG5cdFx0XHRcdDogY2hhbmdlZCB8IHRvb2x0aXAuaGFuZGxlRXZlbnQoZSk7XG5cdFx0fVxuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRXZlbnQnLCBbZV0pO1xuXG5cdFx0dmFyIGJ1ZmZlcmVkUmVxdWVzdCA9IG1lLl9idWZmZXJlZFJlcXVlc3Q7XG5cdFx0aWYgKGJ1ZmZlcmVkUmVxdWVzdCkge1xuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhbiB1cGRhdGUgdGhhdCB3YXMgdHJpZ2dlcmVkLCB3ZSBuZWVkIHRvIGRvIGEgbm9ybWFsIHJlbmRlclxuXHRcdFx0bWUucmVuZGVyKGJ1ZmZlcmVkUmVxdWVzdCk7XG5cdFx0fSBlbHNlIGlmIChjaGFuZ2VkICYmICFtZS5hbmltYXRpbmcpIHtcblx0XHRcdC8vIElmIGVudGVyaW5nLCBsZWF2aW5nLCBvciBjaGFuZ2luZyBlbGVtZW50cywgYW5pbWF0ZSB0aGUgY2hhbmdlIHZpYSBwaXZvdFxuXHRcdFx0bWUuc3RvcCgpO1xuXG5cdFx0XHQvLyBXZSBvbmx5IG5lZWQgdG8gcmVuZGVyIGF0IHRoaXMgcG9pbnQuIFVwZGF0aW5nIHdpbGwgY2F1c2Ugc2NhbGVzIHRvIGJlXG5cdFx0XHQvLyByZWNvbXB1dGVkIGdlbmVyYXRpbmcgZmxpY2tlciAmIHVzaW5nIG1vcmUgbWVtb3J5IHRoYW4gbmVjZXNzYXJ5LlxuXHRcdFx0bWUucmVuZGVyKHtcblx0XHRcdFx0ZHVyYXRpb246IG1lLm9wdGlvbnMuaG92ZXIuYW5pbWF0aW9uRHVyYXRpb24sXG5cdFx0XHRcdGxhenk6IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdG1lLl9idWZmZXJlZFJlbmRlciA9IGZhbHNlO1xuXHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IHRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hhcnQgbmVlZHMgdG8gcmUtcmVuZGVyXG5cdCAqL1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zIHx8IHt9O1xuXHRcdHZhciBob3Zlck9wdGlvbnMgPSBvcHRpb25zLmhvdmVyO1xuXHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cblx0XHRtZS5sYXN0QWN0aXZlID0gbWUubGFzdEFjdGl2ZSB8fCBbXTtcblxuXHRcdC8vIEZpbmQgQWN0aXZlIEVsZW1lbnRzIGZvciBob3ZlciBhbmQgdG9vbHRpcHNcblx0XHRpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG5cdFx0XHRtZS5hY3RpdmUgPSBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuYWN0aXZlID0gbWUuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zKTtcblx0XHR9XG5cblx0XHQvLyBJbnZva2Ugb25Ib3ZlciBob29rXG5cdFx0Ly8gTmVlZCB0byBjYWxsIHdpdGggbmF0aXZlIGV2ZW50IGhlcmUgdG8gbm90IGJyZWFrIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKG9wdGlvbnMub25Ib3ZlciB8fCBvcHRpb25zLmhvdmVyLm9uSG92ZXIsIFtlLm5hdGl2ZSwgbWUuYWN0aXZlXSwgbWUpO1xuXG5cdFx0aWYgKGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0aWYgKG9wdGlvbnMub25DbGljaykge1xuXHRcdFx0XHQvLyBVc2UgZS5uYXRpdmUgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0b3B0aW9ucy5vbkNsaWNrLmNhbGwobWUsIGUubmF0aXZlLCBtZS5hY3RpdmUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBzdHlsaW5nIGZvciBsYXN0IGFjdGl2ZSAoZXZlbiBpZiBpdCBtYXkgc3RpbGwgYmUgYWN0aXZlKVxuXHRcdGlmIChtZS5sYXN0QWN0aXZlLmxlbmd0aCkge1xuXHRcdFx0bWUudXBkYXRlSG92ZXJTdHlsZShtZS5sYXN0QWN0aXZlLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdC8vIEJ1aWx0IGluIGhvdmVyIHN0eWxpbmdcblx0XHRpZiAobWUuYWN0aXZlLmxlbmd0aCAmJiBob3Zlck9wdGlvbnMubW9kZSkge1xuXHRcdFx0bWUudXBkYXRlSG92ZXJTdHlsZShtZS5hY3RpdmUsIGhvdmVyT3B0aW9ucy5tb2RlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRjaGFuZ2VkID0gIWhlbHBlcnMkMS5hcnJheUVxdWFscyhtZS5hY3RpdmUsIG1lLmxhc3RBY3RpdmUpO1xuXG5cdFx0Ly8gUmVtZW1iZXIgTGFzdCBBY3RpdmVzXG5cdFx0bWUubGFzdEFjdGl2ZSA9IG1lLmFjdGl2ZTtcblxuXHRcdHJldHVybiBjaGFuZ2VkO1xuXHR9XG59KTtcblxuLyoqXG4gKiBOT1RFKFNCKSBXZSBhY3R1YWxseSBkb24ndCB1c2UgdGhpcyBjb250YWluZXIgYW55bW9yZSBidXQgd2UgbmVlZCB0byBrZWVwIGl0XG4gKiBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gVGhvdWdoLCBpdCBjYW4gc3RpbGwgYmUgdXNlZnVsIGZvciBwbHVnaW5zIHRoYXRcbiAqIHdvdWxkIG5lZWQgdG8gd29yayBvbiBtdWx0aXBsZSBjaGFydHM/IVxuICovXG5DaGFydC5pbnN0YW5jZXMgPSB7fTtcblxudmFyIGNvcmVfY29udHJvbGxlciA9IENoYXJ0O1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0IGluc3RlYWQuXG4gKiBAY2xhc3MgQ2hhcnQuQ29udHJvbGxlclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjZcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbkNoYXJ0LkNvbnRyb2xsZXIgPSBDaGFydDtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxuICogQG5hbWVzcGFjZSBDaGFydFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjhcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbkNoYXJ0LnR5cGVzID0ge307XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZS5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5jb25maWdNZXJnZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycyQxLmNvbmZpZ01lcmdlID0gbWVyZ2VDb25maWc7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZS5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5zY2FsZU1lcmdlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzJDEuc2NhbGVNZXJnZSA9IG1lcmdlU2NhbGVDb25maWc7XG5cbnZhciBjb3JlX2hlbHBlcnMgPSBmdW5jdGlvbigpIHtcblxuXHQvLyAtLSBCYXNpYyBqcyB1dGlsaXR5IG1ldGhvZHNcblxuXHRoZWxwZXJzJDEud2hlcmUgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBmaWx0ZXJDYWxsYmFjaykge1xuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShjb2xsZWN0aW9uKSAmJiBBcnJheS5wcm90b3R5cGUuZmlsdGVyKSB7XG5cdFx0XHRyZXR1cm4gY29sbGVjdGlvbi5maWx0ZXIoZmlsdGVyQ2FsbGJhY2spO1xuXHRcdH1cblx0XHR2YXIgZmlsdGVyZWQgPSBbXTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhpdGVtKSkge1xuXHRcdFx0XHRmaWx0ZXJlZC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGZpbHRlcmVkO1xuXHR9O1xuXHRoZWxwZXJzJDEuZmluZEluZGV4ID0gQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCA/XG5cdFx0ZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xuXHRcdFx0cmV0dXJuIGFycmF5LmZpbmRJbmRleChjYWxsYmFjaywgc2NvcGUpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKGFycmF5LCBjYWxsYmFjaywgc2NvcGUpIHtcblx0XHRcdHNjb3BlID0gc2NvcGUgPT09IHVuZGVmaW5lZCA/IGFycmF5IDogc2NvcGU7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRpZiAoY2FsbGJhY2suY2FsbChzY29wZSwgYXJyYXlbaV0sIGksIGFycmF5KSkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fTtcblx0aGVscGVycyQxLmZpbmROZXh0V2hlcmUgPSBmdW5jdGlvbihhcnJheVRvU2VhcmNoLCBmaWx0ZXJDYWxsYmFjaywgc3RhcnRJbmRleCkge1xuXHRcdC8vIERlZmF1bHQgdG8gc3RhcnQgb2YgdGhlIGFycmF5XG5cdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHN0YXJ0SW5kZXgpKSB7XG5cdFx0XHRzdGFydEluZGV4ID0gLTE7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSBzdGFydEluZGV4ICsgMTsgaSA8IGFycmF5VG9TZWFyY2gubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBjdXJyZW50SXRlbSA9IGFycmF5VG9TZWFyY2hbaV07XG5cdFx0XHRpZiAoZmlsdGVyQ2FsbGJhY2soY3VycmVudEl0ZW0pKSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50SXRlbTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGhlbHBlcnMkMS5maW5kUHJldmlvdXNXaGVyZSA9IGZ1bmN0aW9uKGFycmF5VG9TZWFyY2gsIGZpbHRlckNhbGxiYWNrLCBzdGFydEluZGV4KSB7XG5cdFx0Ly8gRGVmYXVsdCB0byBlbmQgb2YgdGhlIGFycmF5XG5cdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHN0YXJ0SW5kZXgpKSB7XG5cdFx0XHRzdGFydEluZGV4ID0gYXJyYXlUb1NlYXJjaC5sZW5ndGg7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSBzdGFydEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBjdXJyZW50SXRlbSA9IGFycmF5VG9TZWFyY2hbaV07XG5cdFx0XHRpZiAoZmlsdGVyQ2FsbGJhY2soY3VycmVudEl0ZW0pKSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50SXRlbTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gLS0gTWF0aCBtZXRob2RzXG5cdGhlbHBlcnMkMS5pc051bWJlciA9IGZ1bmN0aW9uKG4pIHtcblx0XHRyZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuXHR9O1xuXHRoZWxwZXJzJDEuYWxtb3N0RXF1YWxzID0gZnVuY3Rpb24oeCwgeSwgZXBzaWxvbikge1xuXHRcdHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xuXHR9O1xuXHRoZWxwZXJzJDEuYWxtb3N0V2hvbGUgPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG5cdFx0dmFyIHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuXHRcdHJldHVybiAoKChyb3VuZGVkIC0gZXBzaWxvbikgPCB4KSAmJiAoKHJvdW5kZWQgKyBlcHNpbG9uKSA+IHgpKTtcblx0fTtcblx0aGVscGVycyQxLm1heCA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihtYXgsIHZhbHVlKSB7XG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgobWF4LCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF4O1xuXHRcdH0sIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG5cdH07XG5cdGhlbHBlcnMkMS5taW4gPSBmdW5jdGlvbihhcnJheSkge1xuXHRcdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24obWluLCB2YWx1ZSkge1xuXHRcdFx0aWYgKCFpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgubWluKG1pbiwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1pbjtcblx0XHR9LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuXHR9O1xuXHRoZWxwZXJzJDEuc2lnbiA9IE1hdGguc2lnbiA/XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIE1hdGguc2lnbih4KTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHR4ID0gK3g7IC8vIGNvbnZlcnQgdG8gYSBudW1iZXJcblx0XHRcdGlmICh4ID09PSAwIHx8IGlzTmFOKHgpKSB7XG5cdFx0XHRcdHJldHVybiB4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHggPiAwID8gMSA6IC0xO1xuXHRcdH07XG5cdGhlbHBlcnMkMS5sb2cxMCA9IE1hdGgubG9nMTAgP1xuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiBNYXRoLmxvZzEwKHgpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHZhciBleHBvbmVudCA9IE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7IC8vIE1hdGguTE9HMTBFID0gMSAvIE1hdGguTE4xMC5cblx0XHRcdC8vIENoZWNrIGZvciB3aG9sZSBwb3dlcnMgb2YgMTAsXG5cdFx0XHQvLyB3aGljaCBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3Igc2hvdWxkIGJlIGNvcnJlY3RlZC5cblx0XHRcdHZhciBwb3dlck9mMTAgPSBNYXRoLnJvdW5kKGV4cG9uZW50KTtcblx0XHRcdHZhciBpc1Bvd2VyT2YxMCA9IHggPT09IE1hdGgucG93KDEwLCBwb3dlck9mMTApO1xuXG5cdFx0XHRyZXR1cm4gaXNQb3dlck9mMTAgPyBwb3dlck9mMTAgOiBleHBvbmVudDtcblx0XHR9O1xuXHRoZWxwZXJzJDEudG9SYWRpYW5zID0gZnVuY3Rpb24oZGVncmVlcykge1xuXHRcdHJldHVybiBkZWdyZWVzICogKE1hdGguUEkgLyAxODApO1xuXHR9O1xuXHRoZWxwZXJzJDEudG9EZWdyZWVzID0gZnVuY3Rpb24ocmFkaWFucykge1xuXHRcdHJldHVybiByYWRpYW5zICogKDE4MCAvIE1hdGguUEkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcblx0ICogaS5lLiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgb2YgdGhlIHZhbHVlIG9mIHRoaXMgTnVtYmVyLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIEEgbnVtYmVyLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aGVscGVycyQxLl9kZWNpbWFsUGxhY2VzID0gZnVuY3Rpb24oeCkge1xuXHRcdGlmICghaGVscGVycyQxLmlzRmluaXRlKHgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBlID0gMTtcblx0XHR2YXIgcCA9IDA7XG5cdFx0d2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xuXHRcdFx0ZSAqPSAxMDtcblx0XHRcdHArKztcblx0XHR9XG5cdFx0cmV0dXJuIHA7XG5cdH07XG5cblx0Ly8gR2V0cyB0aGUgYW5nbGUgZnJvbSB2ZXJ0aWNhbCB1cHJpZ2h0IHRvIHRoZSBwb2ludCBhYm91dCBhIGNlbnRyZS5cblx0aGVscGVycyQxLmdldEFuZ2xlRnJvbVBvaW50ID0gZnVuY3Rpb24oY2VudHJlUG9pbnQsIGFuZ2xlUG9pbnQpIHtcblx0XHR2YXIgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG5cdFx0dmFyIGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuXHRcdHZhciByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG5cblx0XHR2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGRpc3RhbmNlRnJvbVlDZW50ZXIsIGRpc3RhbmNlRnJvbVhDZW50ZXIpO1xuXG5cdFx0aWYgKGFuZ2xlIDwgKC0wLjUgKiBNYXRoLlBJKSkge1xuXHRcdFx0YW5nbGUgKz0gMi4wICogTWF0aC5QSTsgLy8gbWFrZSBzdXJlIHRoZSByZXR1cm5lZCBhbmdsZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgKC1QSS8yLCAzUEkvMl1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YW5nbGU6IGFuZ2xlLFxuXHRcdFx0ZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuXHRcdH07XG5cdH07XG5cdGhlbHBlcnMkMS5kaXN0YW5jZUJldHdlZW5Qb2ludHMgPSBmdW5jdGlvbihwdDEsIHB0Mikge1xuXHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocHQyLnggLSBwdDEueCwgMikgKyBNYXRoLnBvdyhwdDIueSAtIHB0MS55LCAyKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcblx0ICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuYWxpYXNQaXhlbFxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0ICovXG5cdGhlbHBlcnMkMS5hbGlhc1BpeGVsID0gZnVuY3Rpb24ocGl4ZWxXaWR0aCkge1xuXHRcdHJldHVybiAocGl4ZWxXaWR0aCAlIDIgPT09IDApID8gMCA6IDAuNTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYWxpZ25lZCBwaXhlbCB2YWx1ZSB0byBhdm9pZCBhbnRpLWFsaWFzaW5nIGJsdXJcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbCAtIEEgcGl4ZWwgdmFsdWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudC5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIGFsaWduZWQgcGl4ZWwgdmFsdWUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoZWxwZXJzJDEuX2FsaWduUGl4ZWwgPSBmdW5jdGlvbihjaGFydCwgcGl4ZWwsIHdpZHRoKSB7XG5cdFx0dmFyIGRldmljZVBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbztcblx0XHR2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKChwaXhlbCAtIGhhbGZXaWR0aCkgKiBkZXZpY2VQaXhlbFJhdGlvKSAvIGRldmljZVBpeGVsUmF0aW8gKyBoYWxmV2lkdGg7XG5cdH07XG5cblx0aGVscGVycyQxLnNwbGluZUN1cnZlID0gZnVuY3Rpb24oZmlyc3RQb2ludCwgbWlkZGxlUG9pbnQsIGFmdGVyUG9pbnQsIHQpIHtcblx0XHQvLyBQcm9wcyB0byBSb2IgU3BlbmNlciBhdCBzY2FsZWQgaW5ub3ZhdGlvbiBmb3IgaGlzIHBvc3Qgb24gc3BsaW5pbmcgYmV0d2VlbiBwb2ludHNcblx0XHQvLyBodHRwOi8vc2NhbGVkaW5ub3ZhdGlvbi5jb20vYW5hbHl0aWNzL3NwbGluZXMvYWJvdXRTcGxpbmVzLmh0bWxcblxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gbXVzdCBhbHNvIHJlc3BlY3QgXCJza2lwcGVkXCIgcG9pbnRzXG5cblx0XHR2YXIgcHJldmlvdXMgPSBmaXJzdFBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGZpcnN0UG9pbnQ7XG5cdFx0dmFyIGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcblx0XHR2YXIgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcblxuXHRcdHZhciBkMDEgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudC54IC0gcHJldmlvdXMueCwgMikgKyBNYXRoLnBvdyhjdXJyZW50LnkgLSBwcmV2aW91cy55LCAyKSk7XG5cdFx0dmFyIGQxMiA9IE1hdGguc3FydChNYXRoLnBvdyhuZXh0LnggLSBjdXJyZW50LngsIDIpICsgTWF0aC5wb3cobmV4dC55IC0gY3VycmVudC55LCAyKSk7XG5cblx0XHR2YXIgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XG5cdFx0dmFyIHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xuXG5cdFx0Ly8gSWYgYWxsIHBvaW50cyBhcmUgdGhlIHNhbWUsIHMwMSAmIHMwMiB3aWxsIGJlIGluZlxuXHRcdHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xuXHRcdHMxMiA9IGlzTmFOKHMxMikgPyAwIDogczEyO1xuXG5cdFx0dmFyIGZhID0gdCAqIHMwMTsgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHRyaWFuZ2xlIFRhXG5cdFx0dmFyIGZiID0gdCAqIHMxMjtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRwcmV2aW91czoge1xuXHRcdFx0XHR4OiBjdXJyZW50LnggLSBmYSAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcblx0XHRcdFx0eTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcblx0XHRcdH0sXG5cdFx0XHRuZXh0OiB7XG5cdFx0XHRcdHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuXHRcdFx0XHR5OiBjdXJyZW50LnkgKyBmYiAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cdGhlbHBlcnMkMS5FUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQ7XG5cdGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZU1vbm90b25lID0gZnVuY3Rpb24ocG9pbnRzKSB7XG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIELDqXppZXIgY29udHJvbCBwb2ludHMgaW4gYSBzaW1pbGFyIHdheSB0aGFuIHxzcGxpbmVDdXJ2ZXwsXG5cdFx0Ly8gYnV0IHByZXNlcnZlcyBtb25vdG9uaWNpdHkgb2YgdGhlIHByb3ZpZGVkIGRhdGEgYW5kIGVuc3VyZXMgbm8gbG9jYWwgZXh0cmVtdW1zIGFyZSBhZGRlZFxuXHRcdC8vIGJldHdlZW4gdGhlIGRhdGFzZXQgZGlzY3JldGUgcG9pbnRzIGR1ZSB0byB0aGUgaW50ZXJwb2xhdGlvbi5cblx0XHQvLyBTZWUgOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb25vdG9uZV9jdWJpY19pbnRlcnBvbGF0aW9uXG5cblx0XHR2YXIgcG9pbnRzV2l0aFRhbmdlbnRzID0gKHBvaW50cyB8fCBbXSkubWFwKGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRtb2RlbDogcG9pbnQuX21vZGVsLFxuXHRcdFx0XHRkZWx0YUs6IDAsXG5cdFx0XHRcdG1LOiAwXG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIHNsb3BlcyAoZGVsdGFLKSBhbmQgaW5pdGlhbGl6ZSB0YW5nZW50cyAobUspXG5cdFx0dmFyIHBvaW50c0xlbiA9IHBvaW50c1dpdGhUYW5nZW50cy5sZW5ndGg7XG5cdFx0dmFyIGksIHBvaW50QmVmb3JlLCBwb2ludEN1cnJlbnQsIHBvaW50QWZ0ZXI7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XG5cdFx0XHRpZiAocG9pbnRDdXJyZW50Lm1vZGVsLnNraXApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHBvaW50QmVmb3JlID0gaSA+IDAgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSAtIDFdIDogbnVsbDtcblx0XHRcdHBvaW50QWZ0ZXIgPSBpIDwgcG9pbnRzTGVuIC0gMSA/IHBvaW50c1dpdGhUYW5nZW50c1tpICsgMV0gOiBudWxsO1xuXHRcdFx0aWYgKHBvaW50QWZ0ZXIgJiYgIXBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHR2YXIgc2xvcGVEZWx0YVggPSAocG9pbnRBZnRlci5tb2RlbC54IC0gcG9pbnRDdXJyZW50Lm1vZGVsLngpO1xuXG5cdFx0XHRcdC8vIEluIHRoZSBjYXNlIG9mIHR3byBwb2ludHMgdGhhdCBhcHBlYXIgYXQgdGhlIHNhbWUgeCBwaXhlbCwgc2xvcGVEZWx0YVggaXMgMFxuXHRcdFx0XHRwb2ludEN1cnJlbnQuZGVsdGFLID0gc2xvcGVEZWx0YVggIT09IDAgPyAocG9pbnRBZnRlci5tb2RlbC55IC0gcG9pbnRDdXJyZW50Lm1vZGVsLnkpIC8gc2xvcGVEZWx0YVggOiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXBvaW50QmVmb3JlIHx8IHBvaW50QmVmb3JlLm1vZGVsLnNraXApIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdH0gZWxzZSBpZiAoIXBvaW50QWZ0ZXIgfHwgcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IHBvaW50QmVmb3JlLmRlbHRhSztcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5zaWduKHBvaW50QmVmb3JlLmRlbHRhSykgIT09IHRoaXMuc2lnbihwb2ludEN1cnJlbnQuZGVsdGFLKSkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gKHBvaW50QmVmb3JlLmRlbHRhSyArIHBvaW50Q3VycmVudC5kZWx0YUspIC8gMjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGp1c3QgdGFuZ2VudHMgdG8gZW5zdXJlIG1vbm90b25pYyBwcm9wZXJ0aWVzXG5cdFx0dmFyIGFscGhhSywgYmV0YUssIHRhdUssIHNxdWFyZWRNYWduaXR1ZGU7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuXHRcdFx0cG9pbnRDdXJyZW50ID0gcG9pbnRzV2l0aFRhbmdlbnRzW2ldO1xuXHRcdFx0cG9pbnRBZnRlciA9IHBvaW50c1dpdGhUYW5nZW50c1tpICsgMV07XG5cdFx0XHRpZiAocG9pbnRDdXJyZW50Lm1vZGVsLnNraXAgfHwgcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaGVscGVycyQxLmFsbW9zdEVxdWFscyhwb2ludEN1cnJlbnQuZGVsdGFLLCAwLCB0aGlzLkVQU0lMT04pKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IHBvaW50QWZ0ZXIubUsgPSAwO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0YWxwaGFLID0gcG9pbnRDdXJyZW50Lm1LIC8gcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdGJldGFLID0gcG9pbnRBZnRlci5tSyAvIHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHRzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcblx0XHRcdGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuXHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gYWxwaGFLICogdGF1SyAqIHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHRwb2ludEFmdGVyLm1LID0gYmV0YUsgKiB0YXVLICogcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlIGNvbnRyb2wgcG9pbnRzXG5cdFx0dmFyIGRlbHRhWDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cG9pbnRCZWZvcmUgPSBpID4gMCA/IHBvaW50c1dpdGhUYW5nZW50c1tpIC0gMV0gOiBudWxsO1xuXHRcdFx0cG9pbnRBZnRlciA9IGkgPCBwb2ludHNMZW4gLSAxID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXSA6IG51bGw7XG5cdFx0XHRpZiAocG9pbnRCZWZvcmUgJiYgIXBvaW50QmVmb3JlLm1vZGVsLnNraXApIHtcblx0XHRcdFx0ZGVsdGFYID0gKHBvaW50Q3VycmVudC5tb2RlbC54IC0gcG9pbnRCZWZvcmUubW9kZWwueCkgLyAzO1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gcG9pbnRDdXJyZW50Lm1vZGVsLnggLSBkZWx0YVg7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBwb2ludEN1cnJlbnQubW9kZWwueSAtIGRlbHRhWCAqIHBvaW50Q3VycmVudC5tSztcblx0XHRcdH1cblx0XHRcdGlmIChwb2ludEFmdGVyICYmICFwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0ZGVsdGFYID0gKHBvaW50QWZ0ZXIubW9kZWwueCAtIHBvaW50Q3VycmVudC5tb2RlbC54KSAvIDM7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IHBvaW50Q3VycmVudC5tb2RlbC54ICsgZGVsdGFYO1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBwb2ludEN1cnJlbnQubW9kZWwueSArIGRlbHRhWCAqIHBvaW50Q3VycmVudC5tSztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGhlbHBlcnMkMS5uZXh0SXRlbSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGluZGV4LCBsb29wKSB7XG5cdFx0aWYgKGxvb3ApIHtcblx0XHRcdHJldHVybiBpbmRleCA+PSBjb2xsZWN0aW9uLmxlbmd0aCAtIDEgPyBjb2xsZWN0aW9uWzBdIDogY29sbGVjdGlvbltpbmRleCArIDFdO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5kZXggPj0gY29sbGVjdGlvbi5sZW5ndGggLSAxID8gY29sbGVjdGlvbltjb2xsZWN0aW9uLmxlbmd0aCAtIDFdIDogY29sbGVjdGlvbltpbmRleCArIDFdO1xuXHR9O1xuXHRoZWxwZXJzJDEucHJldmlvdXNJdGVtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgaW5kZXgsIGxvb3ApIHtcblx0XHRpZiAobG9vcCkge1xuXHRcdFx0cmV0dXJuIGluZGV4IDw9IDAgPyBjb2xsZWN0aW9uW2NvbGxlY3Rpb24ubGVuZ3RoIC0gMV0gOiBjb2xsZWN0aW9uW2luZGV4IC0gMV07XG5cdFx0fVxuXHRcdHJldHVybiBpbmRleCA8PSAwID8gY29sbGVjdGlvblswXSA6IGNvbGxlY3Rpb25baW5kZXggLSAxXTtcblx0fTtcblx0Ly8gSW1wbGVtZW50YXRpb24gb2YgdGhlIG5pY2UgbnVtYmVyIGFsZ29yaXRobSB1c2VkIGluIGRldGVybWluaW5nIHdoZXJlIGF4aXMgbGFiZWxzIHdpbGwgZ29cblx0aGVscGVycyQxLm5pY2VOdW0gPSBmdW5jdGlvbihyYW5nZSwgcm91bmQpIHtcblx0XHR2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChyYW5nZSkpO1xuXHRcdHZhciBmcmFjdGlvbiA9IHJhbmdlIC8gTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcblx0XHR2YXIgbmljZUZyYWN0aW9uO1xuXG5cdFx0aWYgKHJvdW5kKSB7XG5cdFx0XHRpZiAoZnJhY3Rpb24gPCAxLjUpIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPCAzKSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDI7XG5cdFx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDwgNykge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSA1O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gMTA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8PSAxLjApIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDE7XG5cdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8PSAyKSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAyO1xuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gNSkge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gNTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gMTA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5pY2VGcmFjdGlvbiAqIE1hdGgucG93KDEwLCBleHBvbmVudCk7XG5cdH07XG5cdC8vIFJlcXVlc3QgYW5pbWF0aW9uIHBvbHlmaWxsIC0gaHR0cHM6Ly93d3cucGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuXHRoZWxwZXJzJDEucmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcblx0XHRcdH07XG5cdH0oKSk7XG5cdC8vIC0tIERPTSBtZXRob2RzXG5cdGhlbHBlcnMkMS5nZXRSZWxhdGl2ZVBvc2l0aW9uID0gZnVuY3Rpb24oZXZ0LCBjaGFydCkge1xuXHRcdHZhciBtb3VzZVgsIG1vdXNlWTtcblx0XHR2YXIgZSA9IGV2dC5vcmlnaW5hbEV2ZW50IHx8IGV2dDtcblx0XHR2YXIgY2FudmFzID0gZXZ0LnRhcmdldCB8fCBldnQuc3JjRWxlbWVudDtcblx0XHR2YXIgYm91bmRpbmdSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0dmFyIHRvdWNoZXMgPSBlLnRvdWNoZXM7XG5cdFx0aWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRtb3VzZVggPSB0b3VjaGVzWzBdLmNsaWVudFg7XG5cdFx0XHRtb3VzZVkgPSB0b3VjaGVzWzBdLmNsaWVudFk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0bW91c2VYID0gZS5jbGllbnRYO1xuXHRcdFx0bW91c2VZID0gZS5jbGllbnRZO1xuXHRcdH1cblxuXHRcdC8vIFNjYWxlIG1vdXNlIGNvb3JkaW5hdGVzIGludG8gY2FudmFzIGNvb3JkaW5hdGVzXG5cdFx0Ly8gYnkgZm9sbG93aW5nIHRoZSBwYXR0ZXJuIGxhaWQgb3V0IGJ5ICdqZXJyeWonIGluIHRoZSBjb21tZW50cyBvZlxuXHRcdC8vIGh0dHBzOi8vd3d3Lmh0bWw1Y2FudmFzdHV0b3JpYWxzLmNvbS9hZHZhbmNlZC9odG1sNS1jYW52YXMtbW91c2UtY29vcmRpbmF0ZXMvXG5cdFx0dmFyIHBhZGRpbmdMZWZ0ID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1sZWZ0JykpO1xuXHRcdHZhciBwYWRkaW5nVG9wID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy10b3AnKSk7XG5cdFx0dmFyIHBhZGRpbmdSaWdodCA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctcmlnaHQnKSk7XG5cdFx0dmFyIHBhZGRpbmdCb3R0b20gPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLWJvdHRvbScpKTtcblx0XHR2YXIgd2lkdGggPSBib3VuZGluZ1JlY3QucmlnaHQgLSBib3VuZGluZ1JlY3QubGVmdCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xuXHRcdHZhciBoZWlnaHQgPSBib3VuZGluZ1JlY3QuYm90dG9tIC0gYm91bmRpbmdSZWN0LnRvcCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tO1xuXG5cdFx0Ly8gV2UgZGl2aWRlIGJ5IHRoZSBjdXJyZW50IGRldmljZSBwaXhlbCByYXRpbywgYmVjYXVzZSB0aGUgY2FudmFzIGlzIHNjYWxlZCB1cCBieSB0aGF0IGFtb3VudCBpbiBlYWNoIGRpcmVjdGlvbi4gSG93ZXZlclxuXHRcdC8vIHRoZSBiYWNrZW5kIG1vZGVsIGlzIGluIHVuc2NhbGVkIGNvb3JkaW5hdGVzLiBTaW5jZSB3ZSBhcmUgZ29pbmcgdG8gZGVhbCB3aXRoIG91ciBtb2RlbCBjb29yZGluYXRlcywgd2UgZ28gYmFjayBoZXJlXG5cdFx0bW91c2VYID0gTWF0aC5yb3VuZCgobW91c2VYIC0gYm91bmRpbmdSZWN0LmxlZnQgLSBwYWRkaW5nTGVmdCkgLyAod2lkdGgpICogY2FudmFzLndpZHRoIC8gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8pO1xuXHRcdG1vdXNlWSA9IE1hdGgucm91bmQoKG1vdXNlWSAtIGJvdW5kaW5nUmVjdC50b3AgLSBwYWRkaW5nVG9wKSAvIChoZWlnaHQpICogY2FudmFzLmhlaWdodCAvIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBtb3VzZVgsXG5cdFx0XHR5OiBtb3VzZVlcblx0XHR9O1xuXG5cdH07XG5cblx0Ly8gUHJpdmF0ZSBoZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBtYXgtd2lkdGgvbWF4LWhlaWdodCB2YWx1ZXMgdGhhdCBtYXkgYmUgcGVyY2VudGFnZXMgaW50byBhIG51bWJlclxuXHRmdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWUsIG5vZGUsIHBhcmVudFByb3BlcnR5KSB7XG5cdFx0dmFyIHZhbHVlSW5QaXhlbHM7XG5cdFx0aWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcblxuXHRcdFx0aWYgKHN0eWxlVmFsdWUuaW5kZXhPZignJScpICE9PSAtMSkge1xuXHRcdFx0XHQvLyBwZXJjZW50YWdlICogc2l6ZSBpbiBkaW1lbnNpb25cblx0XHRcdFx0dmFsdWVJblBpeGVscyA9IHZhbHVlSW5QaXhlbHMgLyAxMDAgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVJblBpeGVscztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGlmIHRoZSBnaXZlbiB2YWx1ZSBjb250YWlucyBhbiBlZmZlY3RpdmUgY29uc3RyYWludC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGlzQ29uc3RyYWluZWRWYWx1ZSh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSAnbm9uZSc7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbWF4IHdpZHRoIG9yIGhlaWdodCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgaW4gYSBjcm9zcy1icm93c2VyIGNvbXBhdGlibGUgZmFzaGlvblxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21Ob2RlIC0gdGhlIG5vZGUgdG8gY2hlY2sgdGhlIGNvbnN0cmFpbnQgb25cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1heFN0eWxlIC0gdGhlIHN0eWxlIHRoYXQgZGVmaW5lcyB0aGUgbWF4aW11bSBmb3IgdGhlIGRpcmVjdGlvbiB3ZSBhcmUgdXNpbmcgKCdtYXgtd2lkdGgnIC8gJ21heC1oZWlnaHQnKVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGVyY2VudGFnZVByb3BlcnR5IC0gcHJvcGVydHkgb2YgcGFyZW50IHRvIHVzZSB3aGVuIGNhbGN1bGF0aW5nIHdpZHRoIGFzIGEgcGVyY2VudGFnZVxuXHQgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5uYXRoYW5hZWxqb25lcy5jb20vYmxvZy8yMDEzL3JlYWRpbmctbWF4LXdpZHRoLWNyb3NzLWJyb3dzZXJ9XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsIG1heFN0eWxlLCBwZXJjZW50YWdlUHJvcGVydHkpIHtcblx0XHR2YXIgdmlldyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHZhciBwYXJlbnROb2RlID0gaGVscGVycyQxLl9nZXRQYXJlbnROb2RlKGRvbU5vZGUpO1xuXHRcdHZhciBjb25zdHJhaW5lZE5vZGUgPSB2aWV3LmdldENvbXB1dGVkU3R5bGUoZG9tTm9kZSlbbWF4U3R5bGVdO1xuXHRcdHZhciBjb25zdHJhaW5lZENvbnRhaW5lciA9IHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnROb2RlKVttYXhTdHlsZV07XG5cdFx0dmFyIGhhc0NOb2RlID0gaXNDb25zdHJhaW5lZFZhbHVlKGNvbnN0cmFpbmVkTm9kZSk7XG5cdFx0dmFyIGhhc0NDb250YWluZXIgPSBpc0NvbnN0cmFpbmVkVmFsdWUoY29uc3RyYWluZWRDb250YWluZXIpO1xuXHRcdHZhciBpbmZpbml0eSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuXHRcdGlmIChoYXNDTm9kZSB8fCBoYXNDQ29udGFpbmVyKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5taW4oXG5cdFx0XHRcdGhhc0NOb2RlID8gcGFyc2VNYXhTdHlsZShjb25zdHJhaW5lZE5vZGUsIGRvbU5vZGUsIHBlcmNlbnRhZ2VQcm9wZXJ0eSkgOiBpbmZpbml0eSxcblx0XHRcdFx0aGFzQ0NvbnRhaW5lciA/IHBhcnNlTWF4U3R5bGUoY29uc3RyYWluZWRDb250YWluZXIsIHBhcmVudE5vZGUsIHBlcmNlbnRhZ2VQcm9wZXJ0eSkgOiBpbmZpbml0eSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdub25lJztcblx0fVxuXHQvLyByZXR1cm5zIE51bWJlciBvciB1bmRlZmluZWQgaWYgbm8gY29uc3RyYWludFxuXHRoZWxwZXJzJDEuZ2V0Q29uc3RyYWludFdpZHRoID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHJldHVybiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsICdtYXgtd2lkdGgnLCAnY2xpZW50V2lkdGgnKTtcblx0fTtcblx0Ly8gcmV0dXJucyBOdW1iZXIgb3IgdW5kZWZpbmVkIGlmIG5vIGNvbnN0cmFpbnRcblx0aGVscGVycyQxLmdldENvbnN0cmFpbnRIZWlnaHQgPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0cmV0dXJuIGdldENvbnN0cmFpbnREaW1lbnNpb24oZG9tTm9kZSwgJ21heC1oZWlnaHQnLCAnY2xpZW50SGVpZ2h0Jyk7XG5cdH07XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuIFx0ICovXG5cdGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgcGFkZGluZywgcGFyZW50RGltZW5zaW9uKSB7XG5cdFx0cGFkZGluZyA9IGhlbHBlcnMkMS5nZXRTdHlsZShjb250YWluZXIsIHBhZGRpbmcpO1xuXG5cdFx0cmV0dXJuIHBhZGRpbmcuaW5kZXhPZignJScpID4gLTEgPyBwYXJlbnREaW1lbnNpb24gKiBwYXJzZUludChwYWRkaW5nLCAxMCkgLyAxMDAgOiBwYXJzZUludChwYWRkaW5nLCAxMCk7XG5cdH07XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aGVscGVycyQxLl9nZXRQYXJlbnROb2RlID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG5cdFx0aWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQuaG9zdDtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcmVudDtcblx0fTtcblx0aGVscGVycyQxLmdldE1heGltdW1XaWR0aCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHR2YXIgY29udGFpbmVyID0gaGVscGVycyQxLl9nZXRQYXJlbnROb2RlKGRvbU5vZGUpO1xuXHRcdGlmICghY29udGFpbmVyKSB7XG5cdFx0XHRyZXR1cm4gZG9tTm9kZS5jbGllbnRXaWR0aDtcblx0XHR9XG5cblx0XHR2YXIgY2xpZW50V2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG5cdFx0dmFyIHBhZGRpbmdMZWZ0ID0gaGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nKGNvbnRhaW5lciwgJ3BhZGRpbmctbGVmdCcsIGNsaWVudFdpZHRoKTtcblx0XHR2YXIgcGFkZGluZ1JpZ2h0ID0gaGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nKGNvbnRhaW5lciwgJ3BhZGRpbmctcmlnaHQnLCBjbGllbnRXaWR0aCk7XG5cblx0XHR2YXIgdyA9IGNsaWVudFdpZHRoIC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQ7XG5cdFx0dmFyIGN3ID0gaGVscGVycyQxLmdldENvbnN0cmFpbnRXaWR0aChkb21Ob2RlKTtcblx0XHRyZXR1cm4gaXNOYU4oY3cpID8gdyA6IE1hdGgubWluKHcsIGN3KTtcblx0fTtcblx0aGVscGVycyQxLmdldE1heGltdW1IZWlnaHQgPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZShkb21Ob2RlKTtcblx0XHRpZiAoIWNvbnRhaW5lcikge1xuXHRcdFx0cmV0dXJuIGRvbU5vZGUuY2xpZW50SGVpZ2h0O1xuXHRcdH1cblxuXHRcdHZhciBjbGllbnRIZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuXHRcdHZhciBwYWRkaW5nVG9wID0gaGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nKGNvbnRhaW5lciwgJ3BhZGRpbmctdG9wJywgY2xpZW50SGVpZ2h0KTtcblx0XHR2YXIgcGFkZGluZ0JvdHRvbSA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLWJvdHRvbScsIGNsaWVudEhlaWdodCk7XG5cblx0XHR2YXIgaCA9IGNsaWVudEhlaWdodCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tO1xuXHRcdHZhciBjaCA9IGhlbHBlcnMkMS5nZXRDb25zdHJhaW50SGVpZ2h0KGRvbU5vZGUpO1xuXHRcdHJldHVybiBpc05hTihjaCkgPyBoIDogTWF0aC5taW4oaCwgY2gpO1xuXHR9O1xuXHRoZWxwZXJzJDEuZ2V0U3R5bGUgPSBmdW5jdGlvbihlbCwgcHJvcGVydHkpIHtcblx0XHRyZXR1cm4gZWwuY3VycmVudFN0eWxlID9cblx0XHRcdGVsLmN1cnJlbnRTdHlsZVtwcm9wZXJ0eV0gOlxuXHRcdFx0ZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG5cdH07XG5cdGhlbHBlcnMkMS5yZXRpbmFTY2FsZSA9IGZ1bmN0aW9uKGNoYXJ0LCBmb3JjZVJhdGlvKSB7XG5cdFx0dmFyIHBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IGZvcmNlUmF0aW8gfHwgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB8fCAxO1xuXHRcdGlmIChwaXhlbFJhdGlvID09PSAxKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblx0XHR2YXIgaGVpZ2h0ID0gY2hhcnQuaGVpZ2h0O1xuXHRcdHZhciB3aWR0aCA9IGNoYXJ0LndpZHRoO1xuXG5cdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG5cdFx0Y2FudmFzLndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuXHRcdGNoYXJ0LmN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblxuXHRcdC8vIElmIG5vIHN0eWxlIGhhcyBiZWVuIHNldCBvbiB0aGUgY2FudmFzLCB0aGUgcmVuZGVyIHNpemUgaXMgdXNlZCBhcyBkaXNwbGF5IHNpemUsXG5cdFx0Ly8gbWFraW5nIHRoZSBjaGFydCB2aXN1YWxseSBiaWdnZXIsIHNvIGxldCdzIGVuZm9yY2UgaXQgdG8gdGhlIFwiY29ycmVjdFwiIHZhbHVlcy5cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM1NzVcblx0XHRpZiAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkge1xuXHRcdFx0Y2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cdFx0XHRjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0fVxuXHR9O1xuXHQvLyAtLSBDYW52YXMgbWV0aG9kc1xuXHRoZWxwZXJzJDEuZm9udFN0cmluZyA9IGZ1bmN0aW9uKHBpeGVsU2l6ZSwgZm9udFN0eWxlLCBmb250RmFtaWx5KSB7XG5cdFx0cmV0dXJuIGZvbnRTdHlsZSArICcgJyArIHBpeGVsU2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcblx0fTtcblx0aGVscGVycyQxLmxvbmdlc3RUZXh0ID0gZnVuY3Rpb24oY3R4LCBmb250LCBhcnJheU9mVGhpbmdzLCBjYWNoZSkge1xuXHRcdGNhY2hlID0gY2FjaGUgfHwge307XG5cdFx0dmFyIGRhdGEgPSBjYWNoZS5kYXRhID0gY2FjaGUuZGF0YSB8fCB7fTtcblx0XHR2YXIgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0IHx8IFtdO1xuXG5cdFx0aWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcblx0XHRcdGRhdGEgPSBjYWNoZS5kYXRhID0ge307XG5cdFx0XHRnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gW107XG5cdFx0XHRjYWNoZS5mb250ID0gZm9udDtcblx0XHR9XG5cblx0XHRjdHguZm9udCA9IGZvbnQ7XG5cdFx0dmFyIGxvbmdlc3QgPSAwO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGFycmF5T2ZUaGluZ3MsIGZ1bmN0aW9uKHRoaW5nKSB7XG5cdFx0XHQvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcblx0XHRcdGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmIGhlbHBlcnMkMS5pc0FycmF5KHRoaW5nKSAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRsb25nZXN0ID0gaGVscGVycyQxLm1lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHRoaW5nKTtcblx0XHRcdH0gZWxzZSBpZiAoaGVscGVycyQxLmlzQXJyYXkodGhpbmcpKSB7XG5cdFx0XHRcdC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldHMgbWVhc3VyZSBlYWNoIGVsZW1lbnRcblx0XHRcdFx0Ly8gdG8gZG8gbWF5YmUgc2ltcGxpZnkgdGhpcyBmdW5jdGlvbiBhIGJpdCBzbyB3ZSBjYW4gZG8gdGhpcyBtb3JlIHJlY3Vyc2l2ZWx5P1xuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaCh0aGluZywgZnVuY3Rpb24obmVzdGVkVGhpbmcpIHtcblx0XHRcdFx0XHQvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcblx0XHRcdFx0XHRpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaGVscGVycyQxLmlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XG5cdFx0XHRcdFx0XHRsb25nZXN0ID0gaGVscGVycyQxLm1lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIG5lc3RlZFRoaW5nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dmFyIGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcblx0XHRpZiAoZ2NMZW4gPiBhcnJheU9mVGhpbmdzLmxlbmd0aCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBnY0xlbjsgaSsrKSB7XG5cdFx0XHRcdGRlbGV0ZSBkYXRhW2djW2ldXTtcblx0XHRcdH1cblx0XHRcdGdjLnNwbGljZSgwLCBnY0xlbik7XG5cdFx0fVxuXHRcdHJldHVybiBsb25nZXN0O1xuXHR9O1xuXHRoZWxwZXJzJDEubWVhc3VyZVRleHQgPSBmdW5jdGlvbihjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBzdHJpbmcpIHtcblx0XHR2YXIgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddO1xuXHRcdGlmICghdGV4dFdpZHRoKSB7XG5cdFx0XHR0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcblx0XHRcdGdjLnB1c2goc3RyaW5nKTtcblx0XHR9XG5cdFx0aWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcblx0XHRcdGxvbmdlc3QgPSB0ZXh0V2lkdGg7XG5cdFx0fVxuXHRcdHJldHVybiBsb25nZXN0O1xuXHR9O1xuXHRoZWxwZXJzJDEubnVtYmVyT2ZMYWJlbExpbmVzID0gZnVuY3Rpb24oYXJyYXlPZlRoaW5ncykge1xuXHRcdHZhciBudW1iZXJPZkxpbmVzID0gMTtcblx0XHRoZWxwZXJzJDEuZWFjaChhcnJheU9mVGhpbmdzLCBmdW5jdGlvbih0aGluZykge1xuXHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRoaW5nKSkge1xuXHRcdFx0XHRpZiAodGhpbmcubGVuZ3RoID4gbnVtYmVyT2ZMaW5lcykge1xuXHRcdFx0XHRcdG51bWJlck9mTGluZXMgPSB0aGluZy5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gbnVtYmVyT2ZMaW5lcztcblx0fTtcblxuXHRoZWxwZXJzJDEuY29sb3IgPSAhY2hhcnRqc0NvbG9yID9cblx0XHRmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignQ29sb3IuanMgbm90IGZvdW5kIScpO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHQvKiBnbG9iYWwgQ2FudmFzR3JhZGllbnQgKi9cblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIENhbnZhc0dyYWRpZW50KSB7XG5cdFx0XHRcdHZhbHVlID0gY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2hhcnRqc0NvbG9yKHZhbHVlKTtcblx0XHR9O1xuXG5cdGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yID0gZnVuY3Rpb24oY29sb3JWYWx1ZSkge1xuXHRcdC8qIGdsb2JhbCBDYW52YXNQYXR0ZXJuICovXG5cdFx0cmV0dXJuIChjb2xvclZhbHVlIGluc3RhbmNlb2YgQ2FudmFzUGF0dGVybiB8fCBjb2xvclZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQpID9cblx0XHRcdGNvbG9yVmFsdWUgOlxuXHRcdFx0aGVscGVycyQxLmNvbG9yKGNvbG9yVmFsdWUpLnNhdHVyYXRlKDAuNSkuZGFya2VuKDAuMSkucmdiU3RyaW5nKCk7XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhYnN0cmFjdCgpIHtcblx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IGVpdGhlciBubyBhZGFwdGVyIGNhbiAnICtcblx0XHQnYmUgZm91bmQgb3IgYW4gaW5jb21wbGV0ZSBpbnRlZ3JhdGlvbiB3YXMgcHJvdmlkZWQuJ1xuXHQpO1xufVxuXG4vKipcbiAqIERhdGUgYWRhcHRlciAoY3VycmVudCB1c2VkIGJ5IHRoZSB0aW1lIHNjYWxlKVxuICogQG5hbWVzcGFjZSBDaGFydC5fYWRhcHRlcnMuX2RhdGVcbiAqIEBtZW1iZXJvZiBDaGFydC5fYWRhcHRlcnNcbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBDdXJyZW50bHkgc3VwcG9ydGVkIHVuaXQgc3RyaW5nIHZhbHVlcy5cbiAqIEB0eXBlZGVmIHsoJ21pbGxpc2Vjb25kJ3wnc2Vjb25kJ3wnbWludXRlJ3wnaG91cid8J2RheSd8J3dlZWsnfCdtb250aCd8J3F1YXJ0ZXInfCd5ZWFyJyl9XG4gKiBAbWVtYmVyb2YgQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlXG4gKiBAbmFtZSBVbml0XG4gKi9cblxuLyoqXG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gRGF0ZUFkYXB0ZXIob3B0aW9ucykge1xuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xufVxuXG5oZWxwZXJzJDEuZXh0ZW5kKERhdGVBZGFwdGVyLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBEYXRlQWRhcHRlciAqLyB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbWFwIG9mIHRpbWUgZm9ybWF0cyBmb3IgdGhlIHN1cHBvcnRlZCBmb3JtYXR0aW5nIHVuaXRzIGRlZmluZWRcblx0ICogaW4gVW5pdCBhcyB3ZWxsIGFzICdkYXRldGltZScgcmVwcmVzZW50aW5nIGEgZGV0YWlsZWQgZGF0ZS90aW1lIHN0cmluZy5cblx0ICogQHJldHVybnMge3tzdHJpbmc6IHN0cmluZ319XG5cdCAqL1xuXHRmb3JtYXRzOiBhYnN0cmFjdCxcblxuXHQvKipcblx0ICogUGFyc2VzIHRoZSBnaXZlbiBgdmFsdWVgIGFuZCByZXR1cm4gdGhlIGFzc29jaWF0ZWQgdGltZXN0YW1wLlxuXHQgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gcGFyc2UgKHVzdWFsbHkgY29tZXMgZnJvbSB0aGUgZGF0YSlcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtmb3JtYXRdIC0gdGhlIGV4cGVjdGVkIGRhdGEgZm9ybWF0XG5cdCAqIEByZXR1cm5zIHsobnVtYmVyfG51bGwpfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdHBhcnNlOiBhYnN0cmFjdCxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZm9ybWF0dGVkIGRhdGUgaW4gdGhlIHNwZWNpZmllZCBgZm9ybWF0YCBmb3IgYSBnaXZlbiBgdGltZXN0YW1wYC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIHRoZSB0aW1lc3RhbXAgdG8gZm9ybWF0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSB0aGUgZGF0ZS90aW1lIHRva2VuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRmb3JtYXQ6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBzcGVjaWZpZWQgYGFtb3VudGAgb2YgYHVuaXRgIHRvIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgdG8gYWRkXG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0YWRkOiBhYnN0cmFjdCxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGB1bml0YCBiZXR3ZWVuIHRoZSBnaXZlbiB0aW1lc3RhbXBzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gdGhlIGlucHV0IHRpbWVzdGFtcCAocmVmZXJlbmNlKVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gdGhlIHRpbWVzdGFtcCB0byBzdWJzdHJhY3Rcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRkaWZmOiBhYnN0cmFjdCxcblxuXHQvKipcblx0ICogUmV0dXJucyBzdGFydCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2Vla2RheV0gLSB0aGUgSVNPIGRheSBvZiB0aGUgd2VlayB3aXRoIDEgYmVpbmcgTW9uZGF5XG5cdCAqIGFuZCA3IGJlaW5nIFN1bmRheSAob25seSBuZWVkZWQgaWYgcGFyYW0gKnVuaXQqIGlzIGBpc29XZWVrYCkuXG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0c3RhcnRPZjogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgZW5kIG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRlbmRPZjogYWJzdHJhY3QsXG5cblx0Ly8gREVQUkVDQVRJT05TXG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBzY2FsZS5nZXRWYWx1ZUZvclBpeGVsKCksXG5cdCAqIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuIG9ubHkgYnkgdGhlIG1vbWVudCBhZGFwdGVyLlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG59KTtcblxuRGF0ZUFkYXB0ZXIub3ZlcnJpZGUgPSBmdW5jdGlvbihtZW1iZXJzKSB7XG5cdGhlbHBlcnMkMS5leHRlbmQoRGF0ZUFkYXB0ZXIucHJvdG90eXBlLCBtZW1iZXJzKTtcbn07XG5cbnZhciBfZGF0ZSA9IERhdGVBZGFwdGVyO1xuXG52YXIgY29yZV9hZGFwdGVycyA9IHtcblx0X2RhdGU6IF9kYXRlXG59O1xuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIHN0YXRpYyB0aWNrIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzXG4gKi9cbnZhciBjb3JlX3RpY2tzID0ge1xuXHQvKipcblx0ICogTmFtZXNwYWNlIHRvIGhvbGQgZm9ybWF0dGVycyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHRpY2tzXG5cdCAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3MuZm9ybWF0dGVyc1xuXHQgKi9cblx0Zm9ybWF0dGVyczoge1xuXHRcdC8qKlxuXHRcdCAqIEZvcm1hdHRlciBmb3IgdmFsdWUgbGFiZWxzXG5cdFx0ICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLnZhbHVlc1xuXHRcdCAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gZGlzcGxheVxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ3xzdHJpbmdbXX0gdGhlIGxhYmVsIHRvIGRpc3BsYXlcblx0XHQgKi9cblx0XHR2YWx1ZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaGVscGVycyQxLmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiAnJyArIHZhbHVlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGb3JtYXR0ZXIgZm9yIGxpbmVhciBudW1lcmljIHRpY2tzXG5cdFx0ICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxuXHRcdCAqIEBwYXJhbSB0aWNrVmFsdWUge251bWJlcn0gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuXHRcdCAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XG5cdFx0ICogQHBhcmFtIHRpY2tzIHtudW1iZXJbXX0gdGhlIGxpc3Qgb2YgdGlja3MgYmVpbmcgY29udmVydGVkXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXJcblx0XHQgKi9cblx0XHRsaW5lYXI6IGZ1bmN0aW9uKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGxvdHMgb2YgdGlja3MsIGRvbid0IHVzZSB0aGUgb25lc1xuXHRcdFx0dmFyIGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdIC0gdGlja3NbMV0gOiB0aWNrc1sxXSAtIHRpY2tzWzBdO1xuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGEgbnVtYmVyIGxpa2UgMi41IGFzIHRoZSBkZWx0YSwgZmlndXJlIG91dCBob3cgbWFueSBkZWNpbWFsIHBsYWNlcyB3ZSBuZWVkXG5cdFx0XHRpZiAoTWF0aC5hYnMoZGVsdGEpID4gMSkge1xuXHRcdFx0XHRpZiAodGlja1ZhbHVlICE9PSBNYXRoLmZsb29yKHRpY2tWYWx1ZSkpIHtcblx0XHRcdFx0XHQvLyBub3QgYW4gaW50ZWdlclxuXHRcdFx0XHRcdGRlbHRhID0gdGlja1ZhbHVlIC0gTWF0aC5mbG9vcih0aWNrVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsb2dEZWx0YSA9IGhlbHBlcnMkMS5sb2cxMChNYXRoLmFicyhkZWx0YSkpO1xuXHRcdFx0dmFyIHRpY2tTdHJpbmcgPSAnJztcblxuXHRcdFx0aWYgKHRpY2tWYWx1ZSAhPT0gMCkge1xuXHRcdFx0XHR2YXIgbWF4VGljayA9IE1hdGgubWF4KE1hdGguYWJzKHRpY2tzWzBdKSwgTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0pKTtcblx0XHRcdFx0aWYgKG1heFRpY2sgPCAxZS00KSB7IC8vIGFsbCB0aWNrcyBhcmUgc21hbGwgbnVtYmVyczsgdXNlIHNjaWVudGlmaWMgbm90YXRpb25cblx0XHRcdFx0XHR2YXIgbG9nVGljayA9IGhlbHBlcnMkMS5sb2cxMChNYXRoLmFicyh0aWNrVmFsdWUpKTtcblx0XHRcdFx0XHR0aWNrU3RyaW5nID0gdGlja1ZhbHVlLnRvRXhwb25lbnRpYWwoTWF0aC5mbG9vcihsb2dUaWNrKSAtIE1hdGguZmxvb3IobG9nRGVsdGEpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgbnVtRGVjaW1hbCA9IC0xICogTWF0aC5mbG9vcihsb2dEZWx0YSk7XG5cdFx0XHRcdFx0bnVtRGVjaW1hbCA9IE1hdGgubWF4KE1hdGgubWluKG51bURlY2ltYWwsIDIwKSwgMCk7IC8vIHRvRml4ZWQgaGFzIGEgbWF4IG9mIDIwIGRlY2ltYWwgcGxhY2VzXG5cdFx0XHRcdFx0dGlja1N0cmluZyA9IHRpY2tWYWx1ZS50b0ZpeGVkKG51bURlY2ltYWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aWNrU3RyaW5nID0gJzAnOyAvLyBuZXZlciBzaG93IGRlY2ltYWwgcGxhY2VzIGZvciAwXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aWNrU3RyaW5nO1xuXHRcdH0sXG5cblx0XHRsb2dhcml0aG1pYzogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcblx0XHRcdHZhciByZW1haW4gPSB0aWNrVmFsdWUgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKHRpY2tWYWx1ZSkpKSk7XG5cblx0XHRcdGlmICh0aWNrVmFsdWUgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuICcwJztcblx0XHRcdH0gZWxzZSBpZiAocmVtYWluID09PSAxIHx8IHJlbWFpbiA9PT0gMiB8fCByZW1haW4gPT09IDUgfHwgaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHRpY2tzLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0cmV0dXJuIHRpY2tWYWx1ZS50b0V4cG9uZW50aWFsKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgdmFsdWVPckRlZmF1bHQkOSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcbnZhciB2YWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3NjYWxlJywge1xuXHRkaXNwbGF5OiB0cnVlLFxuXHRwb3NpdGlvbjogJ2xlZnQnLFxuXHRvZmZzZXQ6IGZhbHNlLFxuXG5cdC8vIGdyaWQgbGluZSBzZXR0aW5nc1xuXHRncmlkTGluZXM6IHtcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcblx0XHRsaW5lV2lkdGg6IDEsXG5cdFx0ZHJhd0JvcmRlcjogdHJ1ZSxcblx0XHRkcmF3T25DaGFydEFyZWE6IHRydWUsXG5cdFx0ZHJhd1RpY2tzOiB0cnVlLFxuXHRcdHRpY2tNYXJrTGVuZ3RoOiAxMCxcblx0XHR6ZXJvTGluZVdpZHRoOiAxLFxuXHRcdHplcm9MaW5lQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMjUpJyxcblx0XHR6ZXJvTGluZUJvcmRlckRhc2g6IFtdLFxuXHRcdHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogMC4wLFxuXHRcdG9mZnNldEdyaWRMaW5lczogZmFsc2UsXG5cdFx0Ym9yZGVyRGFzaDogW10sXG5cdFx0Ym9yZGVyRGFzaE9mZnNldDogMC4wXG5cdH0sXG5cblx0Ly8gc2NhbGUgbGFiZWxcblx0c2NhbGVMYWJlbDoge1xuXHRcdC8vIGRpc3BsYXkgcHJvcGVydHlcblx0XHRkaXNwbGF5OiBmYWxzZSxcblxuXHRcdC8vIGFjdHVhbCBsYWJlbFxuXHRcdGxhYmVsU3RyaW5nOiAnJyxcblxuXHRcdC8vIHRvcC9ib3R0b20gcGFkZGluZ1xuXHRcdHBhZGRpbmc6IHtcblx0XHRcdHRvcDogNCxcblx0XHRcdGJvdHRvbTogNFxuXHRcdH1cblx0fSxcblxuXHQvLyBsYWJlbCBzZXR0aW5nc1xuXHR0aWNrczoge1xuXHRcdGJlZ2luQXRaZXJvOiBmYWxzZSxcblx0XHRtaW5Sb3RhdGlvbjogMCxcblx0XHRtYXhSb3RhdGlvbjogNTAsXG5cdFx0bWlycm9yOiBmYWxzZSxcblx0XHRwYWRkaW5nOiAwLFxuXHRcdHJldmVyc2U6IGZhbHNlLFxuXHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0YXV0b1NraXA6IHRydWUsXG5cdFx0YXV0b1NraXBQYWRkaW5nOiAwLFxuXHRcdGxhYmVsT2Zmc2V0OiAwLFxuXHRcdC8vIFdlIHBhc3MgdGhyb3VnaCBhcnJheXMgdG8gYmUgcmVuZGVyZWQgYXMgbXVsdGlsaW5lIGxhYmVscywgd2UgY29udmVydCBPdGhlcnMgdG8gc3RyaW5ncyBoZXJlLlxuXHRcdGNhbGxiYWNrOiBjb3JlX3RpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxuXHRcdG1pbm9yOiB7fSxcblx0XHRtYWpvcjoge31cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGxhYmVsc0Zyb21UaWNrcyh0aWNrcykge1xuXHR2YXIgbGFiZWxzID0gW107XG5cdHZhciBpLCBpbGVuO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRsYWJlbHMucHVzaCh0aWNrc1tpXS5sYWJlbCk7XG5cdH1cblxuXHRyZXR1cm4gbGFiZWxzO1xufVxuXG5mdW5jdGlvbiBnZXRQaXhlbEZvckdyaWRMaW5lKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XG5cdHZhciBsaW5lVmFsdWUgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaW5kZXgpO1xuXG5cdGlmIChvZmZzZXRHcmlkTGluZXMpIHtcblx0XHRpZiAoc2NhbGUuZ2V0VGlja3MoKS5sZW5ndGggPT09IDEpIHtcblx0XHRcdGxpbmVWYWx1ZSAtPSBzY2FsZS5pc0hvcml6b250YWwoKSA/XG5cdFx0XHRcdE1hdGgubWF4KGxpbmVWYWx1ZSAtIHNjYWxlLmxlZnQsIHNjYWxlLnJpZ2h0IC0gbGluZVZhbHVlKSA6XG5cdFx0XHRcdE1hdGgubWF4KGxpbmVWYWx1ZSAtIHNjYWxlLnRvcCwgc2NhbGUuYm90dG9tIC0gbGluZVZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG5cdFx0XHRsaW5lVmFsdWUgLT0gKHNjYWxlLmdldFBpeGVsRm9yVGljaygxKSAtIGxpbmVWYWx1ZSkgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsaW5lVmFsdWUgLT0gKGxpbmVWYWx1ZSAtIHNjYWxlLmdldFBpeGVsRm9yVGljayhpbmRleCAtIDEpKSAvIDI7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBsaW5lVmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVUZXh0U2l6ZShjb250ZXh0LCB0aWNrLCBmb250KSB7XG5cdHJldHVybiBoZWxwZXJzJDEuaXNBcnJheSh0aWNrKSA/XG5cdFx0aGVscGVycyQxLmxvbmdlc3RUZXh0KGNvbnRleHQsIGZvbnQsIHRpY2spIDpcblx0XHRjb250ZXh0Lm1lYXN1cmVUZXh0KHRpY2spLndpZHRoO1xufVxuXG52YXIgY29yZV9zY2FsZSA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHQvKipcblx0ICogR2V0IHRoZSBwYWRkaW5nIG5lZWRlZCBmb3IgdGhlIHNjYWxlXG5cdCAqIEBtZXRob2QgZ2V0UGFkZGluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmV0dXJucyB7UGFkZGluZ30gdGhlIG5lY2Vzc2FyeSBwYWRkaW5nXG5cdCAqL1xuXHRnZXRQYWRkaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHJldHVybiB7XG5cdFx0XHRsZWZ0OiBtZS5wYWRkaW5nTGVmdCB8fCAwLFxuXHRcdFx0dG9wOiBtZS5wYWRkaW5nVG9wIHx8IDAsXG5cdFx0XHRyaWdodDogbWUucGFkZGluZ1JpZ2h0IHx8IDAsXG5cdFx0XHRib3R0b206IG1lLnBhZGRpbmdCb3R0b20gfHwgMFxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHNjYWxlIHRpY2sgb2JqZWN0cyAoe2xhYmVsLCBtYWpvcn0pXG5cdCAqIEBzaW5jZSAyLjdcblx0ICovXG5cdGdldFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGlja3M7XG5cdH0sXG5cblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3lsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuXHQvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgc2NhbGUgdHlwZXMuXG5cdC8vIEFueSBmdW5jdGlvbiBjYW4gYmUgZXh0ZW5kZWQgYnkgdGhlIHNjYWxlIHR5cGVcblxuXHRtZXJnZVRpY2tzT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXHRcdGlmICh0aWNrcy5taW5vciA9PT0gZmFsc2UpIHtcblx0XHRcdHRpY2tzLm1pbm9yID0ge1xuXHRcdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aWYgKHRpY2tzLm1ham9yID09PSBmYWxzZSkge1xuXHRcdFx0dGlja3MubWFqb3IgPSB7XG5cdFx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRmb3IgKHZhciBrZXkgaW4gdGlja3MpIHtcblx0XHRcdGlmIChrZXkgIT09ICdtYWpvcicgJiYga2V5ICE9PSAnbWlub3InKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgdGlja3MubWlub3Jba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHR0aWNrcy5taW5vcltrZXldID0gdGlja3Nba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mIHRpY2tzLm1ham9yW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0dGlja3MubWFqb3Jba2V5XSA9IHRpY2tzW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaSwgaWxlbiwgbGFiZWxzLCBsYWJlbCwgdGlja3MsIHRpY2s7XG5cblx0XHQvLyBVcGRhdGUgTGlmZWN5Y2xlIC0gUHJvYmFibHkgZG9uJ3Qgd2FudCB0byBldmVyIGV4dGVuZCBvciBvdmVyd3JpdGUgdGhpcyBmdW5jdGlvbiA7KVxuXHRcdG1lLmJlZm9yZVVwZGF0ZSgpO1xuXG5cdFx0Ly8gQWJzb3JiIHRoZSBtYXN0ZXIgbWVhc3VyZW1lbnRzXG5cdFx0bWUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHRtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG5cdFx0bWUubWFyZ2lucyA9IGhlbHBlcnMkMS5leHRlbmQoe1xuXHRcdFx0bGVmdDogMCxcblx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0dG9wOiAwLFxuXHRcdFx0Ym90dG9tOiAwXG5cdFx0fSwgbWFyZ2lucyk7XG5cblx0XHRtZS5fbWF4TGFiZWxMaW5lcyA9IDA7XG5cdFx0bWUubG9uZ2VzdExhYmVsV2lkdGggPSAwO1xuXHRcdG1lLmxvbmdlc3RUZXh0Q2FjaGUgPSBtZS5sb25nZXN0VGV4dENhY2hlIHx8IHt9O1xuXG5cdFx0Ly8gRGltZW5zaW9uc1xuXHRcdG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5zZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG5cblx0XHQvLyBEYXRhIG1pbi9tYXhcblx0XHRtZS5iZWZvcmVEYXRhTGltaXRzKCk7XG5cdFx0bWUuZGV0ZXJtaW5lRGF0YUxpbWl0cygpO1xuXHRcdG1lLmFmdGVyRGF0YUxpbWl0cygpO1xuXG5cdFx0Ly8gVGlja3MgLSBgdGhpcy50aWNrc2AgaXMgbm93IERFUFJFQ0FURUQhXG5cdFx0Ly8gSW50ZXJuYWwgdGlja3MgYXJlIG5vdyBzdG9yZWQgYXMgb2JqZWN0cyBpbiB0aGUgUFJJVkFURSBgdGhpcy5fdGlja3NgIG1lbWJlclxuXHRcdC8vIGFuZCBtdXN0IG5vdCBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIG91dHNpZGUgdGhpcyBjbGFzcy4gYHRoaXMudGlja3NgIGJlaW5nXG5cdFx0Ly8gYXJvdW5kIGZvciBsb25nIHRpbWUgYW5kIG5vdCBtYXJrZWQgYXMgcHJpdmF0ZSwgd2UgY2FuJ3QgY2hhbmdlIGl0cyBzdHJ1Y3R1cmVcblx0XHQvLyB3aXRob3V0IHVuZXhwZWN0ZWQgYnJlYWtpbmcgY2hhbmdlcy4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzY2FsZSB0aWNrcyxcblx0XHQvLyB1c2Ugc2NhbGUuZ2V0VGlja3MoKSBpbnN0ZWFkLlxuXG5cdFx0bWUuYmVmb3JlQnVpbGRUaWNrcygpO1xuXG5cdFx0Ly8gTmV3IGltcGxlbWVudGF0aW9ucyBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIG9iamVjdHMgYnV0IGZvciBCQUNLV0FSRCBDT01QQVQsXG5cdFx0Ly8gd2Ugc3RpbGwgc3VwcG9ydCBubyByZXR1cm4gKGB0aGlzLnRpY2tzYCBpbnRlcm5hbGx5IHNldCBieSBjYWxsaW5nIHRoaXMgbWV0aG9kKS5cblx0XHR0aWNrcyA9IG1lLmJ1aWxkVGlja3MoKSB8fCBbXTtcblxuXHRcdC8vIEFsbG93IG1vZGlmaWNhdGlvbiBvZiB0aWNrcyBpbiBjYWxsYmFjay5cblx0XHR0aWNrcyA9IG1lLmFmdGVyQnVpbGRUaWNrcyh0aWNrcykgfHwgdGlja3M7XG5cblx0XHRtZS5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuXHRcdC8vIE5ldyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHJldHVybiB0aGUgZm9ybWF0dGVkIHRpY2sgbGFiZWxzIGJ1dCBmb3IgQkFDS1dBUkRcblx0XHQvLyBDT01QQVQsIHdlIHN0aWxsIHN1cHBvcnQgbm8gcmV0dXJuIChgdGhpcy50aWNrc2AgaW50ZXJuYWxseSBjaGFuZ2VkIGJ5IGNhbGxpbmdcblx0XHQvLyB0aGlzIG1ldGhvZCBhbmQgc3VwcG9zZWQgdG8gY29udGFpbiBvbmx5IHN0cmluZyB2YWx1ZXMpLlxuXHRcdGxhYmVscyA9IG1lLmNvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB8fCBtZS50aWNrcztcblxuXHRcdG1lLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG5cblx0XHRtZS50aWNrcyA9IGxhYmVsczsgICAvLyBCQUNLV0FSRCBDT01QQVRJQklMSVRZXG5cblx0XHQvLyBJTVBPUlRBTlQ6IGZyb20gdGhpcyBwb2ludCwgd2UgY29uc2lkZXIgdGhhdCBgdGhpcy50aWNrc2Agd2lsbCBORVZFUiBjaGFuZ2UhXG5cblx0XHQvLyBCQUNLV0FSRCBDT01QQVQ6IHN5bmNocm9uaXplIGBfdGlja3NgIHdpdGggbGFiZWxzIChzbyBwb3RlbnRpYWxseSBgdGhpcy50aWNrc2ApXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGxhYmVsID0gbGFiZWxzW2ldO1xuXHRcdFx0dGljayA9IHRpY2tzW2ldO1xuXHRcdFx0aWYgKCF0aWNrKSB7XG5cdFx0XHRcdHRpY2tzLnB1c2godGljayA9IHtcblx0XHRcdFx0XHRsYWJlbDogbGFiZWwsXG5cdFx0XHRcdFx0bWFqb3I6IGZhbHNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGljay5sYWJlbCA9IGxhYmVsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLl90aWNrcyA9IHRpY2tzO1xuXG5cdFx0Ly8gVGljayBSb3RhdGlvblxuXHRcdG1lLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xuXHRcdG1lLmNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xuXHRcdG1lLmFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0Ly8gRml0XG5cdFx0bWUuYmVmb3JlRml0KCk7XG5cdFx0bWUuZml0KCk7XG5cdFx0bWUuYWZ0ZXJGaXQoKTtcblx0XHQvL1xuXHRcdG1lLmFmdGVyVXBkYXRlKCk7XG5cblx0XHRyZXR1cm4gbWUubWluU2l6ZTtcblxuXHR9LFxuXHRhZnRlclVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcblx0fSxcblxuXHQvL1xuXG5cdGJlZm9yZVNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcblx0fSxcblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuXHRcdFx0bWUubGVmdCA9IDA7XG5cdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUudG9wID0gMDtcblx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcblx0XHR9XG5cblx0XHQvLyBSZXNldCBwYWRkaW5nXG5cdFx0bWUucGFkZGluZ0xlZnQgPSAwO1xuXHRcdG1lLnBhZGRpbmdUb3AgPSAwO1xuXHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XG5cdFx0bWUucGFkZGluZ0JvdHRvbSA9IDA7XG5cdH0sXG5cdGFmdGVyU2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly8gRGF0YSBsaW1pdHNcblx0YmVmb3JlRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVEYXRhTGltaXRzLCBbdGhpc10pO1xuXHR9LFxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBoZWxwZXJzJDEubm9vcCxcblx0YWZ0ZXJEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRGF0YUxpbWl0cywgW3RoaXNdKTtcblx0fSxcblxuXHQvL1xuXHRiZWZvcmVCdWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUJ1aWxkVGlja3MsIFt0aGlzXSk7XG5cdH0sXG5cdGJ1aWxkVGlja3M6IGhlbHBlcnMkMS5ub29wLFxuXHRhZnRlckJ1aWxkVGlja3M6IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyB0aWNrcyBpcyBlbXB0eSBmb3Igb2xkIGF4aXMgaW1wbGVtZW50YXRpb25zIGhlcmVcblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGlja3MpICYmIHRpY2tzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGhlbHBlcnMkMS5jYWxsYmFjayhtZS5vcHRpb25zLmFmdGVyQnVpbGRUaWNrcywgW21lLCB0aWNrc10pO1xuXHRcdH1cblx0XHQvLyBTdXBwb3J0IG9sZCBpbXBsZW1lbnRhdGlvbnMgKHRoYXQgbW9kaWZpZWQgYHRoaXMudGlja3NgIGRpcmVjdGx5IGluIGJ1aWxkVGlja3MpXG5cdFx0bWUudGlja3MgPSBoZWxwZXJzJDEuY2FsbGJhY2sobWUub3B0aW9ucy5hZnRlckJ1aWxkVGlja3MsIFttZSwgbWUudGlja3NdKSB8fCBtZS50aWNrcztcblx0XHRyZXR1cm4gdGlja3M7XG5cdH0sXG5cblx0YmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcblx0fSxcblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gQ29udmVydCB0aWNrcyB0byBzdHJpbmdzXG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHRtZS50aWNrcyA9IG1lLnRpY2tzLm1hcCh0aWNrT3B0cy51c2VyQ2FsbGJhY2sgfHwgdGlja09wdHMuY2FsbGJhY2ssIHRoaXMpO1xuXHR9LFxuXHRhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcblx0fSxcblxuXHQvL1xuXG5cdGJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVDYWxjdWxhdGVUaWNrUm90YXRpb24sIFt0aGlzXSk7XG5cdH0sXG5cdGNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY29udGV4dCA9IG1lLmN0eDtcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciBsYWJlbHMgPSBsYWJlbHNGcm9tVGlja3MobWUuX3RpY2tzKTtcblxuXHRcdC8vIEdldCB0aGUgd2lkdGggb2YgZWFjaCBncmlkIGJ5IGNhbGN1bGF0aW5nIHRoZSBkaWZmZXJlbmNlXG5cdFx0Ly8gYmV0d2VlbiB4IG9mZnNldHMgYmV0d2VlbiAwIGFuZCAxLlxuXHRcdHZhciB0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQodGlja09wdHMpO1xuXHRcdGNvbnRleHQuZm9udCA9IHRpY2tGb250LnN0cmluZztcblxuXHRcdHZhciBsYWJlbFJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcblxuXHRcdGlmIChsYWJlbHMubGVuZ3RoICYmIG1lLm9wdGlvbnMuZGlzcGxheSAmJiBtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0dmFyIG9yaWdpbmFsTGFiZWxXaWR0aCA9IGhlbHBlcnMkMS5sb25nZXN0VGV4dChjb250ZXh0LCB0aWNrRm9udC5zdHJpbmcsIGxhYmVscywgbWUubG9uZ2VzdFRleHRDYWNoZSk7XG5cdFx0XHR2YXIgbGFiZWxXaWR0aCA9IG9yaWdpbmFsTGFiZWxXaWR0aDtcblx0XHRcdHZhciBjb3NSb3RhdGlvbiwgc2luUm90YXRpb247XG5cblx0XHRcdC8vIEFsbG93IDMgcGl4ZWxzIHgyIHBhZGRpbmcgZWl0aGVyIHNpZGUgZm9yIGxhYmVsIHJlYWRhYmlsaXR5XG5cdFx0XHR2YXIgdGlja1dpZHRoID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbWUuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gNjtcblxuXHRcdFx0Ly8gTWF4IGxhYmVsIHJvdGF0aW9uIGNhbiBiZSBzZXQgb3IgZGVmYXVsdCB0byA5MCAtIGFsc28gYWN0IGFzIGEgbG9vcCBjb3VudGVyXG5cdFx0XHR3aGlsZSAobGFiZWxXaWR0aCA+IHRpY2tXaWR0aCAmJiBsYWJlbFJvdGF0aW9uIDwgdGlja09wdHMubWF4Um90YXRpb24pIHtcblx0XHRcdFx0dmFyIGFuZ2xlUmFkaWFucyA9IGhlbHBlcnMkMS50b1JhZGlhbnMobGFiZWxSb3RhdGlvbik7XG5cdFx0XHRcdGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcblx0XHRcdFx0c2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuXG5cdFx0XHRcdGlmIChzaW5Sb3RhdGlvbiAqIG9yaWdpbmFsTGFiZWxXaWR0aCA+IG1lLm1heEhlaWdodCkge1xuXHRcdFx0XHRcdC8vIGdvIGJhY2sgb25lIHN0ZXBcblx0XHRcdFx0XHRsYWJlbFJvdGF0aW9uLS07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsYWJlbFJvdGF0aW9uKys7XG5cdFx0XHRcdGxhYmVsV2lkdGggPSBjb3NSb3RhdGlvbiAqIG9yaWdpbmFsTGFiZWxXaWR0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcblx0fSxcblx0YWZ0ZXJDYWxjdWxhdGVUaWNrUm90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJDYWxjdWxhdGVUaWNrUm90YXRpb24sIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly9cblxuXHRiZWZvcmVGaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlRml0LCBbdGhpc10pO1xuXHR9LFxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gUmVzZXRcblx0XHR2YXIgbWluU2l6ZSA9IG1lLm1pblNpemUgPSB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMFxuXHRcdH07XG5cblx0XHR2YXIgbGFiZWxzID0gbGFiZWxzRnJvbVRpY2tzKG1lLl90aWNrcyk7XG5cblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblx0XHR2YXIgc2NhbGVMYWJlbE9wdHMgPSBvcHRzLnNjYWxlTGFiZWw7XG5cdFx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xuXHRcdHZhciBkaXNwbGF5ID0gbWUuX2lzVmlzaWJsZSgpO1xuXHRcdHZhciBwb3NpdGlvbiA9IG9wdHMucG9zaXRpb247XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0dmFyIHBhcnNlRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQ7XG5cdFx0dmFyIHRpY2tGb250ID0gcGFyc2VGb250KHRpY2tPcHRzKTtcblx0XHR2YXIgdGlja01hcmtMZW5ndGggPSBvcHRzLmdyaWRMaW5lcy50aWNrTWFya0xlbmd0aDtcblxuXHRcdC8vIFdpZHRoXG5cdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0Ly8gc3VidHJhY3QgdGhlIG1hcmdpbnMgdG8gbGluZSB1cCB3aXRoIHRoZSBjaGFydEFyZWEgaWYgd2UgYXJlIGEgZnVsbCB3aWR0aCBzY2FsZVxuXHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLmlzRnVsbFdpZHRoKCkgPyBtZS5tYXhXaWR0aCAtIG1lLm1hcmdpbnMubGVmdCAtIG1lLm1hcmdpbnMucmlnaHQgOiBtZS5tYXhXaWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IGRpc3BsYXkgJiYgZ3JpZExpbmVPcHRzLmRyYXdUaWNrcyA/IHRpY2tNYXJrTGVuZ3RoIDogMDtcblx0XHR9XG5cblx0XHQvLyBoZWlnaHRcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IGRpc3BsYXkgJiYgZ3JpZExpbmVPcHRzLmRyYXdUaWNrcyA/IHRpY2tNYXJrTGVuZ3RoIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcblx0XHR9XG5cblx0XHQvLyBBcmUgd2Ugc2hvd2luZyBhIHRpdGxlIGZvciB0aGUgc2NhbGU/XG5cdFx0aWYgKHNjYWxlTGFiZWxPcHRzLmRpc3BsYXkgJiYgZGlzcGxheSkge1xuXHRcdFx0dmFyIHNjYWxlTGFiZWxGb250ID0gcGFyc2VGb250KHNjYWxlTGFiZWxPcHRzKTtcblx0XHRcdHZhciBzY2FsZUxhYmVsUGFkZGluZyA9IGhlbHBlcnMkMS5vcHRpb25zLnRvUGFkZGluZyhzY2FsZUxhYmVsT3B0cy5wYWRkaW5nKTtcblx0XHRcdHZhciBkZWx0YUhlaWdodCA9IHNjYWxlTGFiZWxGb250LmxpbmVIZWlnaHQgKyBzY2FsZUxhYmVsUGFkZGluZy5oZWlnaHQ7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgKz0gZGVsdGFIZWlnaHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtaW5TaXplLndpZHRoICs9IGRlbHRhSGVpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIERvbid0IGJvdGhlciBmaXR0aW5nIHRoZSB0aWNrcyBpZiB3ZSBhcmUgbm90IHNob3dpbmcgdGhlIGxhYmVsc1xuXHRcdGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIGRpc3BsYXkpIHtcblx0XHRcdHZhciBsYXJnZXN0VGV4dFdpZHRoID0gaGVscGVycyQxLmxvbmdlc3RUZXh0KG1lLmN0eCwgdGlja0ZvbnQuc3RyaW5nLCBsYWJlbHMsIG1lLmxvbmdlc3RUZXh0Q2FjaGUpO1xuXHRcdFx0dmFyIHRhbGxlc3RMYWJlbEhlaWdodEluTGluZXMgPSBoZWxwZXJzJDEubnVtYmVyT2ZMYWJlbExpbmVzKGxhYmVscyk7XG5cdFx0XHR2YXIgbGluZVNwYWNlID0gdGlja0ZvbnQuc2l6ZSAqIDAuNTtcblx0XHRcdHZhciB0aWNrUGFkZGluZyA9IG1lLm9wdGlvbnMudGlja3MucGFkZGluZztcblxuXHRcdFx0Ly8gU3RvcmUgbWF4IG51bWJlciBvZiBsaW5lcyBhbmQgd2lkZXN0IGxhYmVsIGZvciBfYXV0b1NraXBcblx0XHRcdG1lLl9tYXhMYWJlbExpbmVzID0gdGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcztcblx0XHRcdG1lLmxvbmdlc3RMYWJlbFdpZHRoID0gbGFyZ2VzdFRleHRXaWR0aDtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHR2YXIgYW5nbGVSYWRpYW5zID0gaGVscGVycyQxLnRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcblx0XHRcdFx0dmFyIGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcblx0XHRcdFx0dmFyIHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcblxuXHRcdFx0XHQvLyBUT0RPIC0gaW1wcm92ZSB0aGlzIGNhbGN1bGF0aW9uXG5cdFx0XHRcdHZhciBsYWJlbEhlaWdodCA9IChzaW5Sb3RhdGlvbiAqIGxhcmdlc3RUZXh0V2lkdGgpXG5cdFx0XHRcdFx0KyAodGlja0ZvbnQubGluZUhlaWdodCAqIHRhbGxlc3RMYWJlbEhlaWdodEluTGluZXMpXG5cdFx0XHRcdFx0KyBsaW5lU3BhY2U7IC8vIHBhZGRpbmdcblxuXHRcdFx0XHRtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKG1lLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcblxuXHRcdFx0XHRtZS5jdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcblx0XHRcdFx0dmFyIGZpcnN0TGFiZWxXaWR0aCA9IGNvbXB1dGVUZXh0U2l6ZShtZS5jdHgsIGxhYmVsc1swXSwgdGlja0ZvbnQuc3RyaW5nKTtcblx0XHRcdFx0dmFyIGxhc3RMYWJlbFdpZHRoID0gY29tcHV0ZVRleHRTaXplKG1lLmN0eCwgbGFiZWxzW2xhYmVscy5sZW5ndGggLSAxXSwgdGlja0ZvbnQuc3RyaW5nKTtcblx0XHRcdFx0dmFyIG9mZnNldExlZnQgPSBtZS5nZXRQaXhlbEZvclRpY2soMCkgLSBtZS5sZWZ0O1xuXHRcdFx0XHR2YXIgb2Zmc2V0UmlnaHQgPSBtZS5yaWdodCAtIG1lLmdldFBpeGVsRm9yVGljayhsYWJlbHMubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdHZhciBwYWRkaW5nTGVmdCwgcGFkZGluZ1JpZ2h0O1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGF0IG91ciB0aWNrcyBhcmUgYWx3YXlzIGluc2lkZSB0aGUgY2FudmFzLiBXaGVuIHJvdGF0ZWQsIHRpY2tzIGFyZSByaWdodCBhbGlnbmVkXG5cdFx0XHRcdC8vIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHJpZ2h0IHBhZGRpbmcgaXMgZG9taW5hdGVkIGJ5IHRoZSBmb250IGhlaWdodFxuXHRcdFx0XHRpZiAobWUubGFiZWxSb3RhdGlvbiAhPT0gMCkge1xuXHRcdFx0XHRcdHBhZGRpbmdMZWZ0ID0gcG9zaXRpb24gPT09ICdib3R0b20nID8gKGNvc1JvdGF0aW9uICogZmlyc3RMYWJlbFdpZHRoKSA6IChjb3NSb3RhdGlvbiAqIGxpbmVTcGFjZSk7XG5cdFx0XHRcdFx0cGFkZGluZ1JpZ2h0ID0gcG9zaXRpb24gPT09ICdib3R0b20nID8gKGNvc1JvdGF0aW9uICogbGluZVNwYWNlKSA6IChjb3NSb3RhdGlvbiAqIGxhc3RMYWJlbFdpZHRoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYWRkaW5nTGVmdCA9IGZpcnN0TGFiZWxXaWR0aCAvIDI7XG5cdFx0XHRcdFx0cGFkZGluZ1JpZ2h0ID0gbGFzdExhYmVsV2lkdGggLyAyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1lLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgocGFkZGluZ0xlZnQgLSBvZmZzZXRMZWZ0LCAwKSArIDM7IC8vIGFkZCAzIHB4IHRvIG1vdmUgYXdheSBmcm9tIGNhbnZhcyBlZGdlc1xuXHRcdFx0XHRtZS5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heChwYWRkaW5nUmlnaHQgLSBvZmZzZXRSaWdodCwgMCkgKyAzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQSB2ZXJ0aWNhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIHdpZHRoLiBMYWJlbHMgYXJlIHRoZVxuXHRcdFx0XHQvLyBkb21pbmFudCBmYWN0b3IgaGVyZSwgc28gZ2V0IHRoYXQgbGVuZ3RoIGZpcnN0IGFuZCBhY2NvdW50IGZvciBwYWRkaW5nXG5cdFx0XHRcdGlmICh0aWNrT3B0cy5taXJyb3IpIHtcblx0XHRcdFx0XHRsYXJnZXN0VGV4dFdpZHRoID0gMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1c2UgbGluZVNwYWNlIGZvciBjb25zaXN0ZW5jeSB3aXRoIGhvcml6b250YWwgYXhpc1xuXHRcdFx0XHRcdC8vIHRpY2tQYWRkaW5nIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgaG9yaXpvbnRhbFxuXHRcdFx0XHRcdGxhcmdlc3RUZXh0V2lkdGggKz0gdGlja1BhZGRpbmcgKyBsaW5lU3BhY2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtaW5TaXplLndpZHRoID0gTWF0aC5taW4obWUubWF4V2lkdGgsIG1pblNpemUud2lkdGggKyBsYXJnZXN0VGV4dFdpZHRoKTtcblxuXHRcdFx0XHRtZS5wYWRkaW5nVG9wID0gdGlja0ZvbnQuc2l6ZSAvIDI7XG5cdFx0XHRcdG1lLnBhZGRpbmdCb3R0b20gPSB0aWNrRm9udC5zaXplIC8gMjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS5oYW5kbGVNYXJnaW5zKCk7XG5cblx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGg7XG5cdFx0bWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBtYXJnaW5zIGFuZCBwYWRkaW5nIGludGVyYWN0aW9uc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aGFuZGxlTWFyZ2luczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAobWUubWFyZ2lucykge1xuXHRcdFx0bWUucGFkZGluZ0xlZnQgPSBNYXRoLm1heChtZS5wYWRkaW5nTGVmdCAtIG1lLm1hcmdpbnMubGVmdCwgMCk7XG5cdFx0XHRtZS5wYWRkaW5nVG9wID0gTWF0aC5tYXgobWUucGFkZGluZ1RvcCAtIG1lLm1hcmdpbnMudG9wLCAwKTtcblx0XHRcdG1lLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KG1lLnBhZGRpbmdSaWdodCAtIG1lLm1hcmdpbnMucmlnaHQsIDApO1xuXHRcdFx0bWUucGFkZGluZ0JvdHRvbSA9IE1hdGgubWF4KG1lLnBhZGRpbmdCb3R0b20gLSBtZS5tYXJnaW5zLmJvdHRvbSwgMCk7XG5cdFx0fVxuXHR9LFxuXG5cdGFmdGVyRml0OiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vIFNoYXJlZCBNZXRob2RzXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcblx0fSxcblx0aXNGdWxsV2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLmZ1bGxXaWR0aCk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBjb3JyZWN0IHZhbHVlLiBOYU4gYmFkIGlucHV0cywgSWYgdGhlIHZhbHVlIHR5cGUgaXMgb2JqZWN0IGdldCB0aGUgeCBvciB5IGJhc2VkIG9uIHdoZXRoZXIgd2UgYXJlIGhvcml6b250YWwgb3Igbm90XG5cdGdldFJpZ2h0VmFsdWU6IGZ1bmN0aW9uKHJhd1ZhbHVlKSB7XG5cdFx0Ly8gTnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBmaXJzdFxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihyYXdWYWx1ZSkpIHtcblx0XHRcdHJldHVybiBOYU47XG5cdFx0fVxuXHRcdC8vIGlzTmFOKG9iamVjdCkgcmV0dXJucyB0cnVlLCBzbyBtYWtlIHN1cmUgTmFOIGlzIGNoZWNraW5nIGZvciBhIG51bWJlcjsgRGlzY2FyZCBJbmZpbml0ZSB2YWx1ZXNcblx0XHRpZiAoKHR5cGVvZiByYXdWYWx1ZSA9PT0gJ251bWJlcicgfHwgcmF3VmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZShyYXdWYWx1ZSkpIHtcblx0XHRcdHJldHVybiBOYU47XG5cdFx0fVxuXHRcdC8vIElmIGl0IGlzIGluIGZhY3QgYW4gb2JqZWN0LCBkaXZlIGluIG9uZSBtb3JlIGxldmVsXG5cdFx0aWYgKHJhd1ZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRpZiAocmF3VmFsdWUueCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZS54KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChyYXdWYWx1ZS55ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZS55KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBWYWx1ZSBpcyBnb29kLCByZXR1cm4gaXRcblx0XHRyZXR1cm4gcmF3VmFsdWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSB2YWx1ZSB0byBkaXNwbGF5IGluIHRoZSB0b29sdGlwIGZvciB0aGUgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqIEBwYXJhbSBkYXRhc2V0SW5kZXhcblx0ICovXG5cdGdldExhYmVsRm9ySW5kZXg6IGhlbHBlcnMkMS5ub29wLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBwb2ludC4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHZhbHVlXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKiBAcGFyYW0gZGF0YXNldEluZGV4XG5cdCAqL1xuXHRnZXRQaXhlbEZvclZhbHVlOiBoZWxwZXJzJDEubm9vcCxcblxuXHQvKipcblx0ICogVXNlZCB0byBnZXQgdGhlIGRhdGEgdmFsdWUgZnJvbSBhIGdpdmVuIHBpeGVsLiBUaGlzIGlzIHRoZSBpbnZlcnNlIG9mIGdldFBpeGVsRm9yVmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSBwaXhlbFxuXHQgKi9cblx0Z2V0VmFsdWVGb3JQaXhlbDogaGVscGVycyQxLm5vb3AsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICovXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdHZhciBpbm5lcldpZHRoID0gbWUud2lkdGggLSAobWUucGFkZGluZ0xlZnQgKyBtZS5wYWRkaW5nUmlnaHQpO1xuXHRcdFx0dmFyIHRpY2tXaWR0aCA9IGlubmVyV2lkdGggLyBNYXRoLm1heCgobWUuX3RpY2tzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSkpLCAxKTtcblx0XHRcdHZhciBwaXhlbCA9ICh0aWNrV2lkdGggKiBpbmRleCkgKyBtZS5wYWRkaW5nTGVmdDtcblxuXHRcdFx0aWYgKG9mZnNldCkge1xuXHRcdFx0XHRwaXhlbCArPSB0aWNrV2lkdGggLyAyO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZmluYWxWYWwgPSBtZS5sZWZ0ICsgcGl4ZWw7XG5cdFx0XHRmaW5hbFZhbCArPSBtZS5pc0Z1bGxXaWR0aCgpID8gbWUubWFyZ2lucy5sZWZ0IDogMDtcblx0XHRcdHJldHVybiBmaW5hbFZhbDtcblx0XHR9XG5cdFx0dmFyIGlubmVySGVpZ2h0ID0gbWUuaGVpZ2h0IC0gKG1lLnBhZGRpbmdUb3AgKyBtZS5wYWRkaW5nQm90dG9tKTtcblx0XHRyZXR1cm4gbWUudG9wICsgKGluZGV4ICogKGlubmVySGVpZ2h0IC8gKG1lLl90aWNrcy5sZW5ndGggLSAxKSkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiBhIHBlcmNlbnRhZ2Ugb2Ygc2NhbGVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqL1xuXHRnZXRQaXhlbEZvckRlY2ltYWw6IGZ1bmN0aW9uKGRlY2ltYWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0dmFyIGlubmVyV2lkdGggPSBtZS53aWR0aCAtIChtZS5wYWRkaW5nTGVmdCArIG1lLnBhZGRpbmdSaWdodCk7XG5cdFx0XHR2YXIgdmFsdWVPZmZzZXQgPSAoaW5uZXJXaWR0aCAqIGRlY2ltYWwpICsgbWUucGFkZGluZ0xlZnQ7XG5cblx0XHRcdHZhciBmaW5hbFZhbCA9IG1lLmxlZnQgKyB2YWx1ZU9mZnNldDtcblx0XHRcdGZpbmFsVmFsICs9IG1lLmlzRnVsbFdpZHRoKCkgPyBtZS5tYXJnaW5zLmxlZnQgOiAwO1xuXHRcdFx0cmV0dXJuIGZpbmFsVmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gbWUudG9wICsgKGRlY2ltYWwgKiBtZS5oZWlnaHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwaXhlbCBmb3IgdGhlIG1pbmltdW0gY2hhcnQgdmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqL1xuXHRnZXRCYXNlUGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG5cdH0sXG5cblx0Z2V0QmFzZVZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtaW4gPSBtZS5taW47XG5cdFx0dmFyIG1heCA9IG1lLm1heDtcblxuXHRcdHJldHVybiBtZS5iZWdpbkF0WmVybyA/IDAgOlxuXHRcdFx0bWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcblx0XHRcdG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG5cdFx0XHQwO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3Vic2V0IG9mIHRpY2tzIHRvIGJlIHBsb3R0ZWQgdG8gYXZvaWQgb3ZlcmxhcHBpbmcgbGFiZWxzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2F1dG9Ta2lwOiBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBvcHRpb25UaWNrcyA9IG1lLm9wdGlvbnMudGlja3MubWlub3I7XG5cdFx0dmFyIHRpY2tDb3VudCA9IHRpY2tzLmxlbmd0aDtcblx0XHR2YXIgc2tpcFJhdGlvID0gZmFsc2U7XG5cdFx0dmFyIG1heFRpY2tzID0gb3B0aW9uVGlja3MubWF4VGlja3NMaW1pdDtcblxuXHRcdC8vIFRvdGFsIHNwYWNlIG5lZWRlZCB0byBkaXNwbGF5IGFsbCB0aWNrcy4gRmlyc3QgYW5kIGxhc3QgdGlja3MgYXJlXG5cdFx0Ly8gZHJhd24gYXMgdGhlaXIgY2VudGVyIGF0IGVuZCBvZiBheGlzLCBzbyB0aWNrQ291bnQtMVxuXHRcdHZhciB0aWNrc0xlbmd0aCA9IG1lLl90aWNrU2l6ZSgpICogKHRpY2tDb3VudCAtIDEpO1xuXG5cdFx0Ly8gQXhpcyBsZW5ndGhcblx0XHR2YXIgYXhpc0xlbmd0aCA9IGlzSG9yaXpvbnRhbFxuXHRcdFx0PyBtZS53aWR0aCAtIChtZS5wYWRkaW5nTGVmdCArIG1lLnBhZGRpbmdSaWdodClcblx0XHRcdDogbWUuaGVpZ2h0IC0gKG1lLnBhZGRpbmdUb3AgKyBtZS5QYWRkaW5nQm90dG9tKTtcblxuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR2YXIgaSwgdGljaztcblxuXHRcdGlmICh0aWNrc0xlbmd0aCA+IGF4aXNMZW5ndGgpIHtcblx0XHRcdHNraXBSYXRpbyA9IDEgKyBNYXRoLmZsb29yKHRpY2tzTGVuZ3RoIC8gYXhpc0xlbmd0aCk7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhleSBkZWZpbmVkIGEgbWF4IG51bWJlciBvZiBvcHRpb25UaWNrcyxcblx0XHQvLyBpbmNyZWFzZSBza2lwUmF0aW8gdW50aWwgdGhhdCBudW1iZXIgaXMgbWV0XG5cdFx0aWYgKHRpY2tDb3VudCA+IG1heFRpY2tzKSB7XG5cdFx0XHRza2lwUmF0aW8gPSBNYXRoLm1heChza2lwUmF0aW8sIDEgKyBNYXRoLmZsb29yKHRpY2tDb3VudCAvIG1heFRpY2tzKSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRpY2tDb3VudDsgaSsrKSB7XG5cdFx0XHR0aWNrID0gdGlja3NbaV07XG5cblx0XHRcdGlmIChza2lwUmF0aW8gPiAxICYmIGkgJSBza2lwUmF0aW8gPiAwKSB7XG5cdFx0XHRcdC8vIGxlYXZlIHRpY2sgaW4gcGxhY2UgYnV0IG1ha2Ugc3VyZSBpdCdzIG5vdCBkaXNwbGF5ZWQgKCM0NjM1KVxuXHRcdFx0XHRkZWxldGUgdGljay5sYWJlbDtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKHRpY2spO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3RpY2tTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgb3B0aW9uVGlja3MgPSBtZS5vcHRpb25zLnRpY2tzLm1pbm9yO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIHNwYWNlIG5lZWRlZCBieSBsYWJlbCBpbiBheGlzIGRpcmVjdGlvbi5cblx0XHR2YXIgcm90ID0gaGVscGVycyQxLnRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcblx0XHR2YXIgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG5cdFx0dmFyIHNpbiA9IE1hdGguYWJzKE1hdGguc2luKHJvdCkpO1xuXG5cdFx0dmFyIHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcblx0XHR2YXIgdyA9IChtZS5sb25nZXN0TGFiZWxXaWR0aCArIHBhZGRpbmcpIHx8IDA7XG5cblx0XHR2YXIgdGlja0ZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG9wdGlvblRpY2tzKTtcblx0XHR2YXIgaCA9IChtZS5fbWF4TGFiZWxMaW5lcyAqIHRpY2tGb250LmxpbmVIZWlnaHQgKyBwYWRkaW5nKSB8fCAwO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIHNwYWNlIG5lZWRlZCBmb3IgMSB0aWNrIGluIGF4aXMgZGlyZWN0aW9uLlxuXHRcdHJldHVybiBpc0hvcml6b250YWxcblx0XHRcdD8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuXHRcdFx0OiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2lzVmlzaWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGlzcGxheSA9IG1lLm9wdGlvbnMuZGlzcGxheTtcblx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcblxuXHRcdGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcblx0XHRcdHJldHVybiAhIWRpc3BsYXk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiAnYXV0bycsIHRoZSBzY2FsZSBpcyB2aXNpYmxlIGlmIGF0IGxlYXN0IG9uZSBhc3NvY2lhdGVkIGRhdGFzZXQgaXMgdmlzaWJsZS5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0aWYgKG1ldGEueEF4aXNJRCA9PT0gbWUuaWQgfHwgbWV0YS55QXhpc0lEID09PSBtZS5pZCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBY3R1YWxseSBkcmF3IHRoZSBzY2FsZSBvbiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBjaGFydEFyZWEgLSB0aGUgYXJlYSBvZiB0aGUgY2hhcnQgdG8gZHJhdyBmdWxsIGdyaWQgbGluZXMgb25cblx0ICovXG5cdGRyYXc6IGZ1bmN0aW9uKGNoYXJ0QXJlYSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXG5cdFx0aWYgKCFtZS5faXNWaXNpYmxlKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgY29udGV4dCA9IG1lLmN0eDtcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcblx0XHR2YXIgZGVmYXVsdEZvbnRDb2xvciA9IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250Q29sb3I7XG5cdFx0dmFyIG9wdGlvblRpY2tzID0gb3B0aW9ucy50aWNrcy5taW5vcjtcblx0XHR2YXIgb3B0aW9uTWFqb3JUaWNrcyA9IG9wdGlvbnMudGlja3MubWFqb3IgfHwgb3B0aW9uVGlja3M7XG5cdFx0dmFyIGdyaWRMaW5lcyA9IG9wdGlvbnMuZ3JpZExpbmVzO1xuXHRcdHZhciBzY2FsZUxhYmVsID0gb3B0aW9ucy5zY2FsZUxhYmVsO1xuXHRcdHZhciBwb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG5cblx0XHR2YXIgaXNSb3RhdGVkID0gbWUubGFiZWxSb3RhdGlvbiAhPT0gMDtcblx0XHR2YXIgaXNNaXJyb3JlZCA9IG9wdGlvblRpY2tzLm1pcnJvcjtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHR2YXIgcGFyc2VGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udDtcblx0XHR2YXIgdGlja3MgPSBvcHRpb25UaWNrcy5kaXNwbGF5ICYmIG9wdGlvblRpY2tzLmF1dG9Ta2lwID8gbWUuX2F1dG9Ta2lwKG1lLmdldFRpY2tzKCkpIDogbWUuZ2V0VGlja3MoKTtcblx0XHR2YXIgdGlja0ZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDkob3B0aW9uVGlja3MuZm9udENvbG9yLCBkZWZhdWx0Rm9udENvbG9yKTtcblx0XHR2YXIgdGlja0ZvbnQgPSBwYXJzZUZvbnQob3B0aW9uVGlja3MpO1xuXHRcdHZhciBsaW5lSGVpZ2h0ID0gdGlja0ZvbnQubGluZUhlaWdodDtcblx0XHR2YXIgbWFqb3JUaWNrRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkOShvcHRpb25NYWpvclRpY2tzLmZvbnRDb2xvciwgZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0dmFyIG1ham9yVGlja0ZvbnQgPSBwYXJzZUZvbnQob3B0aW9uTWFqb3JUaWNrcyk7XG5cdFx0dmFyIHRpY2tQYWRkaW5nID0gb3B0aW9uVGlja3MucGFkZGluZztcblx0XHR2YXIgbGFiZWxPZmZzZXQgPSBvcHRpb25UaWNrcy5sYWJlbE9mZnNldDtcblxuXHRcdHZhciB0bCA9IGdyaWRMaW5lcy5kcmF3VGlja3MgPyBncmlkTGluZXMudGlja01hcmtMZW5ndGggOiAwO1xuXG5cdFx0dmFyIHNjYWxlTGFiZWxGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ5KHNjYWxlTGFiZWwuZm9udENvbG9yLCBkZWZhdWx0Rm9udENvbG9yKTtcblx0XHR2YXIgc2NhbGVMYWJlbEZvbnQgPSBwYXJzZUZvbnQoc2NhbGVMYWJlbCk7XG5cdFx0dmFyIHNjYWxlTGFiZWxQYWRkaW5nID0gaGVscGVycyQxLm9wdGlvbnMudG9QYWRkaW5nKHNjYWxlTGFiZWwucGFkZGluZyk7XG5cdFx0dmFyIGxhYmVsUm90YXRpb25SYWRpYW5zID0gaGVscGVycyQxLnRvUmFkaWFucyhtZS5sYWJlbFJvdGF0aW9uKTtcblxuXHRcdHZhciBpdGVtc1RvRHJhdyA9IFtdO1xuXG5cdFx0dmFyIGF4aXNXaWR0aCA9IGdyaWRMaW5lcy5kcmF3Qm9yZGVyID8gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5saW5lV2lkdGgsIDAsIDApIDogMDtcblx0XHR2YXIgYWxpZ25QaXhlbCA9IGhlbHBlcnMkMS5fYWxpZ25QaXhlbDtcblx0XHR2YXIgYm9yZGVyVmFsdWUsIHRpY2tTdGFydCwgdGlja0VuZDtcblxuXHRcdGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25QaXhlbChjaGFydCwgbWUuYm90dG9tLCBheGlzV2lkdGgpO1xuXHRcdFx0dGlja1N0YXJ0ID0gbWUuYm90dG9tIC0gdGw7XG5cdFx0XHR0aWNrRW5kID0gYm9yZGVyVmFsdWUgLSBheGlzV2lkdGggLyAyO1xuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLnRvcCwgYXhpc1dpZHRoKTtcblx0XHRcdHRpY2tTdGFydCA9IGJvcmRlclZhbHVlICsgYXhpc1dpZHRoIC8gMjtcblx0XHRcdHRpY2tFbmQgPSBtZS50b3AgKyB0bDtcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25QaXhlbChjaGFydCwgbWUucmlnaHQsIGF4aXNXaWR0aCk7XG5cdFx0XHR0aWNrU3RhcnQgPSBtZS5yaWdodCAtIHRsO1xuXHRcdFx0dGlja0VuZCA9IGJvcmRlclZhbHVlIC0gYXhpc1dpZHRoIC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5sZWZ0LCBheGlzV2lkdGgpO1xuXHRcdFx0dGlja1N0YXJ0ID0gYm9yZGVyVmFsdWUgKyBheGlzV2lkdGggLyAyO1xuXHRcdFx0dGlja0VuZCA9IG1lLmxlZnQgKyB0bDtcblx0XHR9XG5cblx0XHR2YXIgZXBzaWxvbiA9IDAuMDAwMDAwMTsgLy8gMC4wMDAwMDAxIGlzIG1hcmdpbiBpbiBwaXhlbHMgZm9yIEFjY3VtdWxhdGVkIGVycm9yLlxuXG5cdFx0aGVscGVycyQxLmVhY2godGlja3MsIGZ1bmN0aW9uKHRpY2ssIGluZGV4KSB7XG5cdFx0XHQvLyBhdXRvc2tpcHBlciBza2lwcGVkIHRoaXMgdGljayAoIzQ2MzUpXG5cdFx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodGljay5sYWJlbCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGFiZWwgPSB0aWNrLmxhYmVsO1xuXHRcdFx0dmFyIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBib3JkZXJEYXNoLCBib3JkZXJEYXNoT2Zmc2V0O1xuXHRcdFx0aWYgKGluZGV4ID09PSBtZS56ZXJvTGluZUluZGV4ICYmIG9wdGlvbnMub2Zmc2V0ID09PSBncmlkTGluZXMub2Zmc2V0R3JpZExpbmVzKSB7XG5cdFx0XHRcdC8vIERyYXcgdGhlIGZpcnN0IGluZGV4IHNwZWNpYWxseVxuXHRcdFx0XHRsaW5lV2lkdGggPSBncmlkTGluZXMuemVyb0xpbmVXaWR0aDtcblx0XHRcdFx0bGluZUNvbG9yID0gZ3JpZExpbmVzLnplcm9MaW5lQ29sb3I7XG5cdFx0XHRcdGJvcmRlckRhc2ggPSBncmlkTGluZXMuemVyb0xpbmVCb3JkZXJEYXNoIHx8IFtdO1xuXHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0ID0gZ3JpZExpbmVzLnplcm9MaW5lQm9yZGVyRGFzaE9mZnNldCB8fCAwLjA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaW5lV2lkdGggPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgaW5kZXgpO1xuXHRcdFx0XHRsaW5lQ29sb3IgPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmNvbG9yLCBpbmRleCk7XG5cdFx0XHRcdGJvcmRlckRhc2ggPSBncmlkTGluZXMuYm9yZGVyRGFzaCB8fCBbXTtcblx0XHRcdFx0Ym9yZGVyRGFzaE9mZnNldCA9IGdyaWRMaW5lcy5ib3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tbW9uIHByb3BlcnRpZXNcblx0XHRcdHZhciB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyLCBsYWJlbFgsIGxhYmVsWSwgdGV4dE9mZnNldCwgdGV4dEFsaWduO1xuXHRcdFx0dmFyIGxhYmVsQ291bnQgPSBoZWxwZXJzJDEuaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuXHRcdFx0dmFyIGxpbmVWYWx1ZSA9IGdldFBpeGVsRm9yR3JpZExpbmUobWUsIGluZGV4LCBncmlkTGluZXMub2Zmc2V0R3JpZExpbmVzKTtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHR2YXIgbGFiZWxZT2Zmc2V0ID0gdGwgKyB0aWNrUGFkZGluZztcblxuXHRcdFx0XHRpZiAobGluZVZhbHVlIDwgbWUubGVmdCAtIGVwc2lsb24pIHtcblx0XHRcdFx0XHRsaW5lQ29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0eDEgPSB0eDIgPSB4MSA9IHgyID0gYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuXHRcdFx0XHR0eTEgPSB0aWNrU3RhcnQ7XG5cdFx0XHRcdHR5MiA9IHRpY2tFbmQ7XG5cdFx0XHRcdGxhYmVsWCA9IG1lLmdldFBpeGVsRm9yVGljayhpbmRleCkgKyBsYWJlbE9mZnNldDsgLy8geCB2YWx1ZXMgZm9yIG9wdGlvblRpY2tzIChuZWVkIHRvIGNvbnNpZGVyIG9mZnNldExhYmVsIG9wdGlvbilcblxuXHRcdFx0XHRpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG5cdFx0XHRcdFx0eTEgPSBhbGlnblBpeGVsKGNoYXJ0LCBjaGFydEFyZWEudG9wLCBheGlzV2lkdGgpICsgYXhpc1dpZHRoIC8gMjtcblx0XHRcdFx0XHR5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG5cdFx0XHRcdFx0dGV4dE9mZnNldCA9ICgoIWlzUm90YXRlZCA/IDAuNSA6IDEpIC0gbGFiZWxDb3VudCkgKiBsaW5lSGVpZ2h0O1xuXHRcdFx0XHRcdHRleHRBbGlnbiA9ICFpc1JvdGF0ZWQgPyAnY2VudGVyJyA6ICdsZWZ0Jztcblx0XHRcdFx0XHRsYWJlbFkgPSBtZS5ib3R0b20gLSBsYWJlbFlPZmZzZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eTEgPSBjaGFydEFyZWEudG9wO1xuXHRcdFx0XHRcdHkyID0gYWxpZ25QaXhlbChjaGFydCwgY2hhcnRBcmVhLmJvdHRvbSwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHRcdFx0dGV4dE9mZnNldCA9ICghaXNSb3RhdGVkID8gMC41IDogMCkgKiBsaW5lSGVpZ2h0O1xuXHRcdFx0XHRcdHRleHRBbGlnbiA9ICFpc1JvdGF0ZWQgPyAnY2VudGVyJyA6ICdyaWdodCc7XG5cdFx0XHRcdFx0bGFiZWxZID0gbWUudG9wICsgbGFiZWxZT2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbGFiZWxYT2Zmc2V0ID0gKGlzTWlycm9yZWQgPyAwIDogdGwpICsgdGlja1BhZGRpbmc7XG5cblx0XHRcdFx0aWYgKGxpbmVWYWx1ZSA8IG1lLnRvcCAtIGVwc2lsb24pIHtcblx0XHRcdFx0XHRsaW5lQ29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0eDEgPSB0aWNrU3RhcnQ7XG5cdFx0XHRcdHR4MiA9IHRpY2tFbmQ7XG5cdFx0XHRcdHR5MSA9IHR5MiA9IHkxID0geTIgPSBhbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG5cdFx0XHRcdGxhYmVsWSA9IG1lLmdldFBpeGVsRm9yVGljayhpbmRleCkgKyBsYWJlbE9mZnNldDtcblx0XHRcdFx0dGV4dE9mZnNldCA9ICgxIC0gbGFiZWxDb3VudCkgKiBsaW5lSGVpZ2h0IC8gMjtcblxuXHRcdFx0XHRpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuXHRcdFx0XHRcdHgxID0gYWxpZ25QaXhlbChjaGFydCwgY2hhcnRBcmVhLmxlZnQsIGF4aXNXaWR0aCkgKyBheGlzV2lkdGggLyAyO1xuXHRcdFx0XHRcdHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuXHRcdFx0XHRcdHRleHRBbGlnbiA9IGlzTWlycm9yZWQgPyAnbGVmdCcgOiAncmlnaHQnO1xuXHRcdFx0XHRcdGxhYmVsWCA9IG1lLnJpZ2h0IC0gbGFiZWxYT2Zmc2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHgxID0gY2hhcnRBcmVhLmxlZnQ7XG5cdFx0XHRcdFx0eDIgPSBhbGlnblBpeGVsKGNoYXJ0LCBjaGFydEFyZWEucmlnaHQsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuXHRcdFx0XHRcdHRleHRBbGlnbiA9IGlzTWlycm9yZWQgPyAncmlnaHQnIDogJ2xlZnQnO1xuXHRcdFx0XHRcdGxhYmVsWCA9IG1lLmxlZnQgKyBsYWJlbFhPZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aXRlbXNUb0RyYXcucHVzaCh7XG5cdFx0XHRcdHR4MTogdHgxLFxuXHRcdFx0XHR0eTE6IHR5MSxcblx0XHRcdFx0dHgyOiB0eDIsXG5cdFx0XHRcdHR5MjogdHkyLFxuXHRcdFx0XHR4MTogeDEsXG5cdFx0XHRcdHkxOiB5MSxcblx0XHRcdFx0eDI6IHgyLFxuXHRcdFx0XHR5MjogeTIsXG5cdFx0XHRcdGxhYmVsWDogbGFiZWxYLFxuXHRcdFx0XHRsYWJlbFk6IGxhYmVsWSxcblx0XHRcdFx0Z2xXaWR0aDogbGluZVdpZHRoLFxuXHRcdFx0XHRnbENvbG9yOiBsaW5lQ29sb3IsXG5cdFx0XHRcdGdsQm9yZGVyRGFzaDogYm9yZGVyRGFzaCxcblx0XHRcdFx0Z2xCb3JkZXJEYXNoT2Zmc2V0OiBib3JkZXJEYXNoT2Zmc2V0LFxuXHRcdFx0XHRyb3RhdGlvbjogLTEgKiBsYWJlbFJvdGF0aW9uUmFkaWFucyxcblx0XHRcdFx0bGFiZWw6IGxhYmVsLFxuXHRcdFx0XHRtYWpvcjogdGljay5tYWpvcixcblx0XHRcdFx0dGV4dE9mZnNldDogdGV4dE9mZnNldCxcblx0XHRcdFx0dGV4dEFsaWduOiB0ZXh0QWxpZ25cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRHJhdyBhbGwgb2YgdGhlIHRpY2sgbGFiZWxzLCB0aWNrIG1hcmtzLCBhbmQgZ3JpZCBsaW5lcyBhdCB0aGUgY29ycmVjdCBwbGFjZXNcblx0XHRoZWxwZXJzJDEuZWFjaChpdGVtc1RvRHJhdywgZnVuY3Rpb24oaXRlbVRvRHJhdykge1xuXHRcdFx0dmFyIGdsV2lkdGggPSBpdGVtVG9EcmF3LmdsV2lkdGg7XG5cdFx0XHR2YXIgZ2xDb2xvciA9IGl0ZW1Ub0RyYXcuZ2xDb2xvcjtcblxuXHRcdFx0aWYgKGdyaWRMaW5lcy5kaXNwbGF5ICYmIGdsV2lkdGggJiYgZ2xDb2xvcikge1xuXHRcdFx0XHRjb250ZXh0LnNhdmUoKTtcblx0XHRcdFx0Y29udGV4dC5saW5lV2lkdGggPSBnbFdpZHRoO1xuXHRcdFx0XHRjb250ZXh0LnN0cm9rZVN0eWxlID0gZ2xDb2xvcjtcblx0XHRcdFx0aWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcblx0XHRcdFx0XHRjb250ZXh0LnNldExpbmVEYXNoKGl0ZW1Ub0RyYXcuZ2xCb3JkZXJEYXNoKTtcblx0XHRcdFx0XHRjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gaXRlbVRvRHJhdy5nbEJvcmRlckRhc2hPZmZzZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG5cdFx0XHRcdGlmIChncmlkTGluZXMuZHJhd1RpY2tzKSB7XG5cdFx0XHRcdFx0Y29udGV4dC5tb3ZlVG8oaXRlbVRvRHJhdy50eDEsIGl0ZW1Ub0RyYXcudHkxKTtcblx0XHRcdFx0XHRjb250ZXh0LmxpbmVUbyhpdGVtVG9EcmF3LnR4MiwgaXRlbVRvRHJhdy50eTIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGdyaWRMaW5lcy5kcmF3T25DaGFydEFyZWEpIHtcblx0XHRcdFx0XHRjb250ZXh0Lm1vdmVUbyhpdGVtVG9EcmF3LngxLCBpdGVtVG9EcmF3LnkxKTtcblx0XHRcdFx0XHRjb250ZXh0LmxpbmVUbyhpdGVtVG9EcmF3LngyLCBpdGVtVG9EcmF3LnkyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRleHQuc3Ryb2tlKCk7XG5cdFx0XHRcdGNvbnRleHQucmVzdG9yZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9uVGlja3MuZGlzcGxheSkge1xuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgZHJhdyB0ZXh0IGluIHRoZSBjb3JyZWN0IGNvbG9yIGFuZCBmb250XG5cdFx0XHRcdGNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0XHRjb250ZXh0LnRyYW5zbGF0ZShpdGVtVG9EcmF3LmxhYmVsWCwgaXRlbVRvRHJhdy5sYWJlbFkpO1xuXHRcdFx0XHRjb250ZXh0LnJvdGF0ZShpdGVtVG9EcmF3LnJvdGF0aW9uKTtcblx0XHRcdFx0Y29udGV4dC5mb250ID0gaXRlbVRvRHJhdy5tYWpvciA/IG1ham9yVGlja0ZvbnQuc3RyaW5nIDogdGlja0ZvbnQuc3RyaW5nO1xuXHRcdFx0XHRjb250ZXh0LmZpbGxTdHlsZSA9IGl0ZW1Ub0RyYXcubWFqb3IgPyBtYWpvclRpY2tGb250Q29sb3IgOiB0aWNrRm9udENvbG9yO1xuXHRcdFx0XHRjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdFx0XHRjb250ZXh0LnRleHRBbGlnbiA9IGl0ZW1Ub0RyYXcudGV4dEFsaWduO1xuXG5cdFx0XHRcdHZhciBsYWJlbCA9IGl0ZW1Ub0RyYXcubGFiZWw7XG5cdFx0XHRcdHZhciB5ID0gaXRlbVRvRHJhdy50ZXh0T2Zmc2V0O1xuXHRcdFx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkobGFiZWwpKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdFx0Ly8gV2UganVzdCBtYWtlIHN1cmUgdGhlIG11bHRpbGluZSBlbGVtZW50IGlzIGEgc3RyaW5nIGhlcmUuLlxuXHRcdFx0XHRcdFx0Y29udGV4dC5maWxsVGV4dCgnJyArIGxhYmVsW2ldLCAwLCB5KTtcblx0XHRcdFx0XHRcdHkgKz0gbGluZUhlaWdodDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGV4dC5maWxsVGV4dChsYWJlbCwgMCwgeSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoc2NhbGVMYWJlbC5kaXNwbGF5KSB7XG5cdFx0XHQvLyBEcmF3IHRoZSBzY2FsZSBsYWJlbFxuXHRcdFx0dmFyIHNjYWxlTGFiZWxYO1xuXHRcdFx0dmFyIHNjYWxlTGFiZWxZO1xuXHRcdFx0dmFyIHJvdGF0aW9uID0gMDtcblx0XHRcdHZhciBoYWxmTGluZUhlaWdodCA9IHNjYWxlTGFiZWxGb250LmxpbmVIZWlnaHQgLyAyO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdHNjYWxlTGFiZWxYID0gbWUubGVmdCArICgobWUucmlnaHQgLSBtZS5sZWZ0KSAvIDIpOyAvLyBtaWRwb2ludCBvZiB0aGUgd2lkdGhcblx0XHRcdFx0c2NhbGVMYWJlbFkgPSBwb3NpdGlvbiA9PT0gJ2JvdHRvbSdcblx0XHRcdFx0XHQ/IG1lLmJvdHRvbSAtIGhhbGZMaW5lSGVpZ2h0IC0gc2NhbGVMYWJlbFBhZGRpbmcuYm90dG9tXG5cdFx0XHRcdFx0OiBtZS50b3AgKyBoYWxmTGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLnRvcDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBpc0xlZnQgPSBwb3NpdGlvbiA9PT0gJ2xlZnQnO1xuXHRcdFx0XHRzY2FsZUxhYmVsWCA9IGlzTGVmdFxuXHRcdFx0XHRcdD8gbWUubGVmdCArIGhhbGZMaW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcudG9wXG5cdFx0XHRcdFx0OiBtZS5yaWdodCAtIGhhbGZMaW5lSGVpZ2h0IC0gc2NhbGVMYWJlbFBhZGRpbmcudG9wO1xuXHRcdFx0XHRzY2FsZUxhYmVsWSA9IG1lLnRvcCArICgobWUuYm90dG9tIC0gbWUudG9wKSAvIDIpO1xuXHRcdFx0XHRyb3RhdGlvbiA9IGlzTGVmdCA/IC0wLjUgKiBNYXRoLlBJIDogMC41ICogTWF0aC5QSTtcblx0XHRcdH1cblxuXHRcdFx0Y29udGV4dC5zYXZlKCk7XG5cdFx0XHRjb250ZXh0LnRyYW5zbGF0ZShzY2FsZUxhYmVsWCwgc2NhbGVMYWJlbFkpO1xuXHRcdFx0Y29udGV4dC5yb3RhdGUocm90YXRpb24pO1xuXHRcdFx0Y29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cdFx0XHRjb250ZXh0LmZpbGxTdHlsZSA9IHNjYWxlTGFiZWxGb250Q29sb3I7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXHRcdFx0Y29udGV4dC5mb250ID0gc2NhbGVMYWJlbEZvbnQuc3RyaW5nO1xuXHRcdFx0Y29udGV4dC5maWxsVGV4dChzY2FsZUxhYmVsLmxhYmVsU3RyaW5nLCAwLCAwKTtcblx0XHRcdGNvbnRleHQucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdGlmIChheGlzV2lkdGgpIHtcblx0XHRcdC8vIERyYXcgdGhlIGxpbmUgYXQgdGhlIGVkZ2Ugb2YgdGhlIGF4aXNcblx0XHRcdHZhciBmaXJzdExpbmVXaWR0aCA9IGF4aXNXaWR0aDtcblx0XHRcdHZhciBsYXN0TGluZVdpZHRoID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5saW5lV2lkdGgsIHRpY2tzLmxlbmd0aCAtIDEsIDApO1xuXHRcdFx0dmFyIHgxLCB4MiwgeTEsIHkyO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdHgxID0gYWxpZ25QaXhlbChjaGFydCwgbWUubGVmdCwgZmlyc3RMaW5lV2lkdGgpIC0gZmlyc3RMaW5lV2lkdGggLyAyO1xuXHRcdFx0XHR4MiA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLnJpZ2h0LCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuXHRcdFx0XHR5MSA9IHkyID0gYm9yZGVyVmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR5MSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLnRvcCwgZmlyc3RMaW5lV2lkdGgpIC0gZmlyc3RMaW5lV2lkdGggLyAyO1xuXHRcdFx0XHR5MiA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcblx0XHRcdFx0eDEgPSB4MiA9IGJvcmRlclZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250ZXh0LmxpbmVXaWR0aCA9IGF4aXNXaWR0aDtcblx0XHRcdGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmNvbG9yLCAwKTtcblx0XHRcdGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHRjb250ZXh0Lm1vdmVUbyh4MSwgeTEpO1xuXHRcdFx0Y29udGV4dC5saW5lVG8oeDIsIHkyKTtcblx0XHRcdGNvbnRleHQuc3Ryb2tlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGRlZmF1bHRDb25maWcgPSB7XG5cdHBvc2l0aW9uOiAnYm90dG9tJ1xufTtcblxudmFyIHNjYWxlX2NhdGVnb3J5ID0gY29yZV9zY2FsZS5leHRlbmQoe1xuXHQvKipcblx0KiBJbnRlcm5hbCBmdW5jdGlvbiB0byBnZXQgdGhlIGNvcnJlY3QgbGFiZWxzLiBJZiBkYXRhLnhMYWJlbHMgb3IgZGF0YS55TGFiZWxzIGFyZSBkZWZpbmVkLCB1c2UgdGhvc2Vcblx0KiBlbHNlIGZhbGwgYmFjayB0byBkYXRhLmxhYmVsc1xuXHQqIEBwcml2YXRlXG5cdCovXG5cdGdldExhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzO1xuXHR9LFxuXG5cdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGxhYmVscyA9IG1lLmdldExhYmVscygpO1xuXHRcdG1lLm1pbkluZGV4ID0gMDtcblx0XHRtZS5tYXhJbmRleCA9IGxhYmVscy5sZW5ndGggLSAxO1xuXHRcdHZhciBmaW5kSW5kZXg7XG5cblx0XHRpZiAobWUub3B0aW9ucy50aWNrcy5taW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gdXNlciBzcGVjaWZpZWQgbWluIHZhbHVlXG5cdFx0XHRmaW5kSW5kZXggPSBsYWJlbHMuaW5kZXhPZihtZS5vcHRpb25zLnRpY2tzLm1pbik7XG5cdFx0XHRtZS5taW5JbmRleCA9IGZpbmRJbmRleCAhPT0gLTEgPyBmaW5kSW5kZXggOiBtZS5taW5JbmRleDtcblx0XHR9XG5cblx0XHRpZiAobWUub3B0aW9ucy50aWNrcy5tYXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gdXNlciBzcGVjaWZpZWQgbWF4IHZhbHVlXG5cdFx0XHRmaW5kSW5kZXggPSBsYWJlbHMuaW5kZXhPZihtZS5vcHRpb25zLnRpY2tzLm1heCk7XG5cdFx0XHRtZS5tYXhJbmRleCA9IGZpbmRJbmRleCAhPT0gLTEgPyBmaW5kSW5kZXggOiBtZS5tYXhJbmRleDtcblx0XHR9XG5cblx0XHRtZS5taW4gPSBsYWJlbHNbbWUubWluSW5kZXhdO1xuXHRcdG1lLm1heCA9IGxhYmVsc1ttZS5tYXhJbmRleF07XG5cdH0sXG5cblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG5cdFx0Ly8gSWYgd2UgYXJlIHZpZXdpbmcgc29tZSBzdWJzZXQgb2YgbGFiZWxzLCBzbGljZSB0aGUgb3JpZ2luYWwgYXJyYXlcblx0XHRtZS50aWNrcyA9IChtZS5taW5JbmRleCA9PT0gMCAmJiBtZS5tYXhJbmRleCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpID8gbGFiZWxzIDogbGFiZWxzLnNsaWNlKG1lLm1pbkluZGV4LCBtZS5tYXhJbmRleCArIDEpO1xuXHR9LFxuXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXG5cdFx0aWYgKGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5fZ2V0VmFsdWVTY2FsZUlkKCkgPT09IG1lLmlkKSB7XG5cdFx0XHRyZXR1cm4gbWUuZ2V0UmlnaHRWYWx1ZShjaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZS50aWNrc1tpbmRleCAtIG1lLm1pbkluZGV4XTtcblx0fSxcblxuXHQvLyBVc2VkIHRvIGdldCBkYXRhIHZhbHVlIGxvY2F0aW9ucy4gIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcblx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb2Zmc2V0ID0gbWUub3B0aW9ucy5vZmZzZXQ7XG5cdFx0Ly8gMSBpcyBhZGRlZCBiZWNhdXNlIHdlIG5lZWQgdGhlIGxlbmd0aCBidXQgd2UgaGF2ZSB0aGUgaW5kZXhlc1xuXHRcdHZhciBvZmZzZXRBbXQgPSBNYXRoLm1heCgobWUubWF4SW5kZXggKyAxIC0gbWUubWluSW5kZXggLSAob2Zmc2V0ID8gMCA6IDEpKSwgMSk7XG5cblx0XHQvLyBJZiB2YWx1ZSBpcyBhIGRhdGEgb2JqZWN0LCB0aGVuIGluZGV4IGlzIHRoZSBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSxcblx0XHQvLyBub3QgdGhlIGluZGV4IG9mIHRoZSBzY2FsZS4gV2UgbmVlZCB0byBjaGFuZ2UgdGhhdC5cblx0XHR2YXIgdmFsdWVDYXRlZ29yeTtcblx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdFx0dmFsdWVDYXRlZ29yeSA9IG1lLmlzSG9yaXpvbnRhbCgpID8gdmFsdWUueCA6IHZhbHVlLnk7XG5cdFx0fVxuXHRcdGlmICh2YWx1ZUNhdGVnb3J5ICE9PSB1bmRlZmluZWQgfHwgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgaXNOYU4oaW5kZXgpKSkge1xuXHRcdFx0dmFyIGxhYmVscyA9IG1lLmdldExhYmVscygpO1xuXHRcdFx0dmFsdWUgPSB2YWx1ZUNhdGVnb3J5IHx8IHZhbHVlO1xuXHRcdFx0dmFyIGlkeCA9IGxhYmVscy5pbmRleE9mKHZhbHVlKTtcblx0XHRcdGluZGV4ID0gaWR4ICE9PSAtMSA/IGlkeCA6IGluZGV4O1xuXHRcdH1cblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0dmFyIHZhbHVlV2lkdGggPSBtZS53aWR0aCAvIG9mZnNldEFtdDtcblx0XHRcdHZhciB3aWR0aE9mZnNldCA9ICh2YWx1ZVdpZHRoICogKGluZGV4IC0gbWUubWluSW5kZXgpKTtcblxuXHRcdFx0aWYgKG9mZnNldCkge1xuXHRcdFx0XHR3aWR0aE9mZnNldCArPSAodmFsdWVXaWR0aCAvIDIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWUubGVmdCArIHdpZHRoT2Zmc2V0O1xuXHRcdH1cblx0XHR2YXIgdmFsdWVIZWlnaHQgPSBtZS5oZWlnaHQgLyBvZmZzZXRBbXQ7XG5cdFx0dmFyIGhlaWdodE9mZnNldCA9ICh2YWx1ZUhlaWdodCAqIChpbmRleCAtIG1lLm1pbkluZGV4KSk7XG5cblx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRoZWlnaHRPZmZzZXQgKz0gKHZhbHVlSGVpZ2h0IC8gMik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lLnRvcCArIGhlaWdodE9mZnNldDtcblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLnRpY2tzW2luZGV4XSwgaW5kZXggKyB0aGlzLm1pbkluZGV4LCBudWxsKTtcblx0fSxcblxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9mZnNldCA9IG1lLm9wdGlvbnMub2Zmc2V0O1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb2Zmc2V0QW10ID0gTWF0aC5tYXgoKG1lLl90aWNrcy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpKSwgMSk7XG5cdFx0dmFyIGhvcnogPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgdmFsdWVEaW1lbnNpb24gPSAoaG9yeiA/IG1lLndpZHRoIDogbWUuaGVpZ2h0KSAvIG9mZnNldEFtdDtcblxuXHRcdHBpeGVsIC09IGhvcnogPyBtZS5sZWZ0IDogbWUudG9wO1xuXG5cdFx0aWYgKG9mZnNldCkge1xuXHRcdFx0cGl4ZWwgLT0gKHZhbHVlRGltZW5zaW9uIC8gMik7XG5cdFx0fVxuXG5cdFx0aWYgKHBpeGVsIDw9IDApIHtcblx0XHRcdHZhbHVlID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSBNYXRoLnJvdW5kKHBpeGVsIC8gdmFsdWVEaW1lbnNpb24pO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZSArIG1lLm1pbkluZGV4O1xuXHR9LFxuXG5cdGdldEJhc2VQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm90dG9tO1xuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzID0gZGVmYXVsdENvbmZpZztcbnNjYWxlX2NhdGVnb3J5Ll9kZWZhdWx0cyA9IF9kZWZhdWx0cztcblxudmFyIG5vb3AgPSBoZWxwZXJzJDEubm9vcDtcbnZhciBpc051bGxPclVuZGVmID0gaGVscGVycyQxLmlzTnVsbE9yVW5kZWY7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbGluZWFyIHRpY2tzXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IGFycmF5IG9mIHRpY2sgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuXHR2YXIgdGlja3MgPSBbXTtcblx0Ly8gVG8gZ2V0IGEgXCJuaWNlXCIgdmFsdWUgZm9yIHRoZSB0aWNrIHNwYWNpbmcsIHdlIHdpbGwgdXNlIHRoZSBhcHByb3ByaWF0ZWx5IG5hbWVkXG5cdC8vIFwibmljZSBudW1iZXJcIiBhbGdvcml0aG0uIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NTA2ODgxL25pY2UtbGFiZWwtYWxnb3JpdGhtLWZvci1jaGFydHMtd2l0aC1taW5pbXVtLXRpY2tzXG5cdC8vIGZvciBkZXRhaWxzLlxuXG5cdHZhciBNSU5fU1BBQ0lORyA9IDFlLTE0O1xuXHR2YXIgc3RlcFNpemUgPSBnZW5lcmF0aW9uT3B0aW9ucy5zdGVwU2l6ZTtcblx0dmFyIHVuaXQgPSBzdGVwU2l6ZSB8fCAxO1xuXHR2YXIgbWF4TnVtU3BhY2VzID0gZ2VuZXJhdGlvbk9wdGlvbnMubWF4VGlja3MgLSAxO1xuXHR2YXIgbWluID0gZ2VuZXJhdGlvbk9wdGlvbnMubWluO1xuXHR2YXIgbWF4ID0gZ2VuZXJhdGlvbk9wdGlvbnMubWF4O1xuXHR2YXIgcHJlY2lzaW9uID0gZ2VuZXJhdGlvbk9wdGlvbnMucHJlY2lzaW9uO1xuXHR2YXIgcm1pbiA9IGRhdGFSYW5nZS5taW47XG5cdHZhciBybWF4ID0gZGF0YVJhbmdlLm1heDtcblx0dmFyIHNwYWNpbmcgPSBoZWxwZXJzJDEubmljZU51bSgocm1heCAtIHJtaW4pIC8gbWF4TnVtU3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuXHR2YXIgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XG5cblx0Ly8gQmV5b25kIE1JTl9TUEFDSU5HIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgYmVpbmcgdG8gbG9zZSBwcmVjaXNpb25cblx0Ly8gc3VjaCB0aGF0IHdlIGNhbid0IGRvIHRoZSBtYXRoIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aWNrc1xuXHRpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmIGlzTnVsbE9yVW5kZWYobWluKSAmJiBpc051bGxPclVuZGVmKG1heCkpIHtcblx0XHRyZXR1cm4gW3JtaW4sIHJtYXhdO1xuXHR9XG5cblx0bnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xuXHRpZiAobnVtU3BhY2VzID4gbWF4TnVtU3BhY2VzKSB7XG5cdFx0Ly8gSWYgdGhlIGNhbGN1bGF0ZWQgbnVtIG9mIHNwYWNlcyBleGNlZWRzIG1heE51bVNwYWNlcywgcmVjYWxjdWxhdGUgaXRcblx0XHRzcGFjaW5nID0gaGVscGVycyQxLm5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heE51bVNwYWNlcyAvIHVuaXQpICogdW5pdDtcblx0fVxuXG5cdGlmIChzdGVwU2l6ZSB8fCBpc051bGxPclVuZGVmKHByZWNpc2lvbikpIHtcblx0XHQvLyBJZiBhIHByZWNpc2lvbiBpcyBub3Qgc3BlY2lmaWVkLCBjYWxjdWxhdGUgZmFjdG9yIGJhc2VkIG9uIHNwYWNpbmdcblx0XHRmYWN0b3IgPSBNYXRoLnBvdygxMCwgaGVscGVycyQxLl9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpKTtcblx0fSBlbHNlIHtcblx0XHQvLyBJZiB0aGUgdXNlciBzcGVjaWZpZWQgYSBwcmVjaXNpb24sIHJvdW5kIHRvIHRoYXQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG5cdFx0ZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG5cdFx0c3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nICogZmFjdG9yKSAvIGZhY3Rvcjtcblx0fVxuXG5cdG5pY2VNaW4gPSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG5cdG5pY2VNYXggPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcblxuXHQvLyBJZiBtaW4sIG1heCBhbmQgc3RlcFNpemUgaXMgc2V0IGFuZCB0aGV5IG1ha2UgYW4gZXZlbmx5IHNwYWNlZCBzY2FsZSB1c2UgaXQuXG5cdGlmIChzdGVwU2l6ZSkge1xuXHRcdC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHdob2xlIG51bWJlciwgdXNlIGl0LlxuXHRcdGlmICghaXNOdWxsT3JVbmRlZihtaW4pICYmIGhlbHBlcnMkMS5hbG1vc3RXaG9sZShtaW4gLyBzcGFjaW5nLCBzcGFjaW5nIC8gMTAwMCkpIHtcblx0XHRcdG5pY2VNaW4gPSBtaW47XG5cdFx0fVxuXHRcdGlmICghaXNOdWxsT3JVbmRlZihtYXgpICYmIGhlbHBlcnMkMS5hbG1vc3RXaG9sZShtYXggLyBzcGFjaW5nLCBzcGFjaW5nIC8gMTAwMCkpIHtcblx0XHRcdG5pY2VNYXggPSBtYXg7XG5cdFx0fVxuXHR9XG5cblx0bnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG5cdC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHJvdW5kZWQgdmFsdWUsIHVzZSBpdC5cblx0aWYgKGhlbHBlcnMkMS5hbG1vc3RFcXVhbHMobnVtU3BhY2VzLCBNYXRoLnJvdW5kKG51bVNwYWNlcyksIHNwYWNpbmcgLyAxMDAwKSkge1xuXHRcdG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcblx0fSBlbHNlIHtcblx0XHRudW1TcGFjZXMgPSBNYXRoLmNlaWwobnVtU3BhY2VzKTtcblx0fVxuXG5cdG5pY2VNaW4gPSBNYXRoLnJvdW5kKG5pY2VNaW4gKiBmYWN0b3IpIC8gZmFjdG9yO1xuXHRuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3Rvcjtcblx0dGlja3MucHVzaChpc051bGxPclVuZGVmKG1pbikgPyBuaWNlTWluIDogbWluKTtcblx0Zm9yICh2YXIgaiA9IDE7IGogPCBudW1TcGFjZXM7ICsraikge1xuXHRcdHRpY2tzLnB1c2goTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IpO1xuXHR9XG5cdHRpY2tzLnB1c2goaXNOdWxsT3JVbmRlZihtYXgpID8gbmljZU1heCA6IG1heCk7XG5cblx0cmV0dXJuIHRpY2tzO1xufVxuXG52YXIgc2NhbGVfbGluZWFyYmFzZSA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuICt2YWx1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvcmVfc2NhbGUucHJvdG90eXBlLmdldFJpZ2h0VmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdH0sXG5cblx0aGFuZGxlVGlja1JhbmdlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRcdC8vIElmIHdlIGFyZSBmb3JjaW5nIGl0IHRvIGJlZ2luIGF0IDAsIGJ1dCAwIHdpbGwgYWxyZWFkeSBiZSByZW5kZXJlZCBvbiB0aGUgY2hhcnQsXG5cdFx0Ly8gZG8gbm90aGluZyBzaW5jZSB0aGF0IHdvdWxkIG1ha2UgdGhlIGNoYXJ0IHdlaXJkLiBJZiB0aGUgdXNlciByZWFsbHkgd2FudHMgYSB3ZWlyZCBjaGFydFxuXHRcdC8vIGF4aXMsIHRoZXkgY2FuIG1hbnVhbGx5IG92ZXJyaWRlIGl0XG5cdFx0aWYgKHRpY2tPcHRzLmJlZ2luQXRaZXJvKSB7XG5cdFx0XHR2YXIgbWluU2lnbiA9IGhlbHBlcnMkMS5zaWduKG1lLm1pbik7XG5cdFx0XHR2YXIgbWF4U2lnbiA9IGhlbHBlcnMkMS5zaWduKG1lLm1heCk7XG5cblx0XHRcdGlmIChtaW5TaWduIDwgMCAmJiBtYXhTaWduIDwgMCkge1xuXHRcdFx0XHQvLyBtb3ZlIHRoZSB0b3AgdXAgdG8gMFxuXHRcdFx0XHRtZS5tYXggPSAwO1xuXHRcdFx0fSBlbHNlIGlmIChtaW5TaWduID4gMCAmJiBtYXhTaWduID4gMCkge1xuXHRcdFx0XHQvLyBtb3ZlIHRoZSBib3R0b20gZG93biB0byAwXG5cdFx0XHRcdG1lLm1pbiA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHNldE1pbiA9IHRpY2tPcHRzLm1pbiAhPT0gdW5kZWZpbmVkIHx8IHRpY2tPcHRzLnN1Z2dlc3RlZE1pbiAhPT0gdW5kZWZpbmVkO1xuXHRcdHZhciBzZXRNYXggPSB0aWNrT3B0cy5tYXggIT09IHVuZGVmaW5lZCB8fCB0aWNrT3B0cy5zdWdnZXN0ZWRNYXggIT09IHVuZGVmaW5lZDtcblxuXHRcdGlmICh0aWNrT3B0cy5taW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bWUubWluID0gdGlja09wdHMubWluO1xuXHRcdH0gZWxzZSBpZiAodGlja09wdHMuc3VnZ2VzdGVkTWluICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChtZS5taW4gPT09IG51bGwpIHtcblx0XHRcdFx0bWUubWluID0gdGlja09wdHMuc3VnZ2VzdGVkTWluO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUubWluID0gTWF0aC5taW4obWUubWluLCB0aWNrT3B0cy5zdWdnZXN0ZWRNaW4pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aWNrT3B0cy5tYXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bWUubWF4ID0gdGlja09wdHMubWF4O1xuXHRcdH0gZWxzZSBpZiAodGlja09wdHMuc3VnZ2VzdGVkTWF4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcblx0XHRcdFx0bWUubWF4ID0gdGlja09wdHMuc3VnZ2VzdGVkTWF4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUubWF4ID0gTWF0aC5tYXgobWUubWF4LCB0aWNrT3B0cy5zdWdnZXN0ZWRNYXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChzZXRNaW4gIT09IHNldE1heCkge1xuXHRcdFx0Ly8gV2Ugc2V0IHRoZSBtaW4gb3IgdGhlIG1heCBidXQgbm90IGJvdGguXG5cdFx0XHQvLyBTbyBlbnN1cmUgdGhhdCBvdXIgcmFuZ2UgaXMgZ29vZFxuXHRcdFx0Ly8gSW52ZXJ0ZWQgb3IgMCBsZW5ndGggcmFuZ2UgY2FuIGhhcHBlbiB3aGVuXG5cdFx0XHQvLyB0aWNrcy5taW4gaXMgc2V0LCBhbmQgbm8gZGF0YXNldHMgYXJlIHZpc2libGVcblx0XHRcdGlmIChtZS5taW4gPj0gbWUubWF4KSB7XG5cdFx0XHRcdGlmIChzZXRNaW4pIHtcblx0XHRcdFx0XHRtZS5tYXggPSBtZS5taW4gKyAxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1lLm1pbiA9IG1lLm1heCAtIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobWUubWluID09PSBtZS5tYXgpIHtcblx0XHRcdG1lLm1heCsrO1xuXG5cdFx0XHRpZiAoIXRpY2tPcHRzLmJlZ2luQXRaZXJvKSB7XG5cdFx0XHRcdG1lLm1pbi0tO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRnZXRUaWNrTGltaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgc3RlcFNpemUgPSB0aWNrT3B0cy5zdGVwU2l6ZTtcblx0XHR2YXIgbWF4VGlja3NMaW1pdCA9IHRpY2tPcHRzLm1heFRpY2tzTGltaXQ7XG5cdFx0dmFyIG1heFRpY2tzO1xuXG5cdFx0aWYgKHN0ZXBTaXplKSB7XG5cdFx0XHRtYXhUaWNrcyA9IE1hdGguY2VpbChtZS5tYXggLyBzdGVwU2l6ZSkgLSBNYXRoLmZsb29yKG1lLm1pbiAvIHN0ZXBTaXplKSArIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1heFRpY2tzID0gbWUuX2NvbXB1dGVUaWNrTGltaXQoKTtcblx0XHRcdG1heFRpY2tzTGltaXQgPSBtYXhUaWNrc0xpbWl0IHx8IDExO1xuXHRcdH1cblxuXHRcdGlmIChtYXhUaWNrc0xpbWl0KSB7XG5cdFx0XHRtYXhUaWNrcyA9IE1hdGgubWluKG1heFRpY2tzTGltaXQsIG1heFRpY2tzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWF4VGlja3M7XG5cdH0sXG5cblx0X2NvbXB1dGVUaWNrTGltaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdH0sXG5cblx0aGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzOiBub29wLFxuXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0XHQvLyBGaWd1cmUgb3V0IHdoYXQgdGhlIG1heCBudW1iZXIgb2YgdGlja3Mgd2UgY2FuIHN1cHBvcnQgaXQgaXMgYmFzZWQgb24gdGhlIHNpemUgb2Zcblx0XHQvLyB0aGUgYXhpcyBhcmVhLiBGb3Igbm93LCB3ZSBzYXkgdGhhdCB0aGUgbWluaW11bSB0aWNrIHNwYWNpbmcgaW4gcGl4ZWxzIG11c3QgYmUgNDBcblx0XHQvLyBXZSBhbHNvIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byAxMSB3aGljaCBnaXZlcyBhIG5pY2UgMTAgc3F1YXJlcyBvblxuXHRcdC8vIHRoZSBncmFwaC4gTWFrZSBzdXJlIHdlIGFsd2F5cyBoYXZlIGF0IGxlYXN0IDIgdGlja3Ncblx0XHR2YXIgbWF4VGlja3MgPSBtZS5nZXRUaWNrTGltaXQoKTtcblx0XHRtYXhUaWNrcyA9IE1hdGgubWF4KDIsIG1heFRpY2tzKTtcblxuXHRcdHZhciBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcblx0XHRcdG1heFRpY2tzOiBtYXhUaWNrcyxcblx0XHRcdG1pbjogdGlja09wdHMubWluLFxuXHRcdFx0bWF4OiB0aWNrT3B0cy5tYXgsXG5cdFx0XHRwcmVjaXNpb246IHRpY2tPcHRzLnByZWNpc2lvbixcblx0XHRcdHN0ZXBTaXplOiBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQodGlja09wdHMuZml4ZWRTdGVwU2l6ZSwgdGlja09wdHMuc3RlcFNpemUpXG5cdFx0fTtcblx0XHR2YXIgdGlja3MgPSBtZS50aWNrcyA9IGdlbmVyYXRlVGlja3MobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIG1lKTtcblxuXHRcdG1lLmhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlcygpO1xuXG5cdFx0Ly8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyBzaW5jZSB3ZSBoYXZlIGV4cGFuZGVkIHRoZVxuXHRcdC8vIHJhbmdlIG9mIHRoZSBzY2FsZVxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5tYXgodGlja3MpO1xuXHRcdG1lLm1pbiA9IGhlbHBlcnMkMS5taW4odGlja3MpO1xuXG5cdFx0aWYgKHRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdHRpY2tzLnJldmVyc2UoKTtcblxuXHRcdFx0bWUuc3RhcnQgPSBtZS5tYXg7XG5cdFx0XHRtZS5lbmQgPSBtZS5taW47XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLnN0YXJ0ID0gbWUubWluO1xuXHRcdFx0bWUuZW5kID0gbWUubWF4O1xuXHRcdH1cblx0fSxcblxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRtZS50aWNrc0FzTnVtYmVycyA9IG1lLnRpY2tzLnNsaWNlKCk7XG5cdFx0bWUuemVyb0xpbmVJbmRleCA9IG1lLnRpY2tzLmluZGV4T2YoMCk7XG5cblx0XHRjb3JlX3NjYWxlLnByb3RvdHlwZS5jb252ZXJ0VGlja3NUb0xhYmVscy5jYWxsKG1lKTtcblx0fVxufSk7XG5cbnZhciBkZWZhdWx0Q29uZmlnJDEgPSB7XG5cdHBvc2l0aW9uOiAnbGVmdCcsXG5cdHRpY2tzOiB7XG5cdFx0Y2FsbGJhY2s6IGNvcmVfdGlja3MuZm9ybWF0dGVycy5saW5lYXJcblx0fVxufTtcblxudmFyIHNjYWxlX2xpbmVhciA9IHNjYWxlX2xpbmVhcmJhc2UuZXh0ZW5kKHtcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBERUZBVUxUX01JTiA9IDA7XG5cdFx0dmFyIERFRkFVTFRfTUFYID0gMTtcblxuXHRcdGZ1bmN0aW9uIElETWF0Y2hlcyhtZXRhKSB7XG5cdFx0XHRyZXR1cm4gaXNIb3Jpem9udGFsID8gbWV0YS54QXhpc0lEID09PSBtZS5pZCA6IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRmlyc3QgQ2FsY3VsYXRlIHRoZSByYW5nZVxuXHRcdG1lLm1pbiA9IG51bGw7XG5cdFx0bWUubWF4ID0gbnVsbDtcblxuXHRcdHZhciBoYXNTdGFja3MgPSBvcHRzLnN0YWNrZWQ7XG5cdFx0aWYgKGhhc1N0YWNrcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdGlmIChoYXNTdGFja3MpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpICYmXG5cdFx0XHRcdFx0bWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0aGFzU3RhY2tzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdHMuc3RhY2tlZCB8fCBoYXNTdGFja3MpIHtcblx0XHRcdHZhciB2YWx1ZXNQZXJTdGFjayA9IHt9O1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0dmFyIGtleSA9IFtcblx0XHRcdFx0XHRtZXRhLnR5cGUsXG5cdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhIHNlcGFyYXRlIHN0YWNrIGZvciBzdGFjaz11bmRlZmluZWQgZGF0YXNldHMgd2hlbiB0aGUgb3B0cy5zdGFja2VkIGlzIHVuZGVmaW5lZFxuXHRcdFx0XHRcdCgob3B0cy5zdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkKSA/IGRhdGFzZXRJbmRleCA6ICcnKSxcblx0XHRcdFx0XHRtZXRhLnN0YWNrXG5cdFx0XHRcdF0uam9pbignLicpO1xuXG5cdFx0XHRcdGlmICh2YWx1ZXNQZXJTdGFja1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR2YWx1ZXNQZXJTdGFja1trZXldID0ge1xuXHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXM6IFtdLFxuXHRcdFx0XHRcdFx0bmVnYXRpdmVWYWx1ZXM6IFtdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN0b3JlIHRoZXNlIHBlciB0eXBlXG5cdFx0XHRcdHZhciBwb3NpdGl2ZVZhbHVlcyA9IHZhbHVlc1BlclN0YWNrW2tleV0ucG9zaXRpdmVWYWx1ZXM7XG5cdFx0XHRcdHZhciBuZWdhdGl2ZVZhbHVlcyA9IHZhbHVlc1BlclN0YWNrW2tleV0ubmVnYXRpdmVWYWx1ZXM7XG5cblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHBvc2l0aXZlVmFsdWVzW2luZGV4XSA9IHBvc2l0aXZlVmFsdWVzW2luZGV4XSB8fCAwO1xuXHRcdFx0XHRcdFx0bmVnYXRpdmVWYWx1ZXNbaW5kZXhdID0gbmVnYXRpdmVWYWx1ZXNbaW5kZXhdIHx8IDA7XG5cblx0XHRcdFx0XHRcdGlmIChvcHRzLnJlbGF0aXZlUG9pbnRzKSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aXZlVmFsdWVzW2luZGV4XSA9IDEwMDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdG5lZ2F0aXZlVmFsdWVzW2luZGV4XSArPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aXZlVmFsdWVzW2luZGV4XSArPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKHZhbHVlc1BlclN0YWNrLCBmdW5jdGlvbih2YWx1ZXNGb3JUeXBlKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB2YWx1ZXNGb3JUeXBlLnBvc2l0aXZlVmFsdWVzLmNvbmNhdCh2YWx1ZXNGb3JUeXBlLm5lZ2F0aXZlVmFsdWVzKTtcblx0XHRcdFx0dmFyIG1pblZhbCA9IGhlbHBlcnMkMS5taW4odmFsdWVzKTtcblx0XHRcdFx0dmFyIG1heFZhbCA9IGhlbHBlcnMkMS5tYXgodmFsdWVzKTtcblx0XHRcdFx0bWUubWluID0gbWUubWluID09PSBudWxsID8gbWluVmFsIDogTWF0aC5taW4obWUubWluLCBtaW5WYWwpO1xuXHRcdFx0XHRtZS5tYXggPSBtZS5tYXggPT09IG51bGwgPyBtYXhWYWwgOiBNYXRoLm1heChtZS5tYXgsIG1heFZhbCk7XG5cdFx0XHR9KTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChtZS5taW4gPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0bWUubWluID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgbWUubWluKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1heCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+IG1lLm1heCkge1xuXHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0bWUubWluID0gaXNGaW5pdGUobWUubWluKSAmJiAhaXNOYU4obWUubWluKSA/IG1lLm1pbiA6IERFRkFVTFRfTUlOO1xuXHRcdG1lLm1heCA9IGlzRmluaXRlKG1lLm1heCkgJiYgIWlzTmFOKG1lLm1heCkgPyBtZS5tYXggOiBERUZBVUxUX01BWDtcblxuXHRcdC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSB0aWNrcy5taW4sIHRpY2tzLm1heCwgdGlja3MuYmVnaW5BdFplcm9cblx0XHR0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcblx0fSxcblxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdF9jb21wdXRlVGlja0xpbWl0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrRm9udDtcblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0cmV0dXJuIE1hdGguY2VpbChtZS53aWR0aCAvIDQwKTtcblx0XHR9XG5cdFx0dGlja0ZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG1lLm9wdGlvbnMudGlja3MpO1xuXHRcdHJldHVybiBNYXRoLmNlaWwobWUuaGVpZ2h0IC8gdGlja0ZvbnQubGluZUhlaWdodCk7XG5cdH0sXG5cblx0Ly8gQ2FsbGVkIGFmdGVyIHRoZSB0aWNrcyBhcmUgYnVpbHQuIFdlIG5lZWRcblx0aGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdC8vIFdlIGFyZSBpbiBhIHZlcnRpY2FsIG9yaWVudGF0aW9uLiBUaGUgdG9wIHZhbHVlIGlzIHRoZSBoaWdoZXN0LiBTbyByZXZlcnNlIHRoZSBhcnJheVxuXHRcdFx0dGhpcy50aWNrcy5yZXZlcnNlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRyZXR1cm4gK3RoaXMuZ2V0UmlnaHRWYWx1ZSh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdH0sXG5cblx0Ly8gVXRpbHNcblx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHQvLyBUaGlzIG11c3QgYmUgY2FsbGVkIGFmdGVyIGZpdCBoYXMgYmVlbiBydW4gc28gdGhhdFxuXHRcdC8vIHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMucmlnaHQsIGFuZCB0aGlzLmJvdHRvbSBoYXZlIGJlZW4gZGVmaW5lZFxuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHN0YXJ0ID0gbWUuc3RhcnQ7XG5cblx0XHR2YXIgcmlnaHRWYWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcblx0XHR2YXIgcGl4ZWw7XG5cdFx0dmFyIHJhbmdlID0gbWUuZW5kIC0gc3RhcnQ7XG5cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdHBpeGVsID0gbWUubGVmdCArIChtZS53aWR0aCAvIHJhbmdlICogKHJpZ2h0VmFsdWUgLSBzdGFydCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwaXhlbCA9IG1lLmJvdHRvbSAtIChtZS5oZWlnaHQgLyByYW5nZSAqIChyaWdodFZhbHVlIC0gc3RhcnQpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBpeGVsO1xuXHR9LFxuXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIGlubmVyRGltZW5zaW9uID0gaXNIb3Jpem9udGFsID8gbWUud2lkdGggOiBtZS5oZWlnaHQ7XG5cdFx0dmFyIG9mZnNldCA9IChpc0hvcml6b250YWwgPyBwaXhlbCAtIG1lLmxlZnQgOiBtZS5ib3R0b20gLSBwaXhlbCkgLyBpbm5lckRpbWVuc2lvbjtcblx0XHRyZXR1cm4gbWUuc3RhcnQgKyAoKG1lLmVuZCAtIG1lLnN0YXJ0KSAqIG9mZnNldCk7XG5cdH0sXG5cblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy50aWNrc0FzTnVtYmVyc1tpbmRleF0pO1xuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzJDEgPSBkZWZhdWx0Q29uZmlnJDE7XG5zY2FsZV9saW5lYXIuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDE7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCRhID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxvZ2FyaXRobWljIHRpY2tzXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IGFycmF5IG9mIHRpY2sgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG5cdHZhciB0aWNrcyA9IFtdO1xuXG5cdHZhciB0aWNrVmFsID0gdmFsdWVPckRlZmF1bHQkYShnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChkYXRhUmFuZ2UubWluKSkpKTtcblxuXHR2YXIgZW5kRXhwID0gTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAoZGF0YVJhbmdlLm1heCkpO1xuXHR2YXIgZW5kU2lnbmlmaWNhbmQgPSBNYXRoLmNlaWwoZGF0YVJhbmdlLm1heCAvIE1hdGgucG93KDEwLCBlbmRFeHApKTtcblx0dmFyIGV4cCwgc2lnbmlmaWNhbmQ7XG5cblx0aWYgKHRpY2tWYWwgPT09IDApIHtcblx0XHRleHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChkYXRhUmFuZ2UubWluTm90WmVybykpO1xuXHRcdHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcihkYXRhUmFuZ2UubWluTm90WmVybyAvIE1hdGgucG93KDEwLCBleHApKTtcblxuXHRcdHRpY2tzLnB1c2godGlja1ZhbCk7XG5cdFx0dGlja1ZhbCA9IHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCk7XG5cdH0gZWxzZSB7XG5cdFx0ZXhwID0gTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAodGlja1ZhbCkpO1xuXHRcdHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcih0aWNrVmFsIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuXHR9XG5cdHZhciBwcmVjaXNpb24gPSBleHAgPCAwID8gTWF0aC5wb3coMTAsIE1hdGguYWJzKGV4cCkpIDogMTtcblxuXHRkbyB7XG5cdFx0dGlja3MucHVzaCh0aWNrVmFsKTtcblxuXHRcdCsrc2lnbmlmaWNhbmQ7XG5cdFx0aWYgKHNpZ25pZmljYW5kID09PSAxMCkge1xuXHRcdFx0c2lnbmlmaWNhbmQgPSAxO1xuXHRcdFx0KytleHA7XG5cdFx0XHRwcmVjaXNpb24gPSBleHAgPj0gMCA/IDEgOiBwcmVjaXNpb247XG5cdFx0fVxuXG5cdFx0dGlja1ZhbCA9IE1hdGgucm91bmQoc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG5cdH0gd2hpbGUgKGV4cCA8IGVuZEV4cCB8fCAoZXhwID09PSBlbmRFeHAgJiYgc2lnbmlmaWNhbmQgPCBlbmRTaWduaWZpY2FuZCkpO1xuXG5cdHZhciBsYXN0VGljayA9IHZhbHVlT3JEZWZhdWx0JGEoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB0aWNrVmFsKTtcblx0dGlja3MucHVzaChsYXN0VGljayk7XG5cblx0cmV0dXJuIHRpY2tzO1xufVxuXG52YXIgZGVmYXVsdENvbmZpZyQyID0ge1xuXHRwb3NpdGlvbjogJ2xlZnQnLFxuXG5cdC8vIGxhYmVsIHNldHRpbmdzXG5cdHRpY2tzOiB7XG5cdFx0Y2FsbGJhY2s6IGNvcmVfdGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pY1xuXHR9XG59O1xuXG4vLyBUT0RPKHYzKTogY2hhbmdlIHRoaXMgdG8gcG9zaXRpdmVPckRlZmF1bHRcbmZ1bmN0aW9uIG5vbk5lZ2F0aXZlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcblx0cmV0dXJuIGhlbHBlcnMkMS5pc0Zpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPj0gMCA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuXG52YXIgc2NhbGVfbG9nYXJpdGhtaWMgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XG5cdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHRmdW5jdGlvbiBJRE1hdGNoZXMobWV0YSkge1xuXHRcdFx0cmV0dXJuIGlzSG9yaXpvbnRhbCA/IG1ldGEueEF4aXNJRCA9PT0gbWUuaWQgOiBtZXRhLnlBeGlzSUQgPT09IG1lLmlkO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBSYW5nZVxuXHRcdG1lLm1pbiA9IG51bGw7XG5cdFx0bWUubWF4ID0gbnVsbDtcblx0XHRtZS5taW5Ob3RaZXJvID0gbnVsbDtcblxuXHRcdHZhciBoYXNTdGFja3MgPSBvcHRzLnN0YWNrZWQ7XG5cdFx0aWYgKGhhc1N0YWNrcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdGlmIChoYXNTdGFja3MpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpICYmXG5cdFx0XHRcdFx0bWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0aGFzU3RhY2tzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdHMuc3RhY2tlZCB8fCBoYXNTdGFja3MpIHtcblx0XHRcdHZhciB2YWx1ZXNQZXJTdGFjayA9IHt9O1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0dmFyIGtleSA9IFtcblx0XHRcdFx0XHRtZXRhLnR5cGUsXG5cdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhIHNlcGFyYXRlIHN0YWNrIGZvciBzdGFjaz11bmRlZmluZWQgZGF0YXNldHMgd2hlbiB0aGUgb3B0cy5zdGFja2VkIGlzIHVuZGVmaW5lZFxuXHRcdFx0XHRcdCgob3B0cy5zdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkKSA/IGRhdGFzZXRJbmRleCA6ICcnKSxcblx0XHRcdFx0XHRtZXRhLnN0YWNrXG5cdFx0XHRcdF0uam9pbignLicpO1xuXG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlc1BlclN0YWNrW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dmFsdWVzUGVyU3RhY2tba2V5XSA9IFtdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XTtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcblx0XHRcdFx0XHRcdC8vIGludmFsaWQsIGhpZGRlbiBhbmQgbmVnYXRpdmUgdmFsdWVzIGFyZSBpZ25vcmVkXG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuIHx8IHZhbHVlIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YWx1ZXNbaW5kZXhdID0gdmFsdWVzW2luZGV4XSB8fCAwO1xuXHRcdFx0XHRcdFx0dmFsdWVzW2luZGV4XSArPSB2YWx1ZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKHZhbHVlc1BlclN0YWNrLCBmdW5jdGlvbih2YWx1ZXNGb3JUeXBlKSB7XG5cdFx0XHRcdGlmICh2YWx1ZXNGb3JUeXBlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR2YXIgbWluVmFsID0gaGVscGVycyQxLm1pbih2YWx1ZXNGb3JUeXBlKTtcblx0XHRcdFx0XHR2YXIgbWF4VmFsID0gaGVscGVycyQxLm1heCh2YWx1ZXNGb3JUeXBlKTtcblx0XHRcdFx0XHRtZS5taW4gPSBtZS5taW4gPT09IG51bGwgPyBtaW5WYWwgOiBNYXRoLm1pbihtZS5taW4sIG1pblZhbCk7XG5cdFx0XHRcdFx0bWUubWF4ID0gbWUubWF4ID09PSBudWxsID8gbWF4VmFsIDogTWF0aC5tYXgobWUubWF4LCBtYXhWYWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0Ly8gaW52YWxpZCwgaGlkZGVuIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGlnbm9yZWRcblx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gfHwgdmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCBtZS5taW4pIHtcblx0XHRcdFx0XHRcdFx0bWUubWluID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID4gbWUubWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1heCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgIT09IDAgJiYgKG1lLm1pbk5vdFplcm8gPT09IG51bGwgfHwgdmFsdWUgPCBtZS5taW5Ob3RaZXJvKSkge1xuXHRcdFx0XHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSB0aWNrcy5taW4sIHRpY2tzLm1heFxuXHRcdHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuXHR9LFxuXG5cdGhhbmRsZVRpY2tSYW5nZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgREVGQVVMVF9NSU4gPSAxO1xuXHRcdHZhciBERUZBVUxUX01BWCA9IDEwO1xuXG5cdFx0bWUubWluID0gbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWluLCBtZS5taW4pO1xuXHRcdG1lLm1heCA9IG5vbk5lZ2F0aXZlT3JEZWZhdWx0KHRpY2tPcHRzLm1heCwgbWUubWF4KTtcblxuXHRcdGlmIChtZS5taW4gPT09IG1lLm1heCkge1xuXHRcdFx0aWYgKG1lLm1pbiAhPT0gMCAmJiBtZS5taW4gIT09IG51bGwpIHtcblx0XHRcdFx0bWUubWluID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKG1lLm1pbikpIC0gMSk7XG5cdFx0XHRcdG1lLm1heCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChtZS5tYXgpKSArIDEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUubWluID0gREVGQVVMVF9NSU47XG5cdFx0XHRcdG1lLm1heCA9IERFRkFVTFRfTUFYO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRtZS5taW4gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWF4KSkgLSAxKTtcblx0XHR9XG5cdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0bWUubWF4ID0gbWUubWluICE9PSAwXG5cdFx0XHRcdD8gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKG1lLm1pbikpICsgMSlcblx0XHRcdFx0OiBERUZBVUxUX01BWDtcblx0XHR9XG5cdFx0aWYgKG1lLm1pbk5vdFplcm8gPT09IG51bGwpIHtcblx0XHRcdGlmIChtZS5taW4gPiAwKSB7XG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBtZS5taW47XG5cdFx0XHR9IGVsc2UgaWYgKG1lLm1heCA8IDEpIHtcblx0XHRcdFx0bWUubWluTm90WmVybyA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChtZS5tYXgpKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gREVGQVVMVF9NSU47XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgcmV2ZXJzZSA9ICFtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdHZhciBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcblx0XHRcdG1pbjogbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWluKSxcblx0XHRcdG1heDogbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWF4KVxuXHRcdH07XG5cdFx0dmFyIHRpY2tzID0gbWUudGlja3MgPSBnZW5lcmF0ZVRpY2tzJDEoZ2VuZXJhdGlvbk9wdGlvbnMsIG1lKTtcblxuXHRcdC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMgc2luY2Ugd2UgaGF2ZSBleHBhbmRlZCB0aGVcblx0XHQvLyByYW5nZSBvZiB0aGUgc2NhbGVcblx0XHRtZS5tYXggPSBoZWxwZXJzJDEubWF4KHRpY2tzKTtcblx0XHRtZS5taW4gPSBoZWxwZXJzJDEubWluKHRpY2tzKTtcblxuXHRcdGlmICh0aWNrT3B0cy5yZXZlcnNlKSB7XG5cdFx0XHRyZXZlcnNlID0gIXJldmVyc2U7XG5cdFx0XHRtZS5zdGFydCA9IG1lLm1heDtcblx0XHRcdG1lLmVuZCA9IG1lLm1pbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuc3RhcnQgPSBtZS5taW47XG5cdFx0XHRtZS5lbmQgPSBtZS5tYXg7XG5cdFx0fVxuXHRcdGlmIChyZXZlcnNlKSB7XG5cdFx0XHR0aWNrcy5yZXZlcnNlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpY2tWYWx1ZXMgPSB0aGlzLnRpY2tzLnNsaWNlKCk7XG5cblx0XHRjb3JlX3NjYWxlLnByb3RvdHlwZS5jb252ZXJ0VGlja3NUb0xhYmVscy5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgY29ycmVjdCB0b29sdGlwIGxhYmVsXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRyZXR1cm4gK3RoaXMuZ2V0UmlnaHRWYWx1ZSh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdH0sXG5cblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy50aWNrVmFsdWVzW2luZGV4XSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCB0aWNrLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgbWluaW11bSBub3QgemVybyB2YWx1ZS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgZmlyc3QgdGljayB2YWx1ZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRGaXJzdFRpY2tWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgZXhwID0gTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAodmFsdWUpKTtcblx0XHR2YXIgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHZhbHVlIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuXG5cdFx0cmV0dXJuIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCk7XG5cdH0sXG5cblx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIHJldmVyc2UgPSB0aWNrT3B0cy5yZXZlcnNlO1xuXHRcdHZhciBsb2cxMCA9IGhlbHBlcnMkMS5sb2cxMDtcblx0XHR2YXIgZmlyc3RUaWNrVmFsdWUgPSBtZS5fZ2V0Rmlyc3RUaWNrVmFsdWUobWUubWluTm90WmVybyk7XG5cdFx0dmFyIG9mZnNldCA9IDA7XG5cdFx0dmFyIGlubmVyRGltZW5zaW9uLCBwaXhlbCwgc3RhcnQsIGVuZCwgc2lnbjtcblxuXHRcdHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xuXHRcdGlmIChyZXZlcnNlKSB7XG5cdFx0XHRzdGFydCA9IG1lLmVuZDtcblx0XHRcdGVuZCA9IG1lLnN0YXJ0O1xuXHRcdFx0c2lnbiA9IC0xO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGFydCA9IG1lLnN0YXJ0O1xuXHRcdFx0ZW5kID0gbWUuZW5kO1xuXHRcdFx0c2lnbiA9IDE7XG5cdFx0fVxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0aW5uZXJEaW1lbnNpb24gPSBtZS53aWR0aDtcblx0XHRcdHBpeGVsID0gcmV2ZXJzZSA/IG1lLnJpZ2h0IDogbWUubGVmdDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5uZXJEaW1lbnNpb24gPSBtZS5oZWlnaHQ7XG5cdFx0XHRzaWduICo9IC0xOyAvLyBpbnZlcnQsIHNpbmNlIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzIGlzIGF0IHBpeGVsICgwLCAwKVxuXHRcdFx0cGl4ZWwgPSByZXZlcnNlID8gbWUudG9wIDogbWUuYm90dG9tO1xuXHRcdH1cblx0XHRpZiAodmFsdWUgIT09IHN0YXJ0KSB7XG5cdFx0XHRpZiAoc3RhcnQgPT09IDApIHsgLy8gaW5jbHVkZSB6ZXJvIHRpY2tcblx0XHRcdFx0b2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQkYSh0aWNrT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdFx0aW5uZXJEaW1lbnNpb24gLT0gb2Zmc2V0O1xuXHRcdFx0XHRzdGFydCA9IGZpcnN0VGlja1ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdG9mZnNldCArPSBpbm5lckRpbWVuc2lvbiAvIChsb2cxMChlbmQpIC0gbG9nMTAoc3RhcnQpKSAqIChsb2cxMCh2YWx1ZSkgLSBsb2cxMChzdGFydCkpO1xuXHRcdFx0fVxuXHRcdFx0cGl4ZWwgKz0gc2lnbiAqIG9mZnNldDtcblx0XHR9XG5cdFx0cmV0dXJuIHBpeGVsO1xuXHR9LFxuXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciByZXZlcnNlID0gdGlja09wdHMucmV2ZXJzZTtcblx0XHR2YXIgbG9nMTAgPSBoZWxwZXJzJDEubG9nMTA7XG5cdFx0dmFyIGZpcnN0VGlja1ZhbHVlID0gbWUuX2dldEZpcnN0VGlja1ZhbHVlKG1lLm1pbk5vdFplcm8pO1xuXHRcdHZhciBpbm5lckRpbWVuc2lvbiwgc3RhcnQsIGVuZCwgdmFsdWU7XG5cblx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0c3RhcnQgPSBtZS5lbmQ7XG5cdFx0XHRlbmQgPSBtZS5zdGFydDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RhcnQgPSBtZS5zdGFydDtcblx0XHRcdGVuZCA9IG1lLmVuZDtcblx0XHR9XG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLndpZHRoO1xuXHRcdFx0dmFsdWUgPSByZXZlcnNlID8gbWUucmlnaHQgLSBwaXhlbCA6IHBpeGVsIC0gbWUubGVmdDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5uZXJEaW1lbnNpb24gPSBtZS5oZWlnaHQ7XG5cdFx0XHR2YWx1ZSA9IHJldmVyc2UgPyBwaXhlbCAtIG1lLnRvcCA6IG1lLmJvdHRvbSAtIHBpeGVsO1xuXHRcdH1cblx0XHRpZiAodmFsdWUgIT09IHN0YXJ0KSB7XG5cdFx0XHRpZiAoc3RhcnQgPT09IDApIHsgLy8gaW5jbHVkZSB6ZXJvIHRpY2tcblx0XHRcdFx0dmFyIG9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JGEodGlja09wdHMuZm9udFNpemUsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHRcdHZhbHVlIC09IG9mZnNldDtcblx0XHRcdFx0aW5uZXJEaW1lbnNpb24gLT0gb2Zmc2V0O1xuXHRcdFx0XHRzdGFydCA9IGZpcnN0VGlja1ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgKj0gbG9nMTAoZW5kKSAtIGxvZzEwKHN0YXJ0KTtcblx0XHRcdHZhbHVlIC89IGlubmVyRGltZW5zaW9uO1xuXHRcdFx0dmFsdWUgPSBNYXRoLnBvdygxMCwgbG9nMTAoc3RhcnQpICsgdmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMkMiA9IGRlZmF1bHRDb25maWckMjtcbnNjYWxlX2xvZ2FyaXRobWljLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQyO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkYiA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcbnZhciB2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMSA9IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG52YXIgcmVzb2x2ZSQ3ID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxudmFyIGRlZmF1bHRDb25maWckMyA9IHtcblx0ZGlzcGxheTogdHJ1ZSxcblxuXHQvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHNjYWxpbmcgdGhlIGNoYXJ0IGZyb20gdGhlIGNlbnRyZVxuXHRhbmltYXRlOiB0cnVlLFxuXHRwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXG5cblx0YW5nbGVMaW5lczoge1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0Y29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMSknLFxuXHRcdGxpbmVXaWR0aDogMSxcblx0XHRib3JkZXJEYXNoOiBbXSxcblx0XHRib3JkZXJEYXNoT2Zmc2V0OiAwLjBcblx0fSxcblxuXHRncmlkTGluZXM6IHtcblx0XHRjaXJjdWxhcjogZmFsc2Vcblx0fSxcblxuXHQvLyBsYWJlbCBzZXR0aW5nc1xuXHR0aWNrczoge1xuXHRcdC8vIEJvb2xlYW4gLSBTaG93IGEgYmFja2Ryb3AgdG8gdGhlIHNjYWxlIGxhYmVsXG5cdFx0c2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG5cblx0XHQvLyBTdHJpbmcgLSBUaGUgY29sb3VyIG9mIHRoZSBsYWJlbCBiYWNrZHJvcFxuXHRcdGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNzUpJyxcblxuXHRcdC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIGFib3ZlICYgYmVsb3cgdGhlIGxhYmVsIGluIHBpeGVsc1xuXHRcdGJhY2tkcm9wUGFkZGluZ1k6IDIsXG5cblx0XHQvLyBOdW1iZXIgLSBUaGUgYmFja2Ryb3AgcGFkZGluZyB0byB0aGUgc2lkZSBvZiB0aGUgbGFiZWwgaW4gcGl4ZWxzXG5cdFx0YmFja2Ryb3BQYWRkaW5nWDogMixcblxuXHRcdGNhbGxiYWNrOiBjb3JlX3RpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdH0sXG5cblx0cG9pbnRMYWJlbHM6IHtcblx0XHQvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgc2hvdyBwb2ludCBsYWJlbHNcblx0XHRkaXNwbGF5OiB0cnVlLFxuXG5cdFx0Ly8gTnVtYmVyIC0gUG9pbnQgbGFiZWwgZm9udCBzaXplIGluIHBpeGVsc1xuXHRcdGZvbnRTaXplOiAxMCxcblxuXHRcdC8vIEZ1bmN0aW9uIC0gVXNlZCB0byBjb252ZXJ0IHBvaW50IGxhYmVsc1xuXHRcdGNhbGxiYWNrOiBmdW5jdGlvbihsYWJlbCkge1xuXHRcdFx0cmV0dXJuIGxhYmVsO1xuXHRcdH1cblx0fVxufTtcblxuZnVuY3Rpb24gZ2V0VmFsdWVDb3VudChzY2FsZSkge1xuXHR2YXIgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG5cdHJldHVybiBvcHRzLmFuZ2xlTGluZXMuZGlzcGxheSB8fCBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkgPyBzY2FsZS5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGggOiAwO1xufVxuXG5mdW5jdGlvbiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykge1xuXHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG5cdGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIG9wdHMuZGlzcGxheSkge1xuXHRcdHJldHVybiB2YWx1ZU9yRGVmYXVsdCRiKHRpY2tPcHRzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpICsgdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSAqIDI7XG5cdH1cblx0cmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBsaW5lSGVpZ2h0LCBsYWJlbCkge1xuXHRpZiAoaGVscGVycyQxLmlzQXJyYXkobGFiZWwpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHc6IGhlbHBlcnMkMS5sb25nZXN0VGV4dChjdHgsIGN0eC5mb250LCBsYWJlbCksXG5cdFx0XHRoOiBsYWJlbC5sZW5ndGggKiBsaW5lSGVpZ2h0XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0dzogY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aCxcblx0XHRoOiBsaW5lSGVpZ2h0XG5cdH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuXHRpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuXHRcdFx0ZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG5cdFx0fTtcblx0fSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzdGFydDogcG9zIC0gc2l6ZSxcblx0XHRcdGVuZDogcG9zXG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c3RhcnQ6IHBvcyxcblx0XHRlbmQ6IHBvcyArIHNpemVcblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZml0IGEgcmFkaWFsIGxpbmVhciBzY2FsZSB3aXRoIHBvaW50IGxhYmVsc1xuICovXG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcblxuXHQvLyBSaWdodCwgdGhpcyBpcyByZWFsbHkgY29uZnVzaW5nIGFuZCB0aGVyZSBpcyBhIGxvdCBvZiBtYXRocyBnb2luZyBvbiBoZXJlXG5cdC8vIFRoZSBnaXN0IG9mIHRoZSBwcm9ibGVtIGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL25ubmljay82OTZjYzljNTVmNGIwYmViOGZlOVxuXHQvL1xuXHQvLyBSZWFjdGlvbjogaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMvdG9vbXVjaHNjaWVuY2UuZ2lmXG5cdC8vXG5cdC8vIFNvbHV0aW9uOlxuXHQvL1xuXHQvLyBXZSBhc3N1bWUgdGhlIHJhZGl1cyBvZiB0aGUgcG9seWdvbiBpcyBoYWxmIHRoZSBzaXplIG9mIHRoZSBjYW52YXMgYXQgZmlyc3Rcblx0Ly8gYXQgZWFjaCBpbmRleCB3ZSBjaGVjayBpZiB0aGUgdGV4dCBvdmVybGFwcy5cblx0Ly9cblx0Ly8gV2hlcmUgaXQgZG9lcywgd2Ugc3RvcmUgdGhhdCBhbmdsZSBhbmQgdGhhdCBpbmRleC5cblx0Ly9cblx0Ly8gQWZ0ZXIgZmluZGluZyB0aGUgbGFyZ2VzdCBpbmRleCBhbmQgYW5nbGUgd2UgY2FsY3VsYXRlIGhvdyBtdWNoIHdlIG5lZWQgdG8gcmVtb3ZlXG5cdC8vIGZyb20gdGhlIHNoYXBlIHJhZGl1cyB0byBtb3ZlIHRoZSBwb2ludCBpbndhcmRzIGJ5IHRoYXQgeC5cblx0Ly9cblx0Ly8gV2UgYXZlcmFnZSB0aGUgbGVmdCBhbmQgcmlnaHQgZGlzdGFuY2VzIHRvIGdldCB0aGUgbWF4aW11bSBzaGFwZSByYWRpdXMgdGhhdCBjYW4gZml0IGluIHRoZSBib3hcblx0Ly8gYWxvbmcgd2l0aCBsYWJlbHMuXG5cdC8vXG5cdC8vIE9uY2Ugd2UgaGF2ZSB0aGF0LCB3ZSBjYW4gZmluZCB0aGUgY2VudHJlIHBvaW50IGZvciB0aGUgY2hhcnQsIGJ5IHRha2luZyB0aGUgeCB0ZXh0IHByb3RydXNpb25cblx0Ly8gb24gZWFjaCBzaWRlLCByZW1vdmluZyB0aGF0IGZyb20gdGhlIHNpemUsIGhhbHZpbmcgaXQgYW5kIGFkZGluZyB0aGUgbGVmdCB4IHByb3RydXNpb24gd2lkdGguXG5cdC8vXG5cdC8vIFRoaXMgd2lsbCBtZWFuIHdlIGhhdmUgYSBzaGFwZSBmaXR0ZWQgdG8gdGhlIGNhbnZhcywgYXMgbGFyZ2UgYXMgaXQgY2FuIGJlIHdpdGggdGhlIGxhYmVsc1xuXHQvLyBhbmQgcG9zaXRpb24gaXQgaW4gdGhlIG1vc3Qgc3BhY2UgZWZmaWNpZW50IG1hbm5lclxuXHQvL1xuXHQvLyBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My95ZWFoc2NpZW5jZS5naWZcblxuXHR2YXIgcGxGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzKTtcblxuXHQvLyBHZXQgbWF4aW11bSByYWRpdXMgb2YgdGhlIHBvbHlnb24uIEVpdGhlciBoYWxmIHRoZSBoZWlnaHQgKG1pbnVzIHRoZSB0ZXh0IHdpZHRoKSBvciBoYWxmIHRoZSB3aWR0aC5cblx0Ly8gVXNlIHRoaXMgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgKyBjaGFuZ2UuIC0gTWFrZSBzdXJlIEwvUiBwcm90cnVzaW9uIGlzIGF0IGxlYXN0IDAgdG8gc3RvcCBpc3N1ZXMgd2l0aCBjZW50cmUgcG9pbnRzXG5cdHZhciBmdXJ0aGVzdExpbWl0cyA9IHtcblx0XHRsOiAwLFxuXHRcdHI6IHNjYWxlLndpZHRoLFxuXHRcdHQ6IDAsXG5cdFx0Yjogc2NhbGUuaGVpZ2h0IC0gc2NhbGUucGFkZGluZ1RvcFxuXHR9O1xuXHR2YXIgZnVydGhlc3RBbmdsZXMgPSB7fTtcblx0dmFyIGksIHRleHRTaXplLCBwb2ludFBvc2l0aW9uO1xuXG5cdHNjYWxlLmN0eC5mb250ID0gcGxGb250LnN0cmluZztcblx0c2NhbGUuX3BvaW50TGFiZWxTaXplcyA9IFtdO1xuXG5cdHZhciB2YWx1ZUNvdW50ID0gZ2V0VmFsdWVDb3VudChzY2FsZSk7XG5cdGZvciAoaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcblx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBzY2FsZS5kcmF3aW5nQXJlYSArIDUpO1xuXHRcdHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udC5saW5lSGVpZ2h0LCBzY2FsZS5wb2ludExhYmVsc1tpXSB8fCAnJyk7XG5cdFx0c2NhbGUuX3BvaW50TGFiZWxTaXplc1tpXSA9IHRleHRTaXplO1xuXG5cdFx0Ly8gQWRkIHF1YXJ0ZXIgY2lyY2xlIHRvIG1ha2UgZGVncmVlIDAgbWVhbiB0b3Agb2YgY2lyY2xlXG5cdFx0dmFyIGFuZ2xlUmFkaWFucyA9IHNjYWxlLmdldEluZGV4QW5nbGUoaSk7XG5cdFx0dmFyIGFuZ2xlID0gaGVscGVycyQxLnRvRGVncmVlcyhhbmdsZVJhZGlhbnMpICUgMzYwO1xuXHRcdHZhciBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XG5cdFx0dmFyIHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XG5cblx0XHRpZiAoaExpbWl0cy5zdGFydCA8IGZ1cnRoZXN0TGltaXRzLmwpIHtcblx0XHRcdGZ1cnRoZXN0TGltaXRzLmwgPSBoTGltaXRzLnN0YXJ0O1xuXHRcdFx0ZnVydGhlc3RBbmdsZXMubCA9IGFuZ2xlUmFkaWFucztcblx0XHR9XG5cblx0XHRpZiAoaExpbWl0cy5lbmQgPiBmdXJ0aGVzdExpbWl0cy5yKSB7XG5cdFx0XHRmdXJ0aGVzdExpbWl0cy5yID0gaExpbWl0cy5lbmQ7XG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy5yID0gYW5nbGVSYWRpYW5zO1xuXHRcdH1cblxuXHRcdGlmICh2TGltaXRzLnN0YXJ0IDwgZnVydGhlc3RMaW1pdHMudCkge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMudCA9IHZMaW1pdHMuc3RhcnQ7XG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy50ID0gYW5nbGVSYWRpYW5zO1xuXHRcdH1cblxuXHRcdGlmICh2TGltaXRzLmVuZCA+IGZ1cnRoZXN0TGltaXRzLmIpIHtcblx0XHRcdGZ1cnRoZXN0TGltaXRzLmIgPSB2TGltaXRzLmVuZDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLmIgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXHR9XG5cblx0c2NhbGUuc2V0UmVkdWN0aW9ucyhzY2FsZS5kcmF3aW5nQXJlYSwgZnVydGhlc3RMaW1pdHMsIGZ1cnRoZXN0QW5nbGVzKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcblx0aWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcblx0XHRyZXR1cm4gJ2NlbnRlcic7XG5cdH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcblx0XHRyZXR1cm4gJ2xlZnQnO1xuXHR9XG5cblx0cmV0dXJuICdyaWdodCc7XG59XG5cbmZ1bmN0aW9uIGZpbGxUZXh0KGN0eCwgdGV4dCwgcG9zaXRpb24sIGxpbmVIZWlnaHQpIHtcblx0dmFyIHkgPSBwb3NpdGlvbi55ICsgbGluZUhlaWdodCAvIDI7XG5cdHZhciBpLCBpbGVuO1xuXG5cdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0ZXh0KSkge1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0Y3R4LmZpbGxUZXh0KHRleHRbaV0sIHBvc2l0aW9uLngsIHkpO1xuXHRcdFx0eSArPSBsaW5lSGVpZ2h0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRjdHguZmlsbFRleHQodGV4dCwgcG9zaXRpb24ueCwgeSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYWRqdXN0UG9pbnRQb3NpdGlvbkZvckxhYmVsSGVpZ2h0KGFuZ2xlLCB0ZXh0U2l6ZSwgcG9zaXRpb24pIHtcblx0aWYgKGFuZ2xlID09PSA5MCB8fCBhbmdsZSA9PT0gMjcwKSB7XG5cdFx0cG9zaXRpb24ueSAtPSAodGV4dFNpemUuaCAvIDIpO1xuXHR9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcblx0XHRwb3NpdGlvbi55IC09IHRleHRTaXplLmg7XG5cdH1cbn1cblxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxzKHNjYWxlKSB7XG5cdHZhciBjdHggPSBzY2FsZS5jdHg7XG5cdHZhciBvcHRzID0gc2NhbGUub3B0aW9ucztcblx0dmFyIGFuZ2xlTGluZU9wdHMgPSBvcHRzLmFuZ2xlTGluZXM7XG5cdHZhciBncmlkTGluZU9wdHMgPSBvcHRzLmdyaWRMaW5lcztcblx0dmFyIHBvaW50TGFiZWxPcHRzID0gb3B0cy5wb2ludExhYmVscztcblx0dmFyIGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JGIoYW5nbGVMaW5lT3B0cy5saW5lV2lkdGgsIGdyaWRMaW5lT3B0cy5saW5lV2lkdGgpO1xuXHR2YXIgbGluZUNvbG9yID0gdmFsdWVPckRlZmF1bHQkYihhbmdsZUxpbmVPcHRzLmNvbG9yLCBncmlkTGluZU9wdHMuY29sb3IpO1xuXHR2YXIgdGlja0JhY2tkcm9wSGVpZ2h0ID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpO1xuXG5cdGN0eC5zYXZlKCk7XG5cdGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cdGN0eC5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcblx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdGN0eC5zZXRMaW5lRGFzaChyZXNvbHZlJDcoW2FuZ2xlTGluZU9wdHMuYm9yZGVyRGFzaCwgZ3JpZExpbmVPcHRzLmJvcmRlckRhc2gsIFtdXSkpO1xuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHJlc29sdmUkNyhbYW5nbGVMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0LCBncmlkTGluZU9wdHMuYm9yZGVyRGFzaE9mZnNldCwgMC4wXSk7XG5cdH1cblxuXHR2YXIgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG9wdHMudGlja3MucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heCk7XG5cblx0Ly8gUG9pbnQgTGFiZWwgRm9udFxuXHR2YXIgcGxGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChwb2ludExhYmVsT3B0cyk7XG5cblx0Y3R4LmZvbnQgPSBwbEZvbnQuc3RyaW5nO1xuXHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cblx0Zm9yICh2YXIgaSA9IGdldFZhbHVlQ291bnQoc2NhbGUpIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRpZiAoYW5nbGVMaW5lT3B0cy5kaXNwbGF5ICYmIGxpbmVXaWR0aCAmJiBsaW5lQ29sb3IpIHtcblx0XHRcdHZhciBvdXRlclBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlKTtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlcik7XG5cdFx0XHRjdHgubGluZVRvKG91dGVyUG9zaXRpb24ueCwgb3V0ZXJQb3NpdGlvbi55KTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cblx0XHRpZiAocG9pbnRMYWJlbE9wdHMuZGlzcGxheSkge1xuXHRcdFx0Ly8gRXh0cmEgcGl4ZWxzIG91dCBmb3Igc29tZSBsYWJlbCBzcGFjaW5nXG5cdFx0XHR2YXIgZXh0cmEgPSAoaSA9PT0gMCA/IHRpY2tCYWNrZHJvcEhlaWdodCAvIDIgOiAwKTtcblx0XHRcdHZhciBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UgKyBleHRyYSArIDUpO1xuXG5cdFx0XHQvLyBLZWVwIHRoaXMgaW4gbG9vcCBzaW5jZSB3ZSBtYXkgc3VwcG9ydCBhcnJheSBwcm9wZXJ0aWVzIGhlcmVcblx0XHRcdHZhciBwb2ludExhYmVsRm9udENvbG9yID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEocG9pbnRMYWJlbE9wdHMuZm9udENvbG9yLCBpLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBwb2ludExhYmVsRm9udENvbG9yO1xuXG5cdFx0XHR2YXIgYW5nbGVSYWRpYW5zID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKTtcblx0XHRcdHZhciBhbmdsZSA9IGhlbHBlcnMkMS50b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKTtcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG5cdFx0XHRhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQoYW5nbGUsIHNjYWxlLl9wb2ludExhYmVsU2l6ZXNbaV0sIHBvaW50TGFiZWxQb3NpdGlvbik7XG5cdFx0XHRmaWxsVGV4dChjdHgsIHNjYWxlLnBvaW50TGFiZWxzW2ldIHx8ICcnLCBwb2ludExhYmVsUG9zaXRpb24sIHBsRm9udC5saW5lSGVpZ2h0KTtcblx0XHR9XG5cdH1cblx0Y3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gZHJhd1JhZGl1c0xpbmUoc2NhbGUsIGdyaWRMaW5lT3B0cywgcmFkaXVzLCBpbmRleCkge1xuXHR2YXIgY3R4ID0gc2NhbGUuY3R4O1xuXHR2YXIgY2lyY3VsYXIgPSBncmlkTGluZU9wdHMuY2lyY3VsYXI7XG5cdHZhciB2YWx1ZUNvdW50ID0gZ2V0VmFsdWVDb3VudChzY2FsZSk7XG5cdHZhciBsaW5lQ29sb3IgPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMShncmlkTGluZU9wdHMuY29sb3IsIGluZGV4IC0gMSk7XG5cdHZhciBsaW5lV2lkdGggPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMShncmlkTGluZU9wdHMubGluZVdpZHRoLCBpbmRleCAtIDEpO1xuXHR2YXIgcG9pbnRQb3NpdGlvbjtcblxuXHRpZiAoKCFjaXJjdWxhciAmJiAhdmFsdWVDb3VudCkgfHwgIWxpbmVDb2xvciB8fCAhbGluZVdpZHRoKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y3R4LnNhdmUoKTtcblx0Y3R4LnN0cm9rZVN0eWxlID0gbGluZUNvbG9yO1xuXHRjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0Y3R4LnNldExpbmVEYXNoKGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoIHx8IFtdKTtcblx0XHRjdHgubGluZURhc2hPZmZzZXQgPSBncmlkTGluZU9wdHMuYm9yZGVyRGFzaE9mZnNldCB8fCAwLjA7XG5cdH1cblxuXHRjdHguYmVnaW5QYXRoKCk7XG5cdGlmIChjaXJjdWxhcikge1xuXHRcdC8vIERyYXcgY2lyY3VsYXIgYXJjcyBiZXR3ZWVuIHRoZSBwb2ludHNcblx0XHRjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIERyYXcgc3RyYWlnaHQgbGluZXMgY29ubmVjdGluZyBlYWNoIGluZGV4XG5cdFx0cG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcblx0XHRjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcblxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG5cdFx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuXHRcdFx0Y3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG5cdFx0fVxuXHR9XG5cdGN0eC5jbG9zZVBhdGgoKTtcblx0Y3R4LnN0cm9rZSgpO1xuXHRjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBudW1iZXJPclplcm8ocGFyYW0pIHtcblx0cmV0dXJuIGhlbHBlcnMkMS5pc051bWJlcihwYXJhbSkgPyBwYXJhbSA6IDA7XG59XG5cbnZhciBzY2FsZV9yYWRpYWxMaW5lYXIgPSBzY2FsZV9saW5lYXJiYXNlLmV4dGVuZCh7XG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuXHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXHRcdG1lLnBhZGRpbmdUb3AgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQobWUub3B0aW9ucykgLyAyO1xuXHRcdG1lLnhDZW50ZXIgPSBNYXRoLmZsb29yKG1lLndpZHRoIC8gMik7XG5cdFx0bWUueUNlbnRlciA9IE1hdGguZmxvb3IoKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3ApIC8gMik7XG5cdFx0bWUuZHJhd2luZ0FyZWEgPSBNYXRoLm1pbihtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wLCBtZS53aWR0aCkgLyAyO1xuXHR9LFxuXG5cdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHR2YXIgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG5cdFx0aGVscGVycyQxLmVhY2goY2hhcnQuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpKSB7XG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcblx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWluID0gTWF0aC5taW4odmFsdWUsIG1pbik7XG5cdFx0XHRcdFx0bWF4ID0gTWF0aC5tYXgodmFsdWUsIG1heCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bWUubWluID0gKG1pbiA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID8gMCA6IG1pbik7XG5cdFx0bWUubWF4ID0gKG1heCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID8gMCA6IG1heCk7XG5cblx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXgsIHRpY2tzLmJlZ2luQXRaZXJvXG5cdFx0bWUuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuXHR9LFxuXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0X2NvbXB1dGVUaWNrTGltaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBNYXRoLmNlaWwodGhpcy5kcmF3aW5nQXJlYSAvIGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpKTtcblx0fSxcblxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdHNjYWxlX2xpbmVhcmJhc2UucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwobWUpO1xuXG5cdFx0Ly8gUG9pbnQgbGFiZWxzXG5cdFx0bWUucG9pbnRMYWJlbHMgPSBtZS5jaGFydC5kYXRhLmxhYmVscy5tYXAobWUub3B0aW9ucy5wb2ludExhYmVscy5jYWxsYmFjaywgbWUpO1xuXHR9LFxuXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRyZXR1cm4gK3RoaXMuZ2V0UmlnaHRWYWx1ZSh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdH0sXG5cblx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblxuXHRcdGlmIChvcHRzLmRpc3BsYXkgJiYgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG5cdFx0XHRmaXRXaXRoUG9pbnRMYWJlbHMobWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCByYWRpdXMgcmVkdWN0aW9ucyBhbmQgZGV0ZXJtaW5lIG5ldyByYWRpdXMgYW5kIGNlbnRlciBwb2ludFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c2V0UmVkdWN0aW9uczogZnVuY3Rpb24obGFyZ2VzdFBvc3NpYmxlUmFkaXVzLCBmdXJ0aGVzdExpbWl0cywgZnVydGhlc3RBbmdsZXMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25MZWZ0ID0gZnVydGhlc3RMaW1pdHMubCAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLmwpO1xuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25SaWdodCA9IE1hdGgubWF4KGZ1cnRoZXN0TGltaXRzLnIgLSBtZS53aWR0aCwgMCkgLyBNYXRoLnNpbihmdXJ0aGVzdEFuZ2xlcy5yKTtcblx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uVG9wID0gLWZ1cnRoZXN0TGltaXRzLnQgLyBNYXRoLmNvcyhmdXJ0aGVzdEFuZ2xlcy50KTtcblx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uQm90dG9tID0gLU1hdGgubWF4KGZ1cnRoZXN0TGltaXRzLmIgLSAobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCksIDApIC8gTWF0aC5jb3MoZnVydGhlc3RBbmdsZXMuYik7XG5cblx0XHRyYWRpdXNSZWR1Y3Rpb25MZWZ0ID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvbkxlZnQpO1xuXHRcdHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvblJpZ2h0KTtcblx0XHRyYWRpdXNSZWR1Y3Rpb25Ub3AgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uVG9wKTtcblx0XHRyYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcblxuXHRcdG1lLmRyYXdpbmdBcmVhID0gTWF0aC5taW4oXG5cdFx0XHRNYXRoLmZsb29yKGxhcmdlc3RQb3NzaWJsZVJhZGl1cyAtIChyYWRpdXNSZWR1Y3Rpb25MZWZ0ICsgcmFkaXVzUmVkdWN0aW9uUmlnaHQpIC8gMiksXG5cdFx0XHRNYXRoLmZsb29yKGxhcmdlc3RQb3NzaWJsZVJhZGl1cyAtIChyYWRpdXNSZWR1Y3Rpb25Ub3AgKyByYWRpdXNSZWR1Y3Rpb25Cb3R0b20pIC8gMikpO1xuXHRcdG1lLnNldENlbnRlclBvaW50KHJhZGl1c1JlZHVjdGlvbkxlZnQsIHJhZGl1c1JlZHVjdGlvblJpZ2h0LCByYWRpdXNSZWR1Y3Rpb25Ub3AsIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSk7XG5cdH0sXG5cblx0c2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWF4UmlnaHQgPSBtZS53aWR0aCAtIHJpZ2h0TW92ZW1lbnQgLSBtZS5kcmF3aW5nQXJlYTtcblx0XHR2YXIgbWF4TGVmdCA9IGxlZnRNb3ZlbWVudCArIG1lLmRyYXdpbmdBcmVhO1xuXHRcdHZhciBtYXhUb3AgPSB0b3BNb3ZlbWVudCArIG1lLmRyYXdpbmdBcmVhO1xuXHRcdHZhciBtYXhCb3R0b20gPSAobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCkgLSBib3R0b21Nb3ZlbWVudCAtIG1lLmRyYXdpbmdBcmVhO1xuXG5cdFx0bWUueENlbnRlciA9IE1hdGguZmxvb3IoKChtYXhMZWZ0ICsgbWF4UmlnaHQpIC8gMikgKyBtZS5sZWZ0KTtcblx0XHRtZS55Q2VudGVyID0gTWF0aC5mbG9vcigoKG1heFRvcCArIG1heEJvdHRvbSkgLyAyKSArIG1lLnRvcCArIG1lLnBhZGRpbmdUb3ApO1xuXHR9LFxuXG5cdGdldEluZGV4QW5nbGU6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIGFuZ2xlTXVsdGlwbGllciA9IChNYXRoLlBJICogMikgLyBnZXRWYWx1ZUNvdW50KHRoaXMpO1xuXHRcdHZhciBzdGFydEFuZ2xlID0gdGhpcy5jaGFydC5vcHRpb25zICYmIHRoaXMuY2hhcnQub3B0aW9ucy5zdGFydEFuZ2xlID9cblx0XHRcdHRoaXMuY2hhcnQub3B0aW9ucy5zdGFydEFuZ2xlIDpcblx0XHRcdDA7XG5cblx0XHR2YXIgc3RhcnRBbmdsZVJhZGlhbnMgPSBzdGFydEFuZ2xlICogTWF0aC5QSSAqIDIgLyAzNjA7XG5cblx0XHQvLyBTdGFydCBmcm9tIHRoZSB0b3AgaW5zdGVhZCBvZiByaWdodCwgc28gcmVtb3ZlIGEgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG5cdFx0cmV0dXJuIGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgc3RhcnRBbmdsZVJhZGlhbnM7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIDA7IC8vIG51bGwgYWx3YXlzIGluIGNlbnRlclxuXHRcdH1cblxuXHRcdC8vIFRha2UgaW50byBhY2NvdW50IGhhbGYgZm9udCBzaXplICsgdGhlIHlQYWRkaW5nIG9mIHRoZSB0b3AgdmFsdWVcblx0XHR2YXIgc2NhbGluZ0ZhY3RvciA9IG1lLmRyYXdpbmdBcmVhIC8gKG1lLm1heCAtIG1lLm1pbik7XG5cdFx0aWYgKG1lLm9wdGlvbnMudGlja3MucmV2ZXJzZSkge1xuXHRcdFx0cmV0dXJuIChtZS5tYXggLSB2YWx1ZSkgKiBzY2FsaW5nRmFjdG9yO1xuXHRcdH1cblx0XHRyZXR1cm4gKHZhbHVlIC0gbWUubWluKSAqIHNjYWxpbmdGYWN0b3I7XG5cdH0sXG5cblx0Z2V0UG9pbnRQb3NpdGlvbjogZnVuY3Rpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlcikge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRoaXNBbmdsZSA9IG1lLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gKE1hdGguUEkgLyAyKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogTWF0aC5jb3ModGhpc0FuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIG1lLnhDZW50ZXIsXG5cdFx0XHR5OiBNYXRoLnNpbih0aGlzQW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgbWUueUNlbnRlclxuXHRcdH07XG5cdH0sXG5cblx0Z2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlOiBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSk7XG5cdH0sXG5cblx0Z2V0QmFzZVBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtaW4gPSBtZS5taW47XG5cdFx0dmFyIG1heCA9IG1lLm1heDtcblxuXHRcdHJldHVybiBtZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCxcblx0XHRcdG1lLmJlZ2luQXRaZXJvID8gMCA6XG5cdFx0XHRtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuXHRcdFx0bWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcblx0XHRcdDApO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBncmlkTGluZU9wdHMgPSBvcHRzLmdyaWRMaW5lcztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG5cdFx0aWYgKG9wdHMuZGlzcGxheSkge1xuXHRcdFx0dmFyIGN0eCA9IG1lLmN0eDtcblx0XHRcdHZhciBzdGFydEFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKDApO1xuXHRcdFx0dmFyIHRpY2tGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udCh0aWNrT3B0cyk7XG5cblx0XHRcdGlmIChvcHRzLmFuZ2xlTGluZXMuZGlzcGxheSB8fCBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcblx0XHRcdFx0ZHJhd1BvaW50TGFiZWxzKG1lKTtcblx0XHRcdH1cblxuXHRcdFx0aGVscGVycyQxLmVhY2gobWUudGlja3MsIGZ1bmN0aW9uKGxhYmVsLCBpbmRleCkge1xuXHRcdFx0XHQvLyBEb24ndCBkcmF3IGEgY2VudHJlIHZhbHVlIChpZiBpdCBpcyBtaW5pbXVtKVxuXHRcdFx0XHRpZiAoaW5kZXggPiAwIHx8IHRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdFx0XHR2YXIgeUNlbnRlck9mZnNldCA9IG1lLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG1lLnRpY2tzQXNOdW1iZXJzW2luZGV4XSk7XG5cblx0XHRcdFx0XHQvLyBEcmF3IGNpcmN1bGFyIGxpbmVzIGFyb3VuZCB0aGUgc2NhbGVcblx0XHRcdFx0XHRpZiAoZ3JpZExpbmVPcHRzLmRpc3BsYXkgJiYgaW5kZXggIT09IDApIHtcblx0XHRcdFx0XHRcdGRyYXdSYWRpdXNMaW5lKG1lLCBncmlkTGluZU9wdHMsIHlDZW50ZXJPZmZzZXQsIGluZGV4KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodGlja09wdHMuZGlzcGxheSkge1xuXHRcdFx0XHRcdFx0dmFyIHRpY2tGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRiKHRpY2tPcHRzLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0XHRcdFx0XHRjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcblxuXHRcdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRcdGN0eC50cmFuc2xhdGUobWUueENlbnRlciwgbWUueUNlbnRlcik7XG5cdFx0XHRcdFx0XHRjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xuXG5cdFx0XHRcdFx0XHRpZiAodGlja09wdHMuc2hvd0xhYmVsQmFja2Ryb3ApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGxhYmVsV2lkdGggPSBjdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGlja09wdHMuYmFja2Ryb3BDb2xvcjtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KFxuXHRcdFx0XHRcdFx0XHRcdC1sYWJlbFdpZHRoIC8gMiAtIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1gsXG5cdFx0XHRcdFx0XHRcdFx0LXlDZW50ZXJPZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1ksXG5cdFx0XHRcdFx0XHRcdFx0bGFiZWxXaWR0aCArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1ggKiAyLFxuXHRcdFx0XHRcdFx0XHRcdHRpY2tGb250LnNpemUgKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZICogMlxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cdFx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdGlja0ZvbnRDb2xvcjtcblx0XHRcdFx0XHRcdGN0eC5maWxsVGV4dChsYWJlbCwgMCwgLXlDZW50ZXJPZmZzZXQpO1xuXHRcdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xudmFyIF9kZWZhdWx0cyQzID0gZGVmYXVsdENvbmZpZyQzO1xuc2NhbGVfcmFkaWFsTGluZWFyLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQzO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkYyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuLy8gSW50ZWdlciBjb25zdGFudHMgYXJlIGZyb20gdGhlIEVTNiBzcGVjLlxudmFyIE1JTl9JTlRFR0VSID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgfHwgLTkwMDcxOTkyNTQ3NDA5OTE7XG52YXIgTUFYX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuXG52YXIgSU5URVJWQUxTID0ge1xuXHRtaWxsaXNlY29uZDoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAxLFxuXHRcdHN0ZXBzOiBbMSwgMiwgNSwgMTAsIDIwLCA1MCwgMTAwLCAyNTAsIDUwMF1cblx0fSxcblx0c2Vjb25kOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDEwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCA1LCAxMCwgMTUsIDMwXVxuXHR9LFxuXHRtaW51dGU6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogNjAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCA1LCAxMCwgMTUsIDMwXVxuXHR9LFxuXHRob3VyOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDM2MDAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCAzLCA2LCAxMl1cblx0fSxcblx0ZGF5OiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDg2NDAwMDAwLFxuXHRcdHN0ZXBzOiBbMSwgMiwgNV1cblx0fSxcblx0d2Vlazoge1xuXHRcdGNvbW1vbjogZmFsc2UsXG5cdFx0c2l6ZTogNjA0ODAwMDAwLFxuXHRcdHN0ZXBzOiBbMSwgMiwgMywgNF1cblx0fSxcblx0bW9udGg6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMi42MjhlOSxcblx0XHRzdGVwczogWzEsIDIsIDNdXG5cdH0sXG5cdHF1YXJ0ZXI6IHtcblx0XHRjb21tb246IGZhbHNlLFxuXHRcdHNpemU6IDcuODg0ZTksXG5cdFx0c3RlcHM6IFsxLCAyLCAzLCA0XVxuXHR9LFxuXHR5ZWFyOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDMuMTU0ZTEwXG5cdH1cbn07XG5cbnZhciBVTklUUyA9IE9iamVjdC5rZXlzKElOVEVSVkFMUyk7XG5cbmZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG5cdHJldHVybiBhIC0gYjtcbn1cblxuZnVuY3Rpb24gYXJyYXlVbmlxdWUoaXRlbXMpIHtcblx0dmFyIGhhc2ggPSB7fTtcblx0dmFyIG91dCA9IFtdO1xuXHR2YXIgaSwgaWxlbiwgaXRlbTtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aXRlbSA9IGl0ZW1zW2ldO1xuXHRcdGlmICghaGFzaFtpdGVtXSkge1xuXHRcdFx0aGFzaFtpdGVtXSA9IHRydWU7XG5cdFx0XHRvdXQucHVzaChpdGVtKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2Yge3RpbWUsIHBvc30gb2JqZWN0cyB1c2VkIHRvIGludGVycG9sYXRlIGEgc3BlY2lmaWMgYHRpbWVgIG9yIHBvc2l0aW9uXG4gKiAoYHBvc2ApIG9uIHRoZSBzY2FsZSwgYnkgc2VhcmNoaW5nIGVudHJpZXMgYmVmb3JlIGFuZCBhZnRlciB0aGUgcmVxdWVzdGVkIHZhbHVlLiBgcG9zYCBpc1xuICogYSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMTogMCBiZWluZyB0aGUgc3RhcnQgb2YgdGhlIHNjYWxlIChsZWZ0IG9yIHRvcCkgYW5kIDEgdGhlIG90aGVyXG4gKiBleHRyZW1pdHkgKGxlZnQgKyB3aWR0aCBvciB0b3AgKyBoZWlnaHQpLiBOb3RlIHRoYXQgaXQgd291bGQgYmUgbW9yZSBvcHRpbWl6ZWQgdG8gZGlyZWN0bHlcbiAqIHN0b3JlIHByZS1jb21wdXRlZCBwaXhlbHMsIGJ1dCB0aGUgc2NhbGUgZGltZW5zaW9ucyBhcmUgbm90IGd1YXJhbnRlZWQgYXQgdGhlIHRpbWUgd2UgbmVlZFxuICogdG8gY3JlYXRlIHRoZSBsb29rdXAgdGFibGUuIFRoZSB0YWJsZSBBTFdBWVMgY29udGFpbnMgYXQgbGVhc3QgdHdvIGl0ZW1zOiBtaW4gYW5kIG1heC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzIC0gdGltZXN0YW1wcyBzb3J0ZWQgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXN0cmlidXRpb24gLSBJZiAnbGluZWFyJywgdGltZXN0YW1wcyB3aWxsIGJlIHNwcmVhZCBsaW5lYXJseSBhbG9uZyB0aGUgbWluXG4gKiBhbmQgbWF4IHJhbmdlLCBzbyBiYXNpY2FsbHksIHRoZSB0YWJsZSB3aWxsIGNvbnRhaW5zIG9ubHkgdHdvIGl0ZW1zOiB7bWluLCAwfSBhbmQge21heCwgMX0uXG4gKiBJZiAnc2VyaWVzJywgdGltZXN0YW1wcyB3aWxsIGJlIHBvc2l0aW9uZWQgYXQgdGhlIHNhbWUgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLiBJbiB0aGlzXG4gKiBjYXNlLCBvbmx5IHRpbWVzdGFtcHMgdGhhdCBicmVhayB0aGUgdGltZSBsaW5lYXJpdHkgYXJlIHJlZ2lzdGVyZWQsIG1lYW5pbmcgdGhhdCBpbiB0aGVcbiAqIGJlc3QgY2FzZSwgYWxsIHRpbWVzdGFtcHMgYXJlIGxpbmVhciwgdGhlIHRhYmxlIGNvbnRhaW5zIG9ubHkgbWluIGFuZCBtYXguXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcywgbWluLCBtYXgsIGRpc3RyaWJ1dGlvbikge1xuXHRpZiAoZGlzdHJpYnV0aW9uID09PSAnbGluZWFyJyB8fCAhdGltZXN0YW1wcy5sZW5ndGgpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0e3RpbWU6IG1pbiwgcG9zOiAwfSxcblx0XHRcdHt0aW1lOiBtYXgsIHBvczogMX1cblx0XHRdO1xuXHR9XG5cblx0dmFyIHRhYmxlID0gW107XG5cdHZhciBpdGVtcyA9IFttaW5dO1xuXHR2YXIgaSwgaWxlbiwgcHJldiwgY3VyciwgbmV4dDtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRjdXJyID0gdGltZXN0YW1wc1tpXTtcblx0XHRpZiAoY3VyciA+IG1pbiAmJiBjdXJyIDwgbWF4KSB7XG5cdFx0XHRpdGVtcy5wdXNoKGN1cnIpO1xuXHRcdH1cblx0fVxuXG5cdGl0ZW1zLnB1c2gobWF4KTtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0bmV4dCA9IGl0ZW1zW2kgKyAxXTtcblx0XHRwcmV2ID0gaXRlbXNbaSAtIDFdO1xuXHRcdGN1cnIgPSBpdGVtc1tpXTtcblxuXHRcdC8vIG9ubHkgYWRkIHBvaW50cyB0aGF0IGJyZWFrcyB0aGUgc2NhbGUgbGluZWFyaXR5XG5cdFx0aWYgKHByZXYgPT09IHVuZGVmaW5lZCB8fCBuZXh0ID09PSB1bmRlZmluZWQgfHwgTWF0aC5yb3VuZCgobmV4dCArIHByZXYpIC8gMikgIT09IGN1cnIpIHtcblx0XHRcdHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGFibGU7XG59XG5cbi8vIEBzZWUgYWRhcHRlZCBmcm9tIGh0dHBzOi8vd3d3LmFudWpnYWtoYXIuY29tLzIwMTQvMDMvMDEvYmluYXJ5LXNlYXJjaC1pbi1qYXZhc2NyaXB0L1xuZnVuY3Rpb24gbG9va3VwKHRhYmxlLCBrZXksIHZhbHVlKSB7XG5cdHZhciBsbyA9IDA7XG5cdHZhciBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG5cdHZhciBtaWQsIGkwLCBpMTtcblxuXHR3aGlsZSAobG8gPj0gMCAmJiBsbyA8PSBoaSkge1xuXHRcdG1pZCA9IChsbyArIGhpKSA+PiAxO1xuXHRcdGkwID0gdGFibGVbbWlkIC0gMV0gfHwgbnVsbDtcblx0XHRpMSA9IHRhYmxlW21pZF07XG5cblx0XHRpZiAoIWkwKSB7XG5cdFx0XHQvLyBnaXZlbiB2YWx1ZSBpcyBvdXRzaWRlIHRhYmxlIChiZWZvcmUgZmlyc3QgaXRlbSlcblx0XHRcdHJldHVybiB7bG86IG51bGwsIGhpOiBpMX07XG5cdFx0fSBlbHNlIGlmIChpMVtrZXldIDwgdmFsdWUpIHtcblx0XHRcdGxvID0gbWlkICsgMTtcblx0XHR9IGVsc2UgaWYgKGkwW2tleV0gPiB2YWx1ZSkge1xuXHRcdFx0aGkgPSBtaWQgLSAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4ge2xvOiBpMCwgaGk6IGkxfTtcblx0XHR9XG5cdH1cblxuXHQvLyBnaXZlbiB2YWx1ZSBpcyBvdXRzaWRlIHRhYmxlIChhZnRlciBsYXN0IGl0ZW0pXG5cdHJldHVybiB7bG86IGkxLCBoaTogbnVsbH07XG59XG5cbi8qKlxuICogTGluZWFybHkgaW50ZXJwb2xhdGVzIHRoZSBnaXZlbiBzb3VyY2UgYHZhbHVlYCB1c2luZyB0aGUgdGFibGUgaXRlbXMgYHNrZXlgIHZhbHVlcyBhbmRcbiAqIHJldHVybnMgdGhlIGFzc29jaWF0ZWQgYHRrZXlgIHZhbHVlLiBGb3IgZXhhbXBsZSwgaW50ZXJwb2xhdGUodGFibGUsICd0aW1lJywgNDIsICdwb3MnKVxuICogcmV0dXJucyB0aGUgcG9zaXRpb24gZm9yIGEgdGltZXN0YW1wIGVxdWFsIHRvIDQyLiBJZiB2YWx1ZSBpcyBvdXQgb2YgYm91bmRzLCB2YWx1ZXMgYXRcbiAqIGluZGV4IFswLCAxXSBvciBbbiAtIDEsIG5dIGFyZSB1c2VkIGZvciB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUkMSh0YWJsZSwgc2tleSwgc3ZhbCwgdGtleSkge1xuXHR2YXIgcmFuZ2UgPSBsb29rdXAodGFibGUsIHNrZXksIHN2YWwpO1xuXG5cdC8vIE5vdGU6IHRoZSBsb29rdXAgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IDIgaXRlbXMgKG1pbiBhbmQgbWF4KVxuXHR2YXIgcHJldiA9ICFyYW5nZS5sbyA/IHRhYmxlWzBdIDogIXJhbmdlLmhpID8gdGFibGVbdGFibGUubGVuZ3RoIC0gMl0gOiByYW5nZS5sbztcblx0dmFyIG5leHQgPSAhcmFuZ2UubG8gPyB0YWJsZVsxXSA6ICFyYW5nZS5oaSA/IHRhYmxlW3RhYmxlLmxlbmd0aCAtIDFdIDogcmFuZ2UuaGk7XG5cblx0dmFyIHNwYW4gPSBuZXh0W3NrZXldIC0gcHJldltza2V5XTtcblx0dmFyIHJhdGlvID0gc3BhbiA/IChzdmFsIC0gcHJldltza2V5XSkgLyBzcGFuIDogMDtcblx0dmFyIG9mZnNldCA9IChuZXh0W3RrZXldIC0gcHJldlt0a2V5XSkgKiByYXRpbztcblxuXHRyZXR1cm4gcHJldlt0a2V5XSArIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gdG9UaW1lc3RhbXAoc2NhbGUsIGlucHV0KSB7XG5cdHZhciBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG5cdHZhciBvcHRpb25zID0gc2NhbGUub3B0aW9ucy50aW1lO1xuXHR2YXIgcGFyc2VyID0gb3B0aW9ucy5wYXJzZXI7XG5cdHZhciBmb3JtYXQgPSBwYXJzZXIgfHwgb3B0aW9ucy5mb3JtYXQ7XG5cdHZhciB2YWx1ZSA9IGlucHV0O1xuXG5cdGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuXHR9XG5cblx0Ly8gT25seSBwYXJzZSBpZiBpdHMgbm90IGEgdGltZXN0YW1wIGFscmVhZHlcblx0aWYgKCFoZWxwZXJzJDEuaXNGaW5pdGUodmFsdWUpKSB7XG5cdFx0dmFsdWUgPSB0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJ1xuXHRcdFx0PyBhZGFwdGVyLnBhcnNlKHZhbHVlLCBmb3JtYXQpXG5cdFx0XHQ6IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xuXHR9XG5cblx0aWYgKHZhbHVlICE9PSBudWxsKSB7XG5cdFx0cmV0dXJuICt2YWx1ZTtcblx0fVxuXG5cdC8vIExhYmVscyBhcmUgaW4gYW4gaW5jb21wYXRpYmxlIGZvcm1hdCBhbmQgbm8gYHBhcnNlcmAgaGFzIGJlZW4gcHJvdmlkZWQuXG5cdC8vIFRoZSB1c2VyIG1pZ2h0IHN0aWxsIHVzZSB0aGUgZGVwcmVjYXRlZCBgZm9ybWF0YCBvcHRpb24gZm9yIHBhcnNpbmcuXG5cdGlmICghcGFyc2VyICYmIHR5cGVvZiBmb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YWx1ZSA9IGZvcm1hdChpbnB1dCk7XG5cblx0XHQvLyBgZm9ybWF0YCBjb3VsZCByZXR1cm4gc29tZXRoaW5nIGVsc2UgdGhhbiBhIHRpbWVzdGFtcCwgaWYgc28sIHBhcnNlIGl0XG5cdFx0aWYgKCFoZWxwZXJzJDEuaXNGaW5pdGUodmFsdWUpKSB7XG5cdFx0XHR2YWx1ZSA9IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG5cdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihpbnB1dCkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBvcHRpb25zID0gc2NhbGUub3B0aW9ucy50aW1lO1xuXHR2YXIgdmFsdWUgPSB0b1RpbWVzdGFtcChzY2FsZSwgc2NhbGUuZ2V0UmlnaHRWYWx1ZShpbnB1dCkpO1xuXHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRpZiAob3B0aW9ucy5yb3VuZCkge1xuXHRcdHZhbHVlID0gK3NjYWxlLl9hZGFwdGVyLnN0YXJ0T2YodmFsdWUsIG9wdGlvbnMucm91bmQpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiB1bml0IHRvIHNraXAgdG8gYmUgYWJsZSB0byBkaXNwbGF5IHVwIHRvIGBjYXBhY2l0eWAgbnVtYmVyIG9mIHRpY2tzXG4gKiBpbiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgbWluYCAvIGBtYXhgIHJhbmdlIGFuZCByZXNwZWN0aW5nIHRoZSBpbnRlcnZhbCBzdGVwcyBjb25zdHJhaW50cy5cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lU3RlcFNpemUobWluLCBtYXgsIHVuaXQsIGNhcGFjaXR5KSB7XG5cdHZhciByYW5nZSA9IG1heCAtIG1pbjtcblx0dmFyIGludGVydmFsID0gSU5URVJWQUxTW3VuaXRdO1xuXHR2YXIgbWlsbGlzZWNvbmRzID0gaW50ZXJ2YWwuc2l6ZTtcblx0dmFyIHN0ZXBzID0gaW50ZXJ2YWwuc3RlcHM7XG5cdHZhciBpLCBpbGVuLCBmYWN0b3I7XG5cblx0aWYgKCFzdGVwcykge1xuXHRcdHJldHVybiBNYXRoLmNlaWwocmFuZ2UgLyAoY2FwYWNpdHkgKiBtaWxsaXNlY29uZHMpKTtcblx0fVxuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBzdGVwcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRmYWN0b3IgPSBzdGVwc1tpXTtcblx0XHRpZiAoTWF0aC5jZWlsKHJhbmdlIC8gKG1pbGxpc2Vjb25kcyAqIGZhY3RvcikpIDw9IGNhcGFjaXR5KSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFjdG9yO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCByZXN1bHRzIGluIGFuIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhdXRvLWdlbmVyYXRlZCB0aWNrc1xuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuXHR2YXIgaWxlbiA9IFVOSVRTLmxlbmd0aDtcblx0dmFyIGksIGludGVydmFsLCBmYWN0b3I7XG5cblx0Zm9yIChpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcblx0XHRpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG5cdFx0ZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwc1tpbnRlcnZhbC5zdGVwcy5sZW5ndGggLSAxXSA6IE1BWF9JTlRFR0VSO1xuXG5cdFx0aWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG5cdFx0XHRyZXR1cm4gVU5JVFNbaV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgdG8gZm9ybWF0IGEgc2V0IG9mIHRpY2tzIHdpdGhcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIHRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xuXHR2YXIgaWxlbiA9IFVOSVRTLmxlbmd0aDtcblx0dmFyIGksIHVuaXQ7XG5cblx0Zm9yIChpID0gaWxlbiAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XG5cdFx0dW5pdCA9IFVOSVRTW2ldO1xuXHRcdGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IHRpY2tzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHVuaXQ7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XG5cdGZvciAodmFyIGkgPSBVTklUUy5pbmRleE9mKHVuaXQpICsgMSwgaWxlbiA9IFVOSVRTLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xuXHRcdFx0cmV0dXJuIFVOSVRTW2ldO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG1heGltdW0gb2YgYGNhcGFjaXR5YCB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHJvdW5kZWQgdG8gdGhlXG4gKiBgbWlub3JgIHVuaXQsIGFsaWduZWQgb24gdGhlIGBtYWpvcmAgdW5pdCBhbmQgdXNpbmcgdGhlIGdpdmVuIHNjYWxlIHRpbWUgYG9wdGlvbnNgLlxuICogSW1wb3J0YW50OiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIHRpY2tzIG91dHNpZGUgdGhlIG1pbiBhbmQgbWF4IHJhbmdlLCBpdCdzIHRoZVxuICogcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxpbmcgY29kZSB0byBjbGFtcCB2YWx1ZXMgaWYgbmVlZGVkLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZShzY2FsZSwgbWluLCBtYXgsIGNhcGFjaXR5KSB7XG5cdHZhciBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG5cdHZhciBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcblx0dmFyIHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuXHR2YXIgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KTtcblx0dmFyIG1ham9yID0gZGV0ZXJtaW5lTWFqb3JVbml0KG1pbm9yKTtcblx0dmFyIHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQkYyh0aW1lT3B0cy5zdGVwU2l6ZSwgdGltZU9wdHMudW5pdFN0ZXBTaXplKTtcblx0dmFyIHdlZWtkYXkgPSBtaW5vciA9PT0gJ3dlZWsnID8gdGltZU9wdHMuaXNvV2Vla2RheSA6IGZhbHNlO1xuXHR2YXIgbWFqb3JUaWNrc0VuYWJsZWQgPSBvcHRpb25zLnRpY2tzLm1ham9yLmVuYWJsZWQ7XG5cdHZhciBpbnRlcnZhbCA9IElOVEVSVkFMU1ttaW5vcl07XG5cdHZhciBmaXJzdCA9IG1pbjtcblx0dmFyIGxhc3QgPSBtYXg7XG5cdHZhciB0aWNrcyA9IFtdO1xuXHR2YXIgdGltZTtcblxuXHRpZiAoIXN0ZXBTaXplKSB7XG5cdFx0c3RlcFNpemUgPSBkZXRlcm1pbmVTdGVwU2l6ZShtaW4sIG1heCwgbWlub3IsIGNhcGFjaXR5KTtcblx0fVxuXG5cdC8vIEZvciAnd2VlaycgdW5pdCwgaGFuZGxlIHRoZSBmaXJzdCBkYXkgb2Ygd2VlayBvcHRpb25cblx0aWYgKHdlZWtkYXkpIHtcblx0XHRmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG5cdFx0bGFzdCA9ICthZGFwdGVyLnN0YXJ0T2YobGFzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcblx0fVxuXG5cdC8vIEFsaWduIGZpcnN0L2xhc3QgdGlja3Mgb24gdW5pdFxuXHRmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIHdlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcblx0bGFzdCA9ICthZGFwdGVyLnN0YXJ0T2YobGFzdCwgd2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBsYXN0IHRpY2sgaW5jbHVkZSBtYXhcblx0aWYgKGxhc3QgPCBtYXgpIHtcblx0XHRsYXN0ID0gK2FkYXB0ZXIuYWRkKGxhc3QsIDEsIG1pbm9yKTtcblx0fVxuXG5cdHRpbWUgPSBmaXJzdDtcblxuXHRpZiAobWFqb3JUaWNrc0VuYWJsZWQgJiYgbWFqb3IgJiYgIXdlZWtkYXkgJiYgIXRpbWVPcHRzLnJvdW5kKSB7XG5cdFx0Ly8gQWxpZ24gdGhlIGZpcnN0IHRpY2sgb24gdGhlIHByZXZpb3VzIGBtaW5vcmAgdW5pdCBhbGlnbmVkIG9uIHRoZSBgbWFqb3JgIHVuaXQ6XG5cdFx0Ly8gd2UgZmlyc3QgYWxpZ25lZCB0aW1lIG9uIHRoZSBwcmV2aW91cyBgbWFqb3JgIHVuaXQgdGhlbiBhZGQgdGhlIG51bWJlciBvZiBmdWxsXG5cdFx0Ly8gc3RlcFNpemUgdGhlcmUgaXMgYmV0d2VlbiBmaXJzdCBhbmQgdGhlIHByZXZpb3VzIG1ham9yIHRpbWUuXG5cdFx0dGltZSA9ICthZGFwdGVyLnN0YXJ0T2YodGltZSwgbWFqb3IpO1xuXHRcdHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgfn4oKGZpcnN0IC0gdGltZSkgLyAoaW50ZXJ2YWwuc2l6ZSAqIHN0ZXBTaXplKSkgKiBzdGVwU2l6ZSwgbWlub3IpO1xuXHR9XG5cblx0Zm9yICg7IHRpbWUgPCBsYXN0OyB0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIHN0ZXBTaXplLCBtaW5vcikpIHtcblx0XHR0aWNrcy5wdXNoKCt0aW1lKTtcblx0fVxuXG5cdHRpY2tzLnB1c2goK3RpbWUpO1xuXG5cdHJldHVybiB0aWNrcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdGFydCBhbmQgZW5kIG9mZnNldHMgZnJvbSBlZGdlcyBpbiB0aGUgZm9ybSBvZiB7c3RhcnQsIGVuZH1cbiAqIHdoZXJlIGVhY2ggdmFsdWUgaXMgYSByZWxhdGl2ZSB3aWR0aCB0byB0aGUgc2NhbGUgYW5kIHJhbmdlcyBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBUaGV5IGFkZCBleHRyYSBtYXJnaW5zIG9uIHRoZSBib3RoIHNpZGVzIGJ5IHNjYWxpbmcgZG93biB0aGUgb3JpZ2luYWwgc2NhbGUuXG4gKiBPZmZzZXRzIGFyZSBhZGRlZCB3aGVuIHRoZSBgb2Zmc2V0YCBvcHRpb24gaXMgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZU9mZnNldHModGFibGUsIHRpY2tzLCBtaW4sIG1heCwgb3B0aW9ucykge1xuXHR2YXIgc3RhcnQgPSAwO1xuXHR2YXIgZW5kID0gMDtcblx0dmFyIGZpcnN0LCBsYXN0O1xuXG5cdGlmIChvcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcblx0XHRpZiAoIW9wdGlvbnMudGltZS5taW4pIHtcblx0XHRcdGZpcnN0ID0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1swXSwgJ3BvcycpO1xuXHRcdFx0aWYgKHRpY2tzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRzdGFydCA9IDEgLSBmaXJzdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0YXJ0ID0gKGludGVycG9sYXRlJDEodGFibGUsICd0aW1lJywgdGlja3NbMV0sICdwb3MnKSAtIGZpcnN0KSAvIDI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghb3B0aW9ucy50aW1lLm1heCkge1xuXHRcdFx0bGFzdCA9IGludGVycG9sYXRlJDEodGFibGUsICd0aW1lJywgdGlja3NbdGlja3MubGVuZ3RoIC0gMV0sICdwb3MnKTtcblx0XHRcdGlmICh0aWNrcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0ZW5kID0gbGFzdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVuZCA9IChsYXN0IC0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1t0aWNrcy5sZW5ndGggLSAyXSwgJ3BvcycpKSAvIDI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHtzdGFydDogc3RhcnQsIGVuZDogZW5kfTtcbn1cblxuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcblx0dmFyIHRpY2tzID0gW107XG5cdHZhciBpLCBpbGVuLCB2YWx1ZSwgbWFqb3I7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHR2YWx1ZSA9IHZhbHVlc1tpXTtcblx0XHRtYWpvciA9IG1ham9yVW5pdCA/IHZhbHVlID09PSArc2NhbGUuX2FkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgbWFqb3JVbml0KSA6IGZhbHNlO1xuXG5cdFx0dGlja3MucHVzaCh7XG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRtYWpvcjogbWFqb3Jcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB0aWNrcztcbn1cblxudmFyIGRlZmF1bHRDb25maWckNCA9IHtcblx0cG9zaXRpb246ICdib3R0b20nLFxuXG5cdC8qKlxuXHQgKiBEYXRhIGRpc3RyaWJ1dGlvbiBhbG9uZyB0aGUgc2NhbGU6XG5cdCAqIC0gJ2xpbmVhcic6IGRhdGEgYXJlIHNwcmVhZCBhY2NvcmRpbmcgdG8gdGhlaXIgdGltZSAoZGlzdGFuY2VzIGNhbiB2YXJ5KSxcblx0ICogLSAnc2VyaWVzJzogZGF0YSBhcmUgc3ByZWFkIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci5cblx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1MDdcblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRkaXN0cmlidXRpb246ICdsaW5lYXInLFxuXG5cdC8qKlxuXHQgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG5cdCAqIC0gYGRhdGFgOiBtYWtlIHN1cmUgZGF0YSBhcmUgZnVsbHkgdmlzaWJsZSwgdGlja3Mgb3V0c2lkZSBhcmUgcmVtb3ZlZFxuXHQgKiAtIGB0aWNrc2A6IG1ha2Ugc3VyZSB0aWNrcyBhcmUgZnVsbHkgdmlzaWJsZSwgZGF0YSBvdXRzaWRlIGFyZSB0cnVuY2F0ZWRcblx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRib3VuZHM6ICdkYXRhJyxcblxuXHRhZGFwdGVyczoge30sXG5cdHRpbWU6IHtcblx0XHRwYXJzZXI6IGZhbHNlLCAvLyBmYWxzZSA9PSBhIHBhdHRlcm4gc3RyaW5nIGZyb20gaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nLWZvcm1hdC8gb3IgYSBjdXN0b20gY2FsbGJhY2sgdGhhdCBjb252ZXJ0cyBpdHMgYXJndW1lbnQgdG8gYSBtb21lbnRcblx0XHRmb3JtYXQ6IGZhbHNlLCAvLyBERVBSRUNBVEVEIGZhbHNlID09IGRhdGUgb2JqZWN0cywgbW9tZW50IG9iamVjdCwgY2FsbGJhY2sgb3IgYSBwYXR0ZXJuIHN0cmluZyBmcm9tIGh0dHBzOi8vbW9tZW50anMuY29tL2RvY3MvIy9wYXJzaW5nL3N0cmluZy1mb3JtYXQvXG5cdFx0dW5pdDogZmFsc2UsIC8vIGZhbHNlID09IGF1dG9tYXRpYyBvciBvdmVycmlkZSB3aXRoIHdlZWssIG1vbnRoLCB5ZWFyLCBldGMuXG5cdFx0cm91bmQ6IGZhbHNlLCAvLyBub25lLCBvciBvdmVycmlkZSB3aXRoIHdlZWssIG1vbnRoLCB5ZWFyLCBldGMuXG5cdFx0ZGlzcGxheUZvcm1hdDogZmFsc2UsIC8vIERFUFJFQ0FURURcblx0XHRpc29XZWVrZGF5OiBmYWxzZSwgLy8gb3ZlcnJpZGUgd2VlayBzdGFydCBkYXkgLSBzZWUgaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL2dldC1zZXQvaXNvLXdlZWtkYXkvXG5cdFx0bWluVW5pdDogJ21pbGxpc2Vjb25kJyxcblx0XHRkaXNwbGF5Rm9ybWF0czoge31cblx0fSxcblx0dGlja3M6IHtcblx0XHRhdXRvU2tpcDogZmFsc2UsXG5cblx0XHQvKipcblx0XHQgKiBUaWNrcyBnZW5lcmF0aW9uIGlucHV0IHZhbHVlczpcblx0XHQgKiAtICdhdXRvJzogZ2VuZXJhdGVzIFwib3B0aW1hbFwiIHRpY2tzIGJhc2VkIG9uIHNjYWxlIHNpemUgYW5kIHRpbWUgb3B0aW9ucy5cblx0XHQgKiAtICdkYXRhJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gZGF0YSAoaW5jbHVkaW5nIGxhYmVscyBmcm9tIGRhdGEge3R8eHx5fSBvYmplY3RzKS5cblx0XHQgKiAtICdsYWJlbHMnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSB1c2VyIGdpdmVuIGBkYXRhLmxhYmVsc2AgdmFsdWVzIE9OTFkuXG5cdFx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1MDdcblx0XHQgKiBAc2luY2UgMi43LjBcblx0XHQgKi9cblx0XHRzb3VyY2U6ICdhdXRvJyxcblxuXHRcdG1ham9yOiB7XG5cdFx0XHRlbmFibGVkOiBmYWxzZVxuXHRcdH1cblx0fVxufTtcblxudmFyIHNjYWxlX3RpbWUgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubWVyZ2VUaWNrc09wdGlvbnMoKTtcblx0XHRjb3JlX3NjYWxlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGltZSA9IG9wdGlvbnMudGltZSB8fCAob3B0aW9ucy50aW1lID0ge30pO1xuXHRcdHZhciBhZGFwdGVyID0gbWUuX2FkYXB0ZXIgPSBuZXcgY29yZV9hZGFwdGVycy5fZGF0ZShvcHRpb25zLmFkYXB0ZXJzLmRhdGUpO1xuXG5cdFx0Ly8gREVQUkVDQVRJT05TOiBvdXRwdXQgYSBtZXNzYWdlIG9ubHkgb25lIHRpbWUgcGVyIHVwZGF0ZVxuXHRcdGlmICh0aW1lLmZvcm1hdCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdvcHRpb25zLnRpbWUuZm9ybWF0IGlzIGRlcHJlY2F0ZWQgYW5kIHJlcGxhY2VkIGJ5IG9wdGlvbnMudGltZS5wYXJzZXIuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogYmVmb3JlIGludHJvZHVjaW5nIGFkYXB0ZXIsIGBkaXNwbGF5Rm9ybWF0c2Agd2FzXG5cdFx0Ly8gc3VwcG9zZWQgdG8gY29udGFpbiAqYWxsKiB1bml0L3N0cmluZyBwYWlycyBidXQgdGhpcyBjYW4ndCBiZSByZXNvbHZlZFxuXHRcdC8vIHdoZW4gbG9hZGluZyB0aGUgc2NhbGUgKGFkYXB0ZXJzIGFyZSBsb2FkZWQgYWZ0ZXJ3YXJkKSwgc28gbGV0J3MgcG9wdWxhdGVcblx0XHQvLyBtaXNzaW5nIGZvcm1hdHMgb24gdXBkYXRlXG5cdFx0aGVscGVycyQxLm1lcmdlSWYodGltZS5kaXNwbGF5Rm9ybWF0cywgYWRhcHRlci5mb3JtYXRzKCkpO1xuXG5cdFx0cmV0dXJuIGNvcmVfc2NhbGUucHJvdG90eXBlLnVwZGF0ZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0fSxcblxuXHQvKipcblx0ICogQWxsb3dzIGRhdGEgdG8gYmUgcmVmZXJlbmNlZCB2aWEgJ3QnIGF0dHJpYnV0ZVxuXHQgKi9cblx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24ocmF3VmFsdWUpIHtcblx0XHRpZiAocmF3VmFsdWUgJiYgcmF3VmFsdWUudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyYXdWYWx1ZSA9IHJhd1ZhbHVlLnQ7XG5cdFx0fVxuXHRcdHJldHVybiBjb3JlX3NjYWxlLnByb3RvdHlwZS5nZXRSaWdodFZhbHVlLmNhbGwodGhpcywgcmF3VmFsdWUpO1xuXHR9LFxuXG5cdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcblx0XHR2YXIgdGltZU9wdHMgPSBtZS5vcHRpb25zLnRpbWU7XG5cdFx0dmFyIHVuaXQgPSB0aW1lT3B0cy51bml0IHx8ICdkYXknO1xuXHRcdHZhciBtaW4gPSBNQVhfSU5URUdFUjtcblx0XHR2YXIgbWF4ID0gTUlOX0lOVEVHRVI7XG5cdFx0dmFyIHRpbWVzdGFtcHMgPSBbXTtcblx0XHR2YXIgZGF0YXNldHMgPSBbXTtcblx0XHR2YXIgbGFiZWxzID0gW107XG5cdFx0dmFyIGksIGosIGlsZW4sIGpsZW4sIGRhdGEsIHRpbWVzdGFtcDtcblx0XHR2YXIgZGF0YUxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuXG5cdFx0Ly8gQ29udmVydCBsYWJlbHMgdG8gdGltZXN0YW1wc1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhTGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bGFiZWxzLnB1c2gocGFyc2UobWUsIGRhdGFMYWJlbHNbaV0pKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgdG8gdGltZXN0YW1wc1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRkYXRhID0gY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5kYXRhO1xuXG5cdFx0XHRcdC8vIExldCdzIGNvbnNpZGVyIHRoYXQgYWxsIGRhdGEgaGF2ZSB0aGUgc2FtZSBmb3JtYXQuXG5cdFx0XHRcdGlmIChoZWxwZXJzJDEuaXNPYmplY3QoZGF0YVswXSkpIHtcblx0XHRcdFx0XHRkYXRhc2V0c1tpXSA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yIChqID0gMCwgamxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHRcdFx0XHR0aW1lc3RhbXAgPSBwYXJzZShtZSwgZGF0YVtqXSk7XG5cdFx0XHRcdFx0XHR0aW1lc3RhbXBzLnB1c2godGltZXN0YW1wKTtcblx0XHRcdFx0XHRcdGRhdGFzZXRzW2ldW2pdID0gdGltZXN0YW1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gbGFiZWxzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuXHRcdFx0XHRcdFx0dGltZXN0YW1wcy5wdXNoKGxhYmVsc1tqXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFzZXRzW2ldID0gbGFiZWxzLnNsaWNlKDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhc2V0c1tpXSA9IFtdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChsYWJlbHMubGVuZ3RoKSB7XG5cdFx0XHQvLyBTb3J0IGxhYmVscyAqKmFmdGVyKiogZGF0YSBoYXZlIGJlZW4gY29udmVydGVkXG5cdFx0XHRsYWJlbHMgPSBhcnJheVVuaXF1ZShsYWJlbHMpLnNvcnQoc29ydGVyKTtcblx0XHRcdG1pbiA9IE1hdGgubWluKG1pbiwgbGFiZWxzWzBdKTtcblx0XHRcdG1heCA9IE1hdGgubWF4KG1heCwgbGFiZWxzW2xhYmVscy5sZW5ndGggLSAxXSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG5cdFx0XHR0aW1lc3RhbXBzID0gYXJyYXlVbmlxdWUodGltZXN0YW1wcykuc29ydChzb3J0ZXIpO1xuXHRcdFx0bWluID0gTWF0aC5taW4obWluLCB0aW1lc3RhbXBzWzBdKTtcblx0XHRcdG1heCA9IE1hdGgubWF4KG1heCwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcblx0XHR9XG5cblx0XHRtaW4gPSBwYXJzZShtZSwgdGltZU9wdHMubWluKSB8fCBtaW47XG5cdFx0bWF4ID0gcGFyc2UobWUsIHRpbWVPcHRzLm1heCkgfHwgbWF4O1xuXG5cdFx0Ly8gSW4gY2FzZSB0aGVyZSBpcyBubyB2YWxpZCBtaW4vbWF4LCBzZXQgbGltaXRzIGJhc2VkIG9uIHVuaXQgdGltZSBvcHRpb25cblx0XHRtaW4gPSBtaW4gPT09IE1BWF9JTlRFR0VSID8gK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KSA6IG1pbjtcblx0XHRtYXggPSBtYXggPT09IE1JTl9JTlRFR0VSID8gK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxIDogbWF4O1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbWF4IGlzIHN0cmljdGx5IGhpZ2hlciB0aGFuIG1pbiAocmVxdWlyZWQgYnkgdGhlIGxvb2t1cCB0YWJsZSlcblx0XHRtZS5taW4gPSBNYXRoLm1pbihtaW4sIG1heCk7XG5cdFx0bWUubWF4ID0gTWF0aC5tYXgobWluICsgMSwgbWF4KTtcblxuXHRcdC8vIFBSSVZBVEVcblx0XHRtZS5faG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdG1lLl90YWJsZSA9IFtdO1xuXHRcdG1lLl90aW1lc3RhbXBzID0ge1xuXHRcdFx0ZGF0YTogdGltZXN0YW1wcyxcblx0XHRcdGRhdGFzZXRzOiBkYXRhc2V0cyxcblx0XHRcdGxhYmVsczogbGFiZWxzXG5cdFx0fTtcblx0fSxcblxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtaW4gPSBtZS5taW47XG5cdFx0dmFyIG1heCA9IG1lLm1heDtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuXHRcdHZhciB0aW1lc3RhbXBzID0gW107XG5cdFx0dmFyIHRpY2tzID0gW107XG5cdFx0dmFyIGksIGlsZW4sIHRpbWVzdGFtcDtcblxuXHRcdHN3aXRjaCAob3B0aW9ucy50aWNrcy5zb3VyY2UpIHtcblx0XHRjYXNlICdkYXRhJzpcblx0XHRcdHRpbWVzdGFtcHMgPSBtZS5fdGltZXN0YW1wcy5kYXRhO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbGFiZWxzJzpcblx0XHRcdHRpbWVzdGFtcHMgPSBtZS5fdGltZXN0YW1wcy5sYWJlbHM7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdhdXRvJzpcblx0XHRkZWZhdWx0OlxuXHRcdFx0dGltZXN0YW1wcyA9IGdlbmVyYXRlKG1lLCBtaW4sIG1heCwgbWUuZ2V0TGFiZWxDYXBhY2l0eShtaW4pLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcblx0XHRcdG1pbiA9IHRpbWVzdGFtcHNbMF07XG5cdFx0XHRtYXggPSB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG5cdFx0fVxuXG5cdFx0Ly8gRW5mb3JjZSBsaW1pdHMgd2l0aCB1c2VyIG1pbi9tYXggb3B0aW9uc1xuXHRcdG1pbiA9IHBhcnNlKG1lLCB0aW1lT3B0cy5taW4pIHx8IG1pbjtcblx0XHRtYXggPSBwYXJzZShtZSwgdGltZU9wdHMubWF4KSB8fCBtYXg7XG5cblx0XHQvLyBSZW1vdmUgdGlja3Mgb3V0c2lkZSB0aGUgbWluL21heCByYW5nZVxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0dGltZXN0YW1wID0gdGltZXN0YW1wc1tpXTtcblx0XHRcdGlmICh0aW1lc3RhbXAgPj0gbWluICYmIHRpbWVzdGFtcCA8PSBtYXgpIHtcblx0XHRcdFx0dGlja3MucHVzaCh0aW1lc3RhbXApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLm1pbiA9IG1pbjtcblx0XHRtZS5tYXggPSBtYXg7XG5cblx0XHQvLyBQUklWQVRFXG5cdFx0bWUuX3VuaXQgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKG1lLCB0aWNrcywgdGltZU9wdHMubWluVW5pdCwgbWUubWluLCBtZS5tYXgpO1xuXHRcdG1lLl9tYWpvclVuaXQgPSBkZXRlcm1pbmVNYWpvclVuaXQobWUuX3VuaXQpO1xuXHRcdG1lLl90YWJsZSA9IGJ1aWxkTG9va3VwVGFibGUobWUuX3RpbWVzdGFtcHMuZGF0YSwgbWluLCBtYXgsIG9wdGlvbnMuZGlzdHJpYnV0aW9uKTtcblx0XHRtZS5fb2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKG1lLl90YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKTtcblxuXHRcdGlmIChvcHRpb25zLnRpY2tzLnJldmVyc2UpIHtcblx0XHRcdHRpY2tzLnJldmVyc2UoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGlja3NGcm9tVGltZXN0YW1wcyhtZSwgdGlja3MsIG1lLl9tYWpvclVuaXQpO1xuXHR9LFxuXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBhZGFwdGVyID0gbWUuX2FkYXB0ZXI7XG5cdFx0dmFyIGRhdGEgPSBtZS5jaGFydC5kYXRhO1xuXHRcdHZhciB0aW1lT3B0cyA9IG1lLm9wdGlvbnMudGltZTtcblx0XHR2YXIgbGFiZWwgPSBkYXRhLmxhYmVscyAmJiBpbmRleCA8IGRhdGEubGFiZWxzLmxlbmd0aCA/IGRhdGEubGFiZWxzW2luZGV4XSA6ICcnO1xuXHRcdHZhciB2YWx1ZSA9IGRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XTtcblxuXHRcdGlmIChoZWxwZXJzJDEuaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0XHRsYWJlbCA9IG1lLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xuXHRcdH1cblx0XHRpZiAodGltZU9wdHMudG9vbHRpcEZvcm1hdCkge1xuXHRcdFx0cmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHRvVGltZXN0YW1wKG1lLCBsYWJlbCksIHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIGxhYmVsO1xuXHRcdH1cblx0XHRyZXR1cm4gYWRhcHRlci5mb3JtYXQodG9UaW1lc3RhbXAobWUsIGxhYmVsKSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBGdW5jdGlvbiB0byBmb3JtYXQgYW4gaW5kaXZpZHVhbCB0aWNrIG1hcmtcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHRpY2tGb3JtYXRGdW5jdGlvbjogZnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBhZGFwdGVyID0gbWUuX2FkYXB0ZXI7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuXHRcdHZhciBtaW5vckZvcm1hdCA9IGZvcm1hdHNbbWUuX3VuaXRdO1xuXHRcdHZhciBtYWpvclVuaXQgPSBtZS5fbWFqb3JVbml0O1xuXHRcdHZhciBtYWpvckZvcm1hdCA9IGZvcm1hdHNbbWFqb3JVbml0XTtcblx0XHR2YXIgbWFqb3JUaW1lID0gK2FkYXB0ZXIuc3RhcnRPZih0aW1lLCBtYWpvclVuaXQpO1xuXHRcdHZhciBtYWpvclRpY2tPcHRzID0gb3B0aW9ucy50aWNrcy5tYWpvcjtcblx0XHR2YXIgbWFqb3IgPSBtYWpvclRpY2tPcHRzLmVuYWJsZWQgJiYgbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpbWUgPT09IG1ham9yVGltZTtcblx0XHR2YXIgbGFiZWwgPSBhZGFwdGVyLmZvcm1hdCh0aW1lLCBmb3JtYXQgPyBmb3JtYXQgOiBtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1ham9yID8gbWFqb3JUaWNrT3B0cyA6IG9wdGlvbnMudGlja3MubWlub3I7XG5cdFx0dmFyIGZvcm1hdHRlciA9IHZhbHVlT3JEZWZhdWx0JGModGlja09wdHMuY2FsbGJhY2ssIHRpY2tPcHRzLnVzZXJDYWxsYmFjayk7XG5cblx0XHRyZXR1cm4gZm9ybWF0dGVyID8gZm9ybWF0dGVyKGxhYmVsLCBpbmRleCwgdGlja3MpIDogbGFiZWw7XG5cdH0sXG5cblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIGxhYmVscyA9IFtdO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bGFiZWxzLnB1c2godGhpcy50aWNrRm9ybWF0RnVuY3Rpb24odGlja3NbaV0udmFsdWUsIGksIHRpY2tzKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxhYmVscztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFBpeGVsRm9yT2Zmc2V0OiBmdW5jdGlvbih0aW1lKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaXNSZXZlcnNlID0gbWUub3B0aW9ucy50aWNrcy5yZXZlcnNlO1xuXHRcdHZhciBzaXplID0gbWUuX2hvcml6b250YWwgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHR2YXIgc3RhcnQgPSBtZS5faG9yaXpvbnRhbCA/IGlzUmV2ZXJzZSA/IG1lLnJpZ2h0IDogbWUubGVmdCA6IGlzUmV2ZXJzZSA/IG1lLmJvdHRvbSA6IG1lLnRvcDtcblx0XHR2YXIgcG9zID0gaW50ZXJwb2xhdGUkMShtZS5fdGFibGUsICd0aW1lJywgdGltZSwgJ3BvcycpO1xuXHRcdHZhciBvZmZzZXQgPSBzaXplICogKG1lLl9vZmZzZXRzLnN0YXJ0ICsgcG9zKSAvIChtZS5fb2Zmc2V0cy5zdGFydCArIDEgKyBtZS5fb2Zmc2V0cy5lbmQpO1xuXG5cdFx0cmV0dXJuIGlzUmV2ZXJzZSA/IHN0YXJ0IC0gb2Zmc2V0IDogc3RhcnQgKyBvZmZzZXQ7XG5cdH0sXG5cblx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUsIGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aW1lID0gbnVsbDtcblxuXHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aW1lID0gbWUuX3RpbWVzdGFtcHMuZGF0YXNldHNbZGF0YXNldEluZGV4XVtpbmRleF07XG5cdFx0fVxuXG5cdFx0aWYgKHRpbWUgPT09IG51bGwpIHtcblx0XHRcdHRpbWUgPSBwYXJzZShtZSwgdmFsdWUpO1xuXHRcdH1cblxuXHRcdGlmICh0aW1lICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbWUuZ2V0UGl4ZWxGb3JPZmZzZXQodGltZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgdGlja3MgPSB0aGlzLmdldFRpY2tzKCk7XG5cdFx0cmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCB0aWNrcy5sZW5ndGggP1xuXHRcdFx0dGhpcy5nZXRQaXhlbEZvck9mZnNldCh0aWNrc1tpbmRleF0udmFsdWUpIDpcblx0XHRcdG51bGw7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBzaXplID0gbWUuX2hvcml6b250YWwgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHR2YXIgc3RhcnQgPSBtZS5faG9yaXpvbnRhbCA/IG1lLmxlZnQgOiBtZS50b3A7XG5cdFx0dmFyIHBvcyA9IChzaXplID8gKHBpeGVsIC0gc3RhcnQpIC8gc2l6ZSA6IDApICogKG1lLl9vZmZzZXRzLnN0YXJ0ICsgMSArIG1lLl9vZmZzZXRzLnN0YXJ0KSAtIG1lLl9vZmZzZXRzLmVuZDtcblx0XHR2YXIgdGltZSA9IGludGVycG9sYXRlJDEobWUuX3RhYmxlLCAncG9zJywgcG9zLCAndGltZScpO1xuXG5cdFx0Ly8gREVQUkVDQVRJT04sIHdlIHNob3VsZCByZXR1cm4gdGltZSBkaXJlY3RseVxuXHRcdHJldHVybiBtZS5fYWRhcHRlci5fY3JlYXRlKHRpbWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcnVkZSBhcHByb3hpbWF0aW9uIG9mIHdoYXQgdGhlIGxhYmVsIHdpZHRoIG1pZ2h0IGJlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRMYWJlbFdpZHRoOiBmdW5jdGlvbihsYWJlbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tzT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIHRpY2tMYWJlbFdpZHRoID0gbWUuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcblx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzJDEudG9SYWRpYW5zKHRpY2tzT3B0cy5tYXhSb3RhdGlvbik7XG5cdFx0dmFyIGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHZhciBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHR2YXIgdGlja0ZvbnRTaXplID0gdmFsdWVPckRlZmF1bHQkYyh0aWNrc09wdHMuZm9udFNpemUsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSk7XG5cblx0XHRyZXR1cm4gKHRpY2tMYWJlbFdpZHRoICogY29zUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldExhYmVsQ2FwYWNpdHk6IGZ1bmN0aW9uKGV4YW1wbGVUaW1lKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIHBpY2sgdGhlIGxvbmdlc3QgZm9ybWF0IChtaWxsaXNlY29uZHMpIGZvciBndWVzdGltYXRpb25cblx0XHR2YXIgZm9ybWF0ID0gbWUub3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzLm1pbGxpc2Vjb25kO1xuXHRcdHZhciBleGFtcGxlTGFiZWwgPSBtZS50aWNrRm9ybWF0RnVuY3Rpb24oZXhhbXBsZVRpbWUsIDAsIFtdLCBmb3JtYXQpO1xuXHRcdHZhciB0aWNrTGFiZWxXaWR0aCA9IG1lLmdldExhYmVsV2lkdGgoZXhhbXBsZUxhYmVsKTtcblx0XHR2YXIgaW5uZXJXaWR0aCA9IG1lLmlzSG9yaXpvbnRhbCgpID8gbWUud2lkdGggOiBtZS5oZWlnaHQ7XG5cdFx0dmFyIGNhcGFjaXR5ID0gTWF0aC5mbG9vcihpbm5lcldpZHRoIC8gdGlja0xhYmVsV2lkdGgpO1xuXG5cdFx0cmV0dXJuIGNhcGFjaXR5ID4gMCA/IGNhcGFjaXR5IDogMTtcblx0fVxufSk7XG5cbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xudmFyIF9kZWZhdWx0cyQ0ID0gZGVmYXVsdENvbmZpZyQ0O1xuc2NhbGVfdGltZS5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkNDtcblxudmFyIHNjYWxlcyA9IHtcblx0Y2F0ZWdvcnk6IHNjYWxlX2NhdGVnb3J5LFxuXHRsaW5lYXI6IHNjYWxlX2xpbmVhcixcblx0bG9nYXJpdGhtaWM6IHNjYWxlX2xvZ2FyaXRobWljLFxuXHRyYWRpYWxMaW5lYXI6IHNjYWxlX3JhZGlhbExpbmVhcixcblx0dGltZTogc2NhbGVfdGltZVxufTtcblxudmFyIEZPUk1BVFMgPSB7XG5cdGRhdGV0aW1lOiAnTU1NIEQsIFlZWVksIGg6bW06c3MgYScsXG5cdG1pbGxpc2Vjb25kOiAnaDptbTpzcy5TU1MgYScsXG5cdHNlY29uZDogJ2g6bW06c3MgYScsXG5cdG1pbnV0ZTogJ2g6bW0gYScsXG5cdGhvdXI6ICdoQScsXG5cdGRheTogJ01NTSBEJyxcblx0d2VlazogJ2xsJyxcblx0bW9udGg6ICdNTU0gWVlZWScsXG5cdHF1YXJ0ZXI6ICdbUV1RIC0gWVlZWScsXG5cdHllYXI6ICdZWVlZJ1xufTtcblxuY29yZV9hZGFwdGVycy5fZGF0ZS5vdmVycmlkZSh0eXBlb2YgbW9tZW50ID09PSAnZnVuY3Rpb24nID8ge1xuXHRfaWQ6ICdtb21lbnQnLCAvLyBERUJVRyBPTkxZXG5cblx0Zm9ybWF0czogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEZPUk1BVFM7XG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFsdWUgPSBtb21lbnQodmFsdWUsIGZvcm1hdCk7XG5cdFx0fSBlbHNlIGlmICghKHZhbHVlIGluc3RhbmNlb2YgbW9tZW50KSkge1xuXHRcdFx0dmFsdWUgPSBtb21lbnQodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWUuaXNWYWxpZCgpID8gdmFsdWUudmFsdWVPZigpIDogbnVsbDtcblx0fSxcblxuXHRmb3JtYXQ6IGZ1bmN0aW9uKHRpbWUsIGZvcm1hdCkge1xuXHRcdHJldHVybiBtb21lbnQodGltZSkuZm9ybWF0KGZvcm1hdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbih0aW1lLCBhbW91bnQsIHVuaXQpIHtcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpLmFkZChhbW91bnQsIHVuaXQpLnZhbHVlT2YoKTtcblx0fSxcblxuXHRkaWZmOiBmdW5jdGlvbihtYXgsIG1pbiwgdW5pdCkge1xuXHRcdHJldHVybiBtb21lbnQuZHVyYXRpb24obW9tZW50KG1heCkuZGlmZihtb21lbnQobWluKSkpLmFzKHVuaXQpO1xuXHR9LFxuXG5cdHN0YXJ0T2Y6IGZ1bmN0aW9uKHRpbWUsIHVuaXQsIHdlZWtkYXkpIHtcblx0XHR0aW1lID0gbW9tZW50KHRpbWUpO1xuXHRcdGlmICh1bml0ID09PSAnaXNvV2VlaycpIHtcblx0XHRcdHJldHVybiB0aW1lLmlzb1dlZWtkYXkod2Vla2RheSkudmFsdWVPZigpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGltZS5zdGFydE9mKHVuaXQpLnZhbHVlT2YoKTtcblx0fSxcblxuXHRlbmRPZjogZnVuY3Rpb24odGltZSwgdW5pdCkge1xuXHRcdHJldHVybiBtb21lbnQodGltZSkuZW5kT2YodW5pdCkudmFsdWVPZigpO1xuXHR9LFxuXG5cdC8vIERFUFJFQ0FUSU9OU1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoKS5cblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY3JlYXRlOiBmdW5jdGlvbih0aW1lKSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKTtcblx0fSxcbn0gOiB7fSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRwbHVnaW5zOiB7XG5cdFx0ZmlsbGVyOiB7XG5cdFx0XHRwcm9wYWdhdGU6IHRydWVcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgbWFwcGVycyA9IHtcblx0ZGF0YXNldDogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0dmFyIGluZGV4ID0gc291cmNlLmZpbGw7XG5cdFx0dmFyIGNoYXJ0ID0gc291cmNlLmNoYXJ0O1xuXHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuXHRcdHZhciB2aXNpYmxlID0gbWV0YSAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KTtcblx0XHR2YXIgcG9pbnRzID0gKHZpc2libGUgJiYgbWV0YS5kYXRhc2V0Ll9jaGlsZHJlbikgfHwgW107XG5cdFx0dmFyIGxlbmd0aCA9IHBvaW50cy5sZW5ndGggfHwgMDtcblxuXHRcdHJldHVybiAhbGVuZ3RoID8gbnVsbCA6IGZ1bmN0aW9uKHBvaW50LCBpKSB7XG5cdFx0XHRyZXR1cm4gKGkgPCBsZW5ndGggJiYgcG9pbnRzW2ldLl92aWV3KSB8fCBudWxsO1xuXHRcdH07XG5cdH0sXG5cblx0Ym91bmRhcnk6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHZhciBib3VuZGFyeSA9IHNvdXJjZS5ib3VuZGFyeTtcblx0XHR2YXIgeCA9IGJvdW5kYXJ5ID8gYm91bmRhcnkueCA6IG51bGw7XG5cdFx0dmFyIHkgPSBib3VuZGFyeSA/IGJvdW5kYXJ5LnkgOiBudWxsO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiB4ID09PSBudWxsID8gcG9pbnQueCA6IHgsXG5cdFx0XHRcdHk6IHkgPT09IG51bGwgPyBwb2ludC55IDogeSxcblx0XHRcdH07XG5cdFx0fTtcblx0fVxufTtcblxuLy8gQHRvZG8gaWYgKGZpbGxbMF0gPT09ICcjJylcbmZ1bmN0aW9uIGRlY29kZUZpbGwoZWwsIGluZGV4LCBjb3VudCkge1xuXHR2YXIgbW9kZWwgPSBlbC5fbW9kZWwgfHwge307XG5cdHZhciBmaWxsID0gbW9kZWwuZmlsbDtcblx0dmFyIHRhcmdldDtcblxuXHRpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ZmlsbCA9ICEhbW9kZWwuYmFja2dyb3VuZENvbG9yO1xuXHR9XG5cblx0aWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoZmlsbCA9PT0gdHJ1ZSkge1xuXHRcdHJldHVybiAnb3JpZ2luJztcblx0fVxuXG5cdHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCwgMTApO1xuXHRpZiAoaXNGaW5pdGUodGFyZ2V0KSAmJiBNYXRoLmZsb29yKHRhcmdldCkgPT09IHRhcmdldCkge1xuXHRcdGlmIChmaWxsWzBdID09PSAnLScgfHwgZmlsbFswXSA9PT0gJysnKSB7XG5cdFx0XHR0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcblx0XHR9XG5cblx0XHRpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblxuXHRzd2l0Y2ggKGZpbGwpIHtcblx0Ly8gY29tcGF0aWJpbGl0eVxuXHRjYXNlICdib3R0b20nOlxuXHRcdHJldHVybiAnc3RhcnQnO1xuXHRjYXNlICd0b3AnOlxuXHRcdHJldHVybiAnZW5kJztcblx0Y2FzZSAnemVybyc6XG5cdFx0cmV0dXJuICdvcmlnaW4nO1xuXHQvLyBzdXBwb3J0ZWQgYm91bmRhcmllc1xuXHRjYXNlICdvcmlnaW4nOlxuXHRjYXNlICdzdGFydCc6XG5cdGNhc2UgJ2VuZCc6XG5cdFx0cmV0dXJuIGZpbGw7XG5cdC8vIGludmFsaWQgZmlsbCB2YWx1ZXNcblx0ZGVmYXVsdDpcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSkge1xuXHR2YXIgbW9kZWwgPSBzb3VyY2UuZWwuX21vZGVsIHx8IHt9O1xuXHR2YXIgc2NhbGUgPSBzb3VyY2UuZWwuX3NjYWxlIHx8IHt9O1xuXHR2YXIgZmlsbCA9IHNvdXJjZS5maWxsO1xuXHR2YXIgdGFyZ2V0ID0gbnVsbDtcblx0dmFyIGhvcml6b250YWw7XG5cblx0aWYgKGlzRmluaXRlKGZpbGwpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiB1bnRpbCB2Mywgd2Ugc3RpbGwgbmVlZCB0byBzdXBwb3J0IGJvdW5kYXJ5IHZhbHVlcyBzZXQgb25cblx0Ly8gdGhlIG1vZGVsIChzY2FsZVRvcCwgc2NhbGVCb3R0b20gYW5kIHNjYWxlWmVybykgYmVjYXVzZSBzb21lIGV4dGVybmFsIHBsdWdpbnMgYW5kXG5cdC8vIGNvbnRyb2xsZXJzIG1pZ2h0IHN0aWxsIHVzZSBpdCAoZS5nLiB0aGUgU21pdGggY2hhcnQpLlxuXG5cdGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG5cdFx0dGFyZ2V0ID0gbW9kZWwuc2NhbGVCb3R0b20gPT09IHVuZGVmaW5lZCA/IHNjYWxlLmJvdHRvbSA6IG1vZGVsLnNjYWxlQm90dG9tO1xuXHR9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG5cdFx0dGFyZ2V0ID0gbW9kZWwuc2NhbGVUb3AgPT09IHVuZGVmaW5lZCA/IHNjYWxlLnRvcCA6IG1vZGVsLnNjYWxlVG9wO1xuXHR9IGVsc2UgaWYgKG1vZGVsLnNjYWxlWmVybyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dGFyZ2V0ID0gbW9kZWwuc2NhbGVaZXJvO1xuXHR9IGVsc2UgaWYgKHNjYWxlLmdldEJhc2VQb3NpdGlvbikge1xuXHRcdHRhcmdldCA9IHNjYWxlLmdldEJhc2VQb3NpdGlvbigpO1xuXHR9IGVsc2UgaWYgKHNjYWxlLmdldEJhc2VQaXhlbCkge1xuXHRcdHRhcmdldCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuXHR9XG5cblx0aWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldCAhPT0gbnVsbCkge1xuXHRcdGlmICh0YXJnZXQueCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldC55ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0Zpbml0ZSh0YXJnZXQpKSB7XG5cdFx0XHRob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiBob3Jpem9udGFsID8gdGFyZ2V0IDogbnVsbCxcblx0XHRcdFx0eTogaG9yaXpvbnRhbCA/IG51bGwgOiB0YXJnZXRcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuXHR2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XG5cdHZhciB2aXNpdGVkID0gW2luZGV4XTtcblx0dmFyIHRhcmdldDtcblxuXHRpZiAoIXByb3BhZ2F0ZSkge1xuXHRcdHJldHVybiBmaWxsO1xuXHR9XG5cblx0d2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcblx0XHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG5cdFx0XHRyZXR1cm4gZmlsbDtcblx0XHR9XG5cblx0XHR0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuXHRcdGlmICghdGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHRhcmdldC52aXNpYmxlKSB7XG5cdFx0XHRyZXR1cm4gZmlsbDtcblx0XHR9XG5cblx0XHR2aXNpdGVkLnB1c2goZmlsbCk7XG5cdFx0ZmlsbCA9IHRhcmdldC5maWxsO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXBwZXIoc291cmNlKSB7XG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XG5cdHZhciB0eXBlID0gJ2RhdGFzZXQnO1xuXG5cdGlmIChmaWxsID09PSBmYWxzZSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0aWYgKCFpc0Zpbml0ZShmaWxsKSkge1xuXHRcdHR5cGUgPSAnYm91bmRhcnknO1xuXHR9XG5cblx0cmV0dXJuIG1hcHBlcnNbdHlwZV0oc291cmNlKTtcbn1cblxuZnVuY3Rpb24gaXNEcmF3YWJsZShwb2ludCkge1xuXHRyZXR1cm4gcG9pbnQgJiYgIXBvaW50LnNraXA7XG59XG5cbmZ1bmN0aW9uIGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpIHtcblx0dmFyIGk7XG5cblx0aWYgKCFsZW4wIHx8ICFsZW4xKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gYnVpbGRpbmcgZmlyc3QgYXJlYSBjdXJ2ZSAobm9ybWFsKVxuXHRjdHgubW92ZVRvKGN1cnZlMFswXS54LCBjdXJ2ZTBbMF0ueSk7XG5cdGZvciAoaSA9IDE7IGkgPCBsZW4wOyArK2kpIHtcblx0XHRoZWxwZXJzJDEuY2FudmFzLmxpbmVUbyhjdHgsIGN1cnZlMFtpIC0gMV0sIGN1cnZlMFtpXSk7XG5cdH1cblxuXHQvLyBqb2luaW5nIHRoZSB0d28gYXJlYSBjdXJ2ZXNcblx0Y3R4LmxpbmVUbyhjdXJ2ZTFbbGVuMSAtIDFdLngsIGN1cnZlMVtsZW4xIC0gMV0ueSk7XG5cblx0Ly8gYnVpbGRpbmcgb3Bwb3NpdGUgYXJlYSBjdXJ2ZSAocmV2ZXJzZSlcblx0Zm9yIChpID0gbGVuMSAtIDE7IGkgPiAwOyAtLWkpIHtcblx0XHRoZWxwZXJzJDEuY2FudmFzLmxpbmVUbyhjdHgsIGN1cnZlMVtpXSwgY3VydmUxW2kgLSAxXSwgdHJ1ZSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgcG9pbnRzLCBtYXBwZXIsIHZpZXcsIGNvbG9yLCBsb29wKSB7XG5cdHZhciBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cdHZhciBzcGFuID0gdmlldy5zcGFuR2Fwcztcblx0dmFyIGN1cnZlMCA9IFtdO1xuXHR2YXIgY3VydmUxID0gW107XG5cdHZhciBsZW4wID0gMDtcblx0dmFyIGxlbjEgPSAwO1xuXHR2YXIgaSwgaWxlbiwgaW5kZXgsIHAwLCBwMSwgZDAsIGQxO1xuXG5cdGN0eC5iZWdpblBhdGgoKTtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gKGNvdW50ICsgISFsb29wKTsgaSA8IGlsZW47ICsraSkge1xuXHRcdGluZGV4ID0gaSAlIGNvdW50O1xuXHRcdHAwID0gcG9pbnRzW2luZGV4XS5fdmlldztcblx0XHRwMSA9IG1hcHBlcihwMCwgaW5kZXgsIHZpZXcpO1xuXHRcdGQwID0gaXNEcmF3YWJsZShwMCk7XG5cdFx0ZDEgPSBpc0RyYXdhYmxlKHAxKTtcblxuXHRcdGlmIChkMCAmJiBkMSkge1xuXHRcdFx0bGVuMCA9IGN1cnZlMC5wdXNoKHAwKTtcblx0XHRcdGxlbjEgPSBjdXJ2ZTEucHVzaChwMSk7XG5cdFx0fSBlbHNlIGlmIChsZW4wICYmIGxlbjEpIHtcblx0XHRcdGlmICghc3Bhbikge1xuXHRcdFx0XHRkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKTtcblx0XHRcdFx0bGVuMCA9IGxlbjEgPSAwO1xuXHRcdFx0XHRjdXJ2ZTAgPSBbXTtcblx0XHRcdFx0Y3VydmUxID0gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoZDApIHtcblx0XHRcdFx0XHRjdXJ2ZTAucHVzaChwMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGQxKSB7XG5cdFx0XHRcdFx0Y3VydmUxLnB1c2gocDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSk7XG5cblx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRjdHguZmlsbFN0eWxlID0gY29sb3I7XG5cdGN0eC5maWxsKCk7XG59XG5cbnZhciBwbHVnaW5fZmlsbGVyID0ge1xuXHRpZDogJ2ZpbGxlcicsXG5cblx0YWZ0ZXJEYXRhc2V0c1VwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIG9wdGlvbnMpIHtcblx0XHR2YXIgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuXHRcdHZhciBwcm9wYWdhdGUgPSBvcHRpb25zLnByb3BhZ2F0ZTtcblx0XHR2YXIgc291cmNlcyA9IFtdO1xuXHRcdHZhciBtZXRhLCBpLCBlbCwgc291cmNlO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcblx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdGVsID0gbWV0YS5kYXRhc2V0O1xuXHRcdFx0c291cmNlID0gbnVsbDtcblxuXHRcdFx0aWYgKGVsICYmIGVsLl9tb2RlbCAmJiBlbCBpbnN0YW5jZW9mIGVsZW1lbnRzLkxpbmUpIHtcblx0XHRcdFx0c291cmNlID0ge1xuXHRcdFx0XHRcdHZpc2libGU6IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG5cdFx0XHRcdFx0ZmlsbDogZGVjb2RlRmlsbChlbCwgaSwgY291bnQpLFxuXHRcdFx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdFx0XHRlbDogZWxcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0bWV0YS4kZmlsbGVyID0gc291cmNlO1xuXHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcblx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbaV07XG5cdFx0XHRpZiAoIXNvdXJjZSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c291cmNlLmZpbGwgPSByZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIHByb3BhZ2F0ZSk7XG5cdFx0XHRzb3VyY2UuYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcblx0XHRcdHNvdXJjZS5tYXBwZXIgPSBjcmVhdGVNYXBwZXIoc291cmNlKTtcblx0XHR9XG5cdH0sXG5cblx0YmVmb3JlRGF0YXNldERyYXc6IGZ1bmN0aW9uKGNoYXJ0LCBhcmdzKSB7XG5cdFx0dmFyIG1ldGEgPSBhcmdzLm1ldGEuJGZpbGxlcjtcblx0XHRpZiAoIW1ldGEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY3R4ID0gY2hhcnQuY3R4O1xuXHRcdHZhciBlbCA9IG1ldGEuZWw7XG5cdFx0dmFyIHZpZXcgPSBlbC5fdmlldztcblx0XHR2YXIgcG9pbnRzID0gZWwuX2NoaWxkcmVuIHx8IFtdO1xuXHRcdHZhciBtYXBwZXIgPSBtZXRhLm1hcHBlcjtcblx0XHR2YXIgY29sb3IgPSB2aWV3LmJhY2tncm91bmRDb2xvciB8fCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cblx0XHRpZiAobWFwcGVyICYmIGNvbG9yICYmIHBvaW50cy5sZW5ndGgpIHtcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMuY2xpcEFyZWEoY3R4LCBjaGFydC5jaGFydEFyZWEpO1xuXHRcdFx0ZG9GaWxsKGN0eCwgcG9pbnRzLCBtYXBwZXIsIHZpZXcsIGNvbG9yLCBlbC5fbG9vcCk7XG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY3R4KTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBub29wJDEgPSBoZWxwZXJzJDEubm9vcDtcbnZhciB2YWx1ZU9yRGVmYXVsdCRkID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0bGVnZW5kOiB7XG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRwb3NpdGlvbjogJ3RvcCcsXG5cdFx0ZnVsbFdpZHRoOiB0cnVlLFxuXHRcdHJldmVyc2U6IGZhbHNlLFxuXHRcdHdlaWdodDogMTAwMCxcblxuXHRcdC8vIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGhhbmRsZVxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUsIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdHZhciBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xuXHRcdFx0dmFyIGNpID0gdGhpcy5jaGFydDtcblx0XHRcdHZhciBtZXRhID0gY2kuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuXG5cdFx0XHQvLyBTZWUgY29udHJvbGxlci5pc0RhdGFzZXRWaXNpYmxlIGNvbW1lbnRcblx0XHRcdG1ldGEuaGlkZGVuID0gbWV0YS5oaWRkZW4gPT09IG51bGwgPyAhY2kuZGF0YS5kYXRhc2V0c1tpbmRleF0uaGlkZGVuIDogbnVsbDtcblxuXHRcdFx0Ly8gV2UgaGlkIGEgZGF0YXNldCAuLi4gcmVyZW5kZXIgdGhlIGNoYXJ0XG5cdFx0XHRjaS51cGRhdGUoKTtcblx0XHR9LFxuXG5cdFx0b25Ib3ZlcjogbnVsbCxcblx0XHRvbkxlYXZlOiBudWxsLFxuXG5cdFx0bGFiZWxzOiB7XG5cdFx0XHRib3hXaWR0aDogNDAsXG5cdFx0XHRwYWRkaW5nOiAxMCxcblx0XHRcdC8vIEdlbmVyYXRlcyBsYWJlbHMgc2hvd24gaW4gdGhlIGxlZ2VuZFxuXHRcdFx0Ly8gVmFsaWQgcHJvcGVydGllcyB0byByZXR1cm46XG5cdFx0XHQvLyB0ZXh0IDogdGV4dCB0byBkaXNwbGF5XG5cdFx0XHQvLyBmaWxsU3R5bGUgOiBmaWxsIG9mIGNvbG91cmVkIGJveFxuXHRcdFx0Ly8gc3Ryb2tlU3R5bGU6IHN0cm9rZSBvZiBjb2xvdXJlZCBib3hcblx0XHRcdC8vIGhpZGRlbiA6IGlmIHRoaXMgbGVnZW5kIGl0ZW0gcmVmZXJzIHRvIGEgaGlkZGVuIGl0ZW1cblx0XHRcdC8vIGxpbmVDYXAgOiBjYXAgc3R5bGUgZm9yIGxpbmVcblx0XHRcdC8vIGxpbmVEYXNoXG5cdFx0XHQvLyBsaW5lRGFzaE9mZnNldCA6XG5cdFx0XHQvLyBsaW5lSm9pbiA6XG5cdFx0XHQvLyBsaW5lV2lkdGggOlxuXHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHRcdFx0cmV0dXJuIGhlbHBlcnMkMS5pc0FycmF5KGRhdGEuZGF0YXNldHMpID8gZGF0YS5kYXRhc2V0cy5tYXAoZnVuY3Rpb24oZGF0YXNldCwgaSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0ZXh0OiBkYXRhc2V0LmxhYmVsLFxuXHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiAoIWhlbHBlcnMkMS5pc0FycmF5KGRhdGFzZXQuYmFja2dyb3VuZENvbG9yKSA/IGRhdGFzZXQuYmFja2dyb3VuZENvbG9yIDogZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3JbMF0pLFxuXHRcdFx0XHRcdFx0aGlkZGVuOiAhY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcblx0XHRcdFx0XHRcdGxpbmVDYXA6IGRhdGFzZXQuYm9yZGVyQ2FwU3R5bGUsXG5cdFx0XHRcdFx0XHRsaW5lRGFzaDogZGF0YXNldC5ib3JkZXJEYXNoLFxuXHRcdFx0XHRcdFx0bGluZURhc2hPZmZzZXQ6IGRhdGFzZXQuYm9yZGVyRGFzaE9mZnNldCxcblx0XHRcdFx0XHRcdGxpbmVKb2luOiBkYXRhc2V0LmJvcmRlckpvaW5TdHlsZSxcblx0XHRcdFx0XHRcdGxpbmVXaWR0aDogZGF0YXNldC5ib3JkZXJXaWR0aCxcblx0XHRcdFx0XHRcdHN0cm9rZVN0eWxlOiBkYXRhc2V0LmJvcmRlckNvbG9yLFxuXHRcdFx0XHRcdFx0cG9pbnRTdHlsZTogZGF0YXNldC5wb2ludFN0eWxlLFxuXG5cdFx0XHRcdFx0XHQvLyBCZWxvdyBpcyBleHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBkYXRhc2V0c1xuXHRcdFx0XHRcdFx0ZGF0YXNldEluZGV4OiBpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSwgdGhpcykgOiBbXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0bGVnZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIHRleHQgPSBbXTtcblx0XHR0ZXh0LnB1c2goJzx1bCBjbGFzcz1cIicgKyBjaGFydC5pZCArICctbGVnZW5kXCI+Jyk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0ZXh0LnB1c2goJzxsaT48c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0uYmFja2dyb3VuZENvbG9yICsgJ1wiPjwvc3Bhbj4nKTtcblx0XHRcdGlmIChjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmxhYmVsKSB7XG5cdFx0XHRcdHRleHQucHVzaChjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmxhYmVsKTtcblx0XHRcdH1cblx0XHRcdHRleHQucHVzaCgnPC9saT4nKTtcblx0XHR9XG5cdFx0dGV4dC5wdXNoKCc8L3VsPicpO1xuXHRcdHJldHVybiB0ZXh0LmpvaW4oJycpO1xuXHR9XG59KTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBib3ggd2lkdGggYmFzZWQgb24gdGhlIHVzZVBvaW50U3R5bGUgb3B0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gbGFiZWxvcHRzIC0gdGhlIGxhYmVsIG9wdGlvbnMgb24gdGhlIGxlZ2VuZFxuICogQHBhcmFtIHtudW1iZXJ9IGZvbnRTaXplIC0gdGhlIGxhYmVsIGZvbnQgc2l6ZVxuICogQHJldHVybiB7bnVtYmVyfSB3aWR0aCBvZiB0aGUgY29sb3IgYm94IGFyZWFcbiAqL1xuZnVuY3Rpb24gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSkge1xuXHRyZXR1cm4gbGFiZWxPcHRzLnVzZVBvaW50U3R5bGUgJiYgbGFiZWxPcHRzLmJveFdpZHRoID4gZm9udFNpemUgP1xuXHRcdGZvbnRTaXplIDpcblx0XHRsYWJlbE9wdHMuYm94V2lkdGg7XG59XG5cbi8qKlxuICogSU1QT1JUQU5UOiB0aGlzIGNsYXNzIGlzIGV4cG9zZWQgcHVibGljbHkgYXMgQ2hhcnQuTGVnZW5kLCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHJlcXVpcmVkIVxuICovXG52YXIgTGVnZW5kID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0aGVscGVycyQxLmV4dGVuZCh0aGlzLCBjb25maWcpO1xuXG5cdFx0Ly8gQ29udGFpbnMgaGl0IGJveGVzIGZvciBlYWNoIGRhdGFzZXQgKGluIGRhdGFzZXQgb3JkZXIpXG5cdFx0dGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuXG5cdFx0LyoqXG4gXHRcdCAqIEBwcml2YXRlXG4gXHRcdCAqL1xuXHRcdHRoaXMuX2hvdmVyZWRJdGVtID0gbnVsbDtcblxuXHRcdC8vIEFyZSB3ZSBpbiBkb3VnaG51dCBtb2RlIHdoaWNoIGhhcyBhIGRpZmZlcmVudCBkYXRhIHR5cGVcblx0XHR0aGlzLmRvdWdobnV0TW9kZSA9IGZhbHNlO1xuXHR9LFxuXG5cdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5Y2xlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG5cdC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBsZWdlbmQgdHlwZXMuXG5cdC8vIEFueSBmdW5jdGlvbiBjYW4gYmUgZXh0ZW5kZWQgYnkgdGhlIGxlZ2VuZCB0eXBlXG5cblx0YmVmb3JlVXBkYXRlOiBub29wJDEsXG5cdHVwZGF0ZTogZnVuY3Rpb24obWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHQvLyBVcGRhdGUgTGlmZWN5Y2xlIC0gUHJvYmFibHkgZG9uJ3Qgd2FudCB0byBldmVyIGV4dGVuZCBvciBvdmVyd3JpdGUgdGhpcyBmdW5jdGlvbiA7KVxuXHRcdG1lLmJlZm9yZVVwZGF0ZSgpO1xuXG5cdFx0Ly8gQWJzb3JiIHRoZSBtYXN0ZXIgbWVhc3VyZW1lbnRzXG5cdFx0bWUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHRtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG5cdFx0bWUubWFyZ2lucyA9IG1hcmdpbnM7XG5cblx0XHQvLyBEaW1lbnNpb25zXG5cdFx0bWUuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLnNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcblx0XHQvLyBMYWJlbHNcblx0XHRtZS5iZWZvcmVCdWlsZExhYmVscygpO1xuXHRcdG1lLmJ1aWxkTGFiZWxzKCk7XG5cdFx0bWUuYWZ0ZXJCdWlsZExhYmVscygpO1xuXG5cdFx0Ly8gRml0XG5cdFx0bWUuYmVmb3JlRml0KCk7XG5cdFx0bWUuZml0KCk7XG5cdFx0bWUuYWZ0ZXJGaXQoKTtcblx0XHQvL1xuXHRcdG1lLmFmdGVyVXBkYXRlKCk7XG5cblx0XHRyZXR1cm4gbWUubWluU2l6ZTtcblx0fSxcblx0YWZ0ZXJVcGRhdGU6IG5vb3AkMSxcblxuXHQvL1xuXG5cdGJlZm9yZVNldERpbWVuc2lvbnM6IG5vb3AkMSxcblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuXHRcdFx0bWUubGVmdCA9IDA7XG5cdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUudG9wID0gMDtcblx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcblx0XHR9XG5cblx0XHQvLyBSZXNldCBwYWRkaW5nXG5cdFx0bWUucGFkZGluZ0xlZnQgPSAwO1xuXHRcdG1lLnBhZGRpbmdUb3AgPSAwO1xuXHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XG5cdFx0bWUucGFkZGluZ0JvdHRvbSA9IDA7XG5cblx0XHQvLyBSZXNldCBtaW5TaXplXG5cdFx0bWUubWluU2l6ZSA9IHtcblx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0aGVpZ2h0OiAwXG5cdFx0fTtcblx0fSxcblx0YWZ0ZXJTZXREaW1lbnNpb25zOiBub29wJDEsXG5cblx0Ly9cblxuXHRiZWZvcmVCdWlsZExhYmVsczogbm9vcCQxLFxuXHRidWlsZExhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGFiZWxPcHRzID0gbWUub3B0aW9ucy5sYWJlbHMgfHwge307XG5cdFx0dmFyIGxlZ2VuZEl0ZW1zID0gaGVscGVycyQxLmNhbGxiYWNrKGxhYmVsT3B0cy5nZW5lcmF0ZUxhYmVscywgW21lLmNoYXJ0XSwgbWUpIHx8IFtdO1xuXG5cdFx0aWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcblx0XHRcdGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0cmV0dXJuIGxhYmVsT3B0cy5maWx0ZXIoaXRlbSwgbWUuY2hhcnQuZGF0YSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAobWUub3B0aW9ucy5yZXZlcnNlKSB7XG5cdFx0XHRsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XG5cdFx0fVxuXG5cdFx0bWUubGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcztcblx0fSxcblx0YWZ0ZXJCdWlsZExhYmVsczogbm9vcCQxLFxuXG5cdC8vXG5cblx0YmVmb3JlRml0OiBub29wJDEsXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGxhYmVsT3B0cyA9IG9wdHMubGFiZWxzO1xuXHRcdHZhciBkaXNwbGF5ID0gb3B0cy5kaXNwbGF5O1xuXG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcblxuXHRcdHZhciBsYWJlbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KGxhYmVsT3B0cyk7XG5cdFx0dmFyIGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG5cblx0XHQvLyBSZXNldCBoaXQgYm94ZXNcblx0XHR2YXIgaGl0Ym94ZXMgPSBtZS5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuXG5cdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdG1pblNpemUud2lkdGggPSBtZS5tYXhXaWR0aDsgLy8gZmlsbCBhbGwgdGhlIHdpZHRoXG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IGRpc3BsYXkgPyAxMCA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1pblNpemUud2lkdGggPSBkaXNwbGF5ID8gMTAgOiAwO1xuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcblx0XHR9XG5cblx0XHQvLyBJbmNyZWFzZSBzaXplcyBoZXJlXG5cdFx0aWYgKGRpc3BsYXkpIHtcblx0XHRcdGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHQvLyBMYWJlbHNcblxuXHRcdFx0XHQvLyBXaWR0aCBvZiBlYWNoIGxpbmUgb2YgbGVnZW5kIGJveGVzLiBMYWJlbHMgd3JhcCBvbnRvIG11bHRpcGxlIGxpbmVzIHdoZW4gdGhlcmUgYXJlIHRvbyBtYW55IHRvIGZpdCBvbiBvbmVcblx0XHRcdFx0dmFyIGxpbmVXaWR0aHMgPSBtZS5saW5lV2lkdGhzID0gWzBdO1xuXHRcdFx0XHR2YXIgdG90YWxIZWlnaHQgPSAwO1xuXG5cdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG5cdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXHRcdFx0XHRcdHZhciB3aWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcblxuXHRcdFx0XHRcdGlmIChpID09PSAwIHx8IGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArIHdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmcgPiBtaW5TaXplLndpZHRoKSB7XG5cdFx0XHRcdFx0XHR0b3RhbEhlaWdodCArPSBmb250U2l6ZSArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdFx0bGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIChpID4gMCA/IDAgOiAxKV0gPSBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxuXHRcdFx0XHRcdGhpdGJveGVzW2ldID0ge1xuXHRcdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogZm9udFNpemVcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0bGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IHdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdG1pblNpemUuaGVpZ2h0ICs9IHRvdGFsSGVpZ2h0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgdlBhZGRpbmcgPSBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0dmFyIGNvbHVtbldpZHRocyA9IG1lLmNvbHVtbldpZHRocyA9IFtdO1xuXHRcdFx0XHR2YXIgdG90YWxXaWR0aCA9IGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHR2YXIgY3VycmVudENvbFdpZHRoID0gMDtcblx0XHRcdFx0dmFyIGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuXHRcdFx0XHR2YXIgaXRlbUhlaWdodCA9IGZvbnRTaXplICsgdlBhZGRpbmc7XG5cblx0XHRcdFx0aGVscGVycyQxLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcblx0XHRcdFx0XHR2YXIgYm94V2lkdGggPSBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKTtcblx0XHRcdFx0XHR2YXIgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG5cdFx0XHRcdFx0Ly8gSWYgdG9vIHRhbGwsIGdvIHRvIG5ldyBjb2x1bW5cblx0XHRcdFx0XHRpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgPiBtaW5TaXplLmhlaWdodCAtIHZQYWRkaW5nKSB7XG5cdFx0XHRcdFx0XHR0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdFx0Y29sdW1uV2lkdGhzLnB1c2goY3VycmVudENvbFdpZHRoKTsgLy8gcHJldmlvdXMgY29sdW1uIHdpZHRoXG5cblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xXaWR0aCA9IDA7XG5cdFx0XHRcdFx0XHRjdXJyZW50Q29sSGVpZ2h0ID0gMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBHZXQgbWF4IHdpZHRoXG5cdFx0XHRcdFx0Y3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuXHRcdFx0XHRcdGN1cnJlbnRDb2xIZWlnaHQgKz0gaXRlbUhlaWdodDtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXG5cdFx0XHRcdFx0aGl0Ym94ZXNbaV0gPSB7XG5cdFx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0d2lkdGg6IGl0ZW1XaWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogZm9udFNpemVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcblx0XHRcdFx0Y29sdW1uV2lkdGhzLnB1c2goY3VycmVudENvbFdpZHRoKTtcblx0XHRcdFx0bWluU2l6ZS53aWR0aCArPSB0b3RhbFdpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aDtcblx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcblx0fSxcblx0YWZ0ZXJGaXQ6IG5vb3AkMSxcblxuXHQvLyBTaGFyZWQgTWV0aG9kc1xuXHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG5cdH0sXG5cblx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgbGVnZW5kIG9uIHRoZSBjYW52YXNcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGxhYmVsT3B0cyA9IG9wdHMubGFiZWxzO1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBkZWZhdWx0Q29sb3IgPSBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Q29sb3I7XG5cdFx0dmFyIGxpbmVEZWZhdWx0ID0gZ2xvYmFsRGVmYXVsdHMuZWxlbWVudHMubGluZTtcblx0XHR2YXIgbGVnZW5kV2lkdGggPSBtZS53aWR0aDtcblx0XHR2YXIgbGluZVdpZHRocyA9IG1lLmxpbmVXaWR0aHM7XG5cblx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXHRcdFx0dmFyIGZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JGQobGFiZWxPcHRzLmZvbnRDb2xvciwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0XHR2YXIgbGFiZWxGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChsYWJlbE9wdHMpO1xuXHRcdFx0dmFyIGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG5cdFx0XHR2YXIgY3Vyc29yO1xuXG5cdFx0XHQvLyBDYW52YXMgc2V0dXBcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gMC41O1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gZm9udENvbG9yOyAvLyBmb3Igc3RyaWtldGhyb3VnaCBlZmZlY3Rcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBmb250Q29sb3I7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXHRcdFx0Y3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG5cdFx0XHR2YXIgYm94V2lkdGggPSBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKTtcblx0XHRcdHZhciBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzO1xuXG5cdFx0XHQvLyBjdXJyZW50IHBvc2l0aW9uXG5cdFx0XHR2YXIgZHJhd0xlZ2VuZEJveCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdFx0aWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBjdHggZm9yIHRoZSBib3hcblx0XHRcdFx0Y3R4LnNhdmUoKTtcblxuXHRcdFx0XHR2YXIgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgbGluZURlZmF1bHQuYm9yZGVyV2lkdGgpO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLmZpbGxTdHlsZSwgZGVmYXVsdENvbG9yKTtcblx0XHRcdFx0Y3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0ubGluZUNhcCwgbGluZURlZmF1bHQuYm9yZGVyQ2FwU3R5bGUpO1xuXHRcdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIGxpbmVEZWZhdWx0LmJvcmRlckRhc2hPZmZzZXQpO1xuXHRcdFx0XHRjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0ubGluZUpvaW4sIGxpbmVEZWZhdWx0LmJvcmRlckpvaW5TdHlsZSk7XG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcblxuXHRcdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0XHRcdFx0Ly8gSUUgOSBhbmQgMTAgZG8gbm90IHN1cHBvcnQgbGluZSBkYXNoXG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lRGFzaCwgbGluZURlZmF1bHQuYm9yZGVyRGFzaCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdHMubGFiZWxzICYmIG9wdHMubGFiZWxzLnVzZVBvaW50U3R5bGUpIHtcblx0XHRcdFx0XHQvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3Rpbmdcblx0XHRcdFx0XHQvLyB4IGFuZCB5IHRvIGJlIGNlbnRlciBvZiBmaWd1cmUgKGluc3RlYWQgb2YgdG9wIGxlZnQpXG5cdFx0XHRcdFx0dmFyIHJhZGl1cyA9IGJveFdpZHRoICogTWF0aC5TUVJUMiAvIDI7XG5cdFx0XHRcdFx0dmFyIGNlbnRlclggPSB4ICsgYm94V2lkdGggLyAyO1xuXHRcdFx0XHRcdHZhciBjZW50ZXJZID0geSArIGZvbnRTaXplIC8gMjtcblxuXHRcdFx0XHRcdC8vIERyYXcgcG9pbnRTdHlsZSBhcyBsZWdlbmQgc3ltYm9sXG5cdFx0XHRcdFx0aGVscGVycyQxLmNhbnZhcy5kcmF3UG9pbnQoY3R4LCBsZWdlbmRJdGVtLnBvaW50U3R5bGUsIHJhZGl1cywgY2VudGVyWCwgY2VudGVyWSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gRHJhdyBib3ggYXMgbGVnZW5kIHN5bWJvbFxuXHRcdFx0XHRcdGlmIChsaW5lV2lkdGggIT09IDApIHtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2VSZWN0KHgsIHksIGJveFdpZHRoLCBmb250U2l6ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5maWxsUmVjdCh4LCB5LCBib3hXaWR0aCwgZm9udFNpemUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdH07XG5cdFx0XHR2YXIgZmlsbFRleHQgPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtLCB0ZXh0V2lkdGgpIHtcblx0XHRcdFx0dmFyIGhhbGZGb250U2l6ZSA9IGZvbnRTaXplIC8gMjtcblx0XHRcdFx0dmFyIHhMZWZ0ID0gYm94V2lkdGggKyBoYWxmRm9udFNpemUgKyB4O1xuXHRcdFx0XHR2YXIgeU1pZGRsZSA9IHkgKyBoYWxmRm9udFNpemU7XG5cblx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxlZ2VuZEl0ZW0udGV4dCwgeExlZnQsIHlNaWRkbGUpO1xuXG5cdFx0XHRcdGlmIChsZWdlbmRJdGVtLmhpZGRlbikge1xuXHRcdFx0XHRcdC8vIFN0cmlrZXRocm91Z2ggdGhlIHRleHQgaWYgaGlkZGVuXG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSAyO1xuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oeExlZnQsIHlNaWRkbGUpO1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeExlZnQgKyB0ZXh0V2lkdGgsIHlNaWRkbGUpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gSG9yaXpvbnRhbFxuXHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRjdXJzb3IgPSB7XG5cdFx0XHRcdFx0eDogbWUubGVmdCArICgobGVnZW5kV2lkdGggLSBsaW5lV2lkdGhzWzBdKSAvIDIpICsgbGFiZWxPcHRzLnBhZGRpbmcsXG5cdFx0XHRcdFx0eTogbWUudG9wICsgbGFiZWxPcHRzLnBhZGRpbmcsXG5cdFx0XHRcdFx0bGluZTogMFxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3Vyc29yID0ge1xuXHRcdFx0XHRcdHg6IG1lLmxlZnQgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHR5OiBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHRsaW5lOiAwXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpdGVtSGVpZ2h0ID0gZm9udFNpemUgKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLmxlZ2VuZEl0ZW1zLCBmdW5jdGlvbihsZWdlbmRJdGVtLCBpKSB7XG5cdFx0XHRcdHZhciB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcblx0XHRcdFx0dmFyIHdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIHRleHRXaWR0aDtcblx0XHRcdFx0dmFyIHggPSBjdXJzb3IueDtcblx0XHRcdFx0dmFyIHkgPSBjdXJzb3IueTtcblxuXHRcdFx0XHQvLyBVc2UgKG1lLmxlZnQgKyBtZS5taW5TaXplLndpZHRoKSBhbmQgKG1lLnRvcCArIG1lLm1pblNpemUuaGVpZ2h0KVxuXHRcdFx0XHQvLyBpbnN0ZWFkIG9mIG1lLnJpZ2h0IGFuZCBtZS5ib3R0b20gYmVjYXVzZSBtZS53aWR0aCBhbmQgbWUuaGVpZ2h0XG5cdFx0XHRcdC8vIG1heSBoYXZlIGJlZW4gY2hhbmdlZCBzaW5jZSBtZS5taW5TaXplIHdhcyBjYWxjdWxhdGVkXG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHRpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmcgPiBtZS5sZWZ0ICsgbWUubWluU2l6ZS53aWR0aCkge1xuXHRcdFx0XHRcdFx0eSA9IGN1cnNvci55ICs9IGl0ZW1IZWlnaHQ7XG5cdFx0XHRcdFx0XHRjdXJzb3IubGluZSsrO1xuXHRcdFx0XHRcdFx0eCA9IGN1cnNvci54ID0gbWUubGVmdCArICgobGVnZW5kV2lkdGggLSBsaW5lV2lkdGhzW2N1cnNvci5saW5lXSkgLyAyKSArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChpID4gMCAmJiB5ICsgaXRlbUhlaWdodCA+IG1lLnRvcCArIG1lLm1pblNpemUuaGVpZ2h0KSB7XG5cdFx0XHRcdFx0eCA9IGN1cnNvci54ID0geCArIG1lLmNvbHVtbldpZHRoc1tjdXJzb3IubGluZV0gKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHR5ID0gY3Vyc29yLnkgPSBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHRjdXJzb3IubGluZSsrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZHJhd0xlZ2VuZEJveCh4LCB5LCBsZWdlbmRJdGVtKTtcblxuXHRcdFx0XHRoaXRib3hlc1tpXS5sZWZ0ID0geDtcblx0XHRcdFx0aGl0Ym94ZXNbaV0udG9wID0geTtcblxuXHRcdFx0XHQvLyBGaWxsIHRoZSBhY3R1YWwgbGFiZWxcblx0XHRcdFx0ZmlsbFRleHQoeCwgeSwgbGVnZW5kSXRlbSwgdGV4dFdpZHRoKTtcblxuXHRcdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0Y3Vyc29yLnggKz0gd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdXJzb3IueSArPSBpdGVtSGVpZ2h0O1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRMZWdlbmRJdGVtQXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpLCBoaXRCb3gsIGxoO1xuXG5cdFx0aWYgKHggPj0gbWUubGVmdCAmJiB4IDw9IG1lLnJpZ2h0ICYmIHkgPj0gbWUudG9wICYmIHkgPD0gbWUuYm90dG9tKSB7XG5cdFx0XHQvLyBTZWUgaWYgd2UgYXJlIHRvdWNoaW5nIG9uZSBvZiB0aGUgZGF0YXNldCBib3hlc1xuXHRcdFx0bGggPSBtZS5sZWdlbmRIaXRCb3hlcztcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRoaXRCb3ggPSBsaFtpXTtcblxuXHRcdFx0XHRpZiAoeCA+PSBoaXRCb3gubGVmdCAmJiB4IDw9IGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoICYmIHkgPj0gaGl0Qm94LnRvcCAmJiB5IDw9IGhpdEJveC50b3AgKyBoaXRCb3guaGVpZ2h0KSB7XG5cdFx0XHRcdFx0Ly8gVG91Y2hpbmcgYW4gZWxlbWVudFxuXHRcdFx0XHRcdHJldHVybiBtZS5sZWdlbmRJdGVtc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKi9cblx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgdHlwZSA9IGUudHlwZSA9PT0gJ21vdXNldXAnID8gJ2NsaWNrJyA6IGUudHlwZTtcblx0XHR2YXIgaG92ZXJlZEl0ZW07XG5cblx0XHRpZiAodHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcblx0XHRcdGlmICghb3B0cy5vbkhvdmVyICYmICFvcHRzLm9uTGVhdmUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0aWYgKCFvcHRzLm9uQ2xpY2spIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2hhcnQgZXZlbnQgYWxyZWFkeSBoYXMgcmVsYXRpdmUgcG9zaXRpb24gaW4gaXRcblx0XHRob3ZlcmVkSXRlbSA9IG1lLl9nZXRMZWdlbmRJdGVtQXQoZS54LCBlLnkpO1xuXG5cdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdGlmIChob3ZlcmVkSXRlbSAmJiBvcHRzLm9uQ2xpY2spIHtcblx0XHRcdFx0Ly8gdXNlIGUubmF0aXZlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRvcHRzLm9uQ2xpY2suY2FsbChtZSwgZS5uYXRpdmUsIGhvdmVyZWRJdGVtKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKG9wdHMub25MZWF2ZSAmJiBob3ZlcmVkSXRlbSAhPT0gbWUuX2hvdmVyZWRJdGVtKSB7XG5cdFx0XHRcdGlmIChtZS5faG92ZXJlZEl0ZW0pIHtcblx0XHRcdFx0XHRvcHRzLm9uTGVhdmUuY2FsbChtZSwgZS5uYXRpdmUsIG1lLl9ob3ZlcmVkSXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWUuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRzLm9uSG92ZXIgJiYgaG92ZXJlZEl0ZW0pIHtcblx0XHRcdFx0Ly8gdXNlIGUubmF0aXZlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRvcHRzLm9uSG92ZXIuY2FsbChtZSwgZS5uYXRpdmUsIGhvdmVyZWRJdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpIHtcblx0dmFyIGxlZ2VuZCA9IG5ldyBMZWdlbmQoe1xuXHRcdGN0eDogY2hhcnQuY3R4LFxuXHRcdG9wdGlvbnM6IGxlZ2VuZE9wdHMsXG5cdFx0Y2hhcnQ6IGNoYXJ0XG5cdH0pO1xuXG5cdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgbGVnZW5kT3B0cyk7XG5cdGNvcmVfbGF5b3V0cy5hZGRCb3goY2hhcnQsIGxlZ2VuZCk7XG5cdGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbn1cblxudmFyIHBsdWdpbl9sZWdlbmQgPSB7XG5cdGlkOiAnbGVnZW5kJyxcblxuXHQvKipcblx0ICogQmFja3dhcmQgY29tcGF0aWJpbGl0eTogc2luY2UgMi4xLjUsIHRoZSBsZWdlbmQgaXMgcmVnaXN0ZXJlZCBhcyBhIHBsdWdpbiwgbWFraW5nXG5cdCAqIENoYXJ0LkxlZ2VuZCBvYnNvbGV0ZS4gVG8gYXZvaWQgYSBicmVha2luZyBjaGFuZ2UsIHdlIGV4cG9ydCB0aGUgTGVnZW5kIGFzIHBhcnQgb2Zcblx0ICogdGhlIHBsdWdpbiwgd2hpY2ggb25lIHdpbGwgYmUgcmUtZXhwb3NlZCBpbiB0aGUgY2hhcnQuanMgZmlsZS5cblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC8yNjQwXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZWxlbWVudDogTGVnZW5kLFxuXG5cdGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIGxlZ2VuZE9wdHMgPSBjaGFydC5vcHRpb25zLmxlZ2VuZDtcblxuXHRcdGlmIChsZWdlbmRPcHRzKSB7XG5cdFx0XHRjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpO1xuXHRcdH1cblx0fSxcblxuXHRiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIGxlZ2VuZE9wdHMgPSBjaGFydC5vcHRpb25zLmxlZ2VuZDtcblx0XHR2YXIgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuXG5cdFx0aWYgKGxlZ2VuZE9wdHMpIHtcblx0XHRcdGhlbHBlcnMkMS5tZXJnZUlmKGxlZ2VuZE9wdHMsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmxlZ2VuZCk7XG5cblx0XHRcdGlmIChsZWdlbmQpIHtcblx0XHRcdFx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBsZWdlbmRPcHRzKTtcblx0XHRcdFx0bGVnZW5kLm9wdGlvbnMgPSBsZWdlbmRPcHRzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoKGNoYXJ0LCBsZWdlbmRPcHRzKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGxlZ2VuZCkge1xuXHRcdFx0Y29yZV9sYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbGVnZW5kKTtcblx0XHRcdGRlbGV0ZSBjaGFydC5sZWdlbmQ7XG5cdFx0fVxuXHR9LFxuXG5cdGFmdGVyRXZlbnQ6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XG5cdFx0dmFyIGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcblx0XHRpZiAobGVnZW5kKSB7XG5cdFx0XHRsZWdlbmQuaGFuZGxlRXZlbnQoZSk7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgbm9vcCQyID0gaGVscGVycyQxLm5vb3A7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHR0aXRsZToge1xuXHRcdGRpc3BsYXk6IGZhbHNlLFxuXHRcdGZvbnRTdHlsZTogJ2JvbGQnLFxuXHRcdGZ1bGxXaWR0aDogdHJ1ZSxcblx0XHRwYWRkaW5nOiAxMCxcblx0XHRwb3NpdGlvbjogJ3RvcCcsXG5cdFx0dGV4dDogJycsXG5cdFx0d2VpZ2h0OiAyMDAwICAgICAgICAgLy8gYnkgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVnZW5kICgxMDAwKSB0byBiZSBhYm92ZVxuXHR9XG59KTtcblxuLyoqXG4gKiBJTVBPUlRBTlQ6IHRoaXMgY2xhc3MgaXMgZXhwb3NlZCBwdWJsaWNseSBhcyBDaGFydC5MZWdlbmQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgcmVxdWlyZWQhXG4gKi9cbnZhciBUaXRsZSA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGhlbHBlcnMkMS5leHRlbmQobWUsIGNvbmZpZyk7XG5cblx0XHQvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcblx0XHRtZS5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuXHR9LFxuXG5cdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5Y2xlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG5cblx0YmVmb3JlVXBkYXRlOiBub29wJDIsXG5cdHVwZGF0ZTogZnVuY3Rpb24obWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHQvLyBVcGRhdGUgTGlmZWN5Y2xlIC0gUHJvYmFibHkgZG9uJ3Qgd2FudCB0byBldmVyIGV4dGVuZCBvciBvdmVyd3JpdGUgdGhpcyBmdW5jdGlvbiA7KVxuXHRcdG1lLmJlZm9yZVVwZGF0ZSgpO1xuXG5cdFx0Ly8gQWJzb3JiIHRoZSBtYXN0ZXIgbWVhc3VyZW1lbnRzXG5cdFx0bWUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHRtZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG5cdFx0bWUubWFyZ2lucyA9IG1hcmdpbnM7XG5cblx0XHQvLyBEaW1lbnNpb25zXG5cdFx0bWUuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLnNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcblx0XHQvLyBMYWJlbHNcblx0XHRtZS5iZWZvcmVCdWlsZExhYmVscygpO1xuXHRcdG1lLmJ1aWxkTGFiZWxzKCk7XG5cdFx0bWUuYWZ0ZXJCdWlsZExhYmVscygpO1xuXG5cdFx0Ly8gRml0XG5cdFx0bWUuYmVmb3JlRml0KCk7XG5cdFx0bWUuZml0KCk7XG5cdFx0bWUuYWZ0ZXJGaXQoKTtcblx0XHQvL1xuXHRcdG1lLmFmdGVyVXBkYXRlKCk7XG5cblx0XHRyZXR1cm4gbWUubWluU2l6ZTtcblxuXHR9LFxuXHRhZnRlclVwZGF0ZTogbm9vcCQyLFxuXG5cdC8vXG5cblx0YmVmb3JlU2V0RGltZW5zaW9uczogbm9vcCQyLFxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0XHRtZS5sZWZ0ID0gMDtcblx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS50b3AgPSAwO1xuXHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHBhZGRpbmdcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XG5cdFx0bWUucGFkZGluZ1RvcCA9IDA7XG5cdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcblxuXHRcdC8vIFJlc2V0IG1pblNpemVcblx0XHRtZS5taW5TaXplID0ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9O1xuXHR9LFxuXHRhZnRlclNldERpbWVuc2lvbnM6IG5vb3AkMixcblxuXHQvL1xuXG5cdGJlZm9yZUJ1aWxkTGFiZWxzOiBub29wJDIsXG5cdGJ1aWxkTGFiZWxzOiBub29wJDIsXG5cdGFmdGVyQnVpbGRMYWJlbHM6IG5vb3AkMixcblxuXHQvL1xuXG5cdGJlZm9yZUZpdDogbm9vcCQyLFxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBkaXNwbGF5ID0gb3B0cy5kaXNwbGF5O1xuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZTtcblx0XHR2YXIgbGluZUNvdW50ID0gaGVscGVycyQxLmlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xuXHRcdHZhciBmb250T3B0cyA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQob3B0cyk7XG5cdFx0dmFyIHRleHRTaXplID0gZGlzcGxheSA/IChsaW5lQ291bnQgKiBmb250T3B0cy5saW5lSGVpZ2h0KSArIChvcHRzLnBhZGRpbmcgKiAyKSA6IDA7XG5cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdG1pblNpemUud2lkdGggPSBtZS5tYXhXaWR0aDsgLy8gZmlsbCBhbGwgdGhlIHdpZHRoXG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IHRleHRTaXplO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gdGV4dFNpemU7XG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuXHRcdH1cblxuXHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aDtcblx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcblxuXHR9LFxuXHRhZnRlckZpdDogbm9vcCQyLFxuXG5cdC8vIFNoYXJlZCBNZXRob2RzXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcblx0XHRyZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuXHR9LFxuXG5cdC8vIEFjdHVhbGx5IGRyYXcgdGhlIHRpdGxlIGJsb2NrIG9uIHRoZSBjYW52YXNcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblxuXHRcdGlmIChvcHRzLmRpc3BsYXkpIHtcblx0XHRcdHZhciBmb250T3B0cyA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQob3B0cyk7XG5cdFx0XHR2YXIgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyBvcHRzLnBhZGRpbmc7XG5cdFx0XHR2YXIgcm90YXRpb24gPSAwO1xuXHRcdFx0dmFyIHRvcCA9IG1lLnRvcDtcblx0XHRcdHZhciBsZWZ0ID0gbWUubGVmdDtcblx0XHRcdHZhciBib3R0b20gPSBtZS5ib3R0b207XG5cdFx0XHR2YXIgcmlnaHQgPSBtZS5yaWdodDtcblx0XHRcdHZhciBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG5cblx0XHRcdGN0eC5maWxsU3R5bGUgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQob3B0cy5mb250Q29sb3IsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3IpOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcblx0XHRcdGN0eC5mb250ID0gZm9udE9wdHMuc3RyaW5nO1xuXG5cdFx0XHQvLyBIb3Jpem9udGFsXG5cdFx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0dGl0bGVYID0gbGVmdCArICgocmlnaHQgLSBsZWZ0KSAvIDIpOyAvLyBtaWRwb2ludCBvZiB0aGUgd2lkdGhcblx0XHRcdFx0dGl0bGVZID0gdG9wICsgb2Zmc2V0O1xuXHRcdFx0XHRtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRpdGxlWCA9IG9wdHMucG9zaXRpb24gPT09ICdsZWZ0JyA/IGxlZnQgKyBvZmZzZXQgOiByaWdodCAtIG9mZnNldDtcblx0XHRcdFx0dGl0bGVZID0gdG9wICsgKChib3R0b20gLSB0b3ApIC8gMik7XG5cdFx0XHRcdG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xuXHRcdFx0XHRyb3RhdGlvbiA9IE1hdGguUEkgKiAob3B0cy5wb3NpdGlvbiA9PT0gJ2xlZnQnID8gLTAuNSA6IDAuNSk7XG5cdFx0XHR9XG5cblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHgudHJhbnNsYXRlKHRpdGxlWCwgdGl0bGVZKTtcblx0XHRcdGN0eC5yb3RhdGUocm90YXRpb24pO1xuXHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG5cdFx0XHR2YXIgdGV4dCA9IG9wdHMudGV4dDtcblx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0ZXh0KSkge1xuXHRcdFx0XHR2YXIgeSA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0W2ldLCAwLCB5LCBtYXhXaWR0aCk7XG5cdFx0XHRcdFx0eSArPSBsaW5lSGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHguZmlsbFRleHQodGV4dCwgMCwgMCwgbWF4V2lkdGgpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld1RpdGxlQmxvY2tBbmRBdHRhY2goY2hhcnQsIHRpdGxlT3B0cykge1xuXHR2YXIgdGl0bGUgPSBuZXcgVGl0bGUoe1xuXHRcdGN0eDogY2hhcnQuY3R4LFxuXHRcdG9wdGlvbnM6IHRpdGxlT3B0cyxcblx0XHRjaGFydDogY2hhcnRcblx0fSk7XG5cblx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG5cdGNvcmVfbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcblx0Y2hhcnQudGl0bGVCbG9jayA9IHRpdGxlO1xufVxuXG52YXIgcGx1Z2luX3RpdGxlID0ge1xuXHRpZDogJ3RpdGxlJyxcblxuXHQvKipcblx0ICogQmFja3dhcmQgY29tcGF0aWJpbGl0eTogc2luY2UgMi4xLjUsIHRoZSB0aXRsZSBpcyByZWdpc3RlcmVkIGFzIGEgcGx1Z2luLCBtYWtpbmdcblx0ICogQ2hhcnQuVGl0bGUgb2Jzb2xldGUuIFRvIGF2b2lkIGEgYnJlYWtpbmcgY2hhbmdlLCB3ZSBleHBvcnQgdGhlIFRpdGxlIGFzIHBhcnQgb2Zcblx0ICogdGhlIHBsdWdpbiwgd2hpY2ggb25lIHdpbGwgYmUgcmUtZXhwb3NlZCBpbiB0aGUgY2hhcnQuanMgZmlsZS5cblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC8yNjQwXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZWxlbWVudDogVGl0bGUsXG5cblx0YmVmb3JlSW5pdDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgdGl0bGVPcHRzID0gY2hhcnQub3B0aW9ucy50aXRsZTtcblxuXHRcdGlmICh0aXRsZU9wdHMpIHtcblx0XHRcdGNyZWF0ZU5ld1RpdGxlQmxvY2tBbmRBdHRhY2goY2hhcnQsIHRpdGxlT3B0cyk7XG5cdFx0fVxuXHR9LFxuXG5cdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgdGl0bGVPcHRzID0gY2hhcnQub3B0aW9ucy50aXRsZTtcblx0XHR2YXIgdGl0bGVCbG9jayA9IGNoYXJ0LnRpdGxlQmxvY2s7XG5cblx0XHRpZiAodGl0bGVPcHRzKSB7XG5cdFx0XHRoZWxwZXJzJDEubWVyZ2VJZih0aXRsZU9wdHMsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLnRpdGxlKTtcblxuXHRcdFx0aWYgKHRpdGxlQmxvY2spIHtcblx0XHRcdFx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGVCbG9jaywgdGl0bGVPcHRzKTtcblx0XHRcdFx0dGl0bGVCbG9jay5vcHRpb25zID0gdGl0bGVPcHRzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRpdGxlQmxvY2spIHtcblx0XHRcdGNvcmVfbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHRpdGxlQmxvY2spO1xuXHRcdFx0ZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgcGx1Z2lucyA9IHt9O1xudmFyIGZpbGxlciA9IHBsdWdpbl9maWxsZXI7XG52YXIgbGVnZW5kID0gcGx1Z2luX2xlZ2VuZDtcbnZhciB0aXRsZSA9IHBsdWdpbl90aXRsZTtcbnBsdWdpbnMuZmlsbGVyID0gZmlsbGVyO1xucGx1Z2lucy5sZWdlbmQgPSBsZWdlbmQ7XG5wbHVnaW5zLnRpdGxlID0gdGl0bGU7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydFxuICovXG5cblxuY29yZV9jb250cm9sbGVyLmhlbHBlcnMgPSBoZWxwZXJzJDE7XG5cbi8vIEB0b2RvIGRpc3BhdGNoIHRoZXNlIGhlbHBlcnMgaW50byBhcHByb3ByaWF0ZWQgaGVscGVycy9oZWxwZXJzLiogZmlsZSBhbmQgd3JpdGUgdW5pdCB0ZXN0cyFcbmNvcmVfaGVscGVycyhjb3JlX2NvbnRyb2xsZXIpO1xuXG5jb3JlX2NvbnRyb2xsZXIuX2FkYXB0ZXJzID0gY29yZV9hZGFwdGVycztcbmNvcmVfY29udHJvbGxlci5BbmltYXRpb24gPSBjb3JlX2FuaW1hdGlvbjtcbmNvcmVfY29udHJvbGxlci5hbmltYXRpb25TZXJ2aWNlID0gY29yZV9hbmltYXRpb25zO1xuY29yZV9jb250cm9sbGVyLmNvbnRyb2xsZXJzID0gY29udHJvbGxlcnM7XG5jb3JlX2NvbnRyb2xsZXIuRGF0YXNldENvbnRyb2xsZXIgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyO1xuY29yZV9jb250cm9sbGVyLmRlZmF1bHRzID0gY29yZV9kZWZhdWx0cztcbmNvcmVfY29udHJvbGxlci5FbGVtZW50ID0gY29yZV9lbGVtZW50O1xuY29yZV9jb250cm9sbGVyLmVsZW1lbnRzID0gZWxlbWVudHM7XG5jb3JlX2NvbnRyb2xsZXIuSW50ZXJhY3Rpb24gPSBjb3JlX2ludGVyYWN0aW9uO1xuY29yZV9jb250cm9sbGVyLmxheW91dHMgPSBjb3JlX2xheW91dHM7XG5jb3JlX2NvbnRyb2xsZXIucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbmNvcmVfY29udHJvbGxlci5wbHVnaW5zID0gY29yZV9wbHVnaW5zO1xuY29yZV9jb250cm9sbGVyLlNjYWxlID0gY29yZV9zY2FsZTtcbmNvcmVfY29udHJvbGxlci5zY2FsZVNlcnZpY2UgPSBjb3JlX3NjYWxlU2VydmljZTtcbmNvcmVfY29udHJvbGxlci5UaWNrcyA9IGNvcmVfdGlja3M7XG5jb3JlX2NvbnRyb2xsZXIuVG9vbHRpcCA9IGNvcmVfdG9vbHRpcDtcblxuLy8gUmVnaXN0ZXIgYnVpbHQtaW4gc2NhbGVzXG5cbmNvcmVfY29udHJvbGxlci5oZWxwZXJzLmVhY2goc2NhbGVzLCBmdW5jdGlvbihzY2FsZSwgdHlwZSkge1xuXHRjb3JlX2NvbnRyb2xsZXIuc2NhbGVTZXJ2aWNlLnJlZ2lzdGVyU2NhbGVUeXBlKHR5cGUsIHNjYWxlLCBzY2FsZS5fZGVmYXVsdHMpO1xufSk7XG5cbi8vIExvYWQgdG8gcmVnaXN0ZXIgYnVpbHQtaW4gYWRhcHRlcnMgKGFzIHNpZGUgZWZmZWN0cylcblxuXG4vLyBMb2FkaW5nIGJ1aWx0LWluIHBsdWdpbnNcblxuZm9yICh2YXIgayBpbiBwbHVnaW5zKSB7XG5cdGlmIChwbHVnaW5zLmhhc093blByb3BlcnR5KGspKSB7XG5cdFx0Y29yZV9jb250cm9sbGVyLnBsdWdpbnMucmVnaXN0ZXIocGx1Z2luc1trXSk7XG5cdH1cbn1cblxuY29yZV9jb250cm9sbGVyLnBsYXRmb3JtLmluaXRpYWxpemUoKTtcblxudmFyIHNyYyA9IGNvcmVfY29udHJvbGxlcjtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHR3aW5kb3cuQ2hhcnQgPSBjb3JlX2NvbnRyb2xsZXI7XG59XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuQ2hhcnRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5DaGFydCA9IGNvcmVfY29udHJvbGxlcjtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkxlZ2VuZFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjEuNVxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLkxlZ2VuZCA9IHBsdWdpbnMubGVnZW5kLl9lbGVtZW50O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGl0bGVcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjVcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5UaXRsZSA9IHBsdWdpbnMudGl0bGUuX2VsZW1lbnQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5wbHVnaW5zIGluc3RlYWRcbiAqIEBuYW1lc3BhY2UgQ2hhcnQucGx1Z2luU2VydmljZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjEuNVxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLnBsdWdpblNlcnZpY2UgPSBjb3JlX2NvbnRyb2xsZXIucGx1Z2lucztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgaW5oZXJpdGluZyBmcm9tIENoYXJ0LlBsdWdpbmdCYXNlIGhhcyBub1xuICogZWZmZWN0LCBpbnN0ZWFkIHNpbXBseSBjcmVhdGUvcmVnaXN0ZXIgcGx1Z2lucyB2aWEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICogQGludGVyZmFjZSBDaGFydC5QbHVnaW5CYXNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNS4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIuUGx1Z2luQmFzZSA9IGNvcmVfY29udHJvbGxlci5FbGVtZW50LmV4dGVuZCh7fSk7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbnZhcyBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5jYW52YXNIZWxwZXJzXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIuY2FudmFzSGVscGVycyA9IGNvcmVfY29udHJvbGxlci5oZWxwZXJzLmNhbnZhcztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmxheW91dHMgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQubGF5b3V0U2VydmljZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuM1xuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLmxheW91dFNlcnZpY2UgPSBjb3JlX2NvbnRyb2xsZXIubGF5b3V0cztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxuICogQG5hbWVzcGFjZSBDaGFydC5MaW5lYXJTY2FsZUJhc2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIuTGluZWFyU2NhbGVCYXNlID0gc2NhbGVfbGluZWFyYmFzZTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgaW5zdGVhZCB3ZSBzaG91bGQgY3JlYXRlIGEgbmV3IENoYXJ0XG4gKiBieSBzZXR0aW5nIHRoZSB0eXBlIGluIHRoZSBjb25maWcgKGBuZXcgQ2hhcnQoaWQsIHt0eXBlOiAne2NoYXJ0LXR5cGV9J31gKS5cbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqL1xuY29yZV9jb250cm9sbGVyLmhlbHBlcnMuZWFjaChcblx0W1xuXHRcdCdCYXInLFxuXHRcdCdCdWJibGUnLFxuXHRcdCdEb3VnaG51dCcsXG5cdFx0J0xpbmUnLFxuXHRcdCdQb2xhckFyZWEnLFxuXHRcdCdSYWRhcicsXG5cdFx0J1NjYXR0ZXInXG5cdF0sXG5cdGZ1bmN0aW9uKGtsYXNzKSB7XG5cdFx0Y29yZV9jb250cm9sbGVyW2tsYXNzXSA9IGZ1bmN0aW9uKGN0eCwgY2ZnKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGNvcmVfY29udHJvbGxlcihjdHgsIGNvcmVfY29udHJvbGxlci5oZWxwZXJzLm1lcmdlKGNmZyB8fCB7fSwge1xuXHRcdFx0XHR0eXBlOiBrbGFzcy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIGtsYXNzLnNsaWNlKDEpXG5cdFx0XHR9KSk7XG5cdFx0fTtcblx0fVxuKTtcblxucmV0dXJuIHNyYztcblxufSkpKTtcbiIsImltcG9ydCBDaGFydCBmcm9tICdjaGFydC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDaGFydChjaGFydElkLCBjaGFydFR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihjcmVhdGVFbGVtZW50KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICBzdHlsZTogdGhpcy5zdHlsZXMsXG4gICAgICAgIGNsYXNzOiB0aGlzLmNzc0NsYXNzZXNcbiAgICAgIH0sIFtjcmVhdGVFbGVtZW50KCdjYW52YXMnLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuY2hhcnRJZCxcbiAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIHJlZjogJ2NhbnZhcydcbiAgICAgIH0pXSk7XG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgY2hhcnRJZDoge1xuICAgICAgICBkZWZhdWx0OiBjaGFydElkLFxuICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgIH0sXG4gICAgICB3aWR0aDoge1xuICAgICAgICBkZWZhdWx0OiA0MDAsXG4gICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICBkZWZhdWx0OiA0MDAsXG4gICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgfSxcbiAgICAgIGNzc0NsYXNzZXM6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSxcbiAgICAgIHN0eWxlczoge1xuICAgICAgICB0eXBlOiBPYmplY3RcbiAgICAgIH0sXG4gICAgICBwbHVnaW5zOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfY2hhcnQ6IG51bGwsXG4gICAgICAgIF9wbHVnaW5zOiB0aGlzLnBsdWdpbnNcbiAgICAgIH07XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBhZGRQbHVnaW46IGZ1bmN0aW9uIGFkZFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgdGhpcy4kZGF0YS5fcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVMZWdlbmQ6IGZ1bmN0aW9uIGdlbmVyYXRlTGVnZW5kKCkge1xuICAgICAgICBpZiAodGhpcy4kZGF0YS5fY2hhcnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kZGF0YS5fY2hhcnQuZ2VuZXJhdGVMZWdlbmQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbmRlckNoYXJ0OiBmdW5jdGlvbiByZW5kZXJDaGFydChkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhLl9jaGFydCkgdGhpcy4kZGF0YS5fY2hhcnQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLiRkYXRhLl9jaGFydCA9IG5ldyBDaGFydCh0aGlzLiRyZWZzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLCB7XG4gICAgICAgICAgdHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICBwbHVnaW5zOiB0aGlzLiRkYXRhLl9wbHVnaW5zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLiRkYXRhLl9jaGFydCkge1xuICAgICAgICB0aGlzLiRkYXRhLl9jaGFydC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZXhwb3J0IHZhciBCYXIgPSBnZW5lcmF0ZUNoYXJ0KCdiYXItY2hhcnQnLCAnYmFyJyk7XG5leHBvcnQgdmFyIEhvcml6b250YWxCYXIgPSBnZW5lcmF0ZUNoYXJ0KCdob3Jpem9udGFsYmFyLWNoYXJ0JywgJ2hvcml6b250YWxCYXInKTtcbmV4cG9ydCB2YXIgRG91Z2hudXQgPSBnZW5lcmF0ZUNoYXJ0KCdkb3VnaG51dC1jaGFydCcsICdkb3VnaG51dCcpO1xuZXhwb3J0IHZhciBMaW5lID0gZ2VuZXJhdGVDaGFydCgnbGluZS1jaGFydCcsICdsaW5lJyk7XG5leHBvcnQgdmFyIFBpZSA9IGdlbmVyYXRlQ2hhcnQoJ3BpZS1jaGFydCcsICdwaWUnKTtcbmV4cG9ydCB2YXIgUG9sYXJBcmVhID0gZ2VuZXJhdGVDaGFydCgncG9sYXItY2hhcnQnLCAncG9sYXJBcmVhJyk7XG5leHBvcnQgdmFyIFJhZGFyID0gZ2VuZXJhdGVDaGFydCgncmFkYXItY2hhcnQnLCAncmFkYXInKTtcbmV4cG9ydCB2YXIgQnViYmxlID0gZ2VuZXJhdGVDaGFydCgnYnViYmxlLWNoYXJ0JywgJ2J1YmJsZScpO1xuZXhwb3J0IHZhciBTY2F0dGVyID0gZ2VuZXJhdGVDaGFydCgnc2NhdHRlci1jaGFydCcsICdzY2F0dGVyJyk7XG5leHBvcnQgZGVmYXVsdCB7XG4gIEJhcjogQmFyLFxuICBIb3Jpem9udGFsQmFyOiBIb3Jpem9udGFsQmFyLFxuICBEb3VnaG51dDogRG91Z2hudXQsXG4gIExpbmU6IExpbmUsXG4gIFBpZTogUGllLFxuICBQb2xhckFyZWE6IFBvbGFyQXJlYSxcbiAgUmFkYXI6IFJhZGFyLFxuICBCdWJibGU6IEJ1YmJsZSxcbiAgU2NhdHRlcjogU2NhdHRlclxufTsiLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBCYXIsIG1peGlucyB9IGZyb20gJ3Z1ZS1jaGFydGpzJztcbiAgY29uc3QgeyByZWFjdGl2ZVByb3AgfSA9IG1peGlucztcblxuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUucGFkZGluZyA9IDIwO1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUuZm9udFNpemUgPSAxNjtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmxpbmVIZWlnaHQgPSAxLjY7XG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIGV4dGVuZHM6IEJhcixcbiAgICBtaXhpbnM6IFtyZWFjdGl2ZVByb3BdLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2hhcnRMYWJlbHMgPSBbJzE5ODAnLCAnMTk5MCcsICcyMDAwJywgJzIwMTAnLCAnMjAyMCddO1xuXG5jb25zdCBjaGFydERhdGFMaXN0ID0gWzY1NDI1NjQsIDczMjI1NjQsIDgwMDgyNzgsIDgxNzUxMzMsIDU0NzUxMzNdO1xuXG5jb25zdCBDaGFydERhdGEgPSB7XG4gIGRhdGE6IHtcbiAgICBsYWJlbHM6IGNoYXJ0TGFiZWxzLFxuICAgIGRhdGFzZXRzOiBbXG4gICAgICB7XG4gICAgICAgIGRhdGE6IGNoYXJ0RGF0YUxpc3QsXG4gICAgICAgIGZpbGw6IGZhbHNlLCAvLyB1c2VkIGJ5IGxpbmUgY2hhcnRcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXG4gICAgICAgICAgJyMyRjMzNEYnLFxuICAgICAgICAgICcjMzE1NUE2JyxcbiAgICAgICAgICAnI0YyNjk1RCcsXG4gICAgICAgICAgJyNFQkJDRDgnLFxuICAgICAgICAgICcjRjlBMTM3JyxcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVyQ29sb3I6IFtcbiAgICAgICAgICAnI0FDQUVCOSdcbiAgICAgICAgXSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuICBiYXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICB0ZXh0OiAnUG9wdWxhdGlvbiBDaGFydCcsXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHhBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1llYXJzJyxcbiAgICAgICAgICB9XG4gICAgICAgIH1dLFxuICAgICAgICB5QXhlczogW3tcbiAgICAgICAgICBzY2FsZUxhYmVsOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTdHJpbmc6ICdQb3B1bGF0aW9uJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiAyNSxcbiAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBob3Jpem9udGFsQmFyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgdGV4dDogJ1BvcHVsYXRpb24gQ2hhcnQnLFxuICAgICAgfSxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBsaW5lVGVuc2lvbjogMSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4QXhlczogW3tcbiAgICAgICAgICBzY2FsZUxhYmVsOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTdHJpbmc6ICdQb3B1bGF0aW9uJyxcbiAgICAgICAgICB9XG4gICAgICAgIH1dLFxuICAgICAgICB5QXhlczogW3tcbiAgICAgICAgICBzY2FsZUxhYmVsOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTdHJpbmc6ICdZZWFycycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgcGFkZGluZzogMjUsXG4gICAgICAgICAgfVxuICAgICAgICB9XVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGllOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgdGV4dDogJ1BvcHVsYXRpb24gQ2hhcnQnLFxuICAgICAgfSxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgfSxcbiAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydERhdGE7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlcic7XG5pbXBvcnQgQ2hhcnRDb21wb25lbnQgZnJvbSAnLi9jaGFydC0tYmFyLnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBDaGFydERhdGEgZnJvbSAnLi9jaGFydC5kYXRhJzsgLy8gT3VyIHNhbXBsZSBkYXRhXG5cbmNvbnN0IGNoYXJ0VHlwZSA9ICdiYXInO1xuXG5jbGFzcyBDaGFydEJhciB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgVnVlLmNvbXBvbmVudChgbnljby1jaGFydC0ke2NoYXJ0VHlwZX1gLCBDaGFydENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiBgW2RhdGEtanM9XCJjaGFydC0ke2NoYXJ0VHlwZX1cIl1gLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IENoYXJ0RGF0YS5kYXRhLFxuICAgICAgICAgIG9wdGlvbnM6IENoYXJ0RGF0YS5iYXIub3B0aW9uc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0QmFyOyIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IEhvcml6b250YWxCYXIsIG1peGlucyB9IGZyb20gJ3Z1ZS1jaGFydGpzJztcbiAgY29uc3QgeyByZWFjdGl2ZVByb3AgfSA9IG1peGlucztcblxuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUucGFkZGluZyA9IDIwO1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUuZm9udFNpemUgPSAxNjtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmxpbmVIZWlnaHQgPSAxLjY7XG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIGV4dGVuZHM6IEhvcml6b250YWxCYXIsXG4gICAgbWl4aW5zOiBbcmVhY3RpdmVQcm9wXSxcbiAgICBwcm9wczoge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lVGVuc2lvbjogMSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMuY2hhcnREYXRhLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0sXG4gIH07XG48L3NjcmlwdD4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBWdWUgZnJvbSAndnVlL2Rpc3QvdnVlLmVzbS5icm93c2VyJztcbmltcG9ydCBDaGFydENvbXBvbmVudCBmcm9tICcuL2NoYXJ0LS1ob3Jpem9udGFsLWJhci52dWUnOyAvLyBPdXIgY29tcG9uZW50XG5pbXBvcnQgQ2hhcnREYXRhIGZyb20gJy4vY2hhcnQuZGF0YSc7IC8vIE91ciBzYW1wbGUgZGF0YVxuXG5jb25zdCBjaGFydFR5cGUgPSAnaG9yaXpvbnRhbC1iYXInO1xuXG5jbGFzcyBDaGFydEhvcml6b250YWxCYXIge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoYG55Y28tY2hhcnQtJHtjaGFydFR5cGV9YCwgQ2hhcnRDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogYFtkYXRhLWpzPVwiY2hhcnQtJHtjaGFydFR5cGV9XCJdYCxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBDaGFydERhdGEuZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBDaGFydERhdGEuaG9yaXpvbnRhbEJhci5vcHRpb25zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnRIb3Jpem9udGFsQmFyOyIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IExpbmUsIG1peGlucyB9IGZyb20gJ3Z1ZS1jaGFydGpzJztcbiAgY29uc3QgeyByZWFjdGl2ZVByb3AgfSA9IG1peGlucztcblxuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUucGFkZGluZyA9IDIwO1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUuZm9udFNpemUgPSAxNjtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmxpbmVIZWlnaHQgPSAxLjY7XG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIGV4dGVuZHM6IExpbmUsXG4gICAgbWl4aW5zOiBbcmVhY3RpdmVQcm9wXSxcbiAgICBwcm9wczoge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lVGVuc2lvbjogMSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMuY2hhcnREYXRhLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0sXG4gIH07XG48L3NjcmlwdD4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBWdWUgZnJvbSAndnVlL2Rpc3QvdnVlLmVzbS5icm93c2VyJztcbmltcG9ydCBDaGFydENvbXBvbmVudCBmcm9tICcuL2NoYXJ0LS1saW5lLnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBDaGFydERhdGEgZnJvbSAnLi9jaGFydC5kYXRhJzsgLy8gT3VyIHNhbXBsZSBkYXRhXG5cbmNvbnN0IGNoYXJ0VHlwZSA9ICdsaW5lJztcblxuY2xhc3MgQ2hhcnRMaW5lIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KGBueWNvLWNoYXJ0LSR7Y2hhcnRUeXBlfWAsIENoYXJ0Q29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6IGBbZGF0YS1qcz1cImNoYXJ0LSR7Y2hhcnRUeXBlfVwiXWAsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogQ2hhcnREYXRhLmRhdGEsXG4gICAgICAgICAgb3B0aW9uczogQ2hhcnREYXRhLmJhci5vcHRpb25zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnRMaW5lOyIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IFBpZSwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogUGllLFxuICAgIG1peGluczogW3JlYWN0aXZlUHJvcF0sXG4gICAgcHJvcHM6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lVGVuc2lvbjogMSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMuY2hhcnREYXRhLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0sXG4gIH07XG48L3NjcmlwdD4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBWdWUgZnJvbSAndnVlL2Rpc3QvdnVlLmVzbS5icm93c2VyJztcbmltcG9ydCBDaGFydENvbXBvbmVudCBmcm9tICcuL2NoYXJ0LS1waWUudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IENoYXJ0RGF0YSBmcm9tICcuL2NoYXJ0LmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY29uc3QgY2hhcnRUeXBlID0gJ3BpZSc7XG5cbmNsYXNzIENoYXJ0UGllIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KGBueWNvLWNoYXJ0LSR7Y2hhcnRUeXBlfWAsIENoYXJ0Q29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6IGBbZGF0YS1qcz1cImNoYXJ0LSR7Y2hhcnRUeXBlfVwiXWAsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogQ2hhcnREYXRhLmRhdGEsXG4gICAgICAgICAgb3B0aW9uczogQ2hhcnREYXRhLnBpZS5vcHRpb25zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnRQaWU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgSWNvbnMgZnJvbSAnLi4vZWxlbWVudHMvaWNvbnMvSWNvbnMnO1xuaW1wb3J0IEZlZWQgZnJvbSAnLi4vb2JqZWN0cy9mZWVkL0ZlZWQnO1xuaW1wb3J0IFRvZ2dsZSBmcm9tICcuLi91dGlsaXRpZXMvdG9nZ2xlL1RvZ2dsZSc7XG5pbXBvcnQgVHJhY2sgZnJvbSAnLi4vdXRpbGl0aWVzL3RyYWNrL1RyYWNrJztcbmltcG9ydCBTZWxlY3QgZnJvbSAnLi4vZWxlbWVudHMvc2VsZWN0L3NlbGVjdCc7XG5pbXBvcnQgQ2hhcnRCYXIgZnJvbSAnLi4vb2JqZWN0cy9jaGFydHMvY2hhcnQtLWJhcic7XG5pbXBvcnQgQ2hhcnRIb3Jpem9udGFsQmFyIGZyb20gJy4uL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1ob3Jpem9udGFsLWJhcic7XG5pbXBvcnQgQ2hhcnRMaW5lIGZyb20gJy4uL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1saW5lJztcbmltcG9ydCBDaGFydFBpZSBmcm9tICcuLi9vYmplY3RzL2NoYXJ0cy9jaGFydC0tcGllJztcbi8qKiBpbXBvcnQgbW9kdWxlcyBoZXJlIGFzIHRoZXkgYXJlIHdyaXR0ZW4gKi9cblxuLyoqXG4gKiBNZXRob2RzIGZvciB0aGUgZ2xvYmFsIE55Y29QYXR0ZXJucyBpbnN0YW5jZVxuICovXG5jbGFzcyBueWNvIHtcbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgdGhlIEljb25zIEVsZW1lbnRcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoICBUaGUgcGF0aCBvZiB0aGUgaWNvbiBmaWxlXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgSWNvbnMgaW5zdGFuY2VcbiAgICovXG4gIGljb25zKHBhdGgpIHtcbiAgICByZXR1cm4gbmV3IEljb25zKHBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgdGhlIEZlZWQgT2JqZWN0XG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICBzZXR0aW5ncyAgU2V0dGluZyBmb3IgdGhlIGZlZWRcbiAgICogQHJldHVybiAge09iamVjdH0gICAgICAgICAgICBGZWVkIGluc3RhbmNlXG4gICAqL1xuICBmZWVkKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBGZWVkKHNldHRpbmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBUb2dnbGUgVXRpbGl0eVxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSBUb2dnbGUgaW5zdGFuY2VcbiAgICovXG4gIHRvZ2dsZShzZXR0aW5ncykge1xuICAgIHJldHVybiBuZXcgVG9nZ2xlKCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgVHJhY2sgTW9kdWxlXG4gICAqIEByZXR1cm4gIHtPYmplY3R9IFRyYWNrIE1vZHVsZVxuICAgKi9cbiAgdHJhY2soc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrKCk7XG4gIH1cblxuICBzZWxlY3QoKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3QoKTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgQ2hhcnQgT2JqZWN0c1xuICAgKiBAcmV0dXJuICB7T2JqZWN0fSBDaGFydCBpbnN0YW5jZVxuICAgKi9cbiAgY2hhcnQodHlwZSkge1xuICAgIGlmICh0eXBlID09PSAnYmFyJylcbiAgICAgIHJldHVybiBuZXcgQ2hhcnRCYXIoKTtcblxuICAgIGlmICh0eXBlID09PSAnaG9yaXpvbnRhbEJhcicpXG4gICAgICByZXR1cm4gbmV3IENoYXJ0SG9yaXpvbnRhbEJhcigpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdsaW5lJylcbiAgICAgIHJldHVybiBuZXcgQ2hhcnRMaW5lKCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3BpZScpXG4gICAgICByZXR1cm4gbmV3IENoYXJ0UGllKCk7XG4gIH1cbiAgLyoqIGFkZCBBUElzIGhlcmUgYXMgdGhleSBhcmUgd3JpdHRlbiAqL1xufVxuXG5leHBvcnQgZGVmYXVsdCBueWNvO1xuIl0sIm5hbWVzIjpbIlV0aWxpdHkiLCJkZWJ1ZyIsImdldFVybFBhcmFtZXRlciIsIlBBUkFNUyIsIkRFQlVHIiwibmFtZSIsInF1ZXJ5U3RyaW5nIiwicXVlcnkiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInNlYXJjaCIsImNvbnN0IiwicGFyYW0iLCJyZXBsYWNlIiwicmVnZXgiLCJSZWdFeHAiLCJyZXN1bHRzIiwiZXhlYyIsImRlY29kZVVSSUNvbXBvbmVudCIsImxvY2FsaXplIiwic2x1ZyIsInRleHQiLCJsZXQiLCJzdHJpbmdzIiwiTE9DQUxJWkVEX1NUUklOR1MiLCJtYXRjaCIsImZpbHRlciIsInMiLCJoYXNPd25Qcm9wZXJ0eSIsImxhYmVsIiwiU0VMRUNUT1JTIiwicGFyc2VNYXJrZG93biIsIkljb25zIiwicGF0aCIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwib2siLCJjb25zb2xlIiwiZGlyIiwiZXJyb3IiLCJkYXRhIiwic3ByaXRlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwic2V0QXR0cmlidXRlIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsIk9iamVjdCIsImZyZWVTZWxmIiwic2VsZiIsInJvb3QiLCJGdW5jdGlvbiIsIlN5bWJvbCIsIm9iamVjdFByb3RvIiwicHJvdG90eXBlIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJ0b1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJ1bmRlZmluZWQiLCJnZXRSYXdUYWciLCJ2YWx1ZSIsImlzT3duIiwiY2FsbCIsInRhZyIsInVubWFza2VkIiwiZSIsInJlc3VsdCIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsImJhc2VHZXRUYWciLCJpc09iamVjdCIsInR5cGUiLCJhc3luY1RhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImlzRnVuY3Rpb24iLCJjb3JlSnNEYXRhIiwibWFza1NyY0tleSIsInVpZCIsImtleXMiLCJJRV9QUk9UTyIsImlzTWFza2VkIiwiZnVuYyIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInRvU291cmNlIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwicmVJc05hdGl2ZSIsImJhc2VJc05hdGl2ZSIsInBhdHRlcm4iLCJ0ZXN0IiwiZ2V0VmFsdWUiLCJvYmplY3QiLCJrZXkiLCJnZXROYXRpdmUiLCJkZWZpbmVQcm9wZXJ0eSIsImJhc2VBc3NpZ25WYWx1ZSIsImVxIiwib3RoZXIiLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiY29weU9iamVjdCIsInNvdXJjZSIsInByb3BzIiwiY3VzdG9taXplciIsImlzTmV3IiwiaW5kZXgiLCJsZW5ndGgiLCJuZXdWYWx1ZSIsImlkZW50aXR5IiwiYXBwbHkiLCJ0aGlzQXJnIiwiYXJncyIsIm5hdGl2ZU1heCIsIk1hdGgiLCJtYXgiLCJvdmVyUmVzdCIsInN0YXJ0IiwidHJhbnNmb3JtIiwiYXJndW1lbnRzIiwiYXJyYXkiLCJBcnJheSIsIm90aGVyQXJncyIsImNvbnN0YW50IiwiYmFzZVNldFRvU3RyaW5nIiwic3RyaW5nIiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJuYXRpdmVOb3ciLCJEYXRlIiwibm93Iiwic2hvcnRPdXQiLCJjb3VudCIsImxhc3RDYWxsZWQiLCJzdGFtcCIsInJlbWFpbmluZyIsInNldFRvU3RyaW5nIiwiYmFzZVJlc3QiLCJNQVhfU0FGRV9JTlRFR0VSIiwiaXNMZW5ndGgiLCJpc0FycmF5TGlrZSIsInJlSXNVaW50IiwiaXNJbmRleCIsImlzSXRlcmF0ZWVDYWxsIiwiY3JlYXRlQXNzaWduZXIiLCJhc3NpZ25lciIsInNvdXJjZXMiLCJndWFyZCIsImJhc2VUaW1lcyIsIm4iLCJpdGVyYXRlZSIsImlzT2JqZWN0TGlrZSIsImFyZ3NUYWciLCJiYXNlSXNBcmd1bWVudHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzQXJndW1lbnRzIiwiaXNBcnJheSIsInN0dWJGYWxzZSIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwib2JqZWN0VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJ0eXBlZEFycmF5VGFncyIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkiLCJmcmVlUHJvY2VzcyIsInByb2Nlc3MiLCJub2RlVXRpbCIsInR5cGVzIiwicmVxdWlyZSIsImJpbmRpbmciLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5IiwiYXJyYXlMaWtlS2V5cyIsImluaGVyaXRlZCIsImlzQXJyIiwiaXNBcmciLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsIlN0cmluZyIsInB1c2giLCJpc1Byb3RvdHlwZSIsIkN0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvIiwibmF0aXZlS2V5c0luIiwiYmFzZUtleXNJbiIsImlzUHJvdG8iLCJrZXlzSW4iLCJhc3NpZ25JbldpdGgiLCJzcmNJbmRleCIsIm92ZXJBcmciLCJhcmciLCJnZXRQcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIm9iamVjdEN0b3JTdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiZG9tRXhjVGFnIiwiaXNFcnJvciIsIm1lc3NhZ2UiLCJhdHRlbXB0IiwiRXJyb3IiLCJhcnJheU1hcCIsImJhc2VWYWx1ZXMiLCJjdXN0b21EZWZhdWx0c0Fzc2lnbkluIiwic3JjVmFsdWUiLCJzdHJpbmdFc2NhcGVzIiwiZXNjYXBlU3RyaW5nQ2hhciIsImNociIsIm5hdGl2ZUtleXMiLCJiYXNlS2V5cyIsInJlSW50ZXJwb2xhdGUiLCJiYXNlUHJvcGVydHlPZiIsImh0bWxFc2NhcGVzIiwiZXNjYXBlSHRtbENoYXIiLCJzeW1ib2xUYWciLCJpc1N5bWJvbCIsIklORklOSVRZIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xUb1N0cmluZyIsImJhc2VUb1N0cmluZyIsInJlVW5lc2NhcGVkSHRtbCIsInJlSGFzVW5lc2NhcGVkSHRtbCIsImVzY2FwZSIsInJlRXNjYXBlIiwicmVFdmFsdWF0ZSIsInRlbXBsYXRlU2V0dGluZ3MiLCJyZUVtcHR5U3RyaW5nTGVhZGluZyIsInJlRW1wdHlTdHJpbmdNaWRkbGUiLCJyZUVtcHR5U3RyaW5nVHJhaWxpbmciLCJyZUVzVGVtcGxhdGUiLCJyZU5vTWF0Y2giLCJyZVVuZXNjYXBlZFN0cmluZyIsInRlbXBsYXRlIiwib3B0aW9ucyIsInNldHRpbmdzIiwiaW1wb3J0cyIsIl8iLCJpbXBvcnRzS2V5cyIsImltcG9ydHNWYWx1ZXMiLCJpc0VzY2FwaW5nIiwiaXNFdmFsdWF0aW5nIiwiaW50ZXJwb2xhdGUiLCJyZURlbGltaXRlcnMiLCJldmFsdWF0ZSIsInNvdXJjZVVSTCIsImVzY2FwZVZhbHVlIiwiaW50ZXJwb2xhdGVWYWx1ZSIsImVzVGVtcGxhdGVWYWx1ZSIsImV2YWx1YXRlVmFsdWUiLCJvZmZzZXQiLCJzbGljZSIsInZhcmlhYmxlIiwiYXJyYXlFYWNoIiwiY3JlYXRlQmFzZUZvciIsImZyb21SaWdodCIsImtleXNGdW5jIiwiaXRlcmFibGUiLCJiYXNlRm9yIiwiYmFzZUZvck93biIsImNyZWF0ZUJhc2VFYWNoIiwiZWFjaEZ1bmMiLCJjb2xsZWN0aW9uIiwiYmFzZUVhY2giLCJjYXN0RnVuY3Rpb24iLCJmb3JFYWNoIiwibGlzdENhY2hlQ2xlYXIiLCJfX2RhdGFfXyIsInNpemUiLCJhc3NvY0luZGV4T2YiLCJhcnJheVByb3RvIiwic3BsaWNlIiwibGlzdENhY2hlRGVsZXRlIiwibGFzdEluZGV4IiwicG9wIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTGlzdENhY2hlIiwiZW50cmllcyIsImNsZWFyIiwiZW50cnkiLCJzZXQiLCJnZXQiLCJoYXMiLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwiTWFwIiwibmF0aXZlQ3JlYXRlIiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsIkhBU0hfVU5ERUZJTkVEIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSGFzaCIsIm1hcENhY2hlQ2xlYXIiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwibWFwIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJNYXBDYWNoZSIsIkxBUkdFX0FSUkFZX1NJWkUiLCJzdGFja1NldCIsInBhaXJzIiwiU3RhY2siLCJhc3NpZ25NZXJnZVZhbHVlIiwiYWxsb2NVbnNhZmUiLCJjbG9uZUJ1ZmZlciIsImJ1ZmZlciIsImlzRGVlcCIsImNvcHkiLCJVaW50OEFycmF5IiwiY2xvbmVBcnJheUJ1ZmZlciIsImFycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsImNsb25lVHlwZWRBcnJheSIsInR5cGVkQXJyYXkiLCJieXRlT2Zmc2V0IiwiY29weUFycmF5Iiwib2JqZWN0Q3JlYXRlIiwiY3JlYXRlIiwiYmFzZUNyZWF0ZSIsImluaXRDbG9uZU9iamVjdCIsImlzQXJyYXlMaWtlT2JqZWN0Iiwic2FmZUdldCIsInRvUGxhaW5PYmplY3QiLCJiYXNlTWVyZ2VEZWVwIiwibWVyZ2VGdW5jIiwic3RhY2siLCJzdGFja2VkIiwiaXNDb21tb24iLCJpc1R5cGVkIiwiYmFzZU1lcmdlIiwibWVyZ2UiLCJ2YWx1ZXMiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiU2V0Q2FjaGUiLCJhZGQiLCJhcnJheVNvbWUiLCJwcmVkaWNhdGUiLCJjYWNoZUhhcyIsImNhY2hlIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwiZXF1YWxBcnJheXMiLCJiaXRtYXNrIiwiZXF1YWxGdW5jIiwiaXNQYXJ0aWFsIiwiYXJyTGVuZ3RoIiwib3RoTGVuZ3RoIiwic2VlbiIsImFyclZhbHVlIiwib3RoVmFsdWUiLCJjb21wYXJlZCIsIm90aEluZGV4IiwibWFwVG9BcnJheSIsInNldFRvQXJyYXkiLCJzeW1ib2xWYWx1ZU9mIiwidmFsdWVPZiIsImVxdWFsQnlUYWciLCJjb252ZXJ0IiwiYXJyYXlQdXNoIiwiYmFzZUdldEFsbEtleXMiLCJzeW1ib2xzRnVuYyIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJzdHViQXJyYXkiLCJuYXRpdmVHZXRTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0U3ltYm9scyIsInN5bWJvbCIsImdldEFsbEtleXMiLCJlcXVhbE9iamVjdHMiLCJvYmpQcm9wcyIsIm9iakxlbmd0aCIsIm90aFByb3BzIiwic2tpcEN0b3IiLCJvYmpDdG9yIiwib3RoQ3RvciIsIkRhdGFWaWV3IiwiUHJvbWlzZSIsIlNldCIsIldlYWtNYXAiLCJwcm9taXNlVGFnIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwiZ2V0VGFnIiwiQXJyYXlCdWZmZXIiLCJyZXNvbHZlIiwiY3RvclN0cmluZyIsImJhc2VJc0VxdWFsRGVlcCIsIm9iaklzQXJyIiwib3RoSXNBcnIiLCJvYmpUYWciLCJvdGhUYWciLCJvYmpJc09iaiIsIm90aElzT2JqIiwiaXNTYW1lVGFnIiwib2JqSXNXcmFwcGVkIiwib3RoSXNXcmFwcGVkIiwib2JqVW53cmFwcGVkIiwib3RoVW53cmFwcGVkIiwiYmFzZUlzRXF1YWwiLCJiYXNlSXNNYXRjaCIsIm1hdGNoRGF0YSIsIm5vQ3VzdG9taXplciIsImlzU3RyaWN0Q29tcGFyYWJsZSIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiYmFzZU1hdGNoZXMiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwiaXNLZXkiLCJGVU5DX0VSUk9SX1RFWFQiLCJtZW1vaXplIiwicmVzb2x2ZXIiLCJUeXBlRXJyb3IiLCJtZW1vaXplZCIsIkNhY2hlIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwic3RyaW5nVG9QYXRoIiwiY2hhckNvZGVBdCIsIm51bWJlciIsInF1b3RlIiwic3ViU3RyaW5nIiwiY2FzdFBhdGgiLCJ0b0tleSIsImJhc2VHZXQiLCJkZWZhdWx0VmFsdWUiLCJiYXNlSGFzSW4iLCJoYXNQYXRoIiwiaGFzRnVuYyIsImhhc0luIiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSIsImJhc2VQcm9wZXJ0eSIsImJhc2VQcm9wZXJ0eURlZXAiLCJwcm9wZXJ0eSIsImJhc2VJdGVyYXRlZSIsImJhc2VNYXAiLCJiYXNlU29ydEJ5IiwiY29tcGFyZXIiLCJzb3J0IiwiY29tcGFyZUFzY2VuZGluZyIsInZhbElzRGVmaW5lZCIsInZhbElzTnVsbCIsInZhbElzUmVmbGV4aXZlIiwidmFsSXNTeW1ib2wiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwiY29tcGFyZU11bHRpcGxlIiwib3JkZXJzIiwib2JqQ3JpdGVyaWEiLCJjcml0ZXJpYSIsIm90aENyaXRlcmlhIiwib3JkZXJzTGVuZ3RoIiwib3JkZXIiLCJiYXNlT3JkZXJCeSIsIml0ZXJhdGVlcyIsIm9yZGVyQnkiLCJub29wIiwiY3JlYXRlU2V0IiwiRmVlZCIsImNvbmZpZyIsIl9zZXR0aW5ncyIsIl9tZXJnZSIsImluaXQiLCJmZWVkIiwicnNzVG9Kc29uIiwicnNzVXJsIiwiX2ZvckVhY2giLCJ1cmwiLCJ0aGlzIiwiX3JlcXVlc3QiLCJfcHJvY2VzcyIsIkpTT04iLCJwYXJzZSIsInRoaXMkMSIsImNvbXBpbGVkIiwiX3JlbmRlciIsImVsIiwicXVlcnlTZWxlY3RvciIsInNlbGVjdG9yIiwicmVqZWN0IiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJldmVudCIsIl94aHIiLCJ0YXJnZXQiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwib250aW1lb3V0Iiwib3BlbiIsInNlbmQiLCJsb2ciLCJfdmFsdWVzIiwidGVtcGxhdGVzIiwiam9pbiIsIl90ZW1wbGF0ZSIsIm1lZGl1bSIsIm9wZW5lciIsImhlYWRlciIsInBvc3RzIiwiY2xvc2VyIiwicG9zdEV4Y2VycHRMZW5ndGgiLCJpdGVtcyIsInBvc3QiLCJleGNlcnB0IiwiZGF0ZSIsImRlc2NyaXB0aW9uIiwic3Vic3RyIiwibWluIiwibGFzdEluZGV4T2YiLCJwdWJEYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwicG9zdERhdGVMb2NhbCIsInBvc3REYXRlRm9ybWF0IiwibWVyZ2VkIiwiY29uY2F0IiwiX29yZGVyQnkiLCJ0aXRsZSIsInRpdGxlVXJsIiwicHJvZmlsZUltZyIsImZvbnRTaXplIiwicmF0aW9Qcm9maWxlIiwicG9zdEJvcmRlckNvbG9yIiwicG9zdEltZ0hlaWdodCIsInBvc3RFeGNlcnB0VHJhaWwiLCJwb3N0Q3RhVGV4dCIsInllYXIiLCJtb250aCIsImRheSIsInBvc3REYXRlVGl0bGUiLCJjbGFzc2VzIiwid3JhcHBlciIsImZlZWRJdGVtIiwibGluayIsInRodW1ibmFpbCIsIml0ZW1Gb290ZXIiLCJjdGEiLCJ1bmlxdWUiLCJUb2dnbGUiLCJuYW1lc3BhY2UiLCJpbmFjdGl2ZUNsYXNzIiwiYWN0aXZlQ2xhc3MiLCJhZGRFdmVudExpc3RlbmVyIiwibWF0Y2hlcyIsInByZXZlbnREZWZhdWx0IiwiX3RvZ2dsZSIsImdldEF0dHJpYnV0ZSIsImVsZW1lbnRUb2dnbGUiLCJkYXRhc2V0IiwidW5kbyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJpIiwiZWxBcmlhUm9sZXMiLCJ0YXJnZXRBcmlhUm9sZXMiLCJjb250YWlucyIsImhhc2giLCJUcmFjayIsInRyYWNrS2V5IiwidHJhY2tEYXRhIiwiY2xpY2siLCJkIiwicGF0aG5hbWUiLCJ3dCIsIndlYnRyZW5kcyIsImdhIiwiZ3RhZyIsInZpZXciLCJhcHAiLCJndGFnVmlldyIsImFzc2lnbiIsInd0ZCIsImFyZ3NhIiwiZmxhdE1hcCIsImsiLCJXZWJ0cmVuZHMiLCJtdWx0aVRyYWNrIiwidXJpIiwiZmluZCIsImVsZW1lbnQiLCJhcHBfbmFtZSIsInNjcmVlbl9uYW1lIiwiZW1wdHlPYmplY3QiLCJmcmVlemUiLCJpc1VuZGVmIiwidiIsImlzRGVmIiwiaXNUcnVlIiwiaXNGYWxzZSIsImlzUHJpbWl0aXZlIiwib2JqIiwiX3RvU3RyaW5nIiwidG9SYXdUeXBlIiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsInBhcnNlRmxvYXQiLCJmbG9vciIsImlzRmluaXRlIiwiaXNQcm9taXNlIiwiY2F0Y2giLCJzdHJpbmdpZnkiLCJ0b051bWJlciIsImlzTmFOIiwibWFrZU1hcCIsInN0ciIsImV4cGVjdHNMb3dlckNhc2UiLCJsaXN0Iiwic3BsaXQiLCJ0b0xvd2VyQ2FzZSIsImlzQnVpbHRJblRhZyIsImlzUmVzZXJ2ZWRBdHRyaWJ1dGUiLCJyZW1vdmUiLCJhcnIiLCJpdGVtIiwiaW5kZXhPZiIsImhhc093biIsImNhY2hlZCIsImZuIiwiY2FjaGVkRm4iLCJoaXQiLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJjIiwidG9VcHBlckNhc2UiLCJjYXBpdGFsaXplIiwiY2hhckF0IiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJwb2x5ZmlsbEJpbmQiLCJjdHgiLCJib3VuZEZuIiwiYSIsImwiLCJfbGVuZ3RoIiwibmF0aXZlQmluZCIsImJpbmQiLCJ0b0FycmF5IiwicmV0IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwiYiIsIm5vIiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJtIiwic3RhdGljS2V5cyIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXlCIiwiZXZlcnkiLCJnZXRUaW1lIiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsImRldnRvb2xzIiwicGVyZm9ybWFuY2UiLCJlcnJvckhhbmRsZXIiLCJ3YXJuSGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJhc3luYyIsIl9saWZlY3ljbGVIb29rcyIsInVuaWNvZGVMZXR0ZXJzIiwiaXNSZXNlcnZlZCIsImRlZiIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImJhaWxSRSIsInBhcnNlUGF0aCIsInNlZ21lbnRzIiwiaGFzUHJvdG8iLCJpbkJyb3dzZXIiLCJpbldlZXgiLCJXWEVudmlyb25tZW50IiwicGxhdGZvcm0iLCJ3ZWV4UGxhdGZvcm0iLCJVQSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJpc1BoYW50b21KUyIsImlzRkYiLCJuYXRpdmVXYXRjaCIsIndhdGNoIiwic3VwcG9ydHNQYXNzaXZlIiwib3B0cyIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiZW52IiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsImhhc1N5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiX1NldCIsIndhcm4iLCJ0aXAiLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsInRyYWNlIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsImNpZCIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJyZXBlYXQiLCIkcGFyZW50IiwidHJlZSIsImN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSIsImxhc3QiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJwb3BUYXJnZXQiLCJWTm9kZSIsImNoaWxkcmVuIiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZuQ29udGV4dCIsImZuT3B0aW9ucyIsImZuU2NvcGVJZCIsImNvbXBvbmVudEluc3RhbmNlIiwicGFyZW50IiwicmF3IiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNoaWxkIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJjbG9uZWQiLCJhcnJheU1ldGhvZHMiLCJtZXRob2RzVG9QYXRjaCIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsIm9iIiwiX19vYl9fIiwiaW5zZXJ0ZWQiLCJvYnNlcnZlQXJyYXkiLCJkZXAiLCJhcnJheUtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic2hvdWxkT2JzZXJ2ZSIsInRvZ2dsZU9ic2VydmluZyIsIk9ic2VydmVyIiwidm1Db3VudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsImRlZmluZVJlYWN0aXZlJCQxIiwib2JzZXJ2ZSIsInNyYyIsIl9fcHJvdG9fXyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJzaGFsbG93IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0dGVyIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsImRlbCIsInN0cmF0cyIsInByb3BzRGF0YSIsImRlZmF1bHRTdHJhdCIsIm1lcmdlRGF0YSIsImZyb20iLCJ0b1ZhbCIsImZyb21WYWwiLCJtZXJnZURhdGFPckZuIiwicGFyZW50VmFsIiwiY2hpbGRWYWwiLCJtZXJnZWREYXRhRm4iLCJtZXJnZWRJbnN0YW5jZURhdGFGbiIsImluc3RhbmNlRGF0YSIsImRlZmF1bHREYXRhIiwibWVyZ2VIb29rIiwiZGVkdXBlSG9va3MiLCJob29rcyIsImhvb2siLCJtZXJnZUFzc2V0cyIsImFzc2VydE9iamVjdFR5cGUiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsInZhbGlkYXRlQ29tcG9uZW50TmFtZSIsIm5vcm1hbGl6ZVByb3BzIiwibm9ybWFsaXplSW5qZWN0Iiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsImRlZiQkMSIsIm1lcmdlT3B0aW9ucyIsIl9iYXNlIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3AiLCJhYnNlbnQiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJCb29sZWFuIiwic3RyaW5nSW5kZXgiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZE9ic2VydmUiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJnZXRJbnZhbGlkVHlwZU1lc3NhZ2UiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImlzU2FtZVR5cGUiLCJsZW4iLCJyZWNlaXZlZFR5cGUiLCJleHBlY3RlZFZhbHVlIiwic3R5bGVWYWx1ZSIsInJlY2VpdmVkVmFsdWUiLCJpc0V4cGxpY2FibGUiLCJpc0Jvb2xlYW4iLCJOdW1iZXIiLCJleHBsaWNpdFR5cGVzIiwic29tZSIsImVsZW0iLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJjdXIiLCJlcnJvckNhcHR1cmVkIiwiY2FwdHVyZSIsImdsb2JhbEhhbmRsZUVycm9yIiwiaW52b2tlV2l0aEVycm9ySGFuZGxpbmciLCJoYW5kbGVyIiwibG9nRXJyb3IiLCJpc1VzaW5nTWljcm9UYXNrIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsImZsdXNoQ2FsbGJhY2tzIiwiY29waWVzIiwidGltZXJGdW5jIiwicCIsInNldFRpbWVvdXQiLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsImNoYXJhY3RlckRhdGEiLCJzZXRJbW1lZGlhdGUiLCJuZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJtYXJrIiwibWVhc3VyZSIsInBlcmYiLCJjbGVhck1hcmtzIiwiY2xlYXJNZWFzdXJlcyIsInN0YXJ0VGFnIiwiZW5kVGFnIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsIndhcm5SZXNlcnZlZFByZWZpeCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCIkZGF0YSIsImdldEhhbmRsZXIiLCJoYW5kbGVycyIsInJlbmRlciIsIl93aXRoU3RyaXBwZWQiLCJfcmVuZGVyUHJveHkiLCJzZWVuT2JqZWN0cyIsInRyYXZlcnNlIiwiX3RyYXZlcnNlIiwiaXNBIiwiaXNGcm96ZW4iLCJkZXBJZCIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwidXBkYXRlTGlzdGVuZXJzIiwib24iLCJvbGRPbiIsInJlbW92ZSQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyIiwib2xkIiwicGFyYW1zIiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5Iiwib2xkSG9vayIsIndyYXBwZWRIb29rIiwiZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSIsImF0dHJzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4Iiwic2hpZnQiLCJfaXNWTGlzdCIsImluaXRQcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwicHJvdmlkZUtleSIsInByb3ZpZGVEZWZhdWx0IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwiaXNXaGl0ZXNwYWNlIiwibm9ybWFsaXplU2NvcGVkU2xvdHMiLCJub3JtYWxTbG90cyIsInByZXZTbG90cyIsIl9ub3JtYWxpemVkIiwiJHN0YWJsZSIsIm5vcm1hbGl6ZVNjb3BlZFNsb3QiLCJwcm94eU5vcm1hbFNsb3QiLCJwcm94eSIsInJlbmRlckxpc3QiLCJpdGVyYXRvciIsIm5leHQiLCJkb25lIiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsIiRzY29wZWRTbG90cyIsIm5vZGVzIiwiJHNsb3RzIiwiJGNyZWF0ZUVsZW1lbnQiLCJyZXNvbHZlRmlsdGVyIiwiaXNLZXlOb3RNYXRjaCIsImV4cGVjdCIsImFjdHVhbCIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluS2V5Q29kZSIsImV2ZW50S2V5TmFtZSIsImJ1aWx0SW5LZXlOYW1lIiwibWFwcGVkS2V5Q29kZSIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImlzU3luYyIsImRvbVByb3BzIiwiY2FtZWxpemVkS2V5IiwiJGV2ZW50IiwicmVuZGVyU3RhdGljIiwiaXNJbkZvciIsIl9zdGF0aWNUcmVlcyIsInN0YXRpY1JlbmRlckZucyIsIm1hcmtTdGF0aWMiLCJtYXJrT25jZSIsIm1hcmtTdGF0aWNOb2RlIiwiYmluZE9iamVjdExpc3RlbmVycyIsImV4aXN0aW5nIiwib3VycyIsInJlc29sdmVTY29wZWRTbG90cyIsImhhc0R5bmFtaWNLZXlzIiwiYmluZER5bmFtaWNLZXlzIiwiYmFzZU9iaiIsInByZXBlbmRNb2RpZmllciIsImluc3RhbGxSZW5kZXJIZWxwZXJzIiwiX28iLCJfbiIsIl9zIiwiX2wiLCJfdCIsIl9xIiwiX2kiLCJfbSIsIl9mIiwiX2siLCJfYiIsIl92IiwiX2UiLCJfdSIsIl9nIiwiX2QiLCJfcCIsIkZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IiwiY29udGV4dFZtIiwiX29yaWdpbmFsIiwiaXNDb21waWxlZCIsIl9jb21waWxlZCIsIm5lZWROb3JtYWxpemF0aW9uIiwibGlzdGVuZXJzIiwiaW5qZWN0aW9ucyIsInNjb3BlZFNsb3RzIiwiX3Njb3BlSWQiLCJfYyIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQiLCJ2bm9kZXMiLCJjbG9uZSIsImRldnRvb2xzTWV0YSIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJoeWRyYXRpbmciLCJfaXNEZXN0cm95ZWQiLCJrZWVwQWxpdmUiLCJtb3VudGVkTm9kZSIsInByZXBhdGNoIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsImFjdGl2ZUluc3RhbmNlIiwiJG1vdW50Iiwib2xkVm5vZGUiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsImluc2VydCIsIl9pc01vdW50ZWQiLCJjYWxsSG9vayIsInF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50IiwiYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImRlc3Ryb3kiLCIkZGVzdHJveSIsImRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsImJhc2VDdG9yIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwiZnVuY3Rpb25hbCIsIm5hdGl2ZU9uIiwiYWJzdHJhY3QiLCJpbnN0YWxsQ29tcG9uZW50SG9va3MiLCJfaXNDb21wb25lbnQiLCJfcGFyZW50Vm5vZGUiLCJpbmxpbmVUZW1wbGF0ZSIsInRvTWVyZ2UiLCJfbWVyZ2VkIiwibWVyZ2VIb29rJDEiLCJmMSIsImYyIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsIiR2bm9kZSIsInByZSIsImFwcGx5TlMiLCJyZWdpc3RlckRlZXBCaW5kaW5ncyIsImZvcmNlIiwic3R5bGUiLCJjbGFzcyIsImluaXRSZW5kZXIiLCJfdm5vZGUiLCJwYXJlbnRWbm9kZSIsIl9yZW5kZXJDaGlsZHJlbiIsInBhcmVudERhdGEiLCJpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQiLCJfcGFyZW50TGlzdGVuZXJzIiwiY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIiwicmVuZGVyTWl4aW4iLCJWdWUiLCIkbmV4dFRpY2siLCJyZW5kZXJFcnJvciIsImVuc3VyZUN0b3IiLCJjb21wIiwiYmFzZSIsIl9fZXNNb2R1bGUiLCJmYWN0b3J5IiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJvd25lciIsIm93bmVycyIsInN5bmMiLCJmb3JjZVJlbmRlciIsInJlbmRlckNvbXBsZXRlZCIsIiRmb3JjZVVwZGF0ZSIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJfdGFyZ2V0Iiwib25jZUhhbmRsZXIiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsImhvb2tSRSIsIiRvbmNlIiwiY2JzIiwiJGVtaXQiLCJsb3dlckNhc2VFdmVudCIsInNldEFjdGl2ZUluc3RhbmNlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiaW5pdExpZmVjeWNsZSIsIiRjaGlsZHJlbiIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsInByZXZFbCIsIiRlbCIsInByZXZWbm9kZSIsInJlc3RvcmVBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9fdnVlX18iLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ1cGRhdGVDb21wb25lbnQiLCJfbmFtZSIsIl91aWQiLCJXYXRjaGVyIiwiYmVmb3JlIiwicmVuZGVyQ2hpbGRyZW4iLCJoYXNEeW5hbWljU2NvcGVkU2xvdCIsIm5lZWRzRm9yY2VVcGRhdGUiLCIkYXR0cnMiLCIkbGlzdGVuZXJzIiwicHJvcEtleXMiLCJfcHJvcEtleXMiLCJpc0luSW5hY3RpdmVUcmVlIiwiZGlyZWN0IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiY3VycmVudEZsdXNoVGltZXN0YW1wIiwiZ2V0Tm93IiwiY3JlYXRlRXZlbnQiLCJ0aW1lU3RhbXAiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInJ1biIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwiZW1pdCIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImlzUmVuZGVyV2F0Y2hlciIsImRlZXAiLCJsYXp5IiwiYWN0aXZlIiwiZGlydHkiLCJkZXBzIiwibmV3RGVwcyIsImRlcElkcyIsIm5ld0RlcElkcyIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24iLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImh5cGhlbmF0ZWRLZXkiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVHZXR0ZXJJbnZva2VyIiwiY29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwidWlkJDMiLCJpbml0TWl4aW4iLCJfaW5pdCIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsIl9zZWxmIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwic3VwZXIiLCJzdXBlck9wdGlvbnMiLCJjYWNoZWRTdXBlck9wdGlvbnMiLCJtb2RpZmllZE9wdGlvbnMiLCJyZXNvbHZlTW9kaWZpZWRPcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsIm1vZGlmaWVkIiwibGF0ZXN0Iiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJwcnVuZUNhY2hlIiwia2VlcEFsaXZlSW5zdGFuY2UiLCJjYWNoZWROb2RlIiwicHJ1bmVDYWNoZUVudHJ5IiwiY3VycmVudCIsImNhY2hlZCQkMSIsInBhdHRlcm5UeXBlcyIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwiY3JlYXRlZCIsImRlc3Ryb3llZCIsIm1vdW50ZWQiLCJwYXJzZUludCIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsInV0aWwiLCJkZWZpbmVSZWFjdGl2ZSIsImRlbGV0ZSIsIm9ic2VydmFibGUiLCJzc3JDb250ZXh0IiwidmVyc2lvbiIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUiLCJjb252ZXJ0RW51bWVyYXRlZFZhbHVlIiwiaXNGYWxzeUF0dHJWYWx1ZSIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImdlbkNsYXNzRm9yVm5vZGUiLCJwYXJlbnROb2RlIiwiY2hpbGROb2RlIiwibWVyZ2VDbGFzc0RhdGEiLCJyZW5kZXJDbGFzcyIsInN0YXRpY0NsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZnlBcnJheSIsInN0cmluZ2lmeU9iamVjdCIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwiaXNQcmVUYWciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1RleHRJbnB1dFR5cGUiLCJzZWxlY3RlZCIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsInJlbW92ZUNoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwic2V0U3R5bGVTY29wZSIsInNjb3BlSWQiLCJub2RlT3BzIiwicmVmIiwicmVnaXN0ZXJSZWYiLCJpc1JlbW92YWwiLCJyZWZzIiwicmVmSW5Gb3IiLCJlbXB0eU5vZGUiLCJzYW1lVm5vZGUiLCJzYW1lSW5wdXRUeXBlIiwidHlwZUEiLCJ0eXBlQiIsImNyZWF0ZUtleVRvT2xkSWR4IiwiYmVnaW5JZHgiLCJlbmRJZHgiLCJjcmVhdGVQYXRjaEZ1bmN0aW9uIiwiYmFja2VuZCIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImlzVW5rbm93bkVsZW1lbnQkJDEiLCJpblZQcmUiLCJpZ25vcmUiLCJjcmVhdGluZ0VsbUluVlByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsInBhcmVudEVsbSIsInJlZkVsbSIsIm5lc3RlZCIsIm93bmVyQXJyYXkiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdENvbXBvbmVudCIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJpbm5lck5vZGUiLCJ0cmFuc2l0aW9uIiwiYWN0aXZhdGUiLCJyZWYkJDEiLCJjaGVja0R1cGxpY2F0ZUtleXMiLCJhbmNlc3RvciIsImFkZFZub2RlcyIsInN0YXJ0SWR4IiwiaW52b2tlRGVzdHJveUhvb2siLCJyZW1vdmVWbm9kZXMiLCJjaCIsInJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2siLCJybSIsInVwZGF0ZUNoaWxkcmVuIiwib2xkQ2giLCJuZXdDaCIsInJlbW92ZU9ubHkiLCJvbGRTdGFydElkeCIsIm5ld1N0YXJ0SWR4Iiwib2xkRW5kSWR4Iiwib2xkU3RhcnRWbm9kZSIsIm9sZEVuZFZub2RlIiwibmV3RW5kSWR4IiwibmV3U3RhcnRWbm9kZSIsIm5ld0VuZFZub2RlIiwib2xkS2V5VG9JZHgiLCJpZHhJbk9sZCIsInZub2RlVG9Nb3ZlIiwiY2FuTW92ZSIsInBhdGNoVm5vZGUiLCJmaW5kSWR4SW5PbGQiLCJzZWVuS2V5cyIsImVuZCIsImh5ZHJhdGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImh5ZHJhdGlvbkJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwiZnVsbEludm9rZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwiX2xlYXZlQ2IiLCJwYXRjaGFibGUiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiY2FsbEhvb2skMSIsIm9sZEFyZyIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsImJhc2VTZXRBdHRyIiwic2V0QXR0cmlidXRlTlMiLCJfX2llcGgiLCJibG9ja2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicmFuZ2UiLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsImR5bmFtaWMiLCJyYW5nZVNldEl0ZW0iLCJwbGFpbiIsImFkZEF0dHIiLCJkeW5hbWljQXR0cnMiLCJhZGRSYXdBdHRyIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJhZGREaXJlY3RpdmUiLCJpc0R5bmFtaWNBcmciLCJwcmVwZW5kTW9kaWZpZXJNYXJrZXIiLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwicHJldmVudCIsInJpZ2h0IiwibWlkZGxlIiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldFJhd0JpbmRpbmdBdHRyIiwicmF3QXR0cnNNYXAiLCJnZXRCaW5kaW5nQXR0ciIsImdldFN0YXRpYyIsImR5bmFtaWNWYWx1ZSIsImdldEFuZFJlbW92ZUF0dHIiLCJzdGF0aWNWYWx1ZSIsInJlbW92ZUZyb21NYXAiLCJnZXRBbmRSZW1vdmVBdHRyQnlSZWdleCIsImdlbkNvbXBvbmVudE1vZGVsIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsInBhcnNlTW9kZWwiLCJpbmRleCQxIiwiZXhwcmVzc2lvblBvcyIsImV4cHJlc3Npb25FbmRQb3MiLCJlb2YiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwidHlwZUJpbmRpbmciLCJuZWVkQ29tcG9zaXRpb25HdWFyZCIsIm5vcm1hbGl6ZUV2ZW50cyIsImNoYW5nZSIsInRhcmdldCQxIiwiY3JlYXRlT25jZUhhbmRsZXIkMSIsInJlbW92ZSQyIiwidXNlTWljcm90YXNrRml4IiwiYWRkJDEiLCJhdHRhY2hlZFRpbWVzdGFtcCIsIl93cmFwcGVyIiwiY3VycmVudFRhcmdldCIsIm93bmVyRG9jdW1lbnQiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJzdmdDb250YWluZXIiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzTm90SW5Gb2N1c0FuZERpcnR5IiwiaXNEaXJ0eVdpdGhNb2RpZmllcnMiLCJub3RJbkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJub3JtYWxpemUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJ3aGl0ZXNwYWNlUkUiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJlbmRlZCIsIm9uRW5kIiwicHJvcENvdW50IiwidHJhbnNmb3JtUkUiLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsImFwcGVhciIsInN0YXJ0Q2xhc3MiLCJhcHBlYXJDbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJiZWZvcmVBcHBlYXIiLCJiZWZvcmVFbnRlciIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiYWZ0ZXJBcHBlYXIiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZW50ZXJDYW5jZWxsZWQiLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJkdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwibGVhdmVDYW5jZWxsZWQiLCJhZnRlckxlYXZlIiwiZGVsYXlMZWF2ZSIsInBlcmZvcm1MZWF2ZSIsImJlZm9yZUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsInRyaWdnZXIiLCJkaXJlY3RpdmUiLCJfdk9wdGlvbnMiLCJzZXRTZWxlY3RlZCIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25FbmQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJvIiwibmVlZFJlc2V0IiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsImFjdHVhbGx5U2V0U2VsZWN0ZWQiLCJpc011bHRpcGxlIiwib3B0aW9uIiwic2VsZWN0ZWRJbmRleCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwidHJhbnNpdGlvbiQkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsImgiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiaXNOb3RUZXh0Tm9kZSIsImlzVlNob3dEaXJlY3RpdmUiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsImJlZm9yZU1vdW50Iiwia2VwdCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJyZW1vdmVkIiwicG9zIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidXBkYXRlZCIsImhhc01vdmUiLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwiYXBwbHlUcmFuc2xhdGlvbiIsIl9yZWZsb3ciLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwiZGVmYXVsdFRhZ1JFIiwicmVnZXhFc2NhcGVSRSIsImJ1aWxkUmVnZXgiLCJkZWxpbWl0ZXJzIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInRva2VucyIsInJhd1Rva2VucyIsInRva2VuVmFsdWUiLCJ0cmFuc2Zvcm1Ob2RlIiwiY2xhc3NCaW5kaW5nIiwiZ2VuRGF0YSIsImtsYXNzJDEiLCJ0cmFuc2Zvcm1Ob2RlJDEiLCJzdHlsZUJpbmRpbmciLCJnZW5EYXRhJDEiLCJzdHlsZSQxIiwiZGVjb2RlciIsImhlIiwiZGVjb2RlIiwiaHRtbCIsImlzVW5hcnlUYWciLCJjYW5CZUxlZnRPcGVuVGFnIiwiaXNOb25QaHJhc2luZ1RhZyIsImF0dHJpYnV0ZSIsImR5bmFtaWNBcmdBdHRyaWJ1dGUiLCJuY25hbWUiLCJxbmFtZUNhcHR1cmUiLCJzdGFydFRhZ09wZW4iLCJzdGFydFRhZ0Nsb3NlIiwiZG9jdHlwZSIsImNvbW1lbnQiLCJjb25kaXRpb25hbENvbW1lbnQiLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiaXNJZ25vcmVOZXdsaW5lVGFnIiwic2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lIiwiZGVjb2RlQXR0ciIsInNob3VsZERlY29kZU5ld2xpbmVzIiwicmUiLCJwYXJzZUhUTUwiLCJleHBlY3RIVE1MIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsInN1YnN0cmluZyIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwiYWxsIiwidW5hcnlTbGFzaCIsInVuYXJ5Iiwic2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmIiwib3V0cHV0U291cmNlUmFuZ2UiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsInN0cmlwUGFyZW5zUkUiLCJkeW5hbWljQXJnUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJzbG90UkUiLCJsaW5lQnJlYWtSRSIsIndoaXRlc3BhY2VSRSQxIiwiaW52YWxpZEF0dHJpYnV0ZVJFIiwiZGVjb2RlSFRNTENhY2hlZCIsImVtcHR5U2xvdFNjb3BlVG9rZW4iLCJ3YXJuJDIiLCJ0cmFuc2Zvcm1zIiwicHJlVHJhbnNmb3JtcyIsInBvc3RUcmFuc2Zvcm1zIiwicGxhdGZvcm1Jc1ByZVRhZyIsInBsYXRmb3JtTXVzdFVzZVByb3AiLCJwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSIsIm1heWJlQ29tcG9uZW50IiwiY3JlYXRlQVNURWxlbWVudCIsIm1ha2VBdHRyc01hcCIsInByZXNlcnZlV2hpdGVzcGFjZSIsIndoaXRlc3BhY2VPcHRpb24iLCJ3aGl0ZXNwYWNlIiwiY3VycmVudFBhcmVudCIsImluUHJlIiwid2FybmVkIiwid2Fybk9uY2UiLCJjbG9zZUVsZW1lbnQiLCJ0cmltRW5kaW5nV2hpdGVzcGFjZSIsInByb2Nlc3NlZCIsInByb2Nlc3NFbGVtZW50IiwiaWYiLCJlbHNlaWYiLCJlbHNlIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwiZm9yYmlkZGVuIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJsYXN0Tm9kZSIsImNvbW1lbnRzIiwiZ3VhcmRJRVNWR0J1ZyIsImN1bXVsYXRlZCIsImlzRm9yYmlkZGVuVGFnIiwicHJvY2Vzc1ByZSIsInByb2Nlc3NSYXdBdHRycyIsInByb2Nlc3NGb3IiLCJwcm9jZXNzSWYiLCJwcm9jZXNzT25jZSIsImlzVGV4dFRhZyIsInByb2Nlc3NLZXkiLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3RDb250ZW50IiwicHJvY2Vzc1Nsb3RPdXRsZXQiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiZm9yIiwiaXRlcmF0b3IyIiwiaXRlcmF0b3IxIiwiY2hlY2tJbkZvciIsInBhcnNlRm9yIiwiaW5NYXRjaCIsImFsaWFzIiwiaXRlcmF0b3JNYXRjaCIsImZpbmRQcmV2RWxlbWVudCIsImNvbmRpdGlvbiIsImlmQ29uZGl0aW9ucyIsInNsb3RUYXJnZXREeW5hbWljIiwic2xvdEJpbmRpbmciLCJnZXRTbG90TmFtZSIsInNsb3RDb250YWluZXIiLCJzbG90TmFtZSIsInN5bmNHZW4iLCJpc0R5bmFtaWMiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwicHJlVHJhbnNmb3JtTm9kZSIsImlmQ29uZGl0aW9uIiwiaWZDb25kaXRpb25FeHRyYSIsImhhc0Vsc2UiLCJlbHNlSWZDb25kaXRpb24iLCJicmFuY2gwIiwiY2xvbmVBU1RFbGVtZW50IiwiYnJhbmNoMSIsImJyYW5jaDIiLCJtb2RlbCQxIiwibW9kdWxlcyQxIiwiZGlyZWN0aXZlcyQxIiwiYmFzZU9wdGlvbnMiLCJpc1N0YXRpY0tleSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyIsImdlblN0YXRpY0tleXNDYWNoZWQiLCJnZW5TdGF0aWNLZXlzJDEiLCJvcHRpbWl6ZSIsIm1hcmtTdGF0aWMkMSIsIm1hcmtTdGF0aWNSb290cyIsInN0YXRpYyIsInN0YXRpY0luRm9yIiwic3RhdGljUm9vdCIsImlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIiwiZm5FeHBSRSIsImZuSW52b2tlUkUiLCJzaW1wbGVQYXRoUkUiLCJlc2MiLCJ0YWIiLCJzcGFjZSIsInVwIiwiZG93biIsImtleU5hbWVzIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwiY3RybCIsImFsdCIsIm1ldGEiLCJnZW5IYW5kbGVycyIsInByZWZpeCIsInN0YXRpY0hhbmRsZXJzIiwiZHluYW1pY0hhbmRsZXJzIiwiaGFuZGxlckNvZGUiLCJnZW5IYW5kbGVyIiwiaXNNZXRob2RQYXRoIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJpc0Z1bmN0aW9uSW52b2NhdGlvbiIsImdlbk1vZGlmaWVyQ29kZSIsImtleU1vZGlmaWVyIiwiZ2VuS2V5RmlsdGVyIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsImtleUNvZGUiLCJrZXlOYW1lIiwid3JhcExpc3RlbmVycyIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIkNvZGVnZW5TdGF0ZSIsImRhdGFHZW5GbnMiLCJvbmNlSWQiLCJnZW5lcmF0ZSIsImFzdCIsInN0YXRlIiwiZ2VuRWxlbWVudCIsInN0YXRpY1Byb2Nlc3NlZCIsImdlblN0YXRpYyIsIm9uY2VQcm9jZXNzZWQiLCJnZW5PbmNlIiwiZm9yUHJvY2Vzc2VkIiwiZ2VuRm9yIiwiaWZQcm9jZXNzZWQiLCJnZW5JZiIsImdlbkNoaWxkcmVuIiwiZ2VuU2xvdCIsImdlbkNvbXBvbmVudCIsImdlbkRhdGEkMiIsIm9yaWdpbmFsUHJlU3RhdGUiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImNvbnRhaW5zU2xvdENoaWxkIiwiZ2VuU2NvcGVkU2xvdCIsImlzTGVnYWN5U3ludGF4IiwicmV2ZXJzZVByb3h5IiwiY2hlY2tTa2lwIiwiYWx0R2VuRWxlbWVudCIsImFsdEdlbk5vZGUiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5Db21tZW50IiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwic3RhdGljUHJvcHMiLCJkeW5hbWljUHJvcHMiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJzdGlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJnZW5lcmF0ZUNvZGVGcmFtZSIsImxpbmVzIiwibGluZUxlbmd0aCIsInBhZCIsImNyZWF0ZUZ1bmN0aW9uIiwiZXJyb3JzIiwiY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiIsImNvbXBpbGUiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJ3YXJuJCQxIiwidGlwcyIsImZuR2VuRXJyb3JzIiwiY3JlYXRlQ29tcGlsZXJDcmVhdG9yIiwiYmFzZUNvbXBpbGUiLCJjcmVhdGVDb21waWxlciIsImZpbmFsT3B0aW9ucyIsImxlYWRpbmdTcGFjZUxlbmd0aCIsImRpdiIsImdldFNob3VsZERlY29kZSIsImhyZWYiLCJpZFRvVGVtcGxhdGUiLCJtb3VudCIsImRvY3VtZW50RWxlbWVudCIsImdldE91dGVySFRNTCIsIm91dGVySFRNTCIsImNvbnRhaW5lciIsIlNlbGVjdERhdGEiLCJTZWxlY3QiLCJTZWxlY3RDb21wb25lbnQiLCJfY29uc3RhbnRzIiwiZGF0YUhhbmRsZXIiLCJuZXdEYXRhIiwiY2hhcnQiLCJfY2hhcnQiLCJuZXdEYXRhc2V0TGFiZWxzIiwiZGF0YXNldHMiLCJvbGREYXRhc2V0TGFiZWxzIiwib2xkTGFiZWxzIiwibmV3TGFiZWxzIiwib2xkRGF0YXNldEtleXMiLCJuZXdEYXRhc2V0S2V5cyIsImRlbGV0aW9uS2V5cyIsImRlbGV0aW9uS2V5IiwibGFiZWxzIiwieExhYmVscyIsInlMYWJlbHMiLCJyZW5kZXJDaGFydCIsImNoYXJ0RGF0YSIsInJlYWN0aXZlRGF0YSIsInJlYWN0aXZlUHJvcCIsImhvb2tDYWxsYmFjayIsInNldEhvb2tDYWxsYmFjayIsImlucHV0IiwiaXNPYmplY3RFbXB0eSIsImlzVW5kZWZpbmVkIiwiaXNOdW1iZXIiLCJpc0RhdGUiLCJoYXNPd25Qcm9wIiwiY3JlYXRlVVRDIiwiZm9ybWF0IiwibG9jYWxlIiwic3RyaWN0IiwiY3JlYXRlTG9jYWxPclVUQyIsInV0YyIsImRlZmF1bHRQYXJzaW5nRmxhZ3MiLCJlbXB0eSIsInVudXNlZFRva2VucyIsInVudXNlZElucHV0Iiwib3ZlcmZsb3ciLCJjaGFyc0xlZnRPdmVyIiwibnVsbElucHV0IiwiaW52YWxpZE1vbnRoIiwiaW52YWxpZEZvcm1hdCIsInVzZXJJbnZhbGlkYXRlZCIsImlzbyIsInBhcnNlZERhdGVQYXJ0cyIsIm1lcmlkaWVtIiwicmZjMjgyMiIsIndlZWtkYXlNaXNtYXRjaCIsImdldFBhcnNpbmdGbGFncyIsIl9wZiIsImZ1biIsImlzVmFsaWQiLCJfaXNWYWxpZCIsImZsYWdzIiwicGFyc2VkUGFydHMiLCJpc05vd1ZhbGlkIiwiaW52YWxpZFdlZWtkYXkiLCJfc3RyaWN0IiwiYmlnSG91ciIsImNyZWF0ZUludmFsaWQiLCJOYU4iLCJtb21lbnRQcm9wZXJ0aWVzIiwiY29weUNvbmZpZyIsIl9pc0FNb21lbnRPYmplY3QiLCJfdHptIiwiX2lzVVRDIiwiX29mZnNldCIsIl9sb2NhbGUiLCJ1cGRhdGVJblByb2dyZXNzIiwiTW9tZW50IiwidXBkYXRlT2Zmc2V0IiwiaXNNb21lbnQiLCJhYnNGbG9vciIsImNlaWwiLCJ0b0ludCIsImFyZ3VtZW50Rm9yQ29lcmNpb24iLCJjb2VyY2VkTnVtYmVyIiwiY29tcGFyZUFycmF5cyIsImFycmF5MSIsImFycmF5MiIsImRvbnRDb252ZXJ0IiwibGVuZ3RoRGlmZiIsImFicyIsImRpZmZzIiwic3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzIiwiZGVwcmVjYXRlIiwiZmlyc3RUaW1lIiwiZGVwcmVjYXRpb25IYW5kbGVyIiwiZGVwcmVjYXRpb25zIiwiZGVwcmVjYXRlU2ltcGxlIiwiX2NvbmZpZyIsIl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCIsIl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwiX29yZGluYWxQYXJzZSIsIm1lcmdlQ29uZmlncyIsInBhcmVudENvbmZpZyIsImNoaWxkQ29uZmlnIiwiTG9jYWxlIiwiZGVmYXVsdENhbGVuZGFyIiwic2FtZURheSIsIm5leHREYXkiLCJuZXh0V2VlayIsImxhc3REYXkiLCJsYXN0V2VlayIsInNhbWVFbHNlIiwiY2FsZW5kYXIiLCJtb20iLCJvdXRwdXQiLCJfY2FsZW5kYXIiLCJkZWZhdWx0TG9uZ0RhdGVGb3JtYXQiLCJMVFMiLCJMVCIsIkwiLCJMTCIsIkxMTCIsIkxMTEwiLCJsb25nRGF0ZUZvcm1hdCIsIl9sb25nRGF0ZUZvcm1hdCIsImZvcm1hdFVwcGVyIiwiZGVmYXVsdEludmFsaWREYXRlIiwiaW52YWxpZERhdGUiLCJfaW52YWxpZERhdGUiLCJkZWZhdWx0T3JkaW5hbCIsImRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwib3JkaW5hbCIsIl9vcmRpbmFsIiwiZGVmYXVsdFJlbGF0aXZlVGltZSIsImZ1dHVyZSIsInBhc3QiLCJzcyIsIm1tIiwiaGgiLCJkZCIsIk0iLCJNTSIsInkiLCJ5eSIsInJlbGF0aXZlVGltZSIsIndpdGhvdXRTdWZmaXgiLCJpc0Z1dHVyZSIsIl9yZWxhdGl2ZVRpbWUiLCJwYXN0RnV0dXJlIiwiZGlmZiIsImFsaWFzZXMiLCJhZGRVbml0QWxpYXMiLCJ1bml0Iiwic2hvcnRoYW5kIiwibG93ZXJDYXNlIiwibm9ybWFsaXplVW5pdHMiLCJ1bml0cyIsIm5vcm1hbGl6ZU9iamVjdFVuaXRzIiwiaW5wdXRPYmplY3QiLCJub3JtYWxpemVkSW5wdXQiLCJub3JtYWxpemVkUHJvcCIsInByaW9yaXRpZXMiLCJhZGRVbml0UHJpb3JpdHkiLCJwcmlvcml0eSIsImdldFByaW9yaXRpemVkVW5pdHMiLCJ1bml0c09iaiIsInUiLCJ6ZXJvRmlsbCIsInRhcmdldExlbmd0aCIsImZvcmNlU2lnbiIsImFic051bWJlciIsInplcm9zVG9GaWxsIiwic2lnbiIsInBvdyIsImZvcm1hdHRpbmdUb2tlbnMiLCJsb2NhbEZvcm1hdHRpbmdUb2tlbnMiLCJmb3JtYXRGdW5jdGlvbnMiLCJmb3JtYXRUb2tlbkZ1bmN0aW9ucyIsImFkZEZvcm1hdFRva2VuIiwidG9rZW4iLCJwYWRkZWQiLCJsb2NhbGVEYXRhIiwicmVtb3ZlRm9ybWF0dGluZ1Rva2VucyIsIm1ha2VGb3JtYXRGdW5jdGlvbiIsImZvcm1hdE1vbWVudCIsImV4cGFuZEZvcm1hdCIsInJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyIsIm1hdGNoMSIsIm1hdGNoMiIsIm1hdGNoMyIsIm1hdGNoNCIsIm1hdGNoNiIsIm1hdGNoMXRvMiIsIm1hdGNoM3RvNCIsIm1hdGNoNXRvNiIsIm1hdGNoMXRvMyIsIm1hdGNoMXRvNCIsIm1hdGNoMXRvNiIsIm1hdGNoVW5zaWduZWQiLCJtYXRjaFNpZ25lZCIsIm1hdGNoT2Zmc2V0IiwibWF0Y2hTaG9ydE9mZnNldCIsIm1hdGNoVGltZXN0YW1wIiwibWF0Y2hXb3JkIiwicmVnZXhlcyIsImFkZFJlZ2V4VG9rZW4iLCJzdHJpY3RSZWdleCIsImlzU3RyaWN0IiwiZ2V0UGFyc2VSZWdleEZvclRva2VuIiwidW5lc2NhcGVGb3JtYXQiLCJyZWdleEVzY2FwZSIsIm1hdGNoZWQiLCJwMSIsInAyIiwicDMiLCJwNCIsImFkZFBhcnNlVG9rZW4iLCJhZGRXZWVrUGFyc2VUb2tlbiIsIl93IiwiYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4iLCJfYSIsIllFQVIiLCJNT05USCIsIkRBVEUiLCJIT1VSIiwiTUlOVVRFIiwiU0VDT05EIiwiTUlMTElTRUNPTkQiLCJXRUVLIiwiV0VFS0RBWSIsInBhcnNlVHdvRGlnaXRZZWFyIiwiZGF5c0luWWVhciIsImlzTGVhcFllYXIiLCJnZXRTZXRZZWFyIiwibWFrZUdldFNldCIsImdldElzTGVhcFllYXIiLCJrZWVwVGltZSIsInNldCQxIiwiZGF5c0luTW9udGgiLCJzdHJpbmdHZXQiLCJzdHJpbmdTZXQiLCJwcmlvcml0aXplZCIsIm1vZCIsIngiLCJtb2RNb250aCIsIm1vbnRoc1Nob3J0IiwibW9udGhzIiwibW9udGhzU2hvcnRSZWdleCIsIm1vbnRoc1JlZ2V4IiwibW9udGhzUGFyc2UiLCJNT05USFNfSU5fRk9STUFUIiwiZGVmYXVsdExvY2FsZU1vbnRocyIsImxvY2FsZU1vbnRocyIsIl9tb250aHMiLCJpc0Zvcm1hdCIsImRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCIsImxvY2FsZU1vbnRoc1Nob3J0IiwiX21vbnRoc1Nob3J0IiwiaGFuZGxlU3RyaWN0UGFyc2UiLCJtb250aE5hbWUiLCJpaSIsImxsYyIsInRvTG9jYWxlTG93ZXJDYXNlIiwiX21vbnRoc1BhcnNlIiwiX2xvbmdNb250aHNQYXJzZSIsIl9zaG9ydE1vbnRoc1BhcnNlIiwibG9jYWxlTW9udGhzUGFyc2UiLCJfbW9udGhzUGFyc2VFeGFjdCIsInNldE1vbnRoIiwiZGF5T2ZNb250aCIsImdldFNldE1vbnRoIiwiZ2V0RGF5c0luTW9udGgiLCJkZWZhdWx0TW9udGhzU2hvcnRSZWdleCIsImNvbXB1dGVNb250aHNQYXJzZSIsIl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IiwiX21vbnRoc1Nob3J0UmVnZXgiLCJkZWZhdWx0TW9udGhzUmVnZXgiLCJfbW9udGhzU3RyaWN0UmVnZXgiLCJfbW9udGhzUmVnZXgiLCJjbXBMZW5SZXYiLCJzaG9ydFBpZWNlcyIsImxvbmdQaWVjZXMiLCJtaXhlZFBpZWNlcyIsImNyZWF0ZURhdGUiLCJtcyIsImdldEZ1bGxZZWFyIiwic2V0RnVsbFllYXIiLCJjcmVhdGVVVENEYXRlIiwiVVRDIiwiZ2V0VVRDRnVsbFllYXIiLCJzZXRVVENGdWxsWWVhciIsImZpcnN0V2Vla09mZnNldCIsImRvdyIsImRveSIsImZ3ZCIsImZ3ZGx3IiwiZ2V0VVRDRGF5IiwiZGF5T2ZZZWFyRnJvbVdlZWtzIiwid2VlayIsIndlZWtkYXkiLCJsb2NhbFdlZWtkYXkiLCJ3ZWVrT2Zmc2V0IiwiZGF5T2ZZZWFyIiwicmVzWWVhciIsInJlc0RheU9mWWVhciIsIndlZWtPZlllYXIiLCJyZXNXZWVrIiwid2Vla3NJblllYXIiLCJ3ZWVrT2Zmc2V0TmV4dCIsImxvY2FsZVdlZWsiLCJfd2VlayIsImRlZmF1bHRMb2NhbGVXZWVrIiwibG9jYWxlRmlyc3REYXlPZldlZWsiLCJsb2NhbGVGaXJzdERheU9mWWVhciIsImdldFNldFdlZWsiLCJnZXRTZXRJU09XZWVrIiwid2Vla2RheXNNaW4iLCJ3ZWVrZGF5c1Nob3J0Iiwid2Vla2RheXMiLCJ3ZWVrZGF5c01pblJlZ2V4Iiwid2Vla2RheXNTaG9ydFJlZ2V4Iiwid2Vla2RheXNSZWdleCIsIndlZWtkYXlzUGFyc2UiLCJwYXJzZVdlZWtkYXkiLCJwYXJzZUlzb1dlZWtkYXkiLCJzaGlmdFdlZWtkYXlzIiwid3MiLCJkZWZhdWx0TG9jYWxlV2Vla2RheXMiLCJsb2NhbGVXZWVrZGF5cyIsIl93ZWVrZGF5cyIsImRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0IiwibG9jYWxlV2Vla2RheXNTaG9ydCIsIl93ZWVrZGF5c1Nob3J0IiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluIiwibG9jYWxlV2Vla2RheXNNaW4iLCJfd2Vla2RheXNNaW4iLCJoYW5kbGVTdHJpY3RQYXJzZSQxIiwid2Vla2RheU5hbWUiLCJfd2Vla2RheXNQYXJzZSIsIl9zaG9ydFdlZWtkYXlzUGFyc2UiLCJfbWluV2Vla2RheXNQYXJzZSIsImxvY2FsZVdlZWtkYXlzUGFyc2UiLCJfd2Vla2RheXNQYXJzZUV4YWN0IiwiX2Z1bGxXZWVrZGF5c1BhcnNlIiwiZ2V0U2V0RGF5T2ZXZWVrIiwiZ2V0RGF5IiwiZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIiwiZ2V0U2V0SVNPRGF5T2ZXZWVrIiwiZGVmYXVsdFdlZWtkYXlzUmVnZXgiLCJjb21wdXRlV2Vla2RheXNQYXJzZSIsIl93ZWVrZGF5c1N0cmljdFJlZ2V4IiwiX3dlZWtkYXlzUmVnZXgiLCJkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4IiwiX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCIsIl93ZWVrZGF5c1Nob3J0UmVnZXgiLCJkZWZhdWx0V2Vla2RheXNNaW5SZWdleCIsIl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IiwiX3dlZWtkYXlzTWluUmVnZXgiLCJtaW5QaWVjZXMiLCJtaW5wIiwic2hvcnRwIiwibG9uZ3AiLCJoRm9ybWF0IiwiaG91cnMiLCJrRm9ybWF0IiwibWludXRlcyIsInNlY29uZHMiLCJsb3dlcmNhc2UiLCJtYXRjaE1lcmlkaWVtIiwiX21lcmlkaWVtUGFyc2UiLCJrSW5wdXQiLCJfaXNQbSIsImlzUE0iLCJfbWVyaWRpZW0iLCJwb3MxIiwicG9zMiIsImxvY2FsZUlzUE0iLCJkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSIsImxvY2FsZU1lcmlkaWVtIiwiaXNMb3dlciIsImdldFNldEhvdXIiLCJiYXNlQ29uZmlnIiwiZGF5T2ZNb250aE9yZGluYWxQYXJzZSIsIm1lcmlkaWVtUGFyc2UiLCJsb2NhbGVzIiwibG9jYWxlRmFtaWxpZXMiLCJnbG9iYWxMb2NhbGUiLCJub3JtYWxpemVMb2NhbGUiLCJjaG9vc2VMb2NhbGUiLCJuYW1lcyIsImxvYWRMb2NhbGUiLCJvbGRMb2NhbGUiLCJfYWJiciIsImFsaWFzZWRSZXF1aXJlIiwiZ2V0U2V0R2xvYmFsTG9jYWxlIiwiZ2V0TG9jYWxlIiwiZGVmaW5lTG9jYWxlIiwiYWJiciIsInBhcmVudExvY2FsZSIsInVwZGF0ZUxvY2FsZSIsInRtcExvY2FsZSIsImxpc3RMb2NhbGVzIiwiY2hlY2tPdmVyZmxvdyIsIl9vdmVyZmxvd0RheU9mWWVhciIsIl9vdmVyZmxvd1dlZWtzIiwiX292ZXJmbG93V2Vla2RheSIsImRlZmF1bHRzIiwiY3VycmVudERhdGVBcnJheSIsIm5vd1ZhbHVlIiwiX3VzZVVUQyIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImNvbmZpZ0Zyb21BcnJheSIsImN1cnJlbnREYXRlIiwiZXhwZWN0ZWRXZWVrZGF5IiwieWVhclRvVXNlIiwiZGF5T2ZZZWFyRnJvbVdlZWtJbmZvIiwiX2RheU9mWWVhciIsIl9uZXh0RGF5Iiwic2V0VVRDTWludXRlcyIsImdldFVUQ01pbnV0ZXMiLCJ3Iiwid2Vla1llYXIiLCJ0ZW1wIiwid2Vla2RheU92ZXJmbG93IiwiR0ciLCJXIiwiRSIsImNyZWF0ZUxvY2FsIiwiY3VyV2VlayIsImdnIiwiZXh0ZW5kZWRJc29SZWdleCIsImJhc2ljSXNvUmVnZXgiLCJ0elJlZ2V4IiwiaXNvRGF0ZXMiLCJpc29UaW1lcyIsImFzcE5ldEpzb25SZWdleCIsImNvbmZpZ0Zyb21JU08iLCJhbGxvd1RpbWUiLCJkYXRlRm9ybWF0IiwidGltZUZvcm1hdCIsInR6Rm9ybWF0IiwiY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCIsImV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MiLCJ5ZWFyU3RyIiwibW9udGhTdHIiLCJkYXlTdHIiLCJob3VyU3RyIiwibWludXRlU3RyIiwic2Vjb25kU3RyIiwidW50cnVuY2F0ZVllYXIiLCJwcmVwcm9jZXNzUkZDMjgyMiIsImNoZWNrV2Vla2RheSIsIndlZWtkYXlTdHIiLCJwYXJzZWRJbnB1dCIsIndlZWtkYXlQcm92aWRlZCIsIndlZWtkYXlBY3R1YWwiLCJvYnNPZmZzZXRzIiwiVVQiLCJHTVQiLCJFRFQiLCJFU1QiLCJDRFQiLCJDU1QiLCJNRFQiLCJNU1QiLCJQRFQiLCJQU1QiLCJjYWxjdWxhdGVPZmZzZXQiLCJvYnNPZmZzZXQiLCJtaWxpdGFyeU9mZnNldCIsIm51bU9mZnNldCIsImhtIiwiY29uZmlnRnJvbVJGQzI4MjIiLCJwYXJzZWRBcnJheSIsImNvbmZpZ0Zyb21TdHJpbmciLCJjcmVhdGVGcm9tSW5wdXRGYWxsYmFjayIsIklTT184NjAxIiwiUkZDXzI4MjIiLCJza2lwcGVkIiwic3RyaW5nTGVuZ3RoIiwidG90YWxQYXJzZWRJbnB1dExlbmd0aCIsIm1lcmlkaWVtRml4V3JhcCIsImhvdXIiLCJpc1BtIiwibWVyaWRpZW1Ib3VyIiwiY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5IiwidGVtcENvbmZpZyIsImJlc3RNb21lbnQiLCJzY29yZVRvQmVhdCIsImN1cnJlbnRTY29yZSIsInNjb3JlIiwiY29uZmlnRnJvbU9iamVjdCIsIm1pbnV0ZSIsInNlY29uZCIsIm1pbGxpc2Vjb25kIiwiY3JlYXRlRnJvbUNvbmZpZyIsInByZXBhcmVDb25maWciLCJwcmVwYXJzZSIsImNvbmZpZ0Zyb21JbnB1dCIsImlzVVRDIiwicHJvdG90eXBlTWluIiwicHJvdG90eXBlTWF4IiwicGlja0J5IiwibW9tZW50cyIsIm9yZGVyaW5nIiwiaXNEdXJhdGlvblZhbGlkIiwidW5pdEhhc0RlY2ltYWwiLCJpc1ZhbGlkJDEiLCJjcmVhdGVJbnZhbGlkJDEiLCJjcmVhdGVEdXJhdGlvbiIsIkR1cmF0aW9uIiwieWVhcnMiLCJxdWFydGVycyIsInF1YXJ0ZXIiLCJ3ZWVrcyIsImlzb1dlZWsiLCJkYXlzIiwibWlsbGlzZWNvbmRzIiwiX21pbGxpc2Vjb25kcyIsIl9kYXlzIiwiX2J1YmJsZSIsImlzRHVyYXRpb24iLCJhYnNSb3VuZCIsInJvdW5kIiwic2VwYXJhdG9yIiwidXRjT2Zmc2V0Iiwib2Zmc2V0RnJvbVN0cmluZyIsImNodW5rT2Zmc2V0IiwibWF0Y2hlciIsImNodW5rIiwicGFydHMiLCJjbG9uZVdpdGhPZmZzZXQiLCJzZXRUaW1lIiwibG9jYWwiLCJnZXREYXRlT2Zmc2V0IiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJnZXRTZXRPZmZzZXQiLCJrZWVwTG9jYWxUaW1lIiwia2VlcE1pbnV0ZXMiLCJsb2NhbEFkanVzdCIsIl9jaGFuZ2VJblByb2dyZXNzIiwiYWRkU3VidHJhY3QiLCJnZXRTZXRab25lIiwic2V0T2Zmc2V0VG9VVEMiLCJzZXRPZmZzZXRUb0xvY2FsIiwic3VidHJhY3QiLCJzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCIsInRab25lIiwiaGFzQWxpZ25lZEhvdXJPZmZzZXQiLCJpc0RheWxpZ2h0U2F2aW5nVGltZSIsImlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCIsIl9pc0RTVFNoaWZ0ZWQiLCJpc0xvY2FsIiwiaXNVdGNPZmZzZXQiLCJpc1V0YyIsImFzcE5ldFJlZ2V4IiwiaXNvUmVnZXgiLCJkaWZmUmVzIiwicGFyc2VJc28iLCJtb21lbnRzRGlmZmVyZW5jZSIsImludmFsaWQiLCJpbnAiLCJwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlIiwiaXNBZnRlciIsImlzQmVmb3JlIiwiY3JlYXRlQWRkZXIiLCJkaXJlY3Rpb24iLCJwZXJpb2QiLCJkdXIiLCJpc0FkZGluZyIsImdldENhbGVuZGFyRm9ybWF0IiwibXlNb21lbnQiLCJjYWxlbmRhciQxIiwidGltZSIsImZvcm1hdHMiLCJzb2QiLCJzdGFydE9mIiwiY2FsZW5kYXJGb3JtYXQiLCJsb2NhbElucHV0IiwiZW5kT2YiLCJpc0JldHdlZW4iLCJpbmNsdXNpdml0eSIsImxvY2FsRnJvbSIsImxvY2FsVG8iLCJpc1NhbWUiLCJpbnB1dE1zIiwiaXNTYW1lT3JBZnRlciIsImlzU2FtZU9yQmVmb3JlIiwiYXNGbG9hdCIsInRoYXQiLCJ6b25lRGVsdGEiLCJtb250aERpZmYiLCJ3aG9sZU1vbnRoRGlmZiIsImFuY2hvciIsImFuY2hvcjIiLCJhZGp1c3QiLCJkZWZhdWx0Rm9ybWF0IiwiZGVmYXVsdEZvcm1hdFV0YyIsInRvSVNPU3RyaW5nIiwia2VlcE9mZnNldCIsInRvRGF0ZSIsImluc3BlY3QiLCJ6b25lIiwiZGF0ZXRpbWUiLCJzdWZmaXgiLCJpbnB1dFN0cmluZyIsInBvc3Rmb3JtYXQiLCJodW1hbml6ZSIsImZyb21Ob3ciLCJ0b05vdyIsIm5ld0xvY2FsZURhdGEiLCJsYW5nIiwiTVNfUEVSX1NFQ09ORCIsIk1TX1BFUl9NSU5VVEUiLCJNU19QRVJfSE9VUiIsIk1TX1BFUl80MDBfWUVBUlMiLCJtb2QkMSIsImRpdmlkZW5kIiwiZGl2aXNvciIsImxvY2FsU3RhcnRPZkRhdGUiLCJ1dGNTdGFydE9mRGF0ZSIsInN0YXJ0T2ZEYXRlIiwiaXNvV2Vla2RheSIsInVuaXgiLCJ0b0pTT04iLCJpc1ZhbGlkJDIiLCJwYXJzaW5nRmxhZ3MiLCJpbnZhbGlkQXQiLCJjcmVhdGlvbkRhdGEiLCJpc29XZWVrWWVhciIsImFkZFdlZWtZZWFyRm9ybWF0VG9rZW4iLCJnZXRTZXRXZWVrWWVhciIsImdldFNldFdlZWtZZWFySGVscGVyIiwiZ2V0U2V0SVNPV2Vla1llYXIiLCJnZXRJU09XZWVrc0luWWVhciIsImdldFdlZWtzSW5ZZWFyIiwid2Vla0luZm8iLCJ3ZWVrc1RhcmdldCIsInNldFdlZWtBbGwiLCJkYXlPZlllYXJEYXRhIiwiZ2V0U2V0UXVhcnRlciIsImdldFNldERheU9mTW9udGgiLCJnZXRTZXREYXlPZlllYXIiLCJnZXRTZXRNaW51dGUiLCJnZXRTZXRTZWNvbmQiLCJwYXJzZU1zIiwiZ2V0U2V0TWlsbGlzZWNvbmQiLCJnZXRab25lQWJiciIsImdldFpvbmVOYW1lIiwiaXNvV2Vla3MiLCJpc29XZWVrc0luWWVhciIsInBhcnNlWm9uZSIsImlzRFNUIiwiem9uZUFiYnIiLCJ6b25lTmFtZSIsImRhdGVzIiwiaXNEU1RTaGlmdGVkIiwiY3JlYXRlVW5peCIsImNyZWF0ZUluWm9uZSIsInByZVBhcnNlUG9zdEZvcm1hdCIsInByb3RvJDEiLCJmaXJzdERheU9mWWVhciIsImZpcnN0RGF5T2ZXZWVrIiwiZ2V0JDEiLCJmaWVsZCIsImxpc3RNb250aHNJbXBsIiwib3V0IiwibGlzdFdlZWtkYXlzSW1wbCIsImxvY2FsZVNvcnRlZCIsImxpc3RNb250aHMiLCJsaXN0TW9udGhzU2hvcnQiLCJsaXN0V2Vla2RheXMiLCJsaXN0V2Vla2RheXNTaG9ydCIsImxpc3RXZWVrZGF5c01pbiIsImxhbmdEYXRhIiwibWF0aEFicyIsImFkZFN1YnRyYWN0JDEiLCJzdWJ0cmFjdCQxIiwiYWJzQ2VpbCIsImJ1YmJsZSIsIm1vbnRoc0Zyb21EYXlzIiwibW9udGhzVG9EYXlzIiwiZGF5c1RvTW9udGhzIiwiYXMiLCJ2YWx1ZU9mJDEiLCJtYWtlQXMiLCJhc01pbGxpc2Vjb25kcyIsImFzU2Vjb25kcyIsImFzTWludXRlcyIsImFzSG91cnMiLCJhc0RheXMiLCJhc1dlZWtzIiwiYXNNb250aHMiLCJhc1F1YXJ0ZXJzIiwiYXNZZWFycyIsImNsb25lJDEiLCJnZXQkMiIsIm1ha2VHZXR0ZXIiLCJ0aHJlc2hvbGRzIiwic3Vic3RpdHV0ZVRpbWVBZ28iLCJyZWxhdGl2ZVRpbWUkMSIsInBvc05lZ0R1cmF0aW9uIiwiZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmciLCJyb3VuZGluZ0Z1bmN0aW9uIiwiZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkIiwidGhyZXNob2xkIiwibGltaXQiLCJ3aXRoU3VmZml4IiwiYWJzJDEiLCJ0b0lTT1N0cmluZyQxIiwiWSIsIkQiLCJ0b0ZpeGVkIiwidG90YWwiLCJ0b3RhbFNpZ24iLCJ5bVNpZ24iLCJkYXlzU2lnbiIsImhtc1NpZ24iLCJwcm90byQyIiwidG9Jc29TdHJpbmciLCJyZWxhdGl2ZVRpbWVSb3VuZGluZyIsInJlbGF0aXZlVGltZVRocmVzaG9sZCIsIkhUTUw1X0ZNVCIsIkRBVEVUSU1FX0xPQ0FMIiwiREFURVRJTUVfTE9DQUxfU0VDT05EUyIsIkRBVEVUSU1FX0xPQ0FMX01TIiwiVElNRSIsIlRJTUVfU0VDT05EUyIsIlRJTUVfTVMiLCJyZXF1aXJlJCQwIiwibW9tZW50IiwiY29udmVyc2lvbnMiLCJyZ2IyaHNsIiwicmdiMmhzdiIsInJnYjJod2IiLCJyZ2IyY215ayIsInJnYjJrZXl3b3JkIiwicmdiMnh5eiIsInJnYjJsYWIiLCJyZ2IybGNoIiwiaHNsMnJnYiIsImhzbDJoc3YiLCJoc2wyaHdiIiwiaHNsMmNteWsiLCJoc2wya2V5d29yZCIsImhzdjJyZ2IiLCJoc3YyaHNsIiwiaHN2Mmh3YiIsImhzdjJjbXlrIiwiaHN2MmtleXdvcmQiLCJod2IycmdiIiwiaHdiMmhzbCIsImh3YjJoc3YiLCJod2IyY215ayIsImh3YjJrZXl3b3JkIiwiY215azJyZ2IiLCJjbXlrMmhzbCIsImNteWsyaHN2IiwiY215azJod2IiLCJjbXlrMmtleXdvcmQiLCJrZXl3b3JkMnJnYiIsImtleXdvcmQyaHNsIiwia2V5d29yZDJoc3YiLCJrZXl3b3JkMmh3YiIsImtleXdvcmQyY215ayIsImtleXdvcmQybGFiIiwia2V5d29yZDJ4eXoiLCJ4eXoycmdiIiwieHl6MmxhYiIsInh5ejJsY2giLCJsYWIyeHl6IiwibGFiMnJnYiIsImxhYjJsY2giLCJsY2gybGFiIiwibGNoMnh5eiIsImxjaDJyZ2IiLCJyZ2IiLCJyIiwiZyIsImRlbHRhIiwicmV2ZXJzZUtleXdvcmRzIiwieiIsInh5eiIsImhzbCIsInQxIiwidDIiLCJ0MyIsInN2IiwiaHN2IiwiaGkiLCJmIiwicSIsInNsIiwiaHdiIiwid2giLCJibCIsInJhdGlvIiwiY215ayIsImxhYiIsInkyIiwiaHIiLCJhdGFuMiIsIlBJIiwic3FydCIsImxjaCIsImNvcyIsInNpbiIsImtleXdvcmQiLCJjc3NLZXl3b3JkcyIsImFsaWNlYmx1ZSIsImFudGlxdWV3aGl0ZSIsImFxdWEiLCJhcXVhbWFyaW5lIiwiYXp1cmUiLCJiZWlnZSIsImJpc3F1ZSIsImJsYWNrIiwiYmxhbmNoZWRhbG1vbmQiLCJibHVlIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiY2FkZXRibHVlIiwiY2hhcnRyZXVzZSIsImNob2NvbGF0ZSIsImNvcmFsIiwiY29ybmZsb3dlcmJsdWUiLCJjb3Juc2lsayIsImNyaW1zb24iLCJjeWFuIiwiZGFya2JsdWUiLCJkYXJrY3lhbiIsImRhcmtnb2xkZW5yb2QiLCJkYXJrZ3JheSIsImRhcmtncmVlbiIsImRhcmtncmV5IiwiZGFya2toYWtpIiwiZGFya21hZ2VudGEiLCJkYXJrb2xpdmVncmVlbiIsImRhcmtvcmFuZ2UiLCJkYXJrb3JjaGlkIiwiZGFya3JlZCIsImRhcmtzYWxtb24iLCJkYXJrc2VhZ3JlZW4iLCJkYXJrc2xhdGVibHVlIiwiZGFya3NsYXRlZ3JheSIsImRhcmtzbGF0ZWdyZXkiLCJkYXJrdHVycXVvaXNlIiwiZGFya3Zpb2xldCIsImRlZXBwaW5rIiwiZGVlcHNreWJsdWUiLCJkaW1ncmF5IiwiZGltZ3JleSIsImRvZGdlcmJsdWUiLCJmaXJlYnJpY2siLCJmbG9yYWx3aGl0ZSIsImZvcmVzdGdyZWVuIiwiZnVjaHNpYSIsImdhaW5zYm9ybyIsImdob3N0d2hpdGUiLCJnb2xkIiwiZ29sZGVucm9kIiwiZ3JheSIsImdyZWVuIiwiZ3JlZW55ZWxsb3ciLCJncmV5IiwiaG9uZXlkZXciLCJob3RwaW5rIiwiaW5kaWFucmVkIiwiaW5kaWdvIiwiaXZvcnkiLCJraGFraSIsImxhdmVuZGVyIiwibGF2ZW5kZXJibHVzaCIsImxhd25ncmVlbiIsImxlbW9uY2hpZmZvbiIsImxpZ2h0Ymx1ZSIsImxpZ2h0Y29yYWwiLCJsaWdodGN5YW4iLCJsaWdodGdvbGRlbnJvZHllbGxvdyIsImxpZ2h0Z3JheSIsImxpZ2h0Z3JlZW4iLCJsaWdodGdyZXkiLCJsaWdodHBpbmsiLCJsaWdodHNhbG1vbiIsImxpZ2h0c2VhZ3JlZW4iLCJsaWdodHNreWJsdWUiLCJsaWdodHNsYXRlZ3JheSIsImxpZ2h0c2xhdGVncmV5IiwibGlnaHRzdGVlbGJsdWUiLCJsaWdodHllbGxvdyIsImxpbWUiLCJsaW1lZ3JlZW4iLCJsaW5lbiIsIm1hZ2VudGEiLCJtYXJvb24iLCJtZWRpdW1hcXVhbWFyaW5lIiwibWVkaXVtYmx1ZSIsIm1lZGl1bW9yY2hpZCIsIm1lZGl1bXB1cnBsZSIsIm1lZGl1bXNlYWdyZWVuIiwibWVkaXVtc2xhdGVibHVlIiwibWVkaXVtc3ByaW5nZ3JlZW4iLCJtZWRpdW10dXJxdW9pc2UiLCJtZWRpdW12aW9sZXRyZWQiLCJtaWRuaWdodGJsdWUiLCJtaW50Y3JlYW0iLCJtaXN0eXJvc2UiLCJtb2NjYXNpbiIsIm5hdmFqb3doaXRlIiwibmF2eSIsIm9sZGxhY2UiLCJvbGl2ZSIsIm9saXZlZHJhYiIsIm9yYW5nZSIsIm9yYW5nZXJlZCIsIm9yY2hpZCIsInBhbGVnb2xkZW5yb2QiLCJwYWxlZ3JlZW4iLCJwYWxldHVycXVvaXNlIiwicGFsZXZpb2xldHJlZCIsInBhcGF5YXdoaXAiLCJwZWFjaHB1ZmYiLCJwZXJ1IiwicGluayIsInBsdW0iLCJwb3dkZXJibHVlIiwicHVycGxlIiwicmViZWNjYXB1cnBsZSIsInJlZCIsInJvc3licm93biIsInJveWFsYmx1ZSIsInNhZGRsZWJyb3duIiwic2FsbW9uIiwic2FuZHlicm93biIsInNlYWdyZWVuIiwic2Vhc2hlbGwiLCJzaWVubmEiLCJzaWx2ZXIiLCJza3libHVlIiwic2xhdGVibHVlIiwic2xhdGVncmF5Iiwic2xhdGVncmV5Iiwic25vdyIsInNwcmluZ2dyZWVuIiwic3RlZWxibHVlIiwidGFuIiwidGVhbCIsInRoaXN0bGUiLCJ0b21hdG8iLCJ0dXJxdW9pc2UiLCJ2aW9sZXQiLCJ3aGVhdCIsIndoaXRlIiwid2hpdGVzbW9rZSIsInllbGxvdyIsInllbGxvd2dyZWVuIiwiQ29udmVydGVyIiwicGFpciIsImNvbnZzIiwicm91dGVTcGFjZSIsImdldFZhbHVlcyIsInNldFZhbHVlcyIsInZhbHMiLCJmc3BhY2UiLCJjb2xvckNvbnZlcnQiLCJjb2xvck5hbWUiLCJjb2xvclN0cmluZyIsImdldFJnYmEiLCJnZXRIc2xhIiwiZ2V0UmdiIiwiZ2V0SHNsIiwiZ2V0SHdiIiwiZ2V0QWxwaGEiLCJoZXhTdHJpbmciLCJyZ2JTdHJpbmciLCJyZ2JhU3RyaW5nIiwicGVyY2VudFN0cmluZyIsInBlcmNlbnRhU3RyaW5nIiwiaHNsU3RyaW5nIiwiaHNsYVN0cmluZyIsImh3YlN0cmluZyIsImhleCIsInJnYmEiLCJwZXIiLCJoZXhBbHBoYSIsInNjYWxlIiwiYWxwaGEiLCJoc2xhIiwiaGV4RG91YmxlIiwicmV2ZXJzZU5hbWVzIiwibnVtIiwiQ29sb3IiLCJsaWdodG5lc3MiLCJ3aGl0ZW5lc3MiLCJzZXRTcGFjZSIsInJnYkFycmF5IiwiaHNsQXJyYXkiLCJoc3ZBcnJheSIsImh3YkFycmF5IiwiY215a0FycmF5IiwicmdiYUFycmF5IiwiaHNsYUFycmF5Iiwic2V0Q2hhbm5lbCIsImh1ZSIsInNhdHVyYXRpb24iLCJzYXR1cmF0aW9udiIsImJsYWNrbmVzcyIsInJnYk51bWJlciIsImx1bWlub3NpdHkiLCJsdW0iLCJjaGFuIiwiY29udHJhc3QiLCJjb2xvcjIiLCJsdW0xIiwibHVtMiIsImxldmVsIiwiY29udHJhc3RSYXRpbyIsImRhcmsiLCJ5aXEiLCJsaWdodCIsIm5lZ2F0ZSIsImxpZ2h0ZW4iLCJkYXJrZW4iLCJzYXR1cmF0ZSIsImRlc2F0dXJhdGUiLCJ3aGl0ZW4iLCJibGFja2VuIiwiZ3JleXNjYWxlIiwiY2xlYXJlciIsIm9wYXF1ZXIiLCJyb3RhdGUiLCJkZWdyZWVzIiwibWl4IiwibWl4aW5Db2xvciIsIndlaWdodCIsImNvbG9yMSIsIncxIiwidzIiLCJzcGFjZXMiLCJtYXhlcyIsImNoYW5zIiwiY2FwcGVkIiwic25hbWUiLCJzdmFsdWVzIiwiY2hhcnRqc0NvbG9yIiwiaGVscGVycyIsImlzTnVsbE9yVW5kZWYiLCJ2YWx1ZU9yRGVmYXVsdCIsInZhbHVlQXRJbmRleE9yRGVmYXVsdCIsImVhY2giLCJsb29wYWJsZSIsInJldmVyc2UiLCJhcnJheUVxdWFscyIsImEwIiwiYTEiLCJpbGVuIiwidjAiLCJ2MSIsImtsZW4iLCJfbWVyZ2VyIiwidHZhbCIsInN2YWwiLCJfbWVyZ2VySWYiLCJtZXJnZUlmIiwibWVyZ2VyIiwic2V0Rm4iLCJpbmhlcml0cyIsImV4dGVuc2lvbnMiLCJtZSIsIkNoYXJ0RWxlbWVudCIsIlN1cnJvZ2F0ZSIsIl9fc3VwZXJfXyIsImhlbHBlcnNfY29yZSIsImNhbGxDYWxsYmFjayIsImZyb21JbmRleCIsImdldFZhbHVlT3JEZWZhdWx0IiwiZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0IiwiZWZmZWN0cyIsImxpbmVhciIsImVhc2VJblF1YWQiLCJlYXNlT3V0UXVhZCIsImVhc2VJbk91dFF1YWQiLCJlYXNlSW5DdWJpYyIsImVhc2VPdXRDdWJpYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluUXVhcnQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJblF1aW50IiwiZWFzZU91dFF1aW50IiwiZWFzZUluT3V0UXVpbnQiLCJlYXNlSW5TaW5lIiwiZWFzZU91dFNpbmUiLCJlYXNlSW5PdXRTaW5lIiwiZWFzZUluRXhwbyIsImVhc2VPdXRFeHBvIiwiZWFzZUluT3V0RXhwbyIsImVhc2VJbkNpcmMiLCJlYXNlT3V0Q2lyYyIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5FbGFzdGljIiwiYXNpbiIsImVhc2VPdXRFbGFzdGljIiwiZWFzZUluT3V0RWxhc3RpYyIsImVhc2VJbkJhY2siLCJlYXNlT3V0QmFjayIsImVhc2VJbk91dEJhY2siLCJlYXNlSW5Cb3VuY2UiLCJlYXNlT3V0Qm91bmNlIiwiZWFzZUluT3V0Qm91bmNlIiwiaGVscGVyc19lYXNpbmciLCJlYXNpbmdFZmZlY3RzIiwiUkFEX1BFUl9ERUciLCJET1VCTEVfUEkiLCJIQUxGX1BJIiwiUVVBUlRFUl9QSSIsIlRXT19USElSRFNfUEkiLCJleHBvcnRzJDEiLCJjbGVhclJlY3QiLCJ3aWR0aCIsImhlaWdodCIsInJvdW5kZWRSZWN0IiwicmFkaXVzIiwiYm90dG9tIiwibW92ZVRvIiwiYXJjIiwiY2xvc2VQYXRoIiwicmVjdCIsImRyYXdQb2ludCIsInJvdGF0aW9uIiwieE9mZnNldCIsInlPZmZzZXQiLCJjb3JuZXJSYWRpdXMiLCJyYWQiLCJkcmF3SW1hZ2UiLCJiZWdpblBhdGgiLCJsaW5lVG8iLCJTUVJUMV8yIiwiZmlsbCIsInN0cm9rZSIsIl9pc1BvaW50SW5BcmVhIiwicG9pbnQiLCJhcmVhIiwiZXBzaWxvbiIsImNsaXBBcmVhIiwic2F2ZSIsImNsaXAiLCJ1bmNsaXBBcmVhIiwicmVzdG9yZSIsInByZXZpb3VzIiwiZmxpcCIsInN0ZXBwZWQiLCJzdGVwcGVkTGluZSIsIm1pZHBvaW50IiwidGVuc2lvbiIsImJlemllckN1cnZlVG8iLCJjb250cm9sUG9pbnRQcmV2aW91c1giLCJjb250cm9sUG9pbnROZXh0WCIsImNvbnRyb2xQb2ludFByZXZpb3VzWSIsImNvbnRyb2xQb2ludE5leHRZIiwiaGVscGVyc19jYW52YXMiLCJkcmF3Um91bmRlZFJlY3RhbmdsZSIsIl9zZXQiLCJzY29wZSIsImRlZmF1bHRDb2xvciIsImRlZmF1bHRGb250Q29sb3IiLCJkZWZhdWx0Rm9udEZhbWlseSIsImRlZmF1bHRGb250U2l6ZSIsImRlZmF1bHRGb250U3R5bGUiLCJkZWZhdWx0TGluZUhlaWdodCIsInNob3dMaW5lcyIsImNvcmVfZGVmYXVsdHMiLCJ0b0ZvbnRTdHJpbmciLCJmb250IiwiZmFtaWx5IiwiaGVscGVyc19vcHRpb25zIiwidG9MaW5lSGVpZ2h0IiwidG9QYWRkaW5nIiwiX3BhcnNlRm9udCIsImdsb2JhbERlZmF1bHRzIiwiZm9udEZhbWlseSIsImxpbmVIZWlnaHQiLCJmb250U3R5bGUiLCJpbnB1dHMiLCJoZWxwZXJzJDEiLCJlYXNpbmciLCJjYW52YXMiLCJlYXNlIiwib3JpZ2luIiwiYzAiLCJjMSIsIkVsZW1lbnQiLCJjb25maWd1cmF0aW9uIiwiaW5pdGlhbGl6ZSIsImhpZGRlbiIsInBpdm90IiwiX3ZpZXciLCJfbW9kZWwiLCJfc3RhcnQiLCJ0b29sdGlwUG9zaXRpb24iLCJoYXNWYWx1ZSIsImNvcmVfZWxlbWVudCIsImV4cG9ydHMkMiIsImN1cnJlbnRTdGVwIiwibnVtU3RlcHMiLCJvbkFuaW1hdGlvblByb2dyZXNzIiwib25BbmltYXRpb25Db21wbGV0ZSIsImNvcmVfYW5pbWF0aW9uIiwiYW5pbWF0aW9uIiwib25Qcm9ncmVzcyIsIm9uQ29tcGxldGUiLCJjb3JlX2FuaW1hdGlvbnMiLCJhbmltYXRpb25zIiwicmVxdWVzdCIsImFkZEFuaW1hdGlvbiIsInN0YXJ0VGltZSIsImFuaW1hdGluZyIsImNhbmNlbEFuaW1hdGlvbiIsImZpbmRJbmRleCIsInJlcXVlc3RBbmltRnJhbWUiLCJzdGFydERpZ2VzdCIsIm5leHRTdGVwIiwiYXJyYXlFdmVudHMiLCJsaXN0ZW5BcnJheUV2ZW50cyIsImxpc3RlbmVyIiwiX2NoYXJ0anMiLCJ1bmxpc3RlbkFycmF5RXZlbnRzIiwic3R1YiIsIkRhdGFzZXRDb250cm9sbGVyIiwiZGF0YXNldEluZGV4IiwiZGF0YXNldEVsZW1lbnRUeXBlIiwiZGF0YUVsZW1lbnRUeXBlIiwibGlua1NjYWxlcyIsImFkZEVsZW1lbnRzIiwidXBkYXRlSW5kZXgiLCJnZXRNZXRhIiwiZ2V0RGF0YXNldCIsInhBeGlzSUQiLCJzY2FsZXMiLCJ4QXhlcyIsInlBeGlzSUQiLCJ5QXhlcyIsImdldERhdGFzZXRNZXRhIiwiZ2V0U2NhbGVGb3JJZCIsInNjYWxlSUQiLCJfZ2V0VmFsdWVTY2FsZUlkIiwiX2dldEluZGV4U2NhbGVJZCIsIl9nZXRWYWx1ZVNjYWxlIiwiX2dldEluZGV4U2NhbGUiLCJyZXNldCIsImNyZWF0ZU1ldGFEYXRhc2V0IiwiX2RhdGFzZXRJbmRleCIsImNyZWF0ZU1ldGFEYXRhIiwiX2luZGV4IiwibWV0YURhdGEiLCJhZGRFbGVtZW50QW5kUmVzZXQiLCJ1cGRhdGVFbGVtZW50IiwiYnVpbGRPclVwZGF0ZUVsZW1lbnRzIiwicmVzeW5jRWxlbWVudHMiLCJlYXNpbmdWYWx1ZSIsImVsZW1lbnRzIiwiZHJhdyIsInJlbW92ZUhvdmVyU3R5bGUiLCIkcHJldmlvdXNTdHlsZSIsInNldEhvdmVyU3R5bGUiLCJjdXN0b20iLCJnZXRIb3ZlckNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJXaWR0aCIsImhvdmVyQmFja2dyb3VuZENvbG9yIiwiaG92ZXJCb3JkZXJDb2xvciIsImhvdmVyQm9yZGVyV2lkdGgiLCJudW1NZXRhIiwibnVtRGF0YSIsImluc2VydEVsZW1lbnRzIiwib25EYXRhUHVzaCIsIm9uRGF0YVBvcCIsIm9uRGF0YVNoaWZ0Iiwib25EYXRhU3BsaWNlIiwib25EYXRhVW5zaGlmdCIsImNvcmVfZGF0YXNldENvbnRyb2xsZXIiLCJib3JkZXJBbGlnbiIsImVsZW1lbnRfYXJjIiwiaW5MYWJlbFJhbmdlIiwibW91c2VYIiwiaG92ZXJSYWRpdXMiLCJpblJhbmdlIiwiY2hhcnRYIiwiY2hhcnRZIiwicG9pbnRSZWxhdGl2ZVBvc2l0aW9uIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJhbmdsZSIsImRpc3RhbmNlIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiYmV0d2VlbkFuZ2xlcyIsIndpdGhpblJhZGl1cyIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJnZXRDZW50ZXJQb2ludCIsImhhbGZBbmdsZSIsImhhbGZSYWRpdXMiLCJnZXRBcmVhIiwiY2VudHJlQW5nbGUiLCJyYW5nZUZyb21DZW50cmUiLCJzQSIsImVBIiwicGl4ZWxNYXJnaW4iLCJhbmdsZU1hcmdpbiIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImxpbmVKb2luIiwic3Ryb2tlU3R5bGUiLCJ2YWx1ZU9yRGVmYXVsdCQxIiwibGluZSIsImJvcmRlckNhcFN0eWxlIiwiYm9yZGVyRGFzaCIsImJvcmRlckRhc2hPZmZzZXQiLCJib3JkZXJKb2luU3R5bGUiLCJjYXBCZXppZXJQb2ludHMiLCJlbGVtZW50X2xpbmUiLCJzcGFuR2FwcyIsInBvaW50cyIsIl9jaGlsZHJlbiIsImdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cyIsImxhc3REcmF3bkluZGV4IiwiY3VycmVudFZNIiwiX2xvb3AiLCJsaW5lQ2FwIiwic2V0TGluZURhc2giLCJsaW5lRGFzaE9mZnNldCIsInByZXZpb3VzSXRlbSIsInNraXAiLCJ2YWx1ZU9yRGVmYXVsdCQyIiwiZGVmYXVsdENvbG9yJDEiLCJwb2ludFN0eWxlIiwiaGl0UmFkaXVzIiwieFJhbmdlIiwieVJhbmdlIiwibW91c2VZIiwiZWxlbWVudF9wb2ludCIsImluWFJhbmdlIiwiaW5ZUmFuZ2UiLCJwYWRkaW5nIiwiY2hhcnRBcmVhIiwiZGVmYXVsdENvbG9yJDIiLCJyZWN0YW5nbGUiLCJib3JkZXJTa2lwcGVkIiwiaXNWZXJ0aWNhbCIsImdldEJhckJvdW5kcyIsIngxIiwieDIiLCJ5MSIsImhhbGYiLCJzd2FwIiwib3JpZyIsInYyIiwicGFyc2VCb3JkZXJTa2lwcGVkIiwiZWRnZSIsImhvcml6b250YWwiLCJwYXJzZUJvcmRlcldpZHRoIiwibWF4VyIsIm1heEgiLCJib3VuZGluZ1JlY3RzIiwiYm91bmRzIiwiYm9yZGVyIiwib3V0ZXIiLCJpbm5lciIsInNraXBYIiwic2tpcFkiLCJlbGVtZW50X3JlY3RhbmdsZSIsInJlY3RzIiwiZmlsbFJlY3QiLCJBcmMiLCJMaW5lIiwiUG9pbnQiLCJSZWN0YW5nbGUiLCJyZXNvbHZlJDEiLCJob3ZlciIsImNhdGVnb3J5UGVyY2VudGFnZSIsImJhclBlcmNlbnRhZ2UiLCJncmlkTGluZXMiLCJvZmZzZXRHcmlkTGluZXMiLCJjb21wdXRlTWluU2FtcGxlU2l6ZSIsInBpeGVscyIsImlzSG9yaXpvbnRhbCIsInRpY2tzIiwiZ2V0VGlja3MiLCJjdXJyIiwiZ2V0UGl4ZWxGb3JUaWNrIiwiY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzIiwicnVsZXIiLCJ0aGlja25lc3MiLCJiYXJUaGlja25lc3MiLCJzdGFja0NvdW50IiwiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsInBlcmNlbnQiLCJjb250cm9sbGVyX2JhciIsImJhciIsIl9ydWxlciIsImdldFJ1bGVyIiwiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsIl94U2NhbGUiLCJfeVNjYWxlIiwiZGF0YXNldExhYmVsIiwiX3VwZGF0ZUVsZW1lbnRHZW9tZXRyeSIsInZzY2FsZSIsImdldEJhc2VQaXhlbCIsInZwaXhlbHMiLCJjYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyIsImlwaXhlbHMiLCJjYWxjdWxhdGVCYXJJbmRleFBpeGVscyIsImhlYWQiLCJjZW50ZXIiLCJfZ2V0U3RhY2tzIiwic3RhY2tzIiwiaXNEYXRhc2V0VmlzaWJsZSIsImdldFN0YWNrQ291bnQiLCJnZXRTdGFja0luZGV4IiwiZ2V0UGl4ZWxGb3JWYWx1ZSIsImdldFJpZ2h0VmFsdWUiLCJtaW5CYXJMZW5ndGgiLCJpbWV0YSIsIml2YWx1ZSIsImNvbnRyb2xsZXIiLCJzdGFja0luZGV4IiwibWF4QmFyVGhpY2tuZXNzIiwiSW5maW5pdHkiLCJkYXRhSW5kZXgiLCJ2YWx1ZU9yRGVmYXVsdCQzIiwicmVzb2x2ZSQyIiwicG9zaXRpb24iLCJ0b29sdGlwcyIsImRhdGFQb2ludCIsInhMYWJlbCIsInlMYWJlbCIsImNvbnRyb2xsZXJfYnViYmxlIiwieFNjYWxlIiwieVNjYWxlIiwiZHNJbmRleCIsImdldFBpeGVsRm9yRGVjaW1hbCIsIl9vcHRpb25zIiwicmVzb2x2ZSQzIiwidmFsdWVPckRlZmF1bHQkNCIsImFuaW1hdGVSb3RhdGUiLCJhbmltYXRlU2NhbGUiLCJsZWdlbmRDYWxsYmFjayIsImxlZ2VuZCIsImdlbmVyYXRlTGFiZWxzIiwiZHMiLCJhcmNPcHRzIiwiYnciLCJvbkNsaWNrIiwibGVnZW5kSXRlbSIsImN1dG91dFBlcmNlbnRhZ2UiLCJjaXJjdW1mZXJlbmNlIiwidG9vbHRpcEl0ZW0iLCJkYXRhTGFiZWwiLCJjb250cm9sbGVyX2RvdWdobnV0IiwiZ2V0UmluZ0luZGV4IiwicmluZ0luZGV4IiwiYXZhaWxhYmxlV2lkdGgiLCJhdmFpbGFibGVIZWlnaHQiLCJtaW5TaXplIiwiYXJjcyIsImNoYXJ0V2VpZ2h0IiwiX2dldFJpbmdXZWlnaHQiLCJjb250YWluczAiLCJjb250YWluczkwIiwiY29udGFpbnMxODAiLCJjb250YWluczI3MCIsImN1dG91dCIsImdldE1heEJvcmRlcldpZHRoIiwicmFkaXVzTGVuZ3RoIiwiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImNhbGN1bGF0ZVRvdGFsIiwiX2dldFJpbmdXZWlnaHRPZmZzZXQiLCJhbmltYXRpb25PcHRzIiwiY2VudGVyWCIsImNlbnRlclkiLCJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlIiwiaG92ZXJXaWR0aCIsInJpbmdXZWlnaHRPZmZzZXQiLCJkYXRhU2V0SW5kZXgiLCJheGlzIiwiY29udHJvbGxlcl9ob3Jpem9udGFsQmFyIiwidmFsdWVPckRlZmF1bHQkNSIsInJlc29sdmUkNCIsImlzUG9pbnRJbkFyZWEiLCJsaW5lRW5hYmxlZCIsInNob3dMaW5lIiwiY29udHJvbGxlcl9saW5lIiwibGluZVRlbnNpb24iLCJfc2NhbGUiLCJfcmVzb2x2ZUxpbmVPcHRpb25zIiwidXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsImxpbmVNb2RlbCIsIl9yZXNvbHZlUG9pbnRPcHRpb25zIiwiY2FsY3VsYXRlUG9pbnRZIiwiRUxFTUVOVF9PUFRJT05TIiwiZWxlbWVudE9wdGlvbnMiLCJzdW1Qb3MiLCJzdW1OZWciLCJkc01ldGEiLCJzdGFja2VkUmlnaHRWYWx1ZSIsInJpZ2h0VmFsdWUiLCJjb250cm9sUG9pbnRzIiwicHQiLCJjYXBDb250cm9sUG9pbnQiLCJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwic3BsaW5lQ3VydmVNb25vdG9uZSIsInNwbGluZUN1cnZlIiwibmV4dEl0ZW0iLCJoYWxmQm9yZGVyV2lkdGgiLCJyZXNvbHZlJDUiLCJhbmdsZUxpbmVzIiwicG9pbnRMYWJlbHMiLCJiZWdpbkF0WmVybyIsImNvbnRyb2xsZXJfcG9sYXJBcmVhIiwic3RhcnRzIiwiX3N0YXJ0cyIsImFuZ2xlcyIsIl9hbmdsZXMiLCJfdXBkYXRlUmFkaXVzIiwiY291bnRWaXNpYmxlRWxlbWVudHMiLCJfY29tcHV0ZUFuZ2xlIiwiZ2V0VmlzaWJsZURhdGFzZXRDb3VudCIsInhDZW50ZXIiLCJ5Q2VudGVyIiwiZGF0YXNldFN0YXJ0QW5nbGUiLCJnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSIsInJlc2V0UmFkaXVzIiwiZG91Z2hudXQiLCJjb250cm9sbGVyX3BpZSIsInZhbHVlT3JEZWZhdWx0JDYiLCJyZXNvbHZlJDYiLCJjb250cm9sbGVyX3JhZGFyIiwicG9pbnRQb3NpdGlvbiIsImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsImNvbnRyb2xsZXJfc2NhdHRlciIsImNvbnRyb2xsZXJzIiwiaG9yaXpvbnRhbEJhciIsInBvbGFyQXJlYSIsInBpZSIsInJhZGFyIiwic2NhdHRlciIsImdldFJlbGF0aXZlUG9zaXRpb24iLCJwYXJzZVZpc2libGVJdGVtcyIsImpsZW4iLCJnZXRJbnRlcnNlY3RJdGVtcyIsImdldE5lYXJlc3RJdGVtcyIsImludGVyc2VjdCIsImRpc3RhbmNlTWV0cmljIiwibWluRGlzdGFuY2UiLCJQT1NJVElWRV9JTkZJTklUWSIsIm5lYXJlc3RJdGVtcyIsImdldERpc3RhbmNlTWV0cmljRm9yQXhpcyIsInVzZVgiLCJ1c2VZIiwicHQxIiwicHQyIiwiZGVsdGFYIiwiZGVsdGFZIiwiaW5kZXhNb2RlIiwiY29yZV9pbnRlcmFjdGlvbiIsIm1vZGVzIiwic2luZ2xlIiwibmVhcmVzdCIsImludGVyc2VjdHNJdGVtIiwiZmlsdGVyQnlQb3NpdGlvbiIsIndoZXJlIiwic29ydEJ5V2VpZ2h0IiwiX3RtcEluZGV4XyIsImZpbmRNYXhQYWRkaW5nIiwiYm94ZXMiLCJib3giLCJnZXRQYWRkaW5nIiwiYm94UGFkZGluZyIsImFkZFNpemVCeVBvc2l0aW9uIiwibGF5b3V0IiwiY29yZV9sYXlvdXRzIiwiYWRkQm94IiwiZnVsbFdpZHRoIiwicmVtb3ZlQm94IiwibGF5b3V0SXRlbSIsImNvbmZpZ3VyZSIsImxheW91dE9wdGlvbnMiLCJsZWZ0UGFkZGluZyIsInJpZ2h0UGFkZGluZyIsInRvcFBhZGRpbmciLCJib3R0b21QYWRkaW5nIiwibGVmdEJveGVzIiwicmlnaHRCb3hlcyIsInRvcEJveGVzIiwiYm90dG9tQm94ZXMiLCJjaGFydEFyZWFCb3hlcyIsInZlcnRpY2FsQm94ZXMiLCJob3Jpem9udGFsQm94ZXMiLCJvdXRlckJveGVzIiwiY2hhcnRXaWR0aCIsImNoYXJ0SGVpZ2h0IiwiY2hhcnRBcmVhV2lkdGgiLCJ2ZXJ0aWNhbEJveFdpZHRoIiwibWF4Q2hhcnRBcmVhV2lkdGgiLCJtYXhDaGFydEFyZWFIZWlnaHQiLCJvdXRlckJveFNpemVzIiwibWluQm94U2l6ZXMiLCJtYXhQYWRkaW5nIiwiZ2V0TWluaW11bUJveFNpemUiLCJmaXRCb3giLCJtaW5Cb3hTaXplIiwiZmluZE5leHRXaGVyZSIsIm1pbkJveCIsInNjYWxlTWFyZ2luIiwiZmluYWxGaXRWZXJ0aWNhbEJveCIsImxlZnRQYWRkaW5nQWRkaXRpb24iLCJ0b3BQYWRkaW5nQWRkaXRpb24iLCJuZXdNYXhDaGFydEFyZWFIZWlnaHQiLCJuZXdNYXhDaGFydEFyZWFXaWR0aCIsInBsYWNlQm94IiwicGxhdGZvcm1fYmFzaWMiLCJhY3F1aXJlQ29udGV4dCIsImdldENvbnRleHQiLCJwbGF0Zm9ybV9kb20iLCJwbGF0Zm9ybV9kb20kMSIsImdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UiLCJzdHlsZXNoZWV0IiwiRVhQQU5ET19LRVkiLCJDU1NfUFJFRklYIiwiQ1NTX1NJWkVfTU9OSVRPUiIsIkNTU19SRU5ERVJfTU9OSVRPUiIsIkNTU19SRU5ERVJfQU5JTUFUSU9OIiwiQU5JTUFUSU9OX1NUQVJUX0VWRU5UUyIsIkVWRU5UX1RZUEVTIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmRvd24iLCJwb2ludGVybW92ZSIsInBvaW50ZXJ1cCIsInBvaW50ZXJsZWF2ZSIsInBvaW50ZXJvdXQiLCJyZWFkVXNlZFNpemUiLCJpbml0Q2FudmFzIiwicmVuZGVySGVpZ2h0IiwicmVuZGVyV2lkdGgiLCJkaXNwbGF5V2lkdGgiLCJhc3BlY3RSYXRpbyIsImRpc3BsYXlIZWlnaHQiLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwic3VwcG9ydHMiLCJldmVudExpc3RlbmVyT3B0aW9ucyIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJuYXRpdmVFdmVudCIsImZyb21OYXRpdmVFdmVudCIsInRocm90dGxlZCIsInRpY2tpbmciLCJjcmVhdGVEaXYiLCJjbGFzc05hbWUiLCJjcmVhdGVSZXNpemVyIiwibWF4U2l6ZSIsInJlc2l6ZXIiLCJleHBhbmQiLCJzaHJpbmsiLCJfcmVzZXQiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwib25TY3JvbGwiLCJ3YXRjaEZvclJlbmRlciIsImV4cGFuZG8iLCJyZW5kZXJQcm94eSIsImFuaW1hdGlvbk5hbWUiLCJyZWZsb3ciLCJvZmZzZXRQYXJlbnQiLCJ1bndhdGNoRm9yUmVuZGVyIiwiYWRkUmVzaXplTGlzdGVuZXIiLCJtYWludGFpbkFzcGVjdFJhdGlvIiwiY2xpZW50V2lkdGgiLCJyZW1vdmVSZXNpemVMaXN0ZW5lciIsImluamVjdENTUyIsIl9zdHlsZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwicGxhdGZvcm1fZG9tJDIiLCJkaXNhYmxlQ1NTSW5qZWN0aW9uIiwiX2VuYWJsZWQiLCJfZW5zdXJlTG9hZGVkIiwiX2xvYWRlZCIsImdldEVsZW1lbnRCeUlkIiwicmVsZWFzZUNvbnRleHQiLCJwcm94aWVzIiwiYWRkRXZlbnQiLCJyZW1vdmVFdmVudCIsImltcGxlbWVudGF0aW9uIiwicGx1Z2lucyIsImNvcmVfcGx1Z2lucyIsIl9wbHVnaW5zIiwiX2NhY2hlSWQiLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJpZHgiLCJnZXRBbGwiLCJkZXNjcmlwdG9ycyIsImRlc2NyaXB0b3IiLCIkcGx1Z2lucyIsIl9pbnZhbGlkYXRlIiwiY29yZV9zY2FsZVNlcnZpY2UiLCJjb25zdHJ1Y3RvcnMiLCJyZWdpc3RlclNjYWxlVHlwZSIsInNjYWxlQ29uc3RydWN0b3IiLCJzY2FsZURlZmF1bHRzIiwiZ2V0U2NhbGVDb25zdHJ1Y3RvciIsImdldFNjYWxlRGVmYXVsdHMiLCJ1cGRhdGVTY2FsZURlZmF1bHRzIiwiYWRkaXRpb25zIiwiYWRkU2NhbGVzVG9MYXlvdXQiLCJ2YWx1ZU9yRGVmYXVsdCQ3IiwiZW5hYmxlZCIsInRpdGxlRm9udFN0eWxlIiwidGl0bGVTcGFjaW5nIiwidGl0bGVNYXJnaW5Cb3R0b20iLCJ0aXRsZUZvbnRDb2xvciIsInRpdGxlQWxpZ24iLCJib2R5U3BhY2luZyIsImJvZHlGb250Q29sb3IiLCJib2R5QWxpZ24iLCJmb290ZXJGb250U3R5bGUiLCJmb290ZXJTcGFjaW5nIiwiZm9vdGVyTWFyZ2luVG9wIiwiZm9vdGVyRm9udENvbG9yIiwiZm9vdGVyQWxpZ24iLCJ5UGFkZGluZyIsInhQYWRkaW5nIiwiY2FyZXRQYWRkaW5nIiwiY2FyZXRTaXplIiwibXVsdGlLZXlCYWNrZ3JvdW5kIiwiZGlzcGxheUNvbG9ycyIsImJlZm9yZVRpdGxlIiwidG9vbHRpcEl0ZW1zIiwibGFiZWxDb3VudCIsImFmdGVyVGl0bGUiLCJiZWZvcmVCb2R5IiwiYmVmb3JlTGFiZWwiLCJsYWJlbENvbG9yIiwibGFiZWxUZXh0Q29sb3IiLCJhZnRlckxhYmVsIiwiYWZ0ZXJCb2R5IiwiYmVmb3JlRm9vdGVyIiwiZm9vdGVyIiwiYWZ0ZXJGb290ZXIiLCJwb3NpdGlvbmVycyIsImF2ZXJhZ2UiLCJldmVudFBvc2l0aW9uIiwibmVhcmVzdEVsZW1lbnQiLCJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCJ0cCIsInB1c2hPckNvbmNhdCIsInRvUHVzaCIsInNwbGl0TmV3bGluZXMiLCJjcmVhdGVUb29sdGlwSXRlbSIsImluZGV4U2NhbGUiLCJ2YWx1ZVNjYWxlIiwiZ2V0TGFiZWxGb3JJbmRleCIsImdldEJhc2VNb2RlbCIsInRvb2x0aXBPcHRzIiwieEFsaWduIiwieUFsaWduIiwiX2JvZHlGb250RmFtaWx5IiwiYm9keUZvbnRGYW1pbHkiLCJfYm9keUZvbnRTdHlsZSIsImJvZHlGb250U3R5bGUiLCJfYm9keUFsaWduIiwiYm9keUZvbnRTaXplIiwiX3RpdGxlRm9udEZhbWlseSIsInRpdGxlRm9udEZhbWlseSIsIl90aXRsZUZvbnRTdHlsZSIsInRpdGxlRm9udFNpemUiLCJfdGl0bGVBbGlnbiIsIl9mb290ZXJGb250RmFtaWx5IiwiZm9vdGVyRm9udEZhbWlseSIsIl9mb290ZXJGb250U3R5bGUiLCJmb290ZXJGb250U2l6ZSIsIl9mb290ZXJBbGlnbiIsIm9wYWNpdHkiLCJsZWdlbmRDb2xvckJhY2tncm91bmQiLCJnZXRUb29sdGlwU2l6ZSIsInRvb2x0aXAiLCJjb21iaW5lZEJvZHlMZW5ndGgiLCJib2R5SXRlbSIsImFmdGVyIiwidGl0bGVMaW5lQ291bnQiLCJmb290ZXJMaW5lQ291bnQiLCJ3aWR0aFBhZGRpbmciLCJtYXhMaW5lV2lkdGgiLCJtZWFzdXJlVGV4dCIsImZvbnRTdHJpbmciLCJkZXRlcm1pbmVBbGlnbm1lbnQiLCJsZiIsInJmIiwib2xmIiwib3JmIiwieWYiLCJtaWRYIiwibWlkWSIsImdldEJhY2tncm91bmRQb2ludCIsImFsaWdubWVudCIsInBhZGRpbmdBbmRTaXplIiwicmFkaXVzQW5kUGFkZGluZyIsImdldEFsaWduZWRYIiwiYWxpZ24iLCJnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyIsImV4cG9ydHMkMyIsIl9sYXN0QWN0aXZlIiwiZ2V0VGl0bGUiLCJnZXRCZWZvcmVCb2R5IiwiZ2V0Qm9keSIsImJvZHlJdGVtcyIsImdldEFmdGVyQm9keSIsImdldEZvb3RlciIsImNoYW5nZWQiLCJleGlzdGluZ01vZGVsIiwiX2FjdGl2ZSIsImJhY2tncm91bmRQb2ludCIsInRvb2x0aXBTaXplIiwiY2FyZXRYIiwiY2FyZXRZIiwibGFiZWxDb2xvcnMiLCJsYWJlbFRleHRDb2xvcnMiLCJfZXZlbnRQb3NpdGlvbiIsIml0ZW1Tb3J0IiwiZGF0YVBvaW50cyIsImRyYXdDYXJldCIsInRvb2x0aXBQb2ludCIsImNhcmV0UG9zaXRpb24iLCJnZXRDYXJldFBvc2l0aW9uIiwieDMiLCJ5MyIsInB0WCIsInB0WSIsImRyYXdUaXRsZSIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0IiwiZHJhd0JvZHkiLCJkcmF3Q29sb3JCb3hlcyIsInhMaW5lUGFkZGluZyIsImNvbG9yWCIsInRleHRDb2xvciIsImZpbGxMaW5lT2ZUZXh0Iiwic3Ryb2tlUmVjdCIsImRyYXdGb290ZXIiLCJkcmF3QmFja2dyb3VuZCIsInF1YWRyYXRpY0N1cnZlVG8iLCJoYXNUb29sdGlwQ29udGVudCIsImdsb2JhbEFscGhhIiwiaGFuZGxlRXZlbnQiLCJnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlIiwicG9zaXRpb25lcnNfMSIsImNvcmVfdG9vbHRpcCIsInZhbHVlT3JEZWZhdWx0JDgiLCJvbkhvdmVyIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJyZXNwb25zaXZlIiwicmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uIiwibWVyZ2VTY2FsZUNvbmZpZyIsInNsZW4iLCJtZXJnZUNvbmZpZyIsImluaXRDb25maWciLCJ1cGRhdGVDb25maWciLCJuZXdPcHRpb25zIiwiZW5zdXJlU2NhbGVzSGF2ZUlEcyIsImJ1aWxkT3JVcGRhdGVTY2FsZXMiLCJwb3NpdGlvbklzSG9yaXpvbnRhbCIsIkNoYXJ0IiwiY29uc3RydWN0IiwiX2J1ZmZlcmVkUmVuZGVyIiwiaW5zdGFuY2VzIiwicmV0aW5hU2NhbGUiLCJkZXZpY2VQaXhlbFJhdGlvIiwiYmluZEV2ZW50cyIsInJlc2l6ZSIsImluaXRUb29sVGlwIiwibmV3V2lkdGgiLCJnZXRNYXhpbXVtV2lkdGgiLCJuZXdIZWlnaHQiLCJnZXRNYXhpbXVtSGVpZ2h0IiwibmV3U2l6ZSIsIm9uUmVzaXplIiwic2NhbGVzT3B0aW9ucyIsInNjYWxlT3B0aW9ucyIsInhBeGlzT3B0aW9ucyIsInlBeGlzT3B0aW9ucyIsImR0eXBlIiwiZHBvc2l0aW9uIiwiaXNEZWZhdWx0Iiwic2NhbGVUeXBlIiwic2NhbGVDbGFzcyIsIm1lcmdlVGlja3NPcHRpb25zIiwiaGFzVXBkYXRlZCIsImJ1aWxkT3JVcGRhdGVDb250cm9sbGVycyIsIm5ld0NvbnRyb2xsZXJzIiwiZGVzdHJveURhdGFzZXRNZXRhIiwiQ29udHJvbGxlckNsYXNzIiwicmVzZXRFbGVtZW50cyIsInVwZGF0ZUxheW91dCIsInVwZGF0ZURhdGFzZXRzIiwibGFzdEFjdGl2ZSIsIl9idWZmZXJlZFJlcXVlc3QiLCJ1cGRhdGVEYXRhc2V0IiwiYW5pbWF0aW9uT3B0aW9ucyIsImFuaW1hdGlvbk9iamVjdCIsImVhc2luZ0Z1bmN0aW9uIiwic3RlcERlY2ltYWwiLCJkcmF3RGF0YXNldHMiLCJfZHJhd1Rvb2x0aXAiLCJkcmF3RGF0YXNldCIsImdldEVsZW1lbnRBdEV2ZW50IiwiZ2V0RWxlbWVudHNBdEV2ZW50IiwiZ2V0RWxlbWVudHNBdFhBeGlzIiwiZ2V0RGF0YXNldEF0RXZlbnQiLCJfbWV0YSIsImdlbmVyYXRlTGVnZW5kIiwidW5iaW5kRXZlbnRzIiwidG9CYXNlNjRJbWFnZSIsInRvRGF0YVVSTCIsIl9jaGFydEluc3RhbmNlIiwiX2xpc3RlbmVycyIsImV2ZW50SGFuZGxlciIsInVwZGF0ZUhvdmVyU3R5bGUiLCJidWZmZXJlZFJlcXVlc3QiLCJob3Zlck9wdGlvbnMiLCJjb3JlX2NvbnRyb2xsZXIiLCJDb250cm9sbGVyIiwiY29uZmlnTWVyZ2UiLCJzY2FsZU1lcmdlIiwiY29yZV9oZWxwZXJzIiwiZmlsdGVyQ2FsbGJhY2siLCJmaWx0ZXJlZCIsImFycmF5VG9TZWFyY2giLCJzdGFydEluZGV4IiwiY3VycmVudEl0ZW0iLCJmaW5kUHJldmlvdXNXaGVyZSIsImFsbW9zdEVxdWFscyIsImFsbW9zdFdob2xlIiwicm91bmRlZCIsIk5FR0FUSVZFX0lORklOSVRZIiwibG9nMTAiLCJleHBvbmVudCIsIkxPRzEwRSIsInBvd2VyT2YxMCIsImlzUG93ZXJPZjEwIiwidG9SYWRpYW5zIiwidG9EZWdyZWVzIiwicmFkaWFucyIsIl9kZWNpbWFsUGxhY2VzIiwiY2VudHJlUG9pbnQiLCJhbmdsZVBvaW50IiwiZGlzdGFuY2VGcm9tWENlbnRlciIsImRpc3RhbmNlRnJvbVlDZW50ZXIiLCJyYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIiLCJhbGlhc1BpeGVsIiwicGl4ZWxXaWR0aCIsIl9hbGlnblBpeGVsIiwicGl4ZWwiLCJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsImhhbGZXaWR0aCIsImZpcnN0UG9pbnQiLCJtaWRkbGVQb2ludCIsImFmdGVyUG9pbnQiLCJkMDEiLCJkMTIiLCJzMDEiLCJzMTIiLCJmYSIsImZiIiwiRVBTSUxPTiIsInBvaW50c1dpdGhUYW5nZW50cyIsImRlbHRhSyIsIm1LIiwicG9pbnRzTGVuIiwicG9pbnRCZWZvcmUiLCJwb2ludEN1cnJlbnQiLCJwb2ludEFmdGVyIiwic2xvcGVEZWx0YVgiLCJhbHBoYUsiLCJiZXRhSyIsInRhdUsiLCJzcXVhcmVkTWFnbml0dWRlIiwibG9vcCIsIm5pY2VOdW0iLCJmcmFjdGlvbiIsIm5pY2VGcmFjdGlvbiIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsImV2dCIsIm9yaWdpbmFsRXZlbnQiLCJzcmNFbGVtZW50IiwiYm91bmRpbmdSZWN0IiwidG91Y2hlcyIsImNsaWVudFgiLCJjbGllbnRZIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ0JvdHRvbSIsInBhcnNlTWF4U3R5bGUiLCJwYXJlbnRQcm9wZXJ0eSIsInZhbHVlSW5QaXhlbHMiLCJpc0NvbnN0cmFpbmVkVmFsdWUiLCJnZXRDb25zdHJhaW50RGltZW5zaW9uIiwiZG9tTm9kZSIsIm1heFN0eWxlIiwicGVyY2VudGFnZVByb3BlcnR5IiwiZGVmYXVsdFZpZXciLCJfZ2V0UGFyZW50Tm9kZSIsImNvbnN0cmFpbmVkTm9kZSIsImNvbnN0cmFpbmVkQ29udGFpbmVyIiwiaGFzQ05vZGUiLCJoYXNDQ29udGFpbmVyIiwiaW5maW5pdHkiLCJnZXRDb25zdHJhaW50V2lkdGgiLCJnZXRDb25zdHJhaW50SGVpZ2h0IiwiX2NhbGN1bGF0ZVBhZGRpbmciLCJwYXJlbnREaW1lbnNpb24iLCJob3N0IiwiY3ciLCJjbGllbnRIZWlnaHQiLCJjdXJyZW50U3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZm9yY2VSYXRpbyIsInBpeGVsUmF0aW8iLCJwaXhlbFNpemUiLCJsb25nZXN0VGV4dCIsImFycmF5T2ZUaGluZ3MiLCJnYyIsImdhcmJhZ2VDb2xsZWN0IiwibG9uZ2VzdCIsInRoaW5nIiwibmVzdGVkVGhpbmciLCJnY0xlbiIsInRleHRXaWR0aCIsIm51bWJlck9mTGFiZWxMaW5lcyIsIm51bWJlck9mTGluZXMiLCJjb2xvciIsIkNhbnZhc0dyYWRpZW50IiwiY29sb3JWYWx1ZSIsIkNhbnZhc1BhdHRlcm4iLCJEYXRlQWRhcHRlciIsIl9jcmVhdGUiLCJvdmVycmlkZSIsIm1lbWJlcnMiLCJfZGF0ZSIsImNvcmVfYWRhcHRlcnMiLCJjb3JlX3RpY2tzIiwiZm9ybWF0dGVycyIsInRpY2tWYWx1ZSIsImxvZ0RlbHRhIiwidGlja1N0cmluZyIsIm1heFRpY2siLCJsb2dUaWNrIiwidG9FeHBvbmVudGlhbCIsIm51bURlY2ltYWwiLCJsb2dhcml0aG1pYyIsInJlbWFpbiIsInZhbHVlT3JEZWZhdWx0JDkiLCJkcmF3Qm9yZGVyIiwiZHJhd09uQ2hhcnRBcmVhIiwiZHJhd1RpY2tzIiwidGlja01hcmtMZW5ndGgiLCJ6ZXJvTGluZVdpZHRoIiwiemVyb0xpbmVDb2xvciIsInplcm9MaW5lQm9yZGVyRGFzaCIsInplcm9MaW5lQm9yZGVyRGFzaE9mZnNldCIsInNjYWxlTGFiZWwiLCJsYWJlbFN0cmluZyIsIm1pblJvdGF0aW9uIiwibWF4Um90YXRpb24iLCJtaXJyb3IiLCJhdXRvU2tpcCIsImF1dG9Ta2lwUGFkZGluZyIsImxhYmVsT2Zmc2V0IiwibWlub3IiLCJtYWpvciIsImxhYmVsc0Zyb21UaWNrcyIsImdldFBpeGVsRm9yR3JpZExpbmUiLCJsaW5lVmFsdWUiLCJjb21wdXRlVGV4dFNpemUiLCJ0aWNrIiwiY29yZV9zY2FsZSIsIl90aWNrcyIsImJlZm9yZVVwZGF0ZSIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwibWFyZ2lucyIsIl9tYXhMYWJlbExpbmVzIiwibG9uZ2VzdExhYmVsV2lkdGgiLCJsb25nZXN0VGV4dENhY2hlIiwiYmVmb3JlU2V0RGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJhZnRlclNldERpbWVuc2lvbnMiLCJiZWZvcmVEYXRhTGltaXRzIiwiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsImFmdGVyRGF0YUxpbWl0cyIsImJlZm9yZUJ1aWxkVGlja3MiLCJidWlsZFRpY2tzIiwiYWZ0ZXJCdWlsZFRpY2tzIiwiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwiY29udmVydFRpY2tzVG9MYWJlbHMiLCJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsImJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uIiwiYmVmb3JlRml0IiwiZml0IiwiYWZ0ZXJGaXQiLCJhZnRlclVwZGF0ZSIsInRpY2tPcHRzIiwidXNlckNhbGxiYWNrIiwidGlja0ZvbnQiLCJsYWJlbFJvdGF0aW9uIiwib3JpZ2luYWxMYWJlbFdpZHRoIiwibGFiZWxXaWR0aCIsImNvc1JvdGF0aW9uIiwic2luUm90YXRpb24iLCJ0aWNrV2lkdGgiLCJhbmdsZVJhZGlhbnMiLCJzY2FsZUxhYmVsT3B0cyIsImdyaWRMaW5lT3B0cyIsIl9pc1Zpc2libGUiLCJwYXJzZUZvbnQiLCJpc0Z1bGxXaWR0aCIsInNjYWxlTGFiZWxGb250Iiwic2NhbGVMYWJlbFBhZGRpbmciLCJkZWx0YUhlaWdodCIsImxhcmdlc3RUZXh0V2lkdGgiLCJ0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzIiwibGluZVNwYWNlIiwidGlja1BhZGRpbmciLCJsYWJlbEhlaWdodCIsImZpcnN0TGFiZWxXaWR0aCIsImxhc3RMYWJlbFdpZHRoIiwib2Zmc2V0TGVmdCIsIm9mZnNldFJpZ2h0IiwiaGFuZGxlTWFyZ2lucyIsInJhd1ZhbHVlIiwiZ2V0VmFsdWVGb3JQaXhlbCIsImlubmVyV2lkdGgiLCJmaW5hbFZhbCIsImlubmVySGVpZ2h0IiwiZGVjaW1hbCIsInZhbHVlT2Zmc2V0IiwiZ2V0QmFzZVZhbHVlIiwiX2F1dG9Ta2lwIiwib3B0aW9uVGlja3MiLCJ0aWNrQ291bnQiLCJza2lwUmF0aW8iLCJtYXhUaWNrcyIsIm1heFRpY2tzTGltaXQiLCJ0aWNrc0xlbmd0aCIsIl90aWNrU2l6ZSIsImF4aXNMZW5ndGgiLCJQYWRkaW5nQm90dG9tIiwicm90Iiwib3B0aW9uTWFqb3JUaWNrcyIsImlzUm90YXRlZCIsImlzTWlycm9yZWQiLCJ0aWNrRm9udENvbG9yIiwiZm9udENvbG9yIiwibWFqb3JUaWNrRm9udENvbG9yIiwibWFqb3JUaWNrRm9udCIsInRsIiwic2NhbGVMYWJlbEZvbnRDb2xvciIsImxhYmVsUm90YXRpb25SYWRpYW5zIiwiaXRlbXNUb0RyYXciLCJheGlzV2lkdGgiLCJhbGlnblBpeGVsIiwiYm9yZGVyVmFsdWUiLCJ0aWNrU3RhcnQiLCJ0aWNrRW5kIiwibGluZUNvbG9yIiwiemVyb0xpbmVJbmRleCIsInR4MSIsInR5MSIsInR4MiIsInR5MiIsImxhYmVsWCIsImxhYmVsWSIsInRleHRPZmZzZXQiLCJsYWJlbFlPZmZzZXQiLCJsYWJlbFhPZmZzZXQiLCJnbFdpZHRoIiwiZ2xDb2xvciIsImdsQm9yZGVyRGFzaCIsImdsQm9yZGVyRGFzaE9mZnNldCIsIml0ZW1Ub0RyYXciLCJ0cmFuc2xhdGUiLCJzY2FsZUxhYmVsWCIsInNjYWxlTGFiZWxZIiwiaGFsZkxpbmVIZWlnaHQiLCJpc0xlZnQiLCJmaXJzdExpbmVXaWR0aCIsImxhc3RMaW5lV2lkdGgiLCJkZWZhdWx0Q29uZmlnIiwic2NhbGVfY2F0ZWdvcnkiLCJnZXRMYWJlbHMiLCJtaW5JbmRleCIsIm1heEluZGV4Iiwib2Zmc2V0QW10IiwidmFsdWVDYXRlZ29yeSIsInZhbHVlV2lkdGgiLCJ3aWR0aE9mZnNldCIsInZhbHVlSGVpZ2h0IiwiaGVpZ2h0T2Zmc2V0IiwiaG9yeiIsInZhbHVlRGltZW5zaW9uIiwiX2RlZmF1bHRzIiwiZ2VuZXJhdGVUaWNrcyIsImdlbmVyYXRpb25PcHRpb25zIiwiZGF0YVJhbmdlIiwiTUlOX1NQQUNJTkciLCJzdGVwU2l6ZSIsIm1heE51bVNwYWNlcyIsInByZWNpc2lvbiIsInJtaW4iLCJybWF4Iiwic3BhY2luZyIsImZhY3RvciIsIm5pY2VNaW4iLCJuaWNlTWF4IiwibnVtU3BhY2VzIiwic2NhbGVfbGluZWFyYmFzZSIsImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCJtaW5TaWduIiwibWF4U2lnbiIsInNldE1pbiIsInN1Z2dlc3RlZE1pbiIsInNldE1heCIsInN1Z2dlc3RlZE1heCIsImdldFRpY2tMaW1pdCIsIl9jb21wdXRlVGlja0xpbWl0IiwiaGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzIiwibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCJmaXhlZFN0ZXBTaXplIiwidGlja3NBc051bWJlcnMiLCJkZWZhdWx0Q29uZmlnJDEiLCJzY2FsZV9saW5lYXIiLCJERUZBVUxUX01JTiIsIkRFRkFVTFRfTUFYIiwiSURNYXRjaGVzIiwiaGFzU3RhY2tzIiwidmFsdWVzUGVyU3RhY2siLCJwb3NpdGl2ZVZhbHVlcyIsIm5lZ2F0aXZlVmFsdWVzIiwicmVsYXRpdmVQb2ludHMiLCJ2YWx1ZXNGb3JUeXBlIiwibWluVmFsIiwibWF4VmFsIiwiaW5uZXJEaW1lbnNpb24iLCJfZGVmYXVsdHMkMSIsInZhbHVlT3JEZWZhdWx0JGEiLCJnZW5lcmF0ZVRpY2tzJDEiLCJ0aWNrVmFsIiwiZW5kRXhwIiwiZW5kU2lnbmlmaWNhbmQiLCJzaWduaWZpY2FuZCIsIm1pbk5vdFplcm8iLCJsYXN0VGljayIsImRlZmF1bHRDb25maWckMiIsIm5vbk5lZ2F0aXZlT3JEZWZhdWx0Iiwic2NhbGVfbG9nYXJpdGhtaWMiLCJ0aWNrVmFsdWVzIiwiX2dldEZpcnN0VGlja1ZhbHVlIiwiZmlyc3RUaWNrVmFsdWUiLCJfZGVmYXVsdHMkMiIsInZhbHVlT3JEZWZhdWx0JGIiLCJ2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMSIsInJlc29sdmUkNyIsImRlZmF1bHRDb25maWckMyIsImFuaW1hdGUiLCJzaG93TGFiZWxCYWNrZHJvcCIsImJhY2tkcm9wQ29sb3IiLCJiYWNrZHJvcFBhZGRpbmdZIiwiYmFja2Ryb3BQYWRkaW5nWCIsImdldFZhbHVlQ291bnQiLCJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCJtZWFzdXJlTGFiZWxTaXplIiwiZGV0ZXJtaW5lTGltaXRzIiwiZml0V2l0aFBvaW50TGFiZWxzIiwicGxGb250IiwiZnVydGhlc3RMaW1pdHMiLCJmdXJ0aGVzdEFuZ2xlcyIsInRleHRTaXplIiwiX3BvaW50TGFiZWxTaXplcyIsInZhbHVlQ291bnQiLCJnZXRQb2ludFBvc2l0aW9uIiwiZHJhd2luZ0FyZWEiLCJnZXRJbmRleEFuZ2xlIiwiaExpbWl0cyIsInZMaW1pdHMiLCJzZXRSZWR1Y3Rpb25zIiwiZ2V0VGV4dEFsaWduRm9yQW5nbGUiLCJhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQiLCJkcmF3UG9pbnRMYWJlbHMiLCJhbmdsZUxpbmVPcHRzIiwicG9pbnRMYWJlbE9wdHMiLCJ0aWNrQmFja2Ryb3BIZWlnaHQiLCJvdXRlckRpc3RhbmNlIiwib3V0ZXJQb3NpdGlvbiIsImV4dHJhIiwicG9pbnRMYWJlbFBvc2l0aW9uIiwicG9pbnRMYWJlbEZvbnRDb2xvciIsImRyYXdSYWRpdXNMaW5lIiwibnVtYmVyT3JaZXJvIiwic2NhbGVfcmFkaWFsTGluZWFyIiwic2V0Q2VudGVyUG9pbnQiLCJsYXJnZXN0UG9zc2libGVSYWRpdXMiLCJyYWRpdXNSZWR1Y3Rpb25MZWZ0IiwicmFkaXVzUmVkdWN0aW9uUmlnaHQiLCJyYWRpdXNSZWR1Y3Rpb25Ub3AiLCJyYWRpdXNSZWR1Y3Rpb25Cb3R0b20iLCJsZWZ0TW92ZW1lbnQiLCJyaWdodE1vdmVtZW50IiwidG9wTW92ZW1lbnQiLCJib3R0b21Nb3ZlbWVudCIsIm1heFJpZ2h0IiwibWF4TGVmdCIsIm1heFRvcCIsIm1heEJvdHRvbSIsImFuZ2xlTXVsdGlwbGllciIsInN0YXJ0QW5nbGVSYWRpYW5zIiwic2NhbGluZ0ZhY3RvciIsImRpc3RhbmNlRnJvbUNlbnRlciIsInRoaXNBbmdsZSIsImdldEJhc2VQb3NpdGlvbiIsInlDZW50ZXJPZmZzZXQiLCJfZGVmYXVsdHMkMyIsInZhbHVlT3JEZWZhdWx0JGMiLCJNSU5fSU5URUdFUiIsIk1JTl9TQUZFX0lOVEVHRVIiLCJNQVhfSU5URUdFUiIsIklOVEVSVkFMUyIsImNvbW1vbiIsInN0ZXBzIiwiVU5JVFMiLCJzb3J0ZXIiLCJhcnJheVVuaXF1ZSIsImJ1aWxkTG9va3VwVGFibGUiLCJ0aW1lc3RhbXBzIiwiZGlzdHJpYnV0aW9uIiwidGFibGUiLCJsb29rdXAiLCJsbyIsIm1pZCIsImkwIiwiaTEiLCJpbnRlcnBvbGF0ZSQxIiwic2tleSIsInRrZXkiLCJzcGFuIiwidG9UaW1lc3RhbXAiLCJhZGFwdGVyIiwiX2FkYXB0ZXIiLCJwYXJzZXIiLCJkZXRlcm1pbmVTdGVwU2l6ZSIsImNhcGFjaXR5IiwiaW50ZXJ2YWwiLCJkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzIiwibWluVW5pdCIsImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwiZGV0ZXJtaW5lTWFqb3JVbml0IiwidGltZU9wdHMiLCJ1bml0U3RlcFNpemUiLCJtYWpvclRpY2tzRW5hYmxlZCIsImZpcnN0IiwiY29tcHV0ZU9mZnNldHMiLCJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwibWFqb3JVbml0IiwiZGVmYXVsdENvbmZpZyQ0IiwiYWRhcHRlcnMiLCJkaXNwbGF5Rm9ybWF0IiwiZGlzcGxheUZvcm1hdHMiLCJzY2FsZV90aW1lIiwidGltZXN0YW1wIiwiZGF0YUxhYmVscyIsIl9ob3Jpem9udGFsIiwiX3RhYmxlIiwiX3RpbWVzdGFtcHMiLCJnZXRMYWJlbENhcGFjaXR5IiwiX3VuaXQiLCJfbWFqb3JVbml0IiwiX29mZnNldHMiLCJ0b29sdGlwRm9ybWF0IiwidGlja0Zvcm1hdEZ1bmN0aW9uIiwibWlub3JGb3JtYXQiLCJtYWpvckZvcm1hdCIsIm1ham9yVGltZSIsIm1ham9yVGlja09wdHMiLCJmb3JtYXR0ZXIiLCJnZXRQaXhlbEZvck9mZnNldCIsImlzUmV2ZXJzZSIsImdldExhYmVsV2lkdGgiLCJ0aWNrc09wdHMiLCJ0aWNrTGFiZWxXaWR0aCIsInRpY2tGb250U2l6ZSIsImV4YW1wbGVUaW1lIiwiZXhhbXBsZUxhYmVsIiwiX2RlZmF1bHRzJDQiLCJjYXRlZ29yeSIsInJhZGlhbExpbmVhciIsIkZPUk1BVFMiLCJfaWQiLCJhbW91bnQiLCJmaWxsZXIiLCJwcm9wYWdhdGUiLCJtYXBwZXJzIiwidmlzaWJsZSIsImJvdW5kYXJ5IiwiZGVjb2RlRmlsbCIsImNvbXB1dGVCb3VuZGFyeSIsInNjYWxlQm90dG9tIiwic2NhbGVUb3AiLCJzY2FsZVplcm8iLCJyZXNvbHZlVGFyZ2V0IiwidmlzaXRlZCIsImNyZWF0ZU1hcHBlciIsImlzRHJhd2FibGUiLCJkcmF3QXJlYSIsImN1cnZlMCIsImN1cnZlMSIsImxlbjAiLCJsZW4xIiwiZG9GaWxsIiwibWFwcGVyIiwicDAiLCJkMCIsImQxIiwicGx1Z2luX2ZpbGxlciIsImFmdGVyRGF0YXNldHNVcGRhdGUiLCIkZmlsbGVyIiwiYmVmb3JlRGF0YXNldERyYXciLCJub29wJDEiLCJ2YWx1ZU9yRGVmYXVsdCRkIiwiY2kiLCJvbkxlYXZlIiwiYm94V2lkdGgiLCJsaW5lRGFzaCIsImdldEJveFdpZHRoIiwibGFiZWxPcHRzIiwidXNlUG9pbnRTdHlsZSIsIkxlZ2VuZCIsImxlZ2VuZEhpdEJveGVzIiwiX2hvdmVyZWRJdGVtIiwiZG91Z2hudXRNb2RlIiwiYmVmb3JlQnVpbGRMYWJlbHMiLCJidWlsZExhYmVscyIsImFmdGVyQnVpbGRMYWJlbHMiLCJsZWdlbmRJdGVtcyIsImxhYmVsRm9udCIsImhpdGJveGVzIiwibGluZVdpZHRocyIsInRvdGFsSGVpZ2h0IiwidlBhZGRpbmciLCJjb2x1bW5XaWR0aHMiLCJ0b3RhbFdpZHRoIiwiY3VycmVudENvbFdpZHRoIiwiY3VycmVudENvbEhlaWdodCIsIml0ZW1IZWlnaHQiLCJpdGVtV2lkdGgiLCJsaW5lRGVmYXVsdCIsImxlZ2VuZFdpZHRoIiwiY3Vyc29yIiwiZHJhd0xlZ2VuZEJveCIsIlNRUlQyIiwiaGFsZkZvbnRTaXplIiwieExlZnQiLCJ5TWlkZGxlIiwiX2dldExlZ2VuZEl0ZW1BdCIsImhpdEJveCIsImxoIiwiaG92ZXJlZEl0ZW0iLCJjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2giLCJsZWdlbmRPcHRzIiwicGx1Z2luX2xlZ2VuZCIsIl9lbGVtZW50IiwiYmVmb3JlSW5pdCIsImFmdGVyRXZlbnQiLCJub29wJDIiLCJUaXRsZSIsImxpbmVDb3VudCIsImZvbnRPcHRzIiwidGl0bGVYIiwidGl0bGVZIiwiY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaCIsInRpdGxlT3B0cyIsInRpdGxlQmxvY2siLCJwbHVnaW5fdGl0bGUiLCJfYWRhcHRlcnMiLCJBbmltYXRpb24iLCJhbmltYXRpb25TZXJ2aWNlIiwiSW50ZXJhY3Rpb24iLCJsYXlvdXRzIiwiU2NhbGUiLCJzY2FsZVNlcnZpY2UiLCJUaWNrcyIsIlRvb2x0aXAiLCJwbHVnaW5TZXJ2aWNlIiwiUGx1Z2luQmFzZSIsImNhbnZhc0hlbHBlcnMiLCJsYXlvdXRTZXJ2aWNlIiwiTGluZWFyU2NhbGVCYXNlIiwiY2ZnIiwiZ2VuZXJhdGVDaGFydCIsImNoYXJ0SWQiLCJjaGFydFR5cGUiLCJjc3NDbGFzc2VzIiwiX2RlZmF1bHQiLCJhZGRQbHVnaW4iLCJiZWZvcmVEZXN0cm95IiwiQmFyIiwiSG9yaXpvbnRhbEJhciIsIlBpZSIsImNoYXJ0TGFiZWxzIiwiY2hhcnREYXRhTGlzdCIsIkNoYXJ0RGF0YSIsIkNoYXJ0QmFyIiwiQ2hhcnRDb21wb25lbnQiLCJDaGFydEhvcml6b250YWxCYXIiLCJDaGFydExpbmUiLCJDaGFydFBpZSIsIm55Y28iLCJpY29ucyIsInRyYWNrIiwic2VsZWN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBTUEsSUFBTUEsT0FBTyxHQUtYLGdCQUFBLEdBQWM7U0FDTCxJQUFUO0NBTkY7Ozs7Ozs7QUFjQUEsT0FBTyxDQUFDQyxLQUFSLGVBQW1CO1NBQUlELE9BQU8sQ0FBQ0UsZUFBUixDQUF3QkYsT0FBTyxDQUFDRyxNQUFSLENBQWVDLEtBQXZDLE1BQWtEO0NBQXpFOzs7Ozs7Ozs7O0FBU0FKLE9BQU8sQ0FBQ0UsZUFBUixhQUEyQkcsTUFBTUMsYUFBYTtNQUN0Q0MsS0FBSyxHQUFHRCxXQUFXLElBQUlFLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkMsTUFBN0NDO01BQ01DLEtBQUssR0FBR1AsSUFBSSxDQUFDUSxPQUFMLENBQWEsTUFBYixFQUFxQixLQUFyQixFQUE0QkEsT0FBNUIsQ0FBb0MsTUFBcEMsRUFBNEMsS0FBNUMsQ0FBZEY7TUFDTUcsS0FBSyxHQUFHLElBQUlDLE1B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QUMsQ0FBRCxFQUFHLENBQUgsRUFBSyxHQUFMLENBdEJNO01BdUJoQkMsUUFBUSxFQUFFLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBdkJNO01Bd0JoQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBeEJBO01BeUJoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBekJNO01BMEJoQkMsU0FBUyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxDQUFQLENBMUJJO01BMkJoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0JNO01BNEJoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUJJO01BNkJoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBN0JFO01BOEJoQkMsY0FBYyxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBOUJBO01BK0JoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBL0JJO01BZ0NoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBaENJO01BaUNoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLENBakNNO01Ba0NoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbENJO01BbUNoQkMsWUFBWSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkNFO01Bb0NoQkMsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxHQUFQLENBcENBO01BcUNoQkMsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLENBckNBO01Bc0NoQkMsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLENBdENBO01BdUNoQkMsYUFBYSxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBdkNBO01Bd0NoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBeENJO01BeUNoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBekNNO01BMENoQkMsV0FBVyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBMUNFO01BMkNoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0NNO01BNENoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUNNO01BNkNoQkMsVUFBVSxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBN0NJO01BOENoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBOUNJO01BK0NoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0NFO01BZ0RoQkMsV0FBVyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBaERFO01BaURoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBakRNO01Ba0RoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbERJO01BbURoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkRJO01Bb0RoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBcERVO01BcURoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBckRJO01Bc0RoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdERVO01BdURoQkMsS0FBSyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgs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LEdBQUwsRUFBUyxFQUFULENBekdJO01BMEdoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBMUdRO01BMkdoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxDQUFSLENBM0dJO01BNEdoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUdRO01BNkdoQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBN0dBO01BOEdoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBOUdJO01BK0doQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0dBO01BZ0hoQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaEhBO01BaUhoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBakhJO01Ba0hoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbEhJO01BbUhoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBbkhVO01Bb0hoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcEhVO01BcUhoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBckhVO01Bc0hoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdEhJO01BdUhoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBdkhRO01Bd0hoQkMsYUFBYSxFQUFFLENBQUMsR0FBRCxFQUFNLEVBQU4sRUFBVSxHQUFWLENBeEhDO01BeUhoQkMsR0FBRyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLENBekhVO01BMEhoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBMUhJO01BMkhoQkMsU0FBUyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBM0hJO01BNEhoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBNUhFO01BNkhoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBN0hRO01BOEhoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBOUhJO01BK0hoQkMsUUFBUSxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBL0hNO01BZ0loQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaElNO01BaUloQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBaklRO01Ba0loQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbElRO01BbUloQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbklNO01Bb0loQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBcElJO01BcUloQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcklJO01Bc0loQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdElJO01BdUloQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdklVO01Bd0loQkMsV0FBVyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBeElFO01BeUloQkMsU0FBUyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBeklJO01BMEloQkMsR0FBRyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENB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
